AiEmbeddingModel-makeDataLoader.md
Package: `@effect/ai`<br />
Module: `AiEmbeddingModel`<br />

## AiEmbeddingModel.makeDataLoader

Creates an `Embeddings` service which will aggregate all `embed` requests
received during the specified `window` (up to a maximum of `maxBatchSize`
requests, if specified) and execute them as a single batch.

**Signature**

```ts
declare const makeDataLoader: (options: { readonly embedMany: (input: ReadonlyArray<string>) => Effect.Effect<Array<AiEmbeddingModel.Result>, AiError>; readonly window: Duration.DurationInput; readonly maxBatchSize?: number; }) => Effect.Effect<AiEmbeddingModel.Service, never, Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiEmbeddingModel.ts#L123)

Since v1.0.0
AiInput-AiInput.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.AiInput

Represents input to a large language model.

**Signature**

```ts
declare class AiInput
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L28)

Since v1.0.0
AiInput-AssistantMessagePart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.AssistantMessagePart

The valid parts of an assistant message.

**Signature**

```ts
declare const AssistantMessagePart: Schema.Union<[typeof TextPart, typeof ReasoningPart, typeof RedactedReasoningPart, typeof ToolCallPart]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L423)

Since v1.0.0
AiInput-FilePart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.FilePart

Represents a file part of a message with binary file data.

**Signature**

```ts
declare class FilePart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L228)

Since v1.0.0
AiInput-FileUrlPart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.FileUrlPart

Represents a file part of a message with a URL pointing to the file.

**Signature**

```ts
declare class FileUrlPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L256)

Since v1.0.0
AiInput-ImagePart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.ImagePart

Represents an image part of a message with binary image data.

**Signature**

```ts
declare class ImagePart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L184)

Since v1.0.0
AiInput-ImageUrlPart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.ImageUrlPart

Represents an image part of a message with a URL pointing to the image.

**Signature**

```ts
declare class ImageUrlPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L208)

Since v1.0.0
AiInput-Raw.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.Raw

Represents raw input types that can be converted into an `AiInput`.

**Signature**

```ts
type Raw = | string
  | Message
  | Iterable<Message>
  | AiInput
  | AiResponse.AiResponse
  | AiResponse.WithStructuredOutput<any>
  | AiResponse.WithToolCallResults<any>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L51)

Since v1.0.0
AiInput-ReasoningPart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.ReasoningPart

Represents a part of a message containing reasoning that the model used to
generate its output.

**Signature**

```ts
declare class ReasoningPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L277)

Since v1.0.0
AiInput-RedactedReasoningPart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.RedactedReasoningPart

Represents a part of a message containing content in the model's reasoning
that was encrypted by the model provider for safety reasons.

**Signature**

```ts
declare class RedactedReasoningPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L303)

Since v1.0.0
AiInput-TextPart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.TextPart

Represents a text part of a message.

**Signature**

```ts
declare class TextPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L164)

Since v1.0.0
AiInput-ToolCallId.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.ToolCallId

Represents the identifier generated by a model when a tool call is requested.

**Signature**

```ts
declare const ToolCallId: Schema.brand<typeof Schema.String, "@effect/ai/ToolCallId">
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L324)

Since v1.0.0
AiInput-ToolCallPart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.ToolCallPart

Represents a part of a message containing a tool call that the model has
requested invocation of.

**Signature**

```ts
declare class ToolCallPart { constructor(props: any, options?: Schema.MakeOptions) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L339)

Since v1.0.0
AiInput-ToolCallResultPart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.ToolCallResultPart

Represents a part of a message containing the results of tool calls that the
model requested invocation of.

**Signature**

```ts
declare class ToolCallResultPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L373)

Since v1.0.0
AiInput-ToolMessagePart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.ToolMessagePart

The valid parts of a tool message.

**Signature**

```ts
declare const ToolMessagePart: typeof ToolCallResultPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L447)

Since v1.0.0
AiInput-UserMessagePart.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.UserMessagePart

The valid parts of a user message.

**Signature**

```ts
declare const UserMessagePart: Schema.Union<[typeof TextPart, typeof ImagePart, typeof ImageUrlPart, typeof FilePart, typeof FileUrlPart]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L397)

Since v1.0.0
AiInput-concat.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.concat

Concatenates the messages of one `AiInput` onto the messages of another,
creating a new `AiInput` with the messages from both.

**Signature**

```ts
declare const concat: { (other: AiInput): (self: AiInput) => AiInput; (self: AiInput, other: AiInput): AiInput; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L560)

Since v1.0.0
AiInput-make.md
Package: `@effect/ai`<br />
Module: `AiInput`<br />

## AiInput.make

Constructs a new `AiInput` from raw user input.

**Signature**

```ts
declare const make: (input: Raw) => AiInput
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiInput.ts#L486)

Since v1.0.0
AiLanguageModel-ExtractContext.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.ExtractContext

A utility type to extract the context type for the text generation methods
of `AiLanguageModel` from the provided options.

**Signature**

```ts
type ExtractContext<Options> = Options extends {
  toolkit: AiToolkit.ToHandler<infer _Tools>
} ? AiTool.Context<_Tools>
  : Options extends {
    toolkit: Effect.Effect<AiToolkit.ToHandler<infer _Tools>, infer _E, infer _R>
  } ? AiTool.Context<_Tools> | _R
  : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L176)

Since v1.0.0
AiLanguageModel-ExtractError.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.ExtractError

A utility type to extract the error type for the text generation methods
of `AiLanguageModel` from the provided options.

**Signature**

```ts
type ExtractError<Options> = Options extends {
  toolkit: AiToolkit.ToHandler<infer _Tools>
} ? AiError | AiTool.Failure<_Tools>
  : Options extends {
    toolkit: Effect.Effect<AiToolkit.ToHandler<infer _Tools>, infer _E, infer _R>
  } ? AiError | AiTool.Failure<_Tools> | _E
  : AiError
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L161)

Since v1.0.0
AiLanguageModel-ExtractSuccess.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.ExtractSuccess

A utility type to extract the success type for the text generation methods
of `AiLanguageModel` from the provided options.

**Signature**

```ts
type ExtractSuccess<Options> = Options extends {
  toolkit: AiToolkit.ToHandler<infer _Tools>
} ? AiResponse.WithToolCallResults<_Tools>
  : Options extends {
    toolkit: Effect.Effect<AiToolkit.ToHandler<infer _Tools>, infer _E, infer _R>
  } ? AiResponse.WithToolCallResults<_Tools>
  : AiResponse.AiResponse
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L146)

Since v1.0.0
AiLanguageModel-GenerateObjectOptions.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.GenerateObjectOptions

Options for generating a structured object using a large language model.

**Signature**

```ts
export interface GenerateObjectOptions<A, I extends Record<string, unknown>, R> {
  /**
   * The prompt input to use to generate text.
   */
  readonly prompt: AiInput.Raw

  /**
   * An optional system message that will be part of the prompt.
   */
  readonly system?: string | undefined

  /**
   * The schema to be used to specify the structure of the object to generate.
   */
  readonly schema: Schema.Schema<A, I, R>

  /**
   * The identifier to use to associating the underlying tool call with the
   * generated output.
   */
  readonly toolCallId?: string | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L116)

Since v1.0.0
AiLanguageModel-GenerateTextOptions.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.GenerateTextOptions

Options for generating text using a large language model.

**Signature**

```ts
export interface GenerateTextOptions<Tools extends AiTool.Any> {
  /**
   * The prompt input to use to generate text.
   */
  readonly prompt: AiInput.Raw

  /**
   * An optional system message that will be part of the prompt.
   */
  readonly system?: string | undefined

  /**
   * A toolkit containing both the tools and the tool call handler to use to
   * augment text generation.
   */
  readonly toolkit?: AiToolkit.ToHandler<Tools> | Effect.Effect<AiToolkit.ToHandler<Tools>, any, any>

  /**
   * The tool choice mode for the language model.
   *
   * - `auto` (default): The model can decide whether or not to call tools, as well as which tools to call.
   * - `required`: The model **must** call a tool but can decide which tool will be called.
   * - `none`: The model **must not** call a tool.
   * - `{ tool: <tool_name> }`: The model must call the specified tool.
   */
  readonly toolChoice?: ToolChoice<Tools>

  /**
   * The concurrency level for resolving tool calls.
   */
  readonly concurrency?: Concurrency | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L77)

Since v1.0.0
AiLanguageModel-ToolChoice.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.ToolChoice

The tool choice mode for the language model.

- `auto` (default): The model can decide whether or not to call tools, as well as which tools to call.
- `required`: The model **must** call a tool but can decide which tool will be called.
- `none`: The model **must not** call a tool.
- `{ tool: <tool_name> }`: The model must call the specified tool.

**Signature**

```ts
type ToolChoice<Tool> = "auto" | "none" | "required" | {
  readonly tool: Tool["name"]
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L67)

Since v1.0.0
AiLanguageModel-generateObject.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.generateObject

Generate a structured object for the specified prompt and schema using a
large language model.

When using a `Schema` that does not have an `identifier` or `_tag`
property, you must specify a `toolCallId` to properly associate the
output of the model.

**Signature**

```ts
declare const generateObject: <A, I extends Record<string, unknown>, R>(options: GenerateObjectOptions<A, I, R>) => Effect.Effect<AiResponse.WithStructuredOutput<A>, AiError, AiLanguageModel | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L565)

Since v1.0.0
AiLanguageModel-generateText.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.generateText

Generate text using a large language model for the specified `prompt`.

If a `toolkit` is specified, the large language model will additionally
be able to perform tool calls to augment its response.

**Signature**

```ts
declare const generateText: <Tools extends AiTool.Any, Options extends NoExcessProperties<GenerateTextOptions<any>, Options>>(options: Options & GenerateTextOptions<Tools>) => Effect.Effect<ExtractSuccess<Options>, ExtractError<Options>, AiLanguageModel | ExtractContext<Options>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L543)

Since v1.0.0
AiLanguageModel-streamText.md
Package: `@effect/ai`<br />
Module: `AiLanguageModel`<br />

## AiLanguageModel.streamText

Generate text using a large language model for the specified `prompt`,
streaming output from the model as soon as it is available.

If a `toolkit` is specified, the large language model will additionally
be able to perform tool calls to augment its response.

**Signature**

```ts
declare const streamText: <Tools extends AiTool.Any, Options extends NoExcessProperties<GenerateTextOptions<any>, Options>>(options: Options & GenerateTextOptions<Tools>) => Stream.Stream<ExtractSuccess<Options>, ExtractError<Options>, AiLanguageModel | ExtractContext<Options>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiLanguageModel.ts#L583)

Since v1.0.0
AiResponse-AiResponse.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.AiResponse

Represents a response received from a large language model.

**Signature**

```ts
declare class AiResponse
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L34)

Since v1.0.0
AiResponse-Annotation.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.Annotation

Represents annotations that were used to support the message generated by
a model.

**Signature**

```ts
declare const Annotation: Schema.Union<[typeof ContentSourceAnnotation, typeof FileAnnotation, typeof UrlAnnotation]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L333)

Since v1.0.0
AiResponse-ContentSourceAnnotation.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.ContentSourceAnnotation

Represents a content source that was used to generate a model response.

**Signature**

```ts
declare class ContentSourceAnnotation
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L234)

Since v1.0.0
AiResponse-FileAnnotation.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.FileAnnotation

Represents a file that was used to generate a model response.

**Signature**

```ts
declare class FileAnnotation
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L276)

Since v1.0.0
AiResponse-FinishPart.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.FinishPart

Represents the final part of a response generated by a large language model.

Contains useful information such as tokens used as part of the interaction
with the model.

**Signature**

```ts
declare class FinishPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L656)

Since v1.0.0
AiResponse-FinishReason.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.FinishReason

Represents the reason why a model finished generation of a response.

Possible finish reasons:
- `"stop"`: The model generated a stop sequence.
- `"length"`: The model exceeded its token budget.
- `"content-filter"`: The model generated content which violated a content filter.
- `"tool-calls"`: The model triggered a tool call.
- `"error"`: The model encountered an error.
- `"other"`: The model stopped for a reason not supported by this protocol.
- `"unknown"`: The model did not specify a finish reason.

**Signature**

```ts
declare const FinishReason: Schema.Literal<["stop", "length", "content-filter", "tool-calls", "error", "other", "unknown"]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L562)

Since v1.0.0
AiResponse-MetadataPart.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.MetadataPart

Represents the initial response metadata generated by a model when responding
to a request.

**Signature**

```ts
declare class MetadataPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L524)

Since v1.0.0
AiResponse-Part.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.Part

Represents an single part of a response received from a large language model.

**Signature**

```ts
declare const Part: Schema.Union<[typeof TextPart, typeof ReasoningPart, typeof RedactedReasoningPart, typeof ToolCallPart, typeof MetadataPart, typeof FinishPart]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L690)

Since v1.0.0
AiResponse-ProviderMetadata.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.ProviderMetadata

Represents additional provider-specific metadata that was returned by the
model. Specific providers will use module augmentation to add their own
specific provider metadata.

The outer record is keyed by provider name, while the inner record is keyed
by the names of the provider-specific metadata properties.

For example:

```ts
const providerMeta = {
  "amazon-bedrock": {
    // Provider specific metadata
  }
}
```

**Signature**

```ts
export interface ProviderMetadata {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L645)

Since v1.0.0
AiResponse-ReasoningPart.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.ReasoningPart

Represents part of the reasoning carried out by the model to generate a
response.

**Signature**

```ts
declare class ReasoningPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L382)

Since v1.0.0
AiResponse-RedactedReasoningPart.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.RedactedReasoningPart

Represents part of the reasoning carried out by the model to generate a
response which needed to be encrypted by the model provider for safety
reasons.

**Signature**

```ts
declare class RedactedReasoningPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L409)

Since v1.0.0
AiResponse-TextPart.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.TextPart

Represents part of the text generated by the model.

**Signature**

```ts
declare class TextPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L355)

Since v1.0.0
AiResponse-ToolCallId.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.ToolCallId

Represents the identifier generated by a model when a tool call is requested.

**Signature**

```ts
declare const ToolCallId: Schema.brand<typeof Schema.String, "@effect/ai/ToolCallId">
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L430)

Since v1.0.0
AiResponse-ToolCallPart.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.ToolCallPart

Represents a request by a model to call a specific tool that it has been
provided with.

**Signature**

```ts
declare class ToolCallPart
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L445)

Since v1.0.0
AiResponse-UrlAnnotation.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.UrlAnnotation

Represents a web resource that was used to generate a model response.

**Signature**

```ts
declare class UrlAnnotation
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L303)

Since v1.0.0
AiResponse-Usage.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.Usage

Represents information about the number of tokens used by the model to
generate a response.

**Signature**

```ts
declare class Usage
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L593)

Since v1.0.0
AiResponse-WithStructuredOutput.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.WithStructuredOutput

Represents a response generated by a large language model that includes
structured output.

**Signature**

```ts
declare class WithStructuredOutput<A> { constructor(props: {
    /**
     * The identifier of the tool which generated the structured output.
     */
    readonly id: ToolCallId
    /**
     * The name of the tool which generated the structured output.
     */
    readonly name: string
    /**
     * The structured output generated by the model.
     */
    readonly value: A
    /**
     * The parts of the response.
     */
    readonly parts: ReadonlyArray<Part>
  }, options?: Schema.MakeOptions) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L108)

Since v1.0.0
AiResponse-WithToolCallResults.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.WithToolCallResults

Represents a response generated by a large language model that includes
tool call results.

**Signature**

```ts
declare class WithToolCallResults<Tools> { constructor(props: {
    /**
     * The tool call results, represented as a mapping between the tool call
     * identifier and the result of the tool call handler.
     */
    readonly results: ReadonlyMap<ToolCallId, AiTool.Success<Tools>>
    /**
     * The encoded tool call results, suitable for incorporation into subsequent
     * requests to the large language model.
     */
    readonly encodedResults: ReadonlyMap<ToolCallId, unknown>
    /**
     * The parts of the response.
     */
    readonly parts: ReadonlyArray<Part>
  }, options?: Schema.MakeOptions) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L173)

Since v1.0.0
AiResponse-merge.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.merge

Combines two responses into a single response.

**Signature**

```ts
declare const merge: { (other: AiResponse): (self: AiResponse) => AiResponse; (self: AiResponse, other: AiResponse): AiResponse; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L753)

Since v1.0.0
AiResponse-withToolCallsJson.md
Package: `@effect/ai`<br />
Module: `AiResponse`<br />

## AiResponse.withToolCallsJson

Adds the specified tool calls to the provided `AiResponse`.

**NOTE**: With this method, the tool call parameters will be parsed as a
JSON string. If your tool call parameters are already parsed, use
`AiResponse.withToolCallsUnknown`.

**Signature**

```ts
declare const withToolCallsJson: { (toolCalls: Iterable<{ readonly id: string; readonly name: string; readonly params: string; }>): (self: AiResponse) => Effect.Effect<AiResponse, AiError>; (self: AiResponse, toolCalls: Iterable<{ readonly id: string; readonly name: string; readonly params: string; }>): Effect.Effect<AiResponse, AiError>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiResponse.ts#L835)

Since v1.0.0
AiTelemetry-AllAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.AllAttributes

All telemetry attributes which are part of the GenAI specification.

**Signature**

```ts
type AllAttributes = & BaseAttributes
  & OperationAttributes
  & TokenAttributes
  & UsageAttributes
  & RequestAttributes
  & ResponseAttributes
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L37)

Since v1.0.0
AiTelemetry-BaseAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.BaseAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai`.

**Signature**

```ts
export interface BaseAttributes {
  /**
   * The Generative AI product as identified by the client or server
   * instrumentation.
   */
  readonly system?: (string & {}) | WellKnownSystem | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L52)

Since v1.0.0
AiTelemetry-addGenAIAnnotations.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.addGenAIAnnotations

Applies the specified GenAI telemetry attributes to the provided `Span`.

**NOTE**: This method will mutate the `Span` **in-place**.

**Signature**

```ts
declare const addGenAIAnnotations: { (options: GenAITelemetryAttributeOptions): (span: Span) => void; (span: Span, options: GenAITelemetryAttributeOptions): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L267)

Since v1.0.0, Utilities
AiTelemetry-GenAITelemetryAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.GenAITelemetryAttributes

The attributes used to describe telemetry in the context of Generative
Artificial Intelligence (GenAI) Models requests and responses.

{@see https://opentelemetry.io/docs/specs/semconv/attributes-registry/gen-ai/}

**Signature**

```ts
type GenAITelemetryAttributes = Simplify<
  & AttributesWithPrefix<BaseAttributes, "gen_ai">
  & AttributesWithPrefix<OperationAttributes, "gen_ai.operation">
  & AttributesWithPrefix<TokenAttributes, "gen_ai.token">
  & AttributesWithPrefix<UsageAttributes, "gen_ai.usage">
  & AttributesWithPrefix<RequestAttributes, "gen_ai.request">
  & AttributesWithPrefix<ResponseAttributes, "gen_ai.response">
>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L22)

Since v1.0.0
AiTelemetry-OperationAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.OperationAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai.operation`.

**Signature**

```ts
export interface OperationAttributes {
  readonly name?: (string & {}) | WellKnownOperationName | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L67)

Since v1.0.0
AiTelemetry-RequestAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.RequestAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai.request`.

**Signature**

```ts
export interface RequestAttributes {
  /**
   * The name of the GenAI model a request is being made to.
   */
  readonly model?: string | null | undefined
  /**
   * The temperature setting for the GenAI request.
   */
  readonly temperature?: number | null | undefined
  /**
   * The temperature setting for the GenAI request.
   */
  readonly topK?: number | null | undefined
  /**
   * The top_k sampling setting for the GenAI request.
   */
  readonly topP?: number | null | undefined
  /**
   * The top_p sampling setting for the GenAI request.
   */
  readonly maxTokens?: number | null | undefined
  /**
   * The encoding formats requested in an embeddings operation, if specified.
   */
  readonly encodingFormats?: ReadonlyArray<string> | null | undefined
  /**
   * List of sequences that the model will use to stop generating further
   * tokens.
   */
  readonly stopSequences?: ReadonlyArray<string> | null | undefined
  /**
   * The frequency penalty setting for the GenAI request.
   */
  readonly frequencyPenalty?: number | null | undefined
  /**
   * The presence penalty setting for the GenAI request.
   */
  readonly presencePenalty?: number | null | undefined
  /**
   * The seed setting for the GenAI request. Requests with same seed value
   * are more likely to return same result.
   */
  readonly seed?: number | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L101)

Since v1.0.0
AiTelemetry-ResponseAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.ResponseAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai.response`.

**Signature**

```ts
export interface ResponseAttributes {
  /**
   * The unique identifier for the completion.
   */
  readonly id?: string | null | undefined
  /**
   * The name of the model that generated the response.
   */
  readonly model?: string | null | undefined
  /**
   * Array of reasons the model stopped generating tokens, corresponding to
   * each generation received.
   */
  readonly finishReasons?: ReadonlyArray<string> | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L153)

Since v1.0.0
AiTelemetry-SpanTransformer.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.SpanTransformer

Represents a method which receives the elements of the request / response to
a large language model and can be used to modify the span used to trace the
API call.

**Signature**

```ts
export interface SpanTransformer {
  (options: AiLanguageModelOptions & { readonly response: AiResponse }): void
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L290)

Since v1.0.0
AiTelemetry-TokenAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.TokenAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai.token`.

**Signature**

```ts
export interface TokenAttributes {
  readonly type?: string | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L78)

Since v1.0.0
AiTelemetry-UsageAttributes.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.UsageAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai.usage`.

**Signature**

```ts
export interface UsageAttributes {
  readonly inputTokens?: number | null | undefined
  readonly outputTokens?: number | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L89)

Since v1.0.0
AiTelemetry-WellKnownOperationName.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.WellKnownOperationName

The `gen_ai.operation.name` attribute has the following list of well-known
values.

If one of them applies, then the respective value **MUST** be used;
otherwise, a custom value **MAY** be used.

**Signature**

```ts
type WellKnownOperationName = "chat" | "embeddings" | "text_completion"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L179)

Since v1.0.0
AiTelemetry-WellKnownSystem.md
Package: `@effect/ai`<br />
Module: `AiTelemetry`<br />

## AiTelemetry.WellKnownSystem

The `gen_ai.system` attribute has the following list of well-known values.

If one of them applies, then the respective value **MUST** be used;
otherwise, a custom value **MAY** be used.

**Signature**

```ts
type WellKnownSystem = | "anthropic"
  | "aws.bedrock"
  | "az.ai.inference"
  | "az.ai.openai"
  | "cohere"
  | "deepseek"
  | "gemini"
  | "groq"
  | "ibm.watsonx.ai"
  | "mistral_ai"
  | "openai"
  | "perplexity"
  | "vertex_ai"
  | "xai"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTelemetry.ts#L190)

Since v1.0.0
AiTool-AiTool.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.AiTool

A `AiTool` represents an action that a large language model can take within
your application. The results of a tool call can be returned back to the
large language model to be incorporated into its next response.

**Signature**

```ts
export interface AiTool<
  out Name extends string,
  out Parameters extends AnyStructSchema = Schema.Struct<{}>,
  out Success extends Schema.Schema.Any = typeof Schema.Void,
  out Failure extends Schema.Schema.All = typeof Schema.Never,
  out Requirements = never
> extends Pipeable {
  readonly [TypeId]: {
    readonly _Requirements: Types.Covariant<Requirements>
  }

  /**
   * The name of the tool.
   */
  readonly name: Name

  /**
   * The optional description of the tool.
   */
  readonly description?: string | undefined

  /**
   * A key for the tool, used to identify the tool within a `Context`.
   */
  readonly key: string

  /**
   * A `Schema` representing the type of the parameters that a tool handler
   * must be called with.
   */
  readonly parametersSchema: Parameters

  /**
   * A `Schema` representing the type that a tool returns from its handler
   * if successful.
   */
  readonly successSchema: Success

  /**
   * A `Schema` representing the type that a tool returns from its handler
   * if it fails.
   */
  readonly failureSchema: Failure

  /**
   * Adds a requirement on a particular service for the tool call to be able to
   * be executed.
   */
  addRequirement<Requirement>(): AiTool<Name, Parameters, Success, Failure, Requirements | Requirement>

  /**
   * Set the schema to use for tool handler success.
   */
  setSuccess<SuccessSchema extends Schema.Schema.Any>(schema: SuccessSchema): AiTool<
    Name,
    Parameters,
    SuccessSchema,
    Failure
  >

  /**
   * Set the schema to use for tool handler failure.
   */
  setFailure<FailureSchema extends Schema.Schema.Any>(schema: FailureSchema): AiTool<
    Name,
    Parameters,
    Success,
    FailureSchema
  >

  /**
   * Set the schema for the tool parameters.
   */
  setParameters<ParametersSchema extends Schema.Struct<any> | Schema.Struct.Fields>(
    schema: ParametersSchema
  ): AiTool<
    Name,
    ParametersSchema extends Schema.Struct<infer _> ? ParametersSchema
      : ParametersSchema extends Schema.Struct.Fields ? Schema.Struct<ParametersSchema>
      : never,
    Success
  >
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L34)

Since v1.0.0
AiTool-ByName.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.ByName

A utility mapped type which associates tool names with tools.

**Signature**

```ts
type ByName<Tools> = {
  readonly [Tool in Tools as Tool["name"]]: Tool
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L207)

Since v1.0.0
AiTool-Context.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.Context

A utility type to the `Context` type from an `AiTool`.

**Signature**

```ts
type Context<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Parameters["Context"] | _Success["Context"] | _Failure["Context"] | _Requirements :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L328)

Since v1.0.0
AiTool-Failure.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.Failure

A utility type to extract the type of the response that an `AiTool` returns
from its handler if it fails.

**Signature**

```ts
type Failure<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Failure["Type"] :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L297)

Since v1.0.0
AiTool-FailureSchema.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.FailureSchema

A utility type to extract the schema type of the response that an `AiTool`
returns from its handler if it fails.

**Signature**

```ts
type FailureSchema<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Failure :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L313)

Since v1.0.0
AiTool-FromTaggedRequest.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.FromTaggedRequest

A utility type to convert a `Schema.TaggedRequest` into an `AiTool`.

**Signature**

```ts
export interface FromTaggedRequest<S extends AnyTaggedRequestSchema>
  extends AiTool<S["_tag"], S, S["success"], S["failure"]>
{}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L367)

Since v1.0.0
AiTool-Handler.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.Handler

Represents an `AiTool` that has been implemented within the application.

**Signature**

```ts
export interface Handler<Name extends string> {
  readonly _: unique symbol
  readonly name: Name
  readonly handler: (params: any) => Effect.Effect<any, any>
  readonly context: Context_.Context<never>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L153)

Since v1.0.0
AiTool-HandlerEffect.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.HandlerEffect

A utility type which returns the type of the `Effect` that will be used to
resolve a tool call.

**Signature**

```ts
type HandlerEffect<Tool> = [Tool] extends [
  AiTool<
    infer _Name,
    infer _Parameters,
    infer _Success,
    infer _Failure,
    infer _Requirements
  >
] ? Effect.Effect<
    _Success["Type"],
    AiError | _Failure["Type"],
    _Parameters["Context"] | _Success["Context"] | _Failure["Context"] | _Requirements
  >
  : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L167)

Since v1.0.0
AiTool-HandlerResult.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.HandlerResult

Represents the result of calling the handler for a particular tool.

**Signature**

```ts
export interface HandlerResult<Tool extends Any> {
  /**
   * The result of executing the handler for a particular tool.
   */
  readonly result: Success<Tool>
  /**
   * The encoded result of executing the handler for a particular tool, which
   * is suitable for returning back to the large language model for
   * incorporation into further responses.
   */
  readonly encodedResult: unknown
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L188)

Since v1.0.0
AiTool-Name.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.Name

A utility type to extract the `Name` type from an `AiTool`.

**Signature**

```ts
type Name<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Name :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L217)

Since v1.0.0
AiTool-Parameters.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.Parameters

A utility type to extract the type of the parameters which an `AiTool` must
be called with.

**Signature**

```ts
type Parameters<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Parameters["Type"] :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L233)

Since v1.0.0
AiTool-ParametersSchema.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.ParametersSchema

A utility type to extract the schema type of the parameters which an `AiTool`
must be called with.

**Signature**

```ts
type ParametersSchema<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Parameters :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L249)

Since v1.0.0
AiTool-Success.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.Success

A utility type to extract the type of the response that an `AiTool` returns
from its handler if successful.

**Signature**

```ts
type Success<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Success["Type"] :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L265)

Since v1.0.0
AiTool-SuccessSchema.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.SuccessSchema

A utility type to extract the schema type of the response that an `AiTool`
returns from its handler if successful.

**Signature**

```ts
type SuccessSchema<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? _Success :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L281)

Since v1.0.0
AiTool-ToHandler.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.ToHandler

A utility type which returns the handler type for an `AiTool`.

**Signature**

```ts
type ToHandler<Tool> = Tool extends AiTool<
  infer _Name,
  infer _Parameters,
  infer _Success,
  infer _Failure,
  infer _Requirements
> ? Handler<_Name> :
  never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L377)

Since v1.0.0
AiTool-fromTaggedRequest.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.fromTaggedRequest

Constructs a new `AiTool` from a `Schema.TaggedRequest`.

**Signature**

```ts
declare const fromTaggedRequest: <S extends AnyTaggedRequestSchema>(schema: S) => FromTaggedRequest<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L487)

Since v1.0.0
AiTool-make.md
Package: `@effect/ai`<br />
Module: `AiTool`<br />

## AiTool.make

Constructs an `AiTool` from a name and, optionally, a specification for the
tool call's protocol.

**Signature**

```ts
declare const make: <const Name extends string, Parameters extends Schema.Struct.Fields = {}, Success extends Schema.Schema.Any = typeof Schema.Void, Failure extends Schema.Schema.All = typeof Schema.Never>(name: Name, options?: { readonly description?: string | undefined; readonly parameters?: Parameters; readonly success?: Success; readonly failure?: Failure; }) => AiTool<Name, Schema.Struct<Parameters>, Success, Failure>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiTool.ts#L442)

Since v1.0.0
AiToolkit-AiToolkit.md
Package: `@effect/ai`<br />
Module: `AiToolkit`<br />

## AiToolkit.AiToolkit

An `AiToolkit` represents a set of tools that a large language model can
use to augment its response.

**Signature**

```ts
export interface AiToolkit<in out Tools extends AiTool.Any>
  extends Effect.Effect<ToHandler<Tools>, never, AiTool.ToHandler<Tools>>, Inspectable, Pipeable
{
  new(_: never): {}

  readonly [TypeId]: TypeId

  /**
   * A map containing the tools that are part of this toolkit.
   */
  readonly tools: AiTool.ByName<Tools>

  /**
   * Converts this toolkit into a `Context` object containing the handlers for
   * all tools in the toolkit.
   */
  toContext<Handlers extends HandlersFrom<Tools>, EX = never, RX = never>(
    build: Handlers | Effect.Effect<Handlers, EX, RX>
  ): Effect.Effect<Context.Context<AiTool.ToHandler<Tools>>, EX, RX>

  /**
   * Converts this toolkit into a `Layer` containing the handlers for all tools
   * in the toolkit.
   */
  toLayer<Handlers extends HandlersFrom<Tools>, EX = never, RX = never>(
    build: Handlers | Effect.Effect<Handlers, EX, RX>
  ): Layer.Layer<AiTool.ToHandler<Tools>, EX, Exclude<RX, Scope.Scope>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiToolkit.ts#L38)

Since v1.0.0
AiToolkit-HandlersFrom.md
Package: `@effect/ai`<br />
Module: `AiToolkit`<br />

## AiToolkit.HandlersFrom

A utility mapped type which associates tool names with their handlers.

**Signature**

```ts
type HandlersFrom<Tools> = {
  [Tool in Tools as Tool["name"]]: (params: AiTool.Parameters<Tool>) => AiTool.HandlerEffect<Tool>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiToolkit.ts#L94)

Since v1.0.0
AiToolkit-ToHandler.md
Package: `@effect/ai`<br />
Module: `AiToolkit`<br />

## AiToolkit.ToHandler

Represents an `AiToolkit` which has been augmented with a handler function
for resolving tool call requests.

**Signature**

```ts
export interface ToHandler<in out Tool extends AiTool.Any> {
  readonly tools: ReadonlyArray<Tool>
  readonly handle: (toolName: AiTool.Name<Tool>, toolParams: AiTool.Parameters<Tool>) => AiTool.HandlerEffect<Tool>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiToolkit.ts#L83)

Since v1.0.0
AiToolkit-Tools.md
Package: `@effect/ai`<br />
Module: `AiToolkit`<br />

## AiToolkit.Tools

A utility type which returns the tools in an `AiToolkit`.

**Signature**

```ts
type Tools<Toolkit> = Toolkit extends AiToolkit<infer Tool> ? string extends Tool["name"] ? never : Tool : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiToolkit.ts#L104)

Since v1.0.0
AiToolkit-make.md
Package: `@effect/ai`<br />
Module: `AiToolkit`<br />

## AiToolkit.make

Constructs a new `AiToolkit` from the specified tools.

**Signature**

```ts
declare const make: <const Tools extends ReadonlyArray<AiTool.Any>>(...tools: Tools) => AiToolkit<Tools[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiToolkit.ts#L241)

Since v1.0.0
AiToolkit-merge.md
Package: `@effect/ai`<br />
Module: `AiToolkit`<br />

## AiToolkit.merge

Merges this toolkit with one or more other toolkits.

**Signature**

```ts
declare const merge: <const Toolkits extends ReadonlyArray<Any>>(...toolkits: Toolkits) => AiToolkit<Tools<Toolkits[number]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/AiToolkit.ts#L251)

Since v1.0.0
Ansi-beep.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.beep

Play a beeping sound.

**Signature**

```ts
declare const beep: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L300)

Since v1.0.0
Ansi-cursorBackward.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorBackward

Moves the cursor backward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorBackward: (columns?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L368)

Since v1.0.0
Ansi-cursorDown.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorDown

Moves the cursor down by the specified number of `lines` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorDown: (lines?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L346)

Since v1.0.0
Ansi-cursorForward.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorForward

Moves the cursor forward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorForward: (columns?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L357)

Since v1.0.0
Ansi-cursorHide.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorHide

Hides the cursor.

**Signature**

```ts
declare const cursorHide: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L419)

Since v1.0.0
Ansi-cursorLeft.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorLeft

Moves the cursor to the first column of the current row.

**Signature**

```ts
declare const cursorLeft: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L376)

Since v1.0.0
Ansi-cursorMove.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorMove

Move the cursor position the specified number of `rows` and `columns`
relative to the current cursor position.

If the cursor is already at the edge of the screen in either direction, then
additional movement will have no effect.

**Signature**

```ts
declare const cursorMove: (column: number, row?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L324)

Since v1.0.0
Ansi-cursorNextLine.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorNextLine

Moves cursor to beginning of the line the specified number of rows down
(default `1`).

**Signature**

```ts
declare const cursorNextLine: (rows?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L402)

Since v1.0.0
Ansi-cursorPrevLine.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorPrevLine

Moves cursor to beginning of the line the specified number of rows up
(default `1`).

**Signature**

```ts
declare const cursorPrevLine: (rows?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L411)

Since v1.0.0
Ansi-cursorRestorePosition.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorRestorePosition

Restores the cursor position, encoding shift state and formatting attributes
from the previous save, if any, otherwise resets these all to their defaults.

**Signature**

```ts
declare const cursorRestorePosition: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L393)

Since v1.0.0
Ansi-cursorSavePosition.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorSavePosition

Saves the cursor position, encoding shift state and formatting attributes.

**Signature**

```ts
declare const cursorSavePosition: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L384)

Since v1.0.0
Ansi-cursorShow.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorShow

Shows the cursor.

**Signature**

```ts
declare const cursorShow: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L427)

Since v1.0.0
Ansi-cursorTo.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorTo

Moves the cursor to the specified `row` and `column`.

Though the ANSI Control Sequence for Cursor Position is `1`-based, this
method takes row and column values starting from `0` and adjusts them to `1`-
based values.

**Signature**

```ts
declare const cursorTo: (column: number, row?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L312)

Since v1.0.0
Ansi-cursorUp.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.cursorUp

Moves the cursor up by the specified number of `lines` (default `1`) relative
to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorUp: (lines?: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L335)

Since v1.0.0
Ansi-eraseDown.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.eraseDown

Clears from the current cursor position to the end of the screen.

The current cursor position does not change.

**Signature**

```ts
declare const eraseDown: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L475)

Since v1.0.0
Ansi-eraseEndLine.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.eraseEndLine

Clears from the current cursor position to the end of the current line.

The current cursor position does not change.

**Signature**

```ts
declare const eraseEndLine: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L445)

Since v1.0.0
Ansi-eraseLine.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.eraseLine

Clears the current line.

The current cursor position does not change.

**Signature**

```ts
declare const eraseLine: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L465)

Since v1.0.0
Ansi-eraseLines.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.eraseLines

Erase from the current cursor position up the specified amount of rows.

**Signature**

```ts
declare const eraseLines: (rows: number) => Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L435)

Since v1.0.0
Ansi-eraseScreen.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.eraseScreen

Clears the entire screen and move the cursor to the upper left.

**Signature**

```ts
declare const eraseScreen: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L493)

Since v1.0.0
Ansi-eraseStartLine.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.eraseStartLine

Clears from the current cursor position to the start of the current line.

The current cursor position does not change.

**Signature**

```ts
declare const eraseStartLine: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L455)

Since v1.0.0
Ansi-eraseUp.md
Package: `@effect/printer-ansi`<br />
Module: `Ansi`<br />

## Ansi.eraseUp

Clears from the current cursor position to the beginning of the screen.

The current cursor position does not change.

**Signature**

```ts
declare const eraseUp: Ansi
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/Ansi.ts#L485)

Since v1.0.0
AnsiDoc-beep.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.beep

Play a beeping sound.

**Signature**

```ts
declare const beep: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L67)

Since v1.0.0
AnsiDoc-cursorBackward.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorBackward

Moves the cursor backward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorBackward: (columns?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L135)

Since v1.0.0
AnsiDoc-cursorDown.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorDown

Moves the cursor down by the specified number of `lines` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorDown: (lines?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L113)

Since v1.0.0
AnsiDoc-cursorForward.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorForward

Moves the cursor forward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorForward: (columns?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L124)

Since v1.0.0
AnsiDoc-cursorHide.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorHide

Hides the cursor.

**Signature**

```ts
declare const cursorHide: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L186)

Since v1.0.0
AnsiDoc-cursorLeft.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorLeft

Moves the cursor to the first column of the current row.

**Signature**

```ts
declare const cursorLeft: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L143)

Since v1.0.0
AnsiDoc-cursorMove.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorMove

Move the cursor position the specified number of `rows` and `columns`
relative to the current cursor position.

If the cursor is already at the edge of the screen in either direction, then
additional movement will have no effect.

**Signature**

```ts
declare const cursorMove: (column: number, row?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L91)

Since v1.0.0
AnsiDoc-cursorNextLine.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorNextLine

Moves cursor to beginning of the line the specified number of rows down
(default `1`).

**Signature**

```ts
declare const cursorNextLine: (rows?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L169)

Since v1.0.0
AnsiDoc-cursorPrevLine.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorPrevLine

Moves cursor to beginning of the line the specified number of rows up
(default `1`).

**Signature**

```ts
declare const cursorPrevLine: (rows?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L178)

Since v1.0.0
AnsiDoc-cursorRestorePosition.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorRestorePosition

Restores the cursor position, encoding shift state and formatting attributes
from the previous save, if any, otherwise resets these all to their defaults.

**Signature**

```ts
declare const cursorRestorePosition: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L160)

Since v1.0.0
AnsiDoc-cursorSavePosition.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorSavePosition

Saves the cursor position, encoding shift state and formatting attributes.

**Signature**

```ts
declare const cursorSavePosition: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L151)

Since v1.0.0
AnsiDoc-cursorShow.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorShow

Shows the cursor.

**Signature**

```ts
declare const cursorShow: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L194)

Since v1.0.0
AnsiDoc-cursorTo.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorTo

Moves the cursor to the specified `row` and `column`.

Though the ANSI Control Sequence for Cursor Position is `1`-based, this
method takes row and column values starting from `0` and adjusts them to `1`-
based values.

**Signature**

```ts
declare const cursorTo: (column: number, row?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L79)

Since v1.0.0
AnsiDoc-cursorUp.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.cursorUp

Moves the cursor up by the specified number of `lines` (default `1`) relative
to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

**Signature**

```ts
declare const cursorUp: (lines?: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L102)

Since v1.0.0
AnsiDoc-eraseDown.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.eraseDown

Clears from the current cursor position to the end of the screen.

The current cursor position does not change.

**Signature**

```ts
declare const eraseDown: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L242)

Since v1.0.0
AnsiDoc-eraseEndLine.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.eraseEndLine

Clears from the current cursor position to the end of the current line.

The current cursor position does not change.

**Signature**

```ts
declare const eraseEndLine: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L212)

Since v1.0.0
AnsiDoc-eraseLine.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.eraseLine

Clears the current line.

The current cursor position does not change.

**Signature**

```ts
declare const eraseLine: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L232)

Since v1.0.0
AnsiDoc-eraseLines.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.eraseLines

Erase from the current cursor position up the specified amount of rows.

**Signature**

```ts
declare const eraseLines: (rows: number) => AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L202)

Since v1.0.0
AnsiDoc-eraseScreen.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.eraseScreen

Clears the entire screen and move the cursor to the upper left.

**Signature**

```ts
declare const eraseScreen: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L260)

Since v1.0.0
AnsiDoc-eraseStartLine.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.eraseStartLine

Clears from the current cursor position to the start of the current line.

The current cursor position does not change.

**Signature**

```ts
declare const eraseStartLine: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L222)

Since v1.0.0
AnsiDoc-eraseUp.md
Package: `@effect/printer-ansi`<br />
Module: `AnsiDoc`<br />

## AnsiDoc.eraseUp

Clears from the current cursor position to the beginning of the screen.

The current cursor position does not change.

**Signature**

```ts
declare const eraseUp: AnsiDoc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/AnsiDoc.ts#L252)

Since v1.0.0
Applicative-getMonoid.md
Package: `@effect/typeclass`<br />
Module: `Applicative`<br />

## Applicative.getMonoid

Lift a `Monoid` into `F`, combining the inner values using the provided `Monoid`:

- `combine` is provided by `semiApplicative.getSemigroup`.
- `empty` is `F.of(M.empty)`

**Signature**

```ts
declare const getMonoid: <F extends TypeLambda>(F: Applicative<F>) => <A, R, O, E>(M: Monoid<A>) => Monoid<Kind<F, R, O, E, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Applicative.ts#L25)

Since v0.24.0
Arbitrary-make.md
Package: `effect`<br />
Module: `Arbitrary`<br />

## Arbitrary.make

Returns a fast-check Arbitrary for the `A` type of the provided schema.

**Signature**

```ts
declare const make: <A, I, R>(schema: Schema.Schema<A, I, R>) => FastCheck.Arbitrary<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Arbitrary.ts#L63)

Since v3.10.0
Arbitrary-makeLazy.md
Package: `effect`<br />
Module: `Arbitrary`<br />

## Arbitrary.makeLazy

Returns a LazyArbitrary for the `A` type of the provided schema.

**Signature**

```ts
declare const makeLazy: <A, I, R>(schema: Schema.Schema<A, I, R>) => LazyArbitrary<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Arbitrary.ts#L52)

Since v3.10.0
Args-Args.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.Args

Represents arguments that can be passed to a command-line application.

**Signature**

```ts
export interface Args<A> extends Args.Variance<A>, Pipeable {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L40)

Since v1.0.0
Args-boolean.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.boolean

Creates a boolean argument.

Can optionally provide a custom argument name (defaults to `"boolean"`).

**Signature**

```ts
declare const boolean: (options?: Args.BaseArgsConfig) => Args<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L181)

Since v1.0.0
Args-choice.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.choice

Creates a choice argument.

Can optionally provide a custom argument name (defaults to `"choice"`).

**Signature**

```ts
declare const choice: <A>(choices: ReadonlyArray<[string, A]>, config?: Args.BaseArgsConfig) => Args<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L191)

Since v1.0.0
Args-date.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.date

Creates a date argument.

Can optionally provide a custom argument name (defaults to `"date"`).

**Signature**

```ts
declare const date: (config?: Args.BaseArgsConfig) => Args<globalThis.Date>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L204)

Since v1.0.0
Args-directory.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.directory

Creates a directory argument.

Can optionally provide a custom argument name (defaults to `"directory"`).

**Signature**

```ts
declare const directory: (config?: Args.PathArgsConfig) => Args<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L214)

Since v1.0.0
Args-file.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.file

Creates a file argument.

Can optionally provide a custom argument name (defaults to `"file"`).

**Signature**

```ts
declare const file: (config?: Args.PathArgsConfig) => Args<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L224)

Since v1.0.0
Args-fileContent.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.fileContent

Creates a file argument that reads its contents.

Can optionally provide a custom argument name (defaults to `"file"`).

**Signature**

```ts
declare const fileContent: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: Uint8Array]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L234)

Since v1.0.0
Args-fileParse.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.fileParse

Creates a file argument that reads and parses its contents.

Can optionally provide a custom argument name (defaults to `"file"`).

**Signature**

```ts
declare const fileParse: (config?: Args.FormatArgsConfig | undefined) => Args<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L246)

Since v1.0.0
Args-fileSchema.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.fileSchema

Creates a file argument that reads, parses and validates its contents.

Can optionally provide a custom argument name (defaults to `"file"`).

**Signature**

```ts
declare const fileSchema: <I, A>(schema: Schema<A, I, FileSystem | Path | Terminal>, config?: Args.FormatArgsConfig | undefined) => Args<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L256)

Since v1.0.0
Args-fileText.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.fileText

Creates a file argument that reads it's contents.

Can optionally provide a custom argument name (defaults to `"file"`).

**Signature**

```ts
declare const fileText: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: string]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L269)

Since v1.0.0
Args-float.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.float

Creates a floating point number argument.

Can optionally provide a custom argument name (defaults to `"float"`).

**Signature**

```ts
declare const float: (config?: Args.BaseArgsConfig) => Args<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L281)

Since v1.0.0
Args-integer.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.integer

Creates an integer argument.

Can optionally provide a custom argument name (defaults to `"integer"`).

**Signature**

```ts
declare const integer: (config?: Args.BaseArgsConfig) => Args<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L321)

Since v1.0.0
Args-none.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.none

Creates an empty argument.

**Signature**

```ts
declare const none: Args<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L362)

Since v1.0.0
Args-path.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.path

Creates a path argument.

Can optionally provide a custom argument name (defaults to `"path"`).

**Signature**

```ts
declare const path: (config?: Args.PathArgsConfig) => Args<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L372)

Since v1.0.0
Args-redacted.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.redacted

Creates a text argument.

Can optionally provide a custom argument name (defaults to `"redacted"`).

**Signature**

```ts
declare const redacted: (config?: Args.BaseArgsConfig) => Args<Redacted>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L388)

Since v1.0.0
Args-secret.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.secret

Creates a text argument.

Can optionally provide a custom argument name (defaults to `"secret"`).

**Signature**

```ts
declare const secret: (config?: Args.BaseArgsConfig) => Args<Secret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L398)

Since v1.0.0
Args-text.md
Package: `@effect/cli`<br />
Module: `Args`<br />

## Args.text

Creates a text argument.

Can optionally provide a custom argument name (defaults to `"text"`).

**Signature**

```ts
declare const text: (config?: Args.BaseArgsConfig) => Args<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Args.ts#L408)

Since v1.0.0
Array-allocate.md
Package: `effect`<br />
Module: `Array`<br />

## Array.allocate

Creates a new `Array` of the specified length.

**Example**

```ts
import { Array } from "effect"

const result = Array.allocate<number>(3)
console.log(result) // [ <3 empty items> ]
```

**Signature**

```ts
declare const allocate: <A = never>(n: number) => Array<A | undefined>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L77)

Since v2.0.0
Array-append.md
Package: `effect`<br />
Module: `Array`<br />

## Array.append

Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.append([1, 2, 3], 4);
console.log(result) // [1, 2, 3, 4]
```

**Signature**

```ts
declare const append: { <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L409)

Since v2.0.0
Array-appendAll.md
Package: `effect`<br />
Module: `Array`<br />

## Array.appendAll

Concatenates two arrays (or iterables), combining their elements.
If either array is non-empty, the result is also a non-empty array.

**Signature**

```ts
declare const appendAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L421)

Since v2.0.0
Array-bind.md
Package: `effect`<br />
Module: `Array`<br />

## Array.bind

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import { Array, pipe } from "effect"

const doResult = pipe(
  Array.Do,
  Array.bind("x", () => [1, 3, 5]),
  Array.bind("y", () => [2, 4, 6]),
  Array.filter(({ x, y }) => x < y), // condition
  Array.map(({ x, y }) => [x, y] as const) // transformation
)
console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]

// equivalent
const x = [1, 3, 5],
      y = [2, 4, 6],
      result = [];
for(let i = 0; i < x.length; i++) {
  for(let j = 0; j < y.length; j++) {
    const _x = x[i], _y = y[j];
    if(_x < _y) result.push([_x, _y] as const)
  }
}
```

**See**

- `bindTo`
- `Do`
- `let`

**Signature**

```ts
declare const bind: { <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: ReadonlyArray<A>, tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3403)

Since v3.2.0
Array-bindTo.md
Package: `effect`<br />
Module: `Array`<br />

## Array.bindTo

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import { Array, pipe } from "effect"

const doResult = pipe(
  Array.Do,
  Array.bind("x", () => [1, 3, 5]),
  Array.bind("y", () => [2, 4, 6]),
  Array.filter(({ x, y }) => x < y), // condition
  Array.map(({ x, y }) => [x, y] as const) // transformation
)
console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]

// equivalent
const x = [1, 3, 5],
      y = [2, 4, 6],
      result = [];
for(let i = 0; i < x.length; i++) {
  for(let j = 0; j < y.length; j++) {
    const _x = x[i], _y = y[j];
    if(_x < _y) result.push([_x, _y] as const)
  }
}
```

**See**

- `bindTo`
- `Do`
- `let`

**Signature**

```ts
declare const bindTo: { <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A; }>; <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3464)

Since v3.2.0
Array-cartesian.md
Package: `effect`<br />
Module: `Array`<br />

## Array.cartesian

Zips this chunk crosswise with the specified chunk.

**Example**

```ts
import { Array } from "effect"

const result = Array.cartesian([1, 2], ["a", "b"])
console.log(result) // [[1, "a"], [1, "b"], [2, "a"], [2, "b"]]
```

**Signature**

```ts
declare const cartesian: { <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>; <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3295)

Since v2.0.0
Array-Do.md
Package: `effect`<br />
Module: `Array`<br />

## Array.Do

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import { Array, pipe } from "effect"

const doResult = pipe(
  Array.Do,
  Array.bind("x", () => [1, 3, 5]),
  Array.bind("y", () => [2, 4, 6]),
  Array.filter(({ x, y }) => x < y), // condition
  Array.map(({ x, y }) => [x, y] as const) // transformation
)
console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]

// equivalent
const x = [1, 3, 5],
      y = [2, 4, 6],
      result = [];
for(let i = 0; i < x.length; i++) {
  for(let j = 0; j < y.length; j++) {
    const _x = x[i], _y = y[j];
    if(_x < _y) result.push([_x, _y] as const)
  }
}
```

**See**

- `bindTo`
- `bind`
- `let`

**Signature**

```ts
declare const Do: ReadonlyArray<{}>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3354)

Since v3.2.0
Array-cartesianWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.cartesianWith

Zips this chunk crosswise with the specified chunk using the specified combiner.

**Example**

```ts
import { Array } from "effect"

const result = Array.cartesianWith([1, 2], ["a", "b"], (a, b) => `${a}-${b}`)
console.log(result) // ["1-a", "1-b", "2-a", "2-b"]
```

**Signature**

```ts
declare const cartesianWith: { <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>; <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3271)

Since v2.0.0
Array-chop.md
Package: `effect`<br />
Module: `Array`<br />

## Array.chop

A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for "chopping" up the input
`Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a
value and the rest of the `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])
console.log(result) // [2, 4, 6, 8, 10]

// Explanation:
// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.
// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,
// resulting in a new array `[2, 4, 6, 8, 10]`.
```

**Signature**

```ts
declare const chop: { <S extends Iterable<any>, B>(f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): NonEmptyArray<B>; <A, B>(self: Iterable<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): Array<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1835)

Since v2.0.0
Array-chunksOf.md
Package: `effect`<br />
Module: `Array`<br />

## Array.chunksOf

Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
definition of `chunksOf`; it satisfies the property that

```ts
chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
```

whenever `n` evenly divides the length of `self`.

**Example**

```ts
import { Array } from "effect"

const result = Array.chunksOf([1, 2, 3, 4, 5], 2)
console.log(result) // [[1, 2], [3, 4], [5]]

// Explanation:
// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.
// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,
// the last chunk contains the remaining elements.
// The result is `[[1, 2], [3, 4], [5]]`.
```

**Signature**

```ts
declare const chunksOf: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>; <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2056)

Since v2.0.0
Array-contains.md
Package: `effect`<br />
Module: `Array`<br />

## Array.contains

Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.

**Example**

```ts
import { Array, pipe } from "effect"

const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))
console.log(result) // true
```

**Signature**

```ts
declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1809)

Since v2.0.0
Array-containsWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.containsWith

Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.

**Example**

```ts
import { Array, pipe } from "effect"

const isEquivalent = (a: number, b: number) => a === b
const containsNumber = Array.containsWith(isEquivalent)
const result = pipe([1, 2, 3, 4], containsNumber(3))
console.log(result) // true
```

**Signature**

```ts
declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1779)

Since v2.0.0
Array-copy.md
Package: `effect`<br />
Module: `Array`<br />

## Array.copy

Copies an array.

**Example**

```ts
import { Array } from "effect"

const result = Array.copy([1, 2, 3])
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const copy: { <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>; <A>(self: ReadonlyArray<A>): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1987)

Since v2.0.0
Array-countBy.md
Package: `effect`<br />
Module: `Array`<br />

## Array.countBy

Counts all the element of the given array that pass the given predicate

**Example**

```ts
import { Array } from "effect"

const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)
console.log(result) // 2
```

**Signature**

```ts
declare const countBy: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => number; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1124)

Since v3.16.0
Array-dedupe.md
Package: `effect`<br />
Module: `Array`<br />

## Array.dedupe

Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.
The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.

**Signature**

```ts
declare const dedupe: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3144)

Since v2.0.0
Array-dedupeAdjacent.md
Package: `effect`<br />
Module: `Array`<br />

## Array.dedupeAdjacent

Deduplicates adjacent elements that are identical.

**Example**

```ts
import { Array } from "effect"

const result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3192)

Since v2.0.0
Array-dedupeAdjacentWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.dedupeAdjacentWith

Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.

**Example**

```ts
import { Array } from "effect"

const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3163)

Since v2.0.0
Array-dedupeWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.dedupeWith

Remove duplicates from an `Iterable` using the provided `isEquivalent` function,
preserving the order of the first occurrence of each element.

**Example**

```ts
import { Array } from "effect"

const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const dedupeWith: { <S extends Iterable<any>>(isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3114)

Since v2.0.0
Array-difference.md
Package: `effect`<br />
Module: `Array`<br />

## Array.difference

Creates a `Array` of values not included in the other given `Iterable`.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const difference = Array.difference([1, 2, 3], [2, 3, 4])
console.log(difference) // [1]
```

**Signature**

```ts
declare const difference: { <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, that: Iterable<A>): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2370)

Since v2.0.0
Array-differenceWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.differenceWith

Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = [2, 3, 4]
const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)
console.log(difference) // [1]
```

**Signature**

```ts
declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2344)

Since v2.0.0
Array-drop.md
Package: `effect`<br />
Module: `Array`<br />

## Array.drop

Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.drop([1, 2, 3, 4, 5], 2)
console.log(result) // [3, 4, 5]
```

**Signature**

```ts
declare const drop: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L923)

Since v2.0.0
Array-dropRight.md
Package: `effect`<br />
Module: `Array`<br />

## Array.dropRight

Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.dropRight([1, 2, 3, 4, 5], 2)
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const dropRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L948)

Since v2.0.0
Array-dropWhile.md
Package: `effect`<br />
Module: `Array`<br />

## Array.dropWhile

Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)
console.log(result) // [4, 5]
```

**Signature**

```ts
declare const dropWhile: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L971)

Since v2.0.0
Array-ensure.md
Package: `effect`<br />
Module: `Array`<br />

## Array.ensure

Creates a new `Array` from a value that might not be an iterable.

**Example**

```ts
import { Array } from "effect"

console.log(Array.ensure("a")) // ["a"]
console.log(Array.ensure(["a"])) // ["a"]
console.log(Array.ensure(["a", "b", "c"])) // ["a", "b", "c"]
```

**Signature**

```ts
declare const ensure: <A>(self: ReadonlyArray<A> | A) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L184)

Since v3.3.0
Array-every.md
Package: `effect`<br />
Module: `Array`<br />

## Array.every

Check if a predicate holds true for every `ReadonlyArray` element.

**Signature**

```ts
declare const every: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean; <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2939)

Since v2.0.0
Array-extend.md
Package: `effect`<br />
Module: `Array`<br />

## Array.extend

Extends an array with a function that maps each subarray to a value.

**Example**

```ts
import { Array } from "effect"

const result = Array.extend([1, 2, 3], as => as.length)
console.log(result) // [3, 2, 1]

// Explanation:
// The function maps each subarray starting from each element to its length.
// The subarrays are: [1, 2, 3], [2, 3], [3].
// The lengths are: 3, 2, 1.
// Therefore, the result is [3, 2, 1].
```

**Signature**

```ts
declare const extend: { <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>; <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2989)

Since v2.0.0
Array-filterMap.md
Package: `effect`<br />
Module: `Array`<br />

## Array.filterMap

Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.
This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.

**Example**

```ts
import { Array, Option } from "effect"

const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()

const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);
console.log(result) // [4, 16]
```

**Signature**

```ts
declare const filterMap: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2516)

Since v2.0.0
Array-filterMapWhile.md
Package: `effect`<br />
Module: `Array`<br />

## Array.filterMapWhile

Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.
This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.
This is useful when you need to transform an array but only up to the point where a certain condition holds true.

**Example**

```ts
import { Array, Option } from "effect"

const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()

const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)
console.log(result) // [4, 16]
```

**Signature**

```ts
declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2553)

Since v2.0.0
Array-findFirst.md
Package: `effect`<br />
Module: `Array`<br />

## Array.findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

**Example**

```ts
import { Array } from "effect"

const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)
console.log(result) // Option.some(4)
```

**Signature**

```ts
declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1053)

Since v2.0.0
Array-findFirstIndex.md
Package: `effect`<br />
Module: `Array`<br />

## Array.findFirstIndex

Return the first index for which a predicate holds.

**Example**

```ts
import { Array } from "effect"

const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)
console.log(result) // Option.some(2)
```

**Signature**

```ts
declare const findFirstIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L995)

Since v2.0.0
Array-findLast.md
Package: `effect`<br />
Module: `Array`<br />

## Array.findLast

Finds the last element in an iterable collection that satisfies the given predicate or refinement.
Returns an `Option` containing the found element, or `Option.none` if no element matches.

**Example**

```ts
import { Array } from "effect"

const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)
console.log(result) // Option.some(4)
```

**Signature**

```ts
declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1078)

Since v2.0.0
Array-findLastIndex.md
Package: `effect`<br />
Module: `Array`<br />

## Array.findLastIndex

Return the last index for which a predicate holds.

**Example**

```ts
import { Array } from "effect"

const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)
console.log(result) // Option.some(1)
```

**Signature**

```ts
declare const findLastIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1024)

Since v2.0.0
Array-flatMap.md
Package: `effect`<br />
Module: `Array`<br />

## Array.flatMap

Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.

**Signature**

```ts
declare const flatMap: { <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A, i: number) => NonEmptyReadonlyArray<B>): NonEmptyArray<B>; <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2454)

Since v2.0.0
Array-flatMapNullable.md
Package: `effect`<br />
Module: `Array`<br />

## Array.flatMapNullable

Maps over an array and flattens the result, removing null and undefined values.

**Example**

```ts
import { Array } from "effect"

const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))
console.log(result) // [1, 3]

// Explanation:
// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers
// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened
// to remove null values, resulting in [1, 3].
```

**Signature**

```ts
declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>; <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2886)

Since v2.0.0
Array-flatten.md
Package: `effect`<br />
Module: `Array`<br />

## Array.flatten

Combines multiple arrays into a single array by concatenating all elements
from each nested array. This function ensures that the structure of nested
arrays is collapsed into a single, flat array.

**Example**

```ts
import { Array } from "effect"

const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])
console.log(result) // [1, 2, 3, 4, 5, 6]
```

**Signature**

```ts
declare const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2494)

Since v2.0.0
Array-forEach.md
Package: `effect`<br />
Module: `Array`<br />

## Array.forEach

Performs a side-effect for each element of the `Iterable`.

**Example**

```ts
import { Array } from "effect"

Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3
```

**Signature**

```ts
declare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3094)

Since v2.0.0
Array-fromIterable.md
Package: `effect`<br />
Module: `Array`<br />

## Array.fromIterable

Creates a new `Array` from an iterable collection of values.
If the input is already an array, it returns the input as-is.
Otherwise, it converts the iterable collection to an array.

**Example**

```ts
import { Array } from "effect"

const result = Array.fromIterable(new Set([1, 2, 3]))
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const fromIterable: <A>(collection: Iterable<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L165)

Since v2.0.0
Array-fromOption.md
Package: `effect`<br />
Module: `Array`<br />

## Array.fromOption

Converts an `Option` to an array.

**Example**

```ts
import { Array, Option } from "effect"

console.log(Array.fromOption(Option.some(1))) // [1]
console.log(Array.fromOption(Option.none())) // []
```

**Signature**

```ts
declare const fromOption: <A>(self: Option.Option<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L218)

Since v2.0.0
Array-fromRecord.md
Package: `effect`<br />
Module: `Array`<br />

## Array.fromRecord

Takes a record and returns an array of tuples containing its keys and values.

**Example**

```ts
import { Array } from "effect"

const result = Array.fromRecord({ a: 1, b: 2, c: 3 })
console.log(result) // [["a", 1], ["b", 2], ["c", 3]]
```

**Signature**

```ts
declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L201)

Since v2.0.0
Array-get.md
Package: `effect`<br />
Module: `Array`<br />

## Array.get

This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.

**Signature**

```ts
declare const get: { (index: number): <A>(self: ReadonlyArray<A>) => Option.Option<A>; <A>(self: ReadonlyArray<A>, index: number): Option.Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L610)

Since v2.0.0
Array-getEquivalence.md
Package: `effect`<br />
Module: `Array`<br />

## Array.getEquivalence

Creates an equivalence relation for arrays.

**Example**

```ts
import { Array } from "effect"

const eq = Array.getEquivalence<number>((a, b) => a === b)
console.log(eq([1, 2, 3], [1, 2, 3])) // true
```

**Signature**

```ts
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<ReadonlyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3077)

Since v2.0.0
Array-getLefts.md
Package: `effect`<br />
Module: `Array`<br />

## Array.getLefts

Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.

**Example**

```ts
import { Array, Either } from "effect"

const result = Array.getLefts([Either.right(1), Either.left("err"), Either.right(2)])
console.log(result) // ["err"]
```

**Signature**

```ts
declare const getLefts: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Left<ReadonlyArray.Infer<T>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2653)

Since v2.0.0
Array-getOrder.md
Package: `effect`<br />
Module: `Array`<br />

## Array.getOrder

This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
If all elements are equal, the arrays are then compared based on their length.
It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.

**Signature**

```ts
declare const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3060)

Since v2.0.0
Array-getRights.md
Package: `effect`<br />
Module: `Array`<br />

## Array.getRights

Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.

**Example**

```ts
import { Array, Either } from "effect"

const result = Array.getRights([Either.right(1), Either.left("err"), Either.right(2)])
console.log(result) // [1, 2]
```

**Signature**

```ts
declare const getRights: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Right<ReadonlyArray.Infer<T>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2681)

Since v2.0.0
Array-getSomes.md
Package: `effect`<br />
Module: `Array`<br />

## Array.getSomes

Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.

**Example**

```ts
import { Array, Option } from "effect"

const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])
console.log(result) // [1, 2]
```

**Signature**

```ts
declare const getSomes: <T extends Iterable<Option.Option<X>>, X = any>(self: T) => Array<Option.Option.Value<ReadonlyArray.Infer<T>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2634)

Since v2.0.0
Array-group.md
Package: `effect`<br />
Module: `Array`<br />

## Array.group

Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.

**Example**

```ts
import { Array } from "effect"

const result = Array.group([1, 1, 2, 2, 2, 3, 1])
console.log(result) // [[1, 1], [2, 2, 2], [3], [1]]
```

**Signature**

```ts
declare const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2156)

Since v2.0.0
Array-groupBy.md
Package: `effect`<br />
Module: `Array`<br />

## Array.groupBy

Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
function on each element, and grouping the results according to values returned

**Example**

```ts
import { Array } from "effect"

const people = [
  { name: "Alice", group: "A" },
  { name: "Bob", group: "B" },
  { name: "Charlie", group: "A" }
]

const result = Array.groupBy(people, person => person.group)
console.log(result)
// {
//  A: [{ name: "Alice", group: "A" }, { name: "Charlie", group: "A" }],
//  B: [{ name: "Bob", group: "B" }]
// }
```

**Signature**

```ts
declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2186)

Since v2.0.0
Array-groupWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.groupWith

Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.

**Example**

```ts
import { Array } from "effect"

const result = Array.groupWith(["a", "a", "b", "b", "b", "c", "a"], (x, y) => x === y)
console.log(result) // [["a", "a"], ["b", "b", "b"], ["c"], ["a"]]
```

**Signature**

```ts
declare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2119)

Since v2.0.0
Array-head.md
Package: `effect`<br />
Module: `Array`<br />

## Array.head

Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.

**Signature**

```ts
declare const head: <A>(self: ReadonlyArray<A>) => Option.Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L679)

Since v2.0.0
Array-headNonEmpty.md
Package: `effect`<br />
Module: `Array`<br />

## Array.headNonEmpty

Get the first element of a non empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.headNonEmpty([1, 2, 3, 4])
console.log(result) // 1
```

**Signature**

```ts
declare const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L696)

Since v2.0.0
Array-init.md
Package: `effect`<br />
Module: `Array`<br />

## Array.init

Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.

**Signature**

```ts
declare const init: <A>(self: Iterable<A>) => Option.Option<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L758)

Since v2.0.0
Array-initNonEmpty.md
Package: `effect`<br />
Module: `Array`<br />

## Array.initNonEmpty

Get all but the last element of a non empty array, creating a new array.

**Example**

```ts
import { Array } from "effect"

const result = Array.initNonEmpty([1, 2, 3, 4])
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const initNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L778)

Since v2.0.0
Array-insertAt.md
Package: `effect`<br />
Module: `Array`<br />

## Array.insertAt

Insert an element at the specified index, creating a new `NonEmptyArray`,
or return `None` if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')
console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])
```

**Signature**

```ts
declare const insertAt: { <B>(i: number, b: B): <A>(self: Iterable<A>) => Option.Option<NonEmptyArray<A | B>>; <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1160)

Since v2.0.0
Array-intersection.md
Package: `effect`<br />
Module: `Array`<br />

## Array.intersection

Creates an `Array` of unique values that are included in all given `Iterable`s.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const result = Array.intersection([1, 2, 3], [3, 4, 1])
console.log(result) // [1, 3]
```

**Signature**

```ts
declare const intersection: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2322)

Since v2.0.0
Array-intersectionWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.intersectionWith

Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]
const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id
const result = Array.intersectionWith(isEquivalent)(array2)(array1)
console.log(result) // [{ id: 1 }, { id: 3 }]
```

**Signature**

```ts
declare const intersectionWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2296)

Since v2.0.0
Array-intersperse.md
Package: `effect`<br />
Module: `Array`<br />

## Array.intersperse

Places an element in between members of an `Iterable`.
If the input is a non-empty array, the result is also a non-empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.intersperse([1, 2, 3], 0)
console.log(result) // [1, 0, 2, 0, 3]
```

**Signature**

```ts
declare const intersperse: { <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, middle: B): Array<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1611)

Since v2.0.0
Array-isArray.md
Package: `effect`<br />
Module: `Array`<br />

## Array.isArray

Determine if `unknown` is an Array.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isArray(null)) // false
console.log(Array.isArray([1, 2, 3])) // true
```

**Signature**

```ts
declare const isArray: { (self: unknown): self is Array<unknown>; <T>(self: T): self is Extract<T, ReadonlyArray<any>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L514)

Since v2.0.0
Array-isEmptyArray.md
Package: `effect`<br />
Module: `Array`<br />

## Array.isEmptyArray

Determine if an `Array` is empty narrowing down the type to `[]`.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isEmptyArray([])) // true
console.log(Array.isEmptyArray([1, 2, 3])) // false
```

**Signature**

```ts
declare const isEmptyArray: <A>(self: Array<A>) => self is []
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L534)

Since v2.0.0
Array-isEmptyReadonlyArray.md
Package: `effect`<br />
Module: `Array`<br />

## Array.isEmptyReadonlyArray

Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isEmptyReadonlyArray([])) // true
console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false
```

**Signature**

```ts
declare const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly []
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L551)

Since v2.0.0
Array-isNonEmptyArray.md
Package: `effect`<br />
Module: `Array`<br />

## Array.isNonEmptyArray

Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.

An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isNonEmptyArray([])) // false
console.log(Array.isNonEmptyArray([1, 2, 3])) // true
```

**Signature**

```ts
declare const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L570)

Since v2.0.0
Array-isNonEmptyReadonlyArray.md
Package: `effect`<br />
Module: `Array`<br />

## Array.isNonEmptyReadonlyArray

Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.

A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isNonEmptyReadonlyArray([])) // false
console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true
```

**Signature**

```ts
declare const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L589)

Since v2.0.0
Array-join.md
Package: `effect`<br />
Module: `Array`<br />

## Array.join

Joins the elements together with "sep" in the middle.

**Example**

```ts
import { Array } from "effect"

const strings = ["a", "b", "c"]
const joined = Array.join(strings, "-")
console.log(joined) // "a-b-c"
```

**Signature**

```ts
declare const join: { (sep: string): (self: Iterable<string>) => string; (self: Iterable<string>, sep: string): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3210)

Since v2.0.0
Array-last.md
Package: `effect`<br />
Module: `Array`<br />

## Array.last

Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.

**Signature**

```ts
declare const last: <A>(self: ReadonlyArray<A>) => Option.Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L704)

Since v2.0.0
Array-lastNonEmpty.md
Package: `effect`<br />
Module: `Array`<br />

## Array.lastNonEmpty

Get the last element of a non empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.lastNonEmpty([1, 2, 3, 4])
console.log(result) // 4
```

**Signature**

```ts
declare const lastNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L722)

Since v2.0.0
Array-length.md
Package: `effect`<br />
Module: `Array`<br />

## Array.length

Return the number of elements in a `ReadonlyArray`.

**Signature**

```ts
declare const length: <A>(self: ReadonlyArray<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L598)

Since v2.0.0
Array-let.md
Package: `effect`<br />
Module: `Array`<br />

## Array.let

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import { Array, pipe } from "effect"

const doResult = pipe(
  Array.Do,
  Array.bind("x", () => [1, 3, 5]),
  Array.bind("y", () => [2, 4, 6]),
  Array.filter(({ x, y }) => x < y), // condition
  Array.map(({ x, y }) => [x, y] as const) // transformation
)
console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]

// equivalent
const x = [1, 3, 5],
      y = [2, 4, 6],
      result = [];
for(let i = 0; i < x.length; i++) {
  for(let j = 0; j < y.length; j++) {
    const _x = x[i], _y = y[j];
    if(_x < _y) result.push([_x, _y] as const)
  }
}

```

**See**

- `bindTo`
- `bind`
- `Do`

**Signature**

```ts
declare const let: { <N extends string, B, A extends object>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <N extends string, A extends object, B>(self: ReadonlyArray<A>, tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3530)

Since v3.2.0
Array-liftEither.md
Package: `effect`<br />
Module: `Array`<br />

## Array.liftEither

Lifts a function that returns an `Either` into a function that returns an array.
If the `Either` is a left, it returns an empty array.
If the `Either` is a right, it returns an array with the right value.

**Example**

```ts
import { Array, Either } from "effect"

const parseNumber = (s: string): Either.Either<number, Error> =>
  isNaN(Number(s)) ? Either.left(new Error("Not a number")) : Either.right(Number(s))

const liftedParseNumber = Array.liftEither(parseNumber)

const result1 = liftedParseNumber("42")
console.log(result1) // [42]

const result2 = liftedParseNumber("not a number")
console.log(result2) // []

// Explanation:
// The function parseNumber is lifted to return an array.
// When parsing "42", it returns an Either.left with the number 42, resulting in [42].
// When parsing "not a number", it returns an Either.right with an error, resulting in an empty array [].
```

**Signature**

```ts
declare const liftEither: <A extends Array<unknown>, E, B>(f: (...a: A) => Either.Either<B, E>) => (...a: A) => Array<B>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2925)

Since v2.0.0
Array-liftPredicate.md
Package: `effect`<br />
Module: `Array`<br />

## Array.liftPredicate

Lifts a predicate into an array.

**Example**

```ts
import { Array } from "effect"

const isEven = (n: number) => n % 2 === 0
const to = Array.liftPredicate(isEven)
console.log(to(1)) // []
console.log(to(2)) // [2]
```

**Signature**

```ts
declare const liftPredicate: { <A, B extends A>(refinement: Predicate.Refinement<A, B>): (a: A) => Array<B>; <A>(predicate: Predicate.Predicate<A>): <B extends A>(b: B) => Array<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2837)

Since v2.0.0
Array-make.md
Package: `effect`<br />
Module: `Array`<br />

## Array.make

Builds a `NonEmptyArray` from an non-empty collection of elements.

**Example**

```ts
import { Array } from "effect"

const result = Array.make(1, 2, 3)
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const make: <Elements extends NonEmptyArray<any>>(...elements: Elements) => NonEmptyArray<Elements[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L58)

Since v2.0.0
Array-makeBy.md
Package: `effect`<br />
Module: `Array`<br />

## Array.makeBy

Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.

**Note**. `n` is normalized to an integer >= 1.

**Example**

```ts
import { makeBy } from "effect/Array"

const result = makeBy(5, n => n * 2)
console.log(result) // [0, 2, 4, 6, 8]
```

**Signature**

```ts
declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>; <A>(n: number, f: (i: number) => A): NonEmptyArray<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L96)

Since v2.0.0
Array-mapAccum.md
Package: `effect`<br />
Module: `Array`<br />

## Array.mapAccum

Statefully maps over the chunk, producing new elements of type `B`.

**Example**

```ts
import { Array } from "effect"

const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])
console.log(result) // [6, [1, 3, 6]]
```

**Signature**

```ts
declare const mapAccum: { <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]; <S, A, B, I extends Iterable<A> = Iterable<A>>(self: I, s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): [state: S, mappedArray: ReadonlyArray.With<I, B>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3230)

Since v2.0.0
Array-match.md
Package: `effect`<br />
Module: `Array`<br />

## Array.match

Matches the elements of an array, applying functions to cases of empty and non-empty arrays.

**Example**

```ts
import { Array } from "effect"

const match = Array.match({
  onEmpty: () => "empty",
  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`
})
console.log(match([])) // "empty"
console.log(match([1, 2, 3])) // "head: 1, tail: 2"
```

**Signature**

```ts
declare const match: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): B | C; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L239)

Since v2.0.0
Array-matchLeft.md
Package: `effect`<br />
Module: `Array`<br />

## Array.matchLeft

Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.

**Example**

```ts
import { Array } from "effect"

const matchLeft = Array.matchLeft({
  onEmpty: () => "empty",
  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`
})
console.log(matchLeft([])) // "empty"
console.log(matchLeft([1, 2, 3])) // "head: 1, tail: 2"
```

**Signature**

```ts
declare const matchLeft: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): B | C; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L280)

Since v2.0.0
Array-matchRight.md
Package: `effect`<br />
Module: `Array`<br />

## Array.matchRight

Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.

**Example**

```ts
import { Array } from "effect"

const matchRight = Array.matchRight({
  onEmpty: () => "empty",
  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`
})
console.log(matchRight([])) // "empty"
console.log(matchRight([1, 2, 3])) // "init: 2, last: 3"
```

**Signature**

```ts
declare const matchRight: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): B | C; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L321)

Since v2.0.0
Array-max.md
Package: `effect`<br />
Module: `Array`<br />

## Array.max

Finds the maximum element in an array based on a comparator.

**Example**

```ts
import { Array, Order } from "effect"

const result = Array.max([3, 1, 2], Order.number)
console.log(result) // 3
```

**Signature**

```ts
declare const max: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3030)

Since v2.0.0
Array-min.md
Package: `effect`<br />
Module: `Array`<br />

## Array.min

Finds the minimum element in an array based on a comparator.

**Example**

```ts
import { Array, Order } from "effect"

const result = Array.min([3, 1, 2], Order.number)
console.log(result) // 1
```

**Signature**

```ts
declare const min: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3011)

Since v2.0.0
Array-modify.md
Package: `effect`<br />
Module: `Array`<br />

## Array.modify

Apply a function to the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)
console.log(result) // [1, 2, 6, 4]
```

**Signature**

```ts
declare const modify: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1248)

Since v2.0.0
Array-modifyNonEmptyHead.md
Package: `effect`<br />
Module: `Array`<br />

## Array.modifyNonEmptyHead

Apply a function to the head, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)
console.log(result) // [10, 2, 3]
```

**Signature**

```ts
declare const modifyNonEmptyHead: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1647)

Since v2.0.0
Array-modifyNonEmptyLast.md
Package: `effect`<br />
Module: `Array`<br />

## Array.modifyNonEmptyLast

Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)
console.log(result) // [1, 2, 6]
```

**Signature**

```ts
declare const modifyNonEmptyLast: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1694)

Since v2.0.0
Array-modifyOption.md
Package: `effect`<br />
Module: `Array`<br />

## Array.modifyOption

Apply a function to the element at the specified index, creating a new `Array`,
or return `None` if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const input = [1, 2, 3, 4]
const result = Array.modifyOption(input, 2, (n) => n * 2)
console.log(result) // Option.some([1, 2, 6, 4])

const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)
console.log(outOfBoundsResult) // Option.none()
```

**Signature**

```ts
declare const modifyOption: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1290)

Since v2.0.0
Array-of.md
Package: `effect`<br />
Module: `Array`<br />

## Array.of

Constructs a new `NonEmptyArray<A>` from the specified value.

**Signature**

```ts
declare const of: <A>(a: A) => NonEmptyArray<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2387)

Since v2.0.0
Array-pad.md
Package: `effect`<br />
Module: `Array`<br />

## Array.pad

Pads an array.
Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.
If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.
If `n` is less than or equal to 0, the returned array will be an empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.pad([1, 2, 3], 6, 0)
console.log(result) // [1, 2, 3, 0, 0, 0]
```

**Signature**

```ts
declare const pad: { <A, T>(n: number, fill: T): (self: Array<A>) => Array<A | T>; <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2009)

Since v3.8.4
Array-partition.md
Package: `effect`<br />
Module: `Array`<br />

## Array.partition

Separate elements based on a predicate that also exposes the index of the element.

**Example**

```ts
import { Array } from "effect"

const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)
console.log(result) // [[1, 3], [2, 4]]
```

**Signature**

```ts
declare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2732)

Since v2.0.0
Array-partitionMap.md
Package: `effect`<br />
Module: `Array`<br />

## Array.partitionMap

Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.
This function is particularly useful for operations where each element can result in two possible types,
and you want to separate these types into different collections. For instance, separating validation results
into successes and failures.

**Example**

```ts
import { Array, Either } from "effect";

const isEven = (x: number) => x % 2 === 0

const result = Array.partitionMap([1, 2, 3, 4, 5], x =>
  isEven(x) ? Either.right(x) : Either.left(x)
)
console.log(result)
// [
//   [1, 3, 5],
//   [2, 4]
// ]
```

**Signature**

```ts
declare const partitionMap: { <A, B, C>(f: (a: A, i: number) => Either.Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]; <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2597)

Since v2.0.0
Array-prepend.md
Package: `effect`<br />
Module: `Array`<br />

## Array.prepend

Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.prepend([2, 3, 4], 1)
console.log(result) // [1, 2, 3, 4]
```

**Signature**

```ts
declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L361)

Since v2.0.0
Array-prependAll.md
Package: `effect`<br />
Module: `Array`<br />

## Array.prependAll

Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).
If either array is non-empty, the result is also a non-empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.prependAll([2, 3], [0, 1])
console.log(result) // [0, 1, 2, 3]
```

**Signature**

```ts
declare const prependAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L382)

Since v2.0.0
Array-range.md
Package: `effect`<br />
Module: `Array`<br />

## Array.range

Return a `NonEmptyArray` containing a range of integers, including both endpoints.

**Example**

```ts
import { range } from "effect/Array"

const result = range(1, 3)
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const range: (start: number, end: number) => NonEmptyArray<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L123)

Since v2.0.0
Array-reduce.md
Package: `effect`<br />
Module: `Array`<br />

## Array.reduce

Reduces an array from the left.

**Example**

```ts
import { Array } from "effect"

const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)
console.log(result) // 6
```

**Signature**

```ts
declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2787)

Since v2.0.0
Array-reduceRight.md
Package: `effect`<br />
Module: `Array`<br />

## Array.reduceRight

Reduces an array from the right.

**Example**

```ts
import { Array } from "effect"

const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)
console.log(result) // 6
```

**Signature**

```ts
declare const reduceRight: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2811)

Since v2.0.0
Array-remove.md
Package: `effect`<br />
Module: `Array`<br />

## Array.remove

Delete the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const input = [1, 2, 3, 4]
const result = Array.remove(input, 2)
console.log(result) // [1, 2, 4]

const outOfBoundsResult = Array.remove(input, 5)
console.log(outOfBoundsResult) // [1, 2, 3, 4]
```

**Signature**

```ts
declare const remove: { (i: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, i: number): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1330)

Since v2.0.0
Array-removeOption.md
Package: `effect`<br />
Module: `Array`<br />

## Array.removeOption

Delete the element at the specified index, creating a new `Array`,
or return `None` if the index is out of bounds.

**Example**

```ts
import * as assert from "node:assert"
import { Array, Option } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.removeOption(numbers, 2)
assert.deepStrictEqual(result, Option.some([1, 2, 4]))

const outOfBoundsResult = Array.removeOption(numbers, 5)
assert.deepStrictEqual(outOfBoundsResult, Option.none())
```

**Signature**

```ts
declare const removeOption: { (i: number): <A>(self: Iterable<A>) => Option.Option<Array<A>>; <A>(self: Iterable<A>, i: number): Option.Option<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1361)

Since v3.16.0
Array-replace.md
Package: `effect`<br />
Module: `Array`<br />

## Array.replace

Change the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')
console.log(result) // ['a', 'z', 'c', 'd']
```

**Signature**

```ts
declare const replace: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1188)

Since v2.0.0
Array-replaceOption.md
Package: `effect`<br />
Module: `Array`<br />

## Array.replaceOption

Replaces an element in an array with the given value, returning an option of the updated array.

**Example**

```ts
import { Array } from "effect"

const result = Array.replaceOption([1, 2, 3], 1, 4)
console.log(result) // Option.some([1, 4, 3])
```

**Signature**

```ts
declare const replaceOption: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1216)

Since v2.0.0
Array-replicate.md
Package: `effect`<br />
Module: `Array`<br />

## Array.replicate

Return a `NonEmptyArray` containing a value repeated the specified number of times.

**Note**. `n` is normalized to an integer >= 1.

**Example**

```ts
import { Array } from "effect"

const result = Array.replicate("a", 3)
console.log(result) // ["a", "a", "a"]
```

**Signature**

```ts
declare const replicate: { (n: number): <A>(a: A) => NonEmptyArray<A>; <A>(a: A, n: number): NonEmptyArray<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L143)

Since v2.0.0
Array-reverse.md
Package: `effect`<br />
Module: `Array`<br />

## Array.reverse

Reverse an `Iterable`, creating a new `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.reverse([1, 2, 3, 4])
console.log(result) // [4, 3, 2, 1]
```

**Signature**

```ts
declare const reverse: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1389)

Since v2.0.0
Array-rotate.md
Package: `effect`<br />
Module: `Array`<br />

## Array.rotate

Rotate an `Iterable` by `n` steps.
If the input is a non-empty array, the result is also a non-empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.rotate(['a', 'b', 'c', 'd'], 2)
console.log(result) // ['c', 'd', 'a', 'b']
```

**Signature**

```ts
declare const rotate: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>; <A>(self: Iterable<A>, n: number): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1740)

Since v2.0.0
Array-scan.md
Package: `effect`<br />
Module: `Array`<br />

## Array.scan

Accumulates values from an `Iterable` starting from the left, storing
each intermediate result in an array. Useful for tracking the progression of
a value through a series of transformations.

**Example**

```ts
import { Array } from "effect";

const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)
console.log(result) // [0, 1, 3, 6, 10]

// Explanation:
// This function starts with the initial value (0 in this case)
// and adds each element of the array to this accumulator one by one,
// keeping track of the cumulative sum after each addition.
// Each of these sums is captured in the resulting array.
```

**Signature**

```ts
declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L456)

Since v2.0.0
Array-scanRight.md
Package: `effect`<br />
Module: `Array`<br />

## Array.scanRight

Accumulates values from an `Iterable` starting from the right, storing
each intermediate result in an array. Useful for tracking the progression of
a value through a series of transformations.

**Example**

```ts
import { Array } from "effect";

const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)
console.log(result) // [10, 9, 7, 4, 0]
```

**Signature**

```ts
declare const scanRight: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L486)

Since v2.0.0
Array-separate.md
Package: `effect`<br />
Module: `Array`<br />

## Array.separate

Separates an `Iterable` into two arrays based on a predicate.

**Signature**

```ts
declare const separate: <T extends Iterable<Either.Either<any, any>>>(self: T) => [Array<Either.Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Either.Right<ReadonlyArray.Infer<T>>>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2767)

Since v2.0.0
Array-setNonEmptyHead.md
Package: `effect`<br />
Module: `Array`<br />

## Array.setNonEmptyHead

Change the head, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.setNonEmptyHead([1, 2, 3], 10)
console.log(result) // [10, 2, 3]
```

**Signature**

```ts
declare const setNonEmptyHead: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1672)

Since v2.0.0
Array-setNonEmptyLast.md
Package: `effect`<br />
Module: `Array`<br />

## Array.setNonEmptyLast

Change the last element, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.setNonEmptyLast([1, 2, 3], 4)
console.log(result) // [1, 2, 4]
```

**Signature**

```ts
declare const setNonEmptyLast: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1717)

Since v2.0.0
Array-some.md
Package: `effect`<br />
Module: `Array`<br />

## Array.some

Check if a predicate holds true for some `ReadonlyArray` element.

**Signature**

```ts
declare const some: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2958)

Since v2.0.0
Array-sort.md
Package: `effect`<br />
Module: `Array`<br />

## Array.sort

Create a new array with elements sorted in increasing order based on the specified comparator.
If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.

**Signature**

```ts
declare const sort: { <B>(O: Order.Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>; <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1401)

Since v2.0.0
Array-sortBy.md
Package: `effect`<br />
Module: `Array`<br />

## Array.sortBy

Sorts the elements of an `Iterable` in increasing order based on the provided
orders. The elements are compared using the first order in `orders`, then the
second order if the first comparison is equal, and so on.

**Example**

```ts
import { Array, Order, pipe } from "effect"

const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 30 }
]

const result = pipe(
  users,
  Array.sortBy(
    Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),
    Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)
  )
)

console.log(result)
// [
//   { name: "Bob", age: 25 },
//   { name: "Alice", age: 30 },
//   { name: "Charlie", age: 30 }
// ]

// Explanation:
// The array of users is sorted first by age in ascending order. When ages are equal,
// the users are further sorted by name in ascending order.
```

**Signature**

```ts
declare const sortBy: <S extends Iterable<any>>(...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>) => (self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1487)

Since v2.0.0
Array-sortWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.sortWith

Sorts an array based on a provided mapping function and order. The mapping
function transforms the elements into a value that can be compared, and the
order defines how those values should be sorted.

**Example**

```ts
import { Array, Order } from "effect"

const result = Array.sortWith(["aaa", "b", "cc"], (s) => s.length, Order.number)
console.log(result) // ["b", "cc", "aaa"]

// Explanation:
// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`
// converts each string into its length, and the `Order.number` specifies that the lengths should
// be sorted in ascending order.
```

**Signature**

```ts
declare const sortWith: { <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order.Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>; <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1435)

Since v2.0.0
Array-span.md
Package: `effect`<br />
Module: `Array`<br />

## Array.span

Split an `Iterable` into two parts:

1. the longest initial subarray for which all elements satisfy the specified predicate
2. the remaining elements

**Signature**

```ts
declare const span: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: Array<B>, rest: Array<Exclude<A, B>>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L890)

Since v2.0.0
Array-split.md
Package: `effect`<br />
Module: `Array`<br />

## Array.split

Splits this iterable into `n` equally sized arrays.

**Example**

```ts
import { Array } from "effect"

const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)
console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]
```

**Signature**

```ts
declare const split: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1938)

Since v2.0.0
Array-splitAt.md
Package: `effect`<br />
Module: `Array`<br />

## Array.splitAt

Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` can be `0`.

**Example**

```ts
import { Array } from "effect"

const result = Array.splitAt([1, 2, 3, 4, 5], 3)
console.log(result) // [[1, 2, 3], [4, 5]]
```

**Signature**

```ts
declare const splitAt: { (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]; <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1882)

Since v2.0.0
Array-splitNonEmptyAt.md
Package: `effect`<br />
Module: `Array`<br />

## Array.splitNonEmptyAt

Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` must be `>= 1`.

**Example**

```ts
import { Array } from "effect"

const result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)
console.log(result) // [["a", "b", "c"], ["d", "e"]]
```

**Signature**

```ts
declare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1913)

Since v2.0.0
Array-splitWhere.md
Package: `effect`<br />
Module: `Array`<br />

## Array.splitWhere

Splits this iterable on the first element that matches this predicate.
Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.

**Example**

```ts
import { Array } from "effect"

const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)
console.log(result) // [[1, 2, 3], [4, 5]]
```

**Signature**

```ts
declare const splitWhere: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1962)

Since v2.0.0
Array-tail.md
Package: `effect`<br />
Module: `Array`<br />

## Array.tail

Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.

**Signature**

```ts
declare const tail: <A>(self: Iterable<A>) => Option.Option<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L730)

Since v2.0.0
Array-tailNonEmpty.md
Package: `effect`<br />
Module: `Array`<br />

## Array.tailNonEmpty

Get all but the first element of a `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.tailNonEmpty([1, 2, 3, 4])
console.log(result) // [2, 3, 4]
```

**Signature**

```ts
declare const tailNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L750)

Since v2.0.0
Array-take.md
Package: `effect`<br />
Module: `Array`<br />

## Array.take

Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.take([1, 2, 3, 4, 5], 3)
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const take: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L797)

Since v2.0.0
Array-takeRight.md
Package: `effect`<br />
Module: `Array`<br />

## Array.takeRight

Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.takeRight([1, 2, 3, 4, 5], 3)
console.log(result) // [3, 4, 5]
```

**Signature**

```ts
declare const takeRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L822)

Since v2.0.0
Array-takeWhile.md
Package: `effect`<br />
Module: `Array`<br />

## Array.takeWhile

Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)
console.log(result) // [1, 3, 2]

// Explanation:
// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.
// - The next element (`3`) is also less than `4`, so it adds `3`.
// - The next element (`2`) is again less than `4`, so it adds `2`.
// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.
```

**Signature**

```ts
declare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L852)

Since v2.0.0
Array-unappend.md
Package: `effect`<br />
Module: `Array`<br />

## Array.unappend

Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.

**Example**

```ts
import { Array } from "effect";

const result = Array.unappend([1, 2, 3, 4])
console.log(result) // [[1, 2, 3], 4]
```

**Signature**

```ts
declare const unappend: <A>(self: NonEmptyReadonlyArray<A>) => [arrayWithoutLastElement: Array<A>, lastElement: A]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L669)

Since v2.0.0
Array-union.md
Package: `effect`<br />
Module: `Array`<br />

## Array.union

Creates a union of two arrays, removing duplicates.

**Example**

```ts
import { Array } from "effect"

const result = Array.union([1, 2], [2, 3])
console.log(result) // [1, 2, 3]
```

**Signature**

```ts
declare const union: { <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2267)

Since v2.0.0
Array-unionWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.unionWith

Calculates the union of two arrays using the provided equivalence relation.

**Example**

```ts
import { Array } from "effect"

const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)
console.log(union) // [1, 2, 3]
```

**Signature**

```ts
declare const unionWith: { <S extends Iterable<any>, T extends Iterable<any>>(that: T, isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): Array<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2224)

Since v2.0.0
Array-unprepend.md
Package: `effect`<br />
Module: `Array`<br />

## Array.unprepend

Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.

**Example**

```ts
import { Array } from "effect";

const result = Array.unprepend([1, 2, 3, 4])
console.log(result) // [1, [2, 3, 4]]
```

**Signature**

```ts
declare const unprepend: <A>(self: NonEmptyReadonlyArray<A>) => [firstElement: A, remainingElements: Array<A>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L650)

Since v2.0.0
Array-unsafeGet.md
Package: `effect`<br />
Module: `Array`<br />

## Array.unsafeGet

Gets an element unsafely, will throw on out of bounds.

**Signature**

```ts
declare const unsafeGet: { (index: number): <A>(self: ReadonlyArray<A>) => A; <A>(self: ReadonlyArray<A>, index: number): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L624)

Since v2.0.0
Array-unzip.md
Package: `effect`<br />
Module: `Array`<br />

## Array.unzip

This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.

**Example**

```ts
import { Array } from "effect"

const result = Array.unzip([[1, "a"], [2, "b"], [3, "c"]])
console.log(result) // [[1, 2, 3], ['a', 'b', 'c']]
```

**Signature**

```ts
declare const unzip: <S extends Iterable<readonly [any, any]>>(self: S) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>] : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>] : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1578)

Since v2.0.0
Array-window.md
Package: `effect`<br />
Module: `Array`<br />

## Array.window

Creates sliding windows of size `n` from an `Iterable`.
If the number of elements is less than `n` or if `n` is not greater than zero,
an empty array is returned.

**Example**

```ts
import * as assert from "node:assert"
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])
assert.deepStrictEqual(Array.window(numbers, 6), [])
```

**Signature**

```ts
declare const window: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2090)

Since v3.13.2
Array-zip.md
Package: `effect`<br />
Module: `Array`<br />

## Array.zip

Takes two `Iterable`s and returns an `Array` of corresponding pairs.
If one input `Iterable` is short, excess elements of the
longer `Iterable` are discarded.

**Example**

```ts
import { Array } from "effect"

const result = Array.zip([1, 2, 3], ['a', 'b'])
console.log(result) // [[1, 'a'], [2, 'b']]
```

**Signature**

```ts
declare const zip: { <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>; <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>; <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1519)

Since v2.0.0
Array-zipWith.md
Package: `effect`<br />
Module: `Array`<br />

## Array.zipWith

Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one
input `Iterable` is short, excess elements of the longer `Iterable` are discarded.

**Example**

```ts
import { Array } from "effect"

const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)
console.log(result) // [5, 7, 9]
```

**Signature**

```ts
declare const zipWith: { <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>; <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>; <A, B, C>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): NonEmptyArray<C>; <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1545)

Since v2.0.0
Bicovariant-bimapComposition.md
Package: `@effect/typeclass`<br />
Module: `Bicovariant`<br />

## Bicovariant.bimapComposition

Returns a default ternary `bimap` composition.

**Signature**

```ts
declare const bimapComposition: <F extends TypeLambda, G extends TypeLambda>(CovariantF: Covariant<F>, BicovariantG: Bicovariant<G>) => <FR, FO, FE, GR, GO, E1, A, E2, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, E1, A>>, f: (e: E1) => E2, g: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, E2, B>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bicovariant.ts#L31)

Since v0.24.0
Bicovariant-map.md
Package: `@effect/typeclass`<br />
Module: `Bicovariant`<br />

## Bicovariant.map

Returns a default `map` implementation.

**Signature**

```ts
declare const map: <F extends TypeLambda>(F: Bicovariant<F>) => Covariant<F>["map"]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bicovariant.ts#L62)

Since v0.24.0
Bicovariant-mapLeft.md
Package: `@effect/typeclass`<br />
Module: `Bicovariant`<br />

## Bicovariant.mapLeft

Returns a default `mapLeft` implementation.

**Signature**

```ts
declare const mapLeft: <F extends TypeLambda>(F: Bicovariant<F>) => { <E, G>(f: (e: E) => G): <R, O, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, G, A>; <R, O, E, A, G>(self: Kind<F, R, O, E, A>, f: (e: E) => G): Kind<F, R, O, G, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bicovariant.ts#L46)

Since v0.24.0
BigDecimal-RoundingMode.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.RoundingMode

Rounding modes for `BigDecimal`.

`ceil`: round towards positive infinity
`floor`: round towards negative infinity
`to-zero`: round towards zero
`from-zero`: round away from zero
`half-ceil`: round to the nearest neighbor; if equidistant round towards positive infinity
`half-floor`: round to the nearest neighbor; if equidistant round towards negative infinity
`half-to-zero`: round to the nearest neighbor; if equidistant round towards zero
`half-from-zero`: round to the nearest neighbor; if equidistant round away from zero
`half-even`: round to the nearest neighbor; if equidistant round to the neighbor with an even digit
`half-odd`: round to the nearest neighbor; if equidistant round to the neighbor with an odd digit

**Signature**

```ts
type RoundingMode = | "ceil"
  | "floor"
  | "to-zero"
  | "from-zero"
  | "half-ceil"
  | "half-floor"
  | "half-to-zero"
  | "half-from-zero"
  | "half-even"
  | "half-odd"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1251)

Since v3.16.0
BigDecimal-abs.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.abs

Determines the absolute value of a given `BigDecimal`.

**Example**

```ts
import * as assert from "node:assert"
import { abs, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(abs(unsafeFromString("-5")), unsafeFromString("5"))
assert.deepStrictEqual(abs(unsafeFromString("0")), unsafeFromString("0"))
assert.deepStrictEqual(abs(unsafeFromString("5")), unsafeFromString("5"))
```

**Signature**

```ts
declare const abs: (n: BigDecimal) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L691)

Since v2.0.0
BigDecimal-between.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.between

Checks if a `BigDecimal` is between a `minimum` and `maximum` value (inclusive).

**Example**

```ts
import * as assert from "node:assert"
import { BigDecimal } from "effect"

const between = BigDecimal.between({
  minimum: BigDecimal.unsafeFromString("1"),
  maximum: BigDecimal.unsafeFromString("5") }
)

assert.deepStrictEqual(between(BigDecimal.unsafeFromString("3")), true)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("0")), false)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("6")), false)
```

**Signature**

```ts
declare const between: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => boolean; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L572)

Since v2.0.0
BigDecimal-ceil.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.ceil

Calculate the ceiling of a `BigDecimal` at the given scale.

**Example**

```ts
import * as assert from "node:assert"
import { ceil, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(ceil(unsafeFromString("145"), -1), unsafeFromString("150"))
assert.deepStrictEqual(ceil(unsafeFromString("-14.5")), unsafeFromString("-14"))
```

**Signature**

```ts
declare const ceil: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale?: number): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1147)

Since v3.16.0
BigDecimal-clamp.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.clamp

Restricts the given `BigDecimal` to be within the range specified by the `minimum` and `maximum` values.

- If the `BigDecimal` is less than the `minimum` value, the function returns the `minimum` value.
- If the `BigDecimal` is greater than the `maximum` value, the function returns the `maximum` value.
- Otherwise, it returns the original `BigDecimal`.

**Example**

```ts
import * as assert from "node:assert"
import { BigDecimal } from "effect"

const clamp = BigDecimal.clamp({
  minimum: BigDecimal.unsafeFromString("1"),
  maximum: BigDecimal.unsafeFromString("5") }
)

assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("3")), BigDecimal.unsafeFromString("3"))
assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("0")), BigDecimal.unsafeFromString("1"))
assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("6")), BigDecimal.unsafeFromString("5"))
```

**Signature**

```ts
declare const clamp: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => BigDecimal; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L608)

Since v2.0.0
BigDecimal-divide.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.divide

Provides a division operation on `BigDecimal`s.

If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value
which represents the integer division rounded down to the nearest integer.

If the divisor is `0`, the result will be `None`.

**Example**

```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("3")), Option.some(BigDecimal.unsafeFromString("2")))
assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("4")), Option.some(BigDecimal.unsafeFromString("1.5")))
assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("0")), Option.none())
```

**Signature**

```ts
declare const divide: { (that: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, that: BigDecimal): Option.Option<BigDecimal>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L387)

Since v2.0.0
BigDecimal-equals.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.equals

Checks if two `BigDecimal`s are equal.

**Signature**

```ts
declare const equals: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L792)

Since v2.0.0
BigDecimal-floor.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.floor

Calculate the floor of a `BigDecimal` at the given scale.

**Example**

```ts
import * as assert from "node:assert"
import { floor, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(floor(unsafeFromString("145"), -1), unsafeFromString("140"))
assert.deepStrictEqual(floor(unsafeFromString("-14.5")), unsafeFromString("-15"))
```

**Signature**

```ts
declare const floor: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale?: number): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1175)

Since v3.16.0
BigDecimal-format.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.format

Formats a given `BigDecimal` as a `string`.

If the scale of the `BigDecimal` is greater than or equal to 16, the `BigDecimal` will
be formatted in scientific notation.

**Example**

```ts
import * as assert from "node:assert"
import { format, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(format(unsafeFromString("-5")), "-5")
assert.deepStrictEqual(format(unsafeFromString("123.456")), "123.456")
assert.deepStrictEqual(format(unsafeFromString("-0.00000123")), "-0.00000123")
```

**Signature**

```ts
declare const format: (n: BigDecimal) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L977)

Since v2.0.0
BigDecimal-fromBigInt.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.fromBigInt

Creates a `BigDecimal` from a `bigint` value.

**Signature**

```ts
declare const fromBigInt: (n: bigint) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L803)

Since v2.0.0
BigDecimal-fromNumber.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## ~~BigDecimal.fromNumber~~

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

**Signature**

```ts
declare const fromNumber: (n: number) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L840)

Since v2.0.0
BigDecimal-fromString.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.fromString

Parses a numerical `string` into a `BigDecimal`.

**Example**

```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.fromString("123"), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.fromString("123.456"), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.fromString("123.abc"), Option.none())
```

**Signature**

```ts
declare const fromString: (s: string) => Option.Option<BigDecimal>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L894)

Since v2.0.0
BigDecimal-greaterThan.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.greaterThan

Returns `true` if the first argument is greater than the second, otherwise `false`.

**Example**

```ts
import * as assert from "node:assert"
import { greaterThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThan(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("4"), unsafeFromString("3")), true)
```

**Signature**

```ts
declare const greaterThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L525)

Since v2.0.0
BigDecimal-greaterThanOrEqualTo.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.greaterThanOrEqualTo

Checks if a given `BigDecimal` is greater than or equal to the provided one.

**Example**

```ts
import * as assert from "node:assert"
import { greaterThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), true)
```

**Signature**

```ts
declare const greaterThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L546)

Since v2.0.0
BigDecimal-isBigDecimal.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.isBigDecimal

Checks if a given value is a `BigDecimal`.

**Signature**

```ts
declare const isBigDecimal: (u: unknown) => u is BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L95)

Since v2.0.0
BigDecimal-isInteger.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.isInteger

Checks if a given `BigDecimal` is an integer.

**Example**

```ts
import * as assert from "node:assert"
import { isInteger, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isInteger(unsafeFromString("0")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1.1")), false)
```

**Signature**

```ts
declare const isInteger: (n: BigDecimal) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1075)

Since v2.0.0
BigDecimal-isNegative.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.isNegative

Checks if a given `BigDecimal` is negative.

**Example**

```ts
import * as assert from "node:assert"
import { isNegative, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isNegative(unsafeFromString("-1")), true)
assert.deepStrictEqual(isNegative(unsafeFromString("0")), false)
assert.deepStrictEqual(isNegative(unsafeFromString("1")), false)
```

**Signature**

```ts
declare const isNegative: (n: BigDecimal) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1110)

Since v2.0.0
BigDecimal-isPositive.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.isPositive

Checks if a given `BigDecimal` is positive.

**Example**

```ts
import * as assert from "node:assert"
import { isPositive, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isPositive(unsafeFromString("-1")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("0")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("1")), true)
```

**Signature**

```ts
declare const isPositive: (n: BigDecimal) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1128)

Since v2.0.0
BigDecimal-isZero.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.isZero

Checks if a given `BigDecimal` is `0`.

**Example**

```ts
import * as assert from "node:assert"
import { isZero, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isZero(unsafeFromString("0")), true)
assert.deepStrictEqual(isZero(unsafeFromString("1")), false)
```

**Signature**

```ts
declare const isZero: (n: BigDecimal) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1092)

Since v2.0.0
BigDecimal-lessThan.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.lessThan

Returns `true` if the first argument is less than the second, otherwise `false`.

**Example**

```ts
import * as assert from "node:assert"
import { lessThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThan(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(lessThan(unsafeFromString("4"), unsafeFromString("3")), false)
```

**Signature**

```ts
declare const lessThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L483)

Since v2.0.0
BigDecimal-lessThanOrEqualTo.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.lessThanOrEqualTo

Checks if a given `BigDecimal` is less than or equal to the provided one.

**Example**

```ts
import * as assert from "node:assert"
import { lessThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), false)
```

**Signature**

```ts
declare const lessThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L504)

Since v2.0.0
BigDecimal-make.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.make

Creates a `BigDecimal` from a `bigint` value and a scale.

**Signature**

```ts
declare const make: (value: bigint, scale: number) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L103)

Since v2.0.0
BigDecimal-max.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.max

Returns the maximum between two `BigDecimal`s.

**Example**

```ts
import * as assert from "node:assert"
import { max, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(max(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("3"))
```

**Signature**

```ts
declare const max: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L652)

Since v2.0.0
BigDecimal-min.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.min

Returns the minimum between two `BigDecimal`s.

**Example**

```ts
import * as assert from "node:assert"
import { min, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(min(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("2"))
```

**Signature**

```ts
declare const min: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L633)

Since v2.0.0
BigDecimal-multiply.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.multiply

Provides a multiplication operation on `BigDecimal`s.

**Example**

```ts
import * as assert from "node:assert"
import { multiply, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(multiply(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("6"))
```

**Signature**

```ts
declare const multiply: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L250)

Since v2.0.0
BigDecimal-negate.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.negate

Provides a negate operation on `BigDecimal`s.

**Example**

```ts
import * as assert from "node:assert"
import { negate, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(negate(unsafeFromString("3")), unsafeFromString("-3"))
assert.deepStrictEqual(negate(unsafeFromString("-6")), unsafeFromString("6"))
```

**Signature**

```ts
declare const negate: (n: BigDecimal) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L708)

Since v2.0.0
BigDecimal-normalize.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.normalize

Normalizes a given `BigDecimal` by removing trailing zeros.

**Example**

```ts
import * as assert from "node:assert"
import { normalize, make, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(normalize(unsafeFromString("123.00000")), normalize(make(123n, 0)))
assert.deepStrictEqual(normalize(unsafeFromString("12300000")), normalize(make(123n, -5)))
```

**Signature**

```ts
declare const normalize: (self: BigDecimal) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L146)

Since v2.0.0
BigDecimal-remainder.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.remainder

Returns the remainder left over when one operand is divided by a second operand.

If the divisor is `0`, the result will be `None`.

**Example**

```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("2"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("0")))
assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("3"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("1")))
assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("-4"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("0")))
```

**Signature**

```ts
declare const remainder: { (divisor: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, divisor: BigDecimal): Option.Option<BigDecimal>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L728)

Since v2.0.0
BigDecimal-round.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.round

Rounds a `BigDecimal` at the given scale with the specified rounding mode.

**Example**

```ts
import * as assert from "node:assert"
import { round, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(round(unsafeFromString("145"), { mode: "from-zero", scale: -1 }), unsafeFromString("150"))
assert.deepStrictEqual(round(unsafeFromString("-14.5")), unsafeFromString("-15"))
```

**Signature**

```ts
declare const round: { (options: { scale?: number; mode?: RoundingMode; }): (self: BigDecimal) => BigDecimal; (n: BigDecimal, options?: { scale?: number; mode?: RoundingMode; }): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1278)

Since v3.16.0
BigDecimal-safeFromNumber.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.safeFromNumber

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Returns `None` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

**Example**

```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())
```

**Signature**

```ts
declare const safeFromNumber: (n: number) => Option.Option<BigDecimal>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L864)

Since v3.11.0
BigDecimal-scale.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.scale

Scales a given `BigDecimal` to the specified scale.

If the given scale is smaller than the current scale, the value will be rounded down to
the nearest integer.

**Signature**

```ts
declare const scale: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale: number): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L184)

Since v2.0.0
BigDecimal-sign.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.sign

Determines the sign of a given `BigDecimal`.

**Example**

```ts
import * as assert from "node:assert"
import { sign, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sign(unsafeFromString("-5")), -1)
assert.deepStrictEqual(sign(unsafeFromString("0")), 0)
assert.deepStrictEqual(sign(unsafeFromString("5")), 1)
```

**Signature**

```ts
declare const sign: (n: BigDecimal) => Ordering
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L673)

Since v2.0.0
BigDecimal-subtract.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.subtract

Provides a subtraction operation on `BigDecimal`s.

**Example**

```ts
import * as assert from "node:assert"
import { subtract, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(subtract(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("-1"))
```

**Signature**

```ts
declare const subtract: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L275)

Since v2.0.0
BigDecimal-sum.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.sum

Provides an addition operation on `BigDecimal`s.

**Example**

```ts
import * as assert from "node:assert"
import { sum, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sum(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("5"))
```

**Signature**

```ts
declare const sum: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L213)

Since v2.0.0
BigDecimal-sumAll.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.sumAll

Takes an `Iterable` of `BigDecimal`s and returns their sum as a single `BigDecimal`

**Example**

```ts
import * as assert from "node:assert"
import { unsafeFromString, sumAll } from "effect/BigDecimal"

assert.deepStrictEqual(sumAll([unsafeFromString("2"), unsafeFromString("3"), unsafeFromString("4")]), unsafeFromString("9"))
```

**Signature**

```ts
declare const sumAll: (collection: Iterable<BigDecimal>) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1342)

Since v3.16.0
BigDecimal-toExponential.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.toExponential

Formats a given `BigDecimal` as a `string` in scientific notation.

**Example**

```ts
import * as assert from "node:assert"
import { toExponential, make } from "effect/BigDecimal"

assert.deepStrictEqual(toExponential(make(123456n, -5)), "1.23456e+10")
```

**Signature**

```ts
declare const toExponential: (n: BigDecimal) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1022)

Since v3.11.0
BigDecimal-truncate.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.truncate

Truncate a `BigDecimal` at the given scale. This is the same operation as rounding away from zero.

**Example**

```ts
import * as assert from "node:assert"
import { truncate, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(truncate(unsafeFromString("145"), -1), unsafeFromString("140"))
assert.deepStrictEqual(truncate(unsafeFromString("-14.5")), unsafeFromString("-14"))
```

**Signature**

```ts
declare const truncate: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale?: number): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1203)

Since v3.16.0
BigDecimal-unsafeDivide.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.unsafeDivide

Provides an unsafe division operation on `BigDecimal`s.

If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value
which represents the integer division rounded down to the nearest integer.

Throws a `RangeError` if the divisor is `0`.

**Example**

```ts
import * as assert from "node:assert"
import { unsafeDivide, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("3")), unsafeFromString("2"))
assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("4")), unsafeFromString("1.5"))
```

**Signature**

```ts
declare const unsafeDivide: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L427)

Since v2.0.0
BigDecimal-unsafeFromNumber.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.unsafeFromNumber

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

**Example**

```ts
import * as assert from "node:assert"
import { unsafeFromNumber, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))
assert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))
```

**Signature**

```ts
declare const unsafeFromNumber: (n: number) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L825)

Since v3.11.0
BigDecimal-unsafeFromString.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.unsafeFromString

Parses a numerical `string` into a `BigDecimal`.

**Example**

```ts
import * as assert from "node:assert"
import { unsafeFromString, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromString("123"), make(123n, 0))
assert.deepStrictEqual(unsafeFromString("123.456"), make(123456n, 3))
assert.throws(() => unsafeFromString("123.abc"))
```

**Signature**

```ts
declare const unsafeFromString: (s: string) => BigDecimal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L955)

Since v2.0.0
BigDecimal-unsafeRemainder.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.unsafeRemainder

Returns the remainder left over when one operand is divided by a second operand.

Throws a `RangeError` if the divisor is `0`.

**Example**

```ts
import * as assert from "node:assert"
import { unsafeRemainder, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeRemainder(unsafeFromString("2"), unsafeFromString("2")), unsafeFromString("0"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("3"), unsafeFromString("2")), unsafeFromString("1"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("-4"), unsafeFromString("2")), unsafeFromString("0"))
```

**Signature**

```ts
declare const unsafeRemainder: { (divisor: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, divisor: BigDecimal): BigDecimal; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L758)

Since v2.0.0
BigDecimal-unsafeToNumber.md
Package: `effect`<br />
Module: `BigDecimal`<br />

## BigDecimal.unsafeToNumber

Converts a `BigDecimal` to a `number`.

This function will produce incorrect results if the `BigDecimal` exceeds the 64-bit range of a `number`.

**Example**

```ts
import * as assert from "node:assert"
import { unsafeToNumber, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeToNumber(unsafeFromString("123.456")), 123.456)
```

**Signature**

```ts
declare const unsafeToNumber: (n: BigDecimal) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1057)

Since v2.0.0
BigInt-abs.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.abs

Determines the absolute value of a given `bigint`.

**Example**

```ts
import * as assert from "node:assert"
import { abs } from "effect/BigInt"

assert.deepStrictEqual(abs(-5n), 5n)
assert.deepStrictEqual(abs(0n), 0n)
assert.deepStrictEqual(abs(5n), 5n)
```

**Signature**

```ts
declare const abs: (n: bigint) => bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L409)

Since v2.0.0
BigInt-between.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.between

Checks if a `bigint` is between a `minimum` and `maximum` value (inclusive).

**Example**

```ts
import * as assert from "node:assert"
import { BigInt } from "effect"

const between = BigInt.between({ minimum: 0n, maximum: 5n })

assert.deepStrictEqual(between(3n), true)
assert.deepStrictEqual(between(-1n), false)
assert.deepStrictEqual(between(6n), false)
```

**Signature**

```ts
declare const between: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => boolean; (self: bigint, options: { minimum: bigint; maximum: bigint; }): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L296)

Since v2.0.0
BigInt-clamp.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.clamp

Restricts the given `bigint` to be within the range specified by the `minimum` and `maximum` values.

- If the `bigint` is less than the `minimum` value, the function returns the `minimum` value.
- If the `bigint` is greater than the `maximum` value, the function returns the `maximum` value.
- Otherwise, it returns the original `bigint`.

**Example**

```ts
import * as assert from "node:assert"
import { BigInt } from "effect"

const clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })

assert.equal(clamp(3n), 3n)
assert.equal(clamp(0n), 1n)
assert.equal(clamp(6n), 5n)
```

**Signature**

```ts
declare const clamp: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => bigint; (self: bigint, options: { minimum: bigint; maximum: bigint; }): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L328)

Since v2.0.0
BigInt-decrement.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.decrement

Decrements a number by `1n`.

**Example**

```ts
import * as assert from "node:assert"
import { decrement } from "effect/BigInt"

assert.deepStrictEqual(decrement(3n), 2n)
```

**Signature**

```ts
declare const decrement: (n: bigint) => bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L180)

Since v2.0.0
BigInt-divide.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.divide

Provides a division operation on `bigint`s.

If the dividend is not a multiple of the divisor the result will be a `bigint` value
which represents the integer division rounded down to the nearest integer.

Returns `None` if the divisor is `0n`.

**Example**

```ts
import * as assert from "node:assert"
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))
assert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())
```

**Signature**

```ts
declare const divide: { (that: bigint): (self: bigint) => Option.Option<bigint>; (self: bigint, that: bigint): Option.Option<bigint>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L117)

Since v2.0.0
BigInt-fromNumber.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.fromNumber

Takes a number and returns an `Option` of `bigint`.

If the number is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it attempts to
convert the number to a `bigint` and returns `Option.some(bigint)`.

**Example**

```ts
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))
assert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())
assert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())
```

**Signature**

```ts
declare const fromNumber: (n: number) => Option.Option<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L633)

Since v2.4.12
BigInt-fromString.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.fromString

Takes a string and returns an `Option` of `bigint`.

If the string is empty or contains characters that cannot be converted into a `bigint`,
it returns `Option.none()`, otherwise, it returns `Option.some(bigint)`.

**Example**

```ts
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.fromString("42"), Option.some(BigInt(42)))
assert.deepStrictEqual(BI.fromString(" "), Option.none())
assert.deepStrictEqual(BI.fromString("a"), Option.none())
```

**Signature**

```ts
declare const fromString: (s: string) => Option.Option<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L603)

Since v2.4.12
BigInt-gcd.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.gcd

Determines the greatest common divisor of two `bigint`s.

**Example**

```ts
import * as assert from "node:assert"
import { gcd } from "effect/BigInt"

assert.deepStrictEqual(gcd(2n, 3n), 1n)
assert.deepStrictEqual(gcd(2n, 4n), 2n)
assert.deepStrictEqual(gcd(16n, 24n), 8n)
```

**Signature**

```ts
declare const gcd: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L427)

Since v2.0.0
BigInt-greaterThan.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.greaterThan

Returns `true` if the first argument is greater than the second, otherwise `false`.

**Example**

```ts
import * as assert from "node:assert"
import { greaterThan } from "effect/BigInt"

assert.deepStrictEqual(greaterThan(2n, 3n), false)
assert.deepStrictEqual(greaterThan(3n, 3n), false)
assert.deepStrictEqual(greaterThan(4n, 3n), true)
```

**Signature**

```ts
declare const greaterThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L252)

Since v2.0.0
BigInt-greaterThanOrEqualTo.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.greaterThanOrEqualTo

Returns a function that checks if a given `bigint` is greater than or equal to the provided one.

**Example**

```ts
import * as assert from "node:assert"
import { greaterThanOrEqualTo } from "effect/BigInt"

assert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)
assert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)
assert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)
```

**Signature**

```ts
declare const greaterThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L273)

Since v2.0.0
BigInt-increment.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.increment

Returns the result of adding `1n` to a given number.

**Example**

```ts
import * as assert from "node:assert"
import { increment } from "effect/BigInt"

assert.deepStrictEqual(increment(2n), 3n)
```

**Signature**

```ts
declare const increment: (n: bigint) => bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L164)

Since v2.0.0
BigInt-isBigInt.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.isBigInt

Tests if a value is a `bigint`.

**Example**

```ts
import * as assert from "node:assert"
import { isBigInt } from "effect/BigInt"

assert.deepStrictEqual(isBigInt(1n), true)
assert.deepStrictEqual(isBigInt(1), false)
```

**Signature**

```ts
declare const isBigInt: (u: unknown) => u is bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L38)

Since v2.0.0
BigInt-lcm.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.lcm

Determines the least common multiple of two `bigint`s.

**Example**

```ts
import * as assert from "node:assert"
import { lcm } from "effect/BigInt"

assert.deepStrictEqual(lcm(2n, 3n), 6n)
assert.deepStrictEqual(lcm(2n, 4n), 4n)
assert.deepStrictEqual(lcm(16n, 24n), 48n)
```

**Signature**

```ts
declare const lcm: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L455)

Since v2.0.0
BigInt-lessThan.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.lessThan

Returns `true` if the first argument is less than the second, otherwise `false`.

**Example**

```ts
import * as assert from "node:assert"
import { lessThan } from "effect/BigInt"

assert.deepStrictEqual(lessThan(2n, 3n), true)
assert.deepStrictEqual(lessThan(3n, 3n), false)
assert.deepStrictEqual(lessThan(4n, 3n), false)
```

**Signature**

```ts
declare const lessThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L210)

Since v2.0.0
BigInt-lessThanOrEqualTo.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.lessThanOrEqualTo

Returns a function that checks if a given `bigint` is less than or equal to the provided one.

**Example**

```ts
import * as assert from "node:assert"
import { lessThanOrEqualTo } from "effect/BigInt"

assert.deepStrictEqual(lessThanOrEqualTo(2n, 3n), true)
assert.deepStrictEqual(lessThanOrEqualTo(3n, 3n), true)
assert.deepStrictEqual(lessThanOrEqualTo(4n, 3n), false)
```

**Signature**

```ts
declare const lessThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L231)

Since v2.0.0
BigInt-max.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.max

Returns the maximum between two `bigint`s.

**Example**

```ts
import * as assert from "node:assert"
import { max } from "effect/BigInt"

assert.deepStrictEqual(max(2n, 3n), 3n)
```

**Signature**

```ts
declare const max: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L370)

Since v2.0.0
BigInt-min.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.min

Returns the minimum between two `bigint`s.

**Example**

```ts
import * as assert from "node:assert"
import { min } from "effect/BigInt"

assert.deepStrictEqual(min(2n, 3n), 2n)
```

**Signature**

```ts
declare const min: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L352)

Since v2.0.0
BigInt-multiply.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.multiply

Provides a multiplication operation on `bigint`s.

**Example**

```ts
import * as assert from "node:assert"
import { multiply } from "effect/BigInt"

assert.deepStrictEqual(multiply(2n, 3n), 6n)
```

**Signature**

```ts
declare const multiply: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L73)

Since v2.0.0
BigInt-multiplyAll.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.multiplyAll

Takes an `Iterable` of `bigint`s and returns their multiplication as a single `number`.

**Example**

```ts
import * as assert from "node:assert"
import { multiplyAll } from "effect/BigInt"

assert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)
```

**Signature**

```ts
declare const multiplyAll: (collection: Iterable<bigint>) => bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L546)

Since v2.0.0
BigInt-sign.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.sign

Determines the sign of a given `bigint`.

**Example**

```ts
import * as assert from "node:assert"
import { sign } from "effect/BigInt"

assert.deepStrictEqual(sign(-5n), -1)
assert.deepStrictEqual(sign(0n), 0)
assert.deepStrictEqual(sign(5n), 1)
```

**Signature**

```ts
declare const sign: (n: bigint) => Ordering
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L391)

Since v2.0.0
BigInt-sqrt.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.sqrt

Determines the square root of a given `bigint` safely. Returns `none` if the given `bigint` is negative.

**Example**

```ts
import * as assert from "node:assert"
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))
assert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))
assert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))
assert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())
```

**Signature**

```ts
declare const sqrt: (n: bigint) => Option.Option<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L507)

Since v2.0.0
BigInt-subtract.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.subtract

Provides a subtraction operation on `bigint`s.

**Example**

```ts
import * as assert from "node:assert"
import { subtract } from "effect/BigInt"

assert.deepStrictEqual(subtract(2n, 3n), -1n)
```

**Signature**

```ts
declare const subtract: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L92)

Since v2.0.0
BigInt-sum.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.sum

Provides an addition operation on `bigint`s.

**Example**

```ts
import * as assert from "node:assert"
import { sum } from "effect/BigInt"

assert.deepStrictEqual(sum(2n, 3n), 5n)
```

**Signature**

```ts
declare const sum: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L54)

Since v2.0.0
BigInt-sumAll.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.sumAll

Takes an `Iterable` of `bigint`s and returns their sum as a single `bigint

**Example**

```ts
import * as assert from "node:assert"
import { sumAll } from "effect/BigInt"

assert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)
```

**Signature**

```ts
declare const sumAll: (collection: Iterable<bigint>) => bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L524)

Since v2.0.0
BigInt-toNumber.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.toNumber

Takes a `bigint` and returns an `Option` of `number`.

If the `bigint` is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it converts the `bigint`
to a number and returns `Option.some(number)`.

**Example**

```ts
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())
```

**Signature**

```ts
declare const toNumber: (b: bigint) => Option.Option<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L577)

Since v2.0.0
BigInt-unsafeDivide.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.unsafeDivide

Provides a division operation on `bigint`s.

If the dividend is not a multiple of the divisor the result will be a `bigint` value
which represents the integer division rounded down to the nearest integer.

Throws a `RangeError` if the divisor is `0n`.

**Example**

```ts
import * as assert from "node:assert"
import { unsafeDivide } from "effect/BigInt"

assert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)
assert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)
```

**Signature**

```ts
declare const unsafeDivide: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L145)

Since v2.0.0
BigInt-unsafeSqrt.md
Package: `effect`<br />
Module: `BigInt`<br />

## BigInt.unsafeSqrt

Determines the square root of a given `bigint` unsafely. Throws if the given `bigint` is negative.

**Example**

```ts
import * as assert from "node:assert"
import { unsafeSqrt } from "effect/BigInt"

assert.deepStrictEqual(unsafeSqrt(4n), 2n)
assert.deepStrictEqual(unsafeSqrt(9n), 3n)
assert.deepStrictEqual(unsafeSqrt(16n), 4n)
```

**Signature**

```ts
declare const unsafeSqrt: (n: bigint) => bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L476)

Since v2.0.0
Boolean-and.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.and

Combines two boolean using AND: `self && that`.

**Example**

```ts
import * as assert from "node:assert"
import { and } from "effect/Boolean"

assert.deepStrictEqual(and(true, true), true)
assert.deepStrictEqual(and(true, false), false)
assert.deepStrictEqual(and(false, true), false)
assert.deepStrictEqual(and(false, false), false)
```

**Signature**

```ts
declare const and: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L106)

Since v2.0.0
Boolean-eqv.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.eqv

Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.

**Example**

```ts
import * as assert from "node:assert"
import { eqv } from "effect/Boolean"

assert.deepStrictEqual(eqv(true, true), true)
assert.deepStrictEqual(eqv(true, false), false)
assert.deepStrictEqual(eqv(false, true), false)
assert.deepStrictEqual(eqv(false, false), true)
```

**Signature**

```ts
declare const eqv: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L216)

Since v2.0.0
Boolean-every.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.every

This utility function is used to check if all the elements in a collection of boolean values are `true`.

**Example**

```ts
import * as assert from "node:assert"
import { every } from "effect/Boolean"

assert.deepStrictEqual(every([true, true, true]), true)
assert.deepStrictEqual(every([true, false, true]), false)
```

**Signature**

```ts
declare const every: (collection: Iterable<boolean>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L257)

Since v2.0.0
Boolean-implies.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.implies

Combines two booleans using an implication: `(!self || that)`.

**Example**

```ts
import * as assert from "node:assert"
import { implies } from "effect/Boolean"

assert.deepStrictEqual(implies(true, true), true)
assert.deepStrictEqual(implies(true, false), false)
assert.deepStrictEqual(implies(false, true), true)
assert.deepStrictEqual(implies(false, false), true)
```

**Signature**

```ts
declare const implies: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L238)

Since v2.0.0
Boolean-isBoolean.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.isBoolean

Tests if a value is a `boolean`.

**Example**

```ts
import * as assert from "node:assert"
import { isBoolean } from "effect/Boolean"

assert.deepStrictEqual(isBoolean(true), true)
assert.deepStrictEqual(isBoolean("true"), false)
```

**Signature**

```ts
declare const isBoolean: (input: unknown) => input is boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L29)

Since v2.0.0
Boolean-match.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.match

This function returns the result of either of the given functions depending on the value of the boolean parameter.
It is useful when you have to run one of two functions depending on the boolean value.

**Example**

```ts
import * as assert from "node:assert"
import { Boolean } from "effect"

assert.deepStrictEqual(Boolean.match(true, { onFalse: () => "It's false!", onTrue: () => "It's true!" }), "It's true!")
```

**Signature**

```ts
declare const match: { <A, B = A>(options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): (value: boolean) => A | B; <A, B>(value: boolean, options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): A | B; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L46)

Since v2.0.0
Boolean-nand.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.nand

Combines two boolean using NAND: `!(self && that)`.

**Example**

```ts
import * as assert from "node:assert"
import { nand } from "effect/Boolean"

assert.deepStrictEqual(nand(true, true), false)
assert.deepStrictEqual(nand(true, false), true)
assert.deepStrictEqual(nand(false, true), true)
assert.deepStrictEqual(nand(false, false), true)
```

**Signature**

```ts
declare const nand: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L128)

Since v2.0.0
Boolean-nor.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.nor

Combines two booleans using NOR: `!(self || that)`.

**Example**

```ts
import * as assert from "node:assert"
import { nor } from "effect/Boolean"

assert.deepStrictEqual(nor(true, true), false)
assert.deepStrictEqual(nor(true, false), false)
assert.deepStrictEqual(nor(false, true), false)
assert.deepStrictEqual(nor(false, false), true)
```

**Signature**

```ts
declare const nor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L172)

Since v2.0.0
Boolean-not.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.not

Negates the given boolean: `!self`

**Example**

```ts
import * as assert from "node:assert"
import { not } from "effect/Boolean"

assert.deepStrictEqual(not(true), false)
assert.deepStrictEqual(not(false), true)
```

**Signature**

```ts
declare const not: (self: boolean) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L87)

Since v2.0.0
Boolean-or.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.or

Combines two boolean using OR: `self || that`.

**Example**

```ts
import * as assert from "node:assert"
import { or } from "effect/Boolean"

assert.deepStrictEqual(or(true, true), true)
assert.deepStrictEqual(or(true, false), true)
assert.deepStrictEqual(or(false, true), true)
assert.deepStrictEqual(or(false, false), false)
```

**Signature**

```ts
declare const or: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L150)

Since v2.0.0
Boolean-some.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.some

This utility function is used to check if at least one of the elements in a collection of boolean values is `true`.

**Example**

```ts
import * as assert from "node:assert"
import { some } from "effect/Boolean"

assert.deepStrictEqual(some([true, false, true]), true)
assert.deepStrictEqual(some([false, false, false]), false)
```

**Signature**

```ts
declare const some: (collection: Iterable<boolean>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L280)

Since v2.0.0
Boolean-xor.md
Package: `effect`<br />
Module: `Boolean`<br />

## Boolean.xor

Combines two booleans using XOR: `(!self && that) || (self && !that)`.

**Example**

```ts
import * as assert from "node:assert"
import { xor } from "effect/Boolean"

assert.deepStrictEqual(xor(true, true), false)
assert.deepStrictEqual(xor(true, false), true)
assert.deepStrictEqual(xor(false, true), true)
assert.deepStrictEqual(xor(false, false), false)
```

**Signature**

```ts
declare const xor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L194)

Since v2.0.0
Bounded-between.md
Package: `@effect/typeclass`<br />
Module: `Bounded`<br />

## Bounded.between

Checks if a value is between the lower and upper limit of a bound.

**Signature**

```ts
declare const between: <A>(B: Bounded<A>) => (a: A) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bounded.ts#L51)

Since v0.24.0
Bounded-clamp.md
Package: `@effect/typeclass`<br />
Module: `Bounded`<br />

## Bounded.clamp

Clamp a value between `minBound` and `maxBound` values.

**Signature**

```ts
declare const clamp: <A>(B: Bounded<A>) => (a: A) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bounded.ts#L60)

Since v0.24.0
Bounded-max.md
Package: `@effect/typeclass`<br />
Module: `Bounded`<br />

## Bounded.max

`Monoid` that returns last maximum of elements.

**Signature**

```ts
declare const max: <A>(B: Bounded<A>) => Monoid<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bounded.ts#L43)

Since v0.24.0
Bounded-min.md
Package: `@effect/typeclass`<br />
Module: `Bounded`<br />

## Bounded.min

`Monoid` that returns last minimum of elements.

**Signature**

```ts
declare const min: <A>(B: Bounded<A>) => Monoid<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bounded.ts#L35)

Since v0.24.0
Bounded-reverse.md
Package: `@effect/typeclass`<br />
Module: `Bounded`<br />

## Bounded.reverse

Reverses the `Order` of a `Bounded` and flips `maxBound` and `minBound` values.

**Signature**

```ts
declare const reverse: <A>(B: Bounded<A>) => Bounded<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Bounded.ts#L69)

Since v0.24.0
Brand-Brand.BrandErrors.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.Brand.BrandErrors

Represents a list of refinement errors.

**Signature**

```ts
export interface BrandErrors extends Array<RefinementError> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L72)

Since v2.0.0
Brand-Brand.Brands.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.Brand.Brands

A utility type to extract the brands from a branded type.

**Signature**

```ts
type Brands<P> = P extends Brand<any> ? Types.UnionToIntersection<
      {
        [k in keyof P[BrandTypeId]]: k extends string | symbol ? Brand<k>
          : never
      }[keyof P[BrandTypeId]]
    >
    : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L135)

Since v2.0.0
Brand-Brand.EnsureCommonBase.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.Brand.EnsureCommonBase

A utility type that checks that all brands have the same base type.

**Signature**

```ts
type EnsureCommonBase<Brands> = {
    [B in keyof Brands]: Brand.Unbranded<Brand.FromConstructor<Brands[0]>> extends
      Brand.Unbranded<Brand.FromConstructor<Brands[B]>>
      ? Brand.Unbranded<Brand.FromConstructor<Brands[B]>> extends Brand.Unbranded<Brand.FromConstructor<Brands[0]>>
        ? Brands[B]
      : Brands[B]
      : "ERROR: All brands should have the same base type"
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L149)

Since v2.0.0
Brand-Brand.FromConstructor.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.Brand.FromConstructor

A utility type to extract a branded type from a `Brand.Constructor`.

**Signature**

```ts
type FromConstructor<A> = A extends Brand.Constructor<infer B> ? B : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L119)

Since v2.0.0
Brand-Brand.RefinementError.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.Brand.RefinementError

Represents an error that occurs when the provided value of the branded type does not pass the refinement predicate.

**Signature**

```ts
export interface RefinementError {
    readonly meta: unknown
    readonly message: string
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L80)

Since v2.0.0
Brand-Brand.Unbranded.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.Brand.Unbranded

A utility type to extract the value type from a brand.

**Signature**

```ts
type Unbranded<P> = P extends infer Q & Brands<P> ? Q : P
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L127)

Since v2.0.0
Brand-Brand.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.Brand

A generic interface that defines a branded type.

**Signature**

```ts
export interface Brand<in out K extends string | symbol> {
  readonly [BrandTypeId]: {
    readonly [k in K]: K
  }
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L56)

Since v2.0.0
Brand-all.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.all

Combines two or more brands together to form a single branded type.
This API is useful when you want to validate that the input data passes multiple brand validators.

**Example**

```ts
import * as assert from "node:assert"
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">
const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)
type Positive = number & Brand.Brand<"Positive">
const Positive = Brand.refined<Positive>(
  (n) => n > 0,
  (n) => Brand.error(`Expected ${n} to be positive`)
)

const PositiveInt = Brand.all(Int, Positive)

console.log(PositiveInt(1))
// 1

assert.throws(() => PositiveInt(1.1))
```

**Signature**

```ts
declare const all: <Brands extends readonly [Brand.Constructor<any>, ...Array<Brand.Constructor<any>>]>(...brands: Brand.EnsureCommonBase<Brands>) => Brand.Constructor<Types.UnionToIntersection<{ [B in keyof Brands]: Brand.FromConstructor<Brands[B]>; }[number]> extends infer X extends Brand<any> ? X : Brand<any>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L313)

Since v2.0.0
Brand-error.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.error

Returns a `BrandErrors` that contains a single `RefinementError`.

**Signature**

```ts
declare const error: (message: string, meta?: unknown) => Brand.BrandErrors
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L173)

Since v2.0.0
Brand-errors.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.errors

Takes a variable number of `BrandErrors` and returns a single `BrandErrors` that contains all refinement errors.

**Signature**

```ts
declare const errors: (...errors: Array<Brand.BrandErrors>) => Brand.BrandErrors
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L184)

Since v2.0.0
Brand-nominal.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.nominal

This function returns a `Brand.Constructor` that **does not apply any runtime checks**, it just returns the provided value.
It can be used to create nominal types that allow distinguishing between two values of the same type but with different meanings.

If you also want to perform some validation, see `refined`.

**Example**

```ts
import * as assert from "node:assert"
import { Brand } from "effect"

type UserId = number & Brand.Brand<"UserId">

const UserId = Brand.nominal<UserId>()

console.log(UserId(1))
// 1
```

**Signature**

```ts
declare const nominal: <A extends Brand<any>>() => Brand.Constructor<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L269)

Since v2.0.0
Brand-refined.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.refined

Returns a `Brand.Constructor` that can construct a branded type from an unbranded value using the provided `refinement`
predicate as validation of the input data.

If you don't want to perform any validation but only distinguish between two values of the same type but with different meanings,
see `nominal`.

**Example**

```ts
import * as assert from "node:assert"
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">

const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)

console.log(Int(1))
// 1

assert.throws(() => Int(1.1))
```

**Signature**

```ts
declare const refined: { <A extends Brand<any>>(f: (unbranded: Brand.Unbranded<A>) => Option.Option<Brand.BrandErrors>): Brand.Constructor<A>; <A extends Brand<any>>(refinement: Predicate<Brand.Unbranded<A>>, onFailure: (unbranded: Brand.Unbranded<A>) => Brand.BrandErrors): Brand.Constructor<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L224)

Since v2.0.0
Brand-unbranded.md
Package: `effect`<br />
Module: `Brand`<br />

## Brand.unbranded

Retrieves the unbranded value from a `Brand` instance.

**Signature**

```ts
declare const unbranded: <A extends Brand<any>>(branded: A) => Brand.Unbranded<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L360)

Since v3.15.0
BrowserKeyValueStore-layerLocalStorage.md
Package: `@effect/platform-browser`<br />
Module: `BrowserKeyValueStore`<br />

## BrowserKeyValueStore.layerLocalStorage

Creates a KeyValueStore layer that uses the browser's localStorage api. Values are stored between sessions.

**Signature**

```ts
declare const layerLocalStorage: Layer.Layer<KeyValueStore.KeyValueStore, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/BrowserKeyValueStore.ts#L14)

Since v1.0.0
BrowserKeyValueStore-layerSessionStorage.md
Package: `@effect/platform-browser`<br />
Module: `BrowserKeyValueStore`<br />

## BrowserKeyValueStore.layerSessionStorage

Creates a KeyValueStore layer that uses the browser's sessionStorage api. Values are stored only for the current session.

**Signature**

```ts
declare const layerSessionStorage: Layer.Layer<KeyValueStore.KeyValueStore, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/BrowserKeyValueStore.ts#L22)

Since v1.0.0
BrowserSocket-layerWebSocketConstructor.md
Package: `@effect/platform-browser`<br />
Module: `BrowserSocket`<br />

## BrowserSocket.layerWebSocketConstructor

A WebSocket constructor that uses globalThis.WebSocket.

**Signature**

```ts
declare const layerWebSocketConstructor: Layer.Layer<Socket.WebSocketConstructor, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/BrowserSocket.ts#L24)

Since v1.0.0
BrowserStream-fromEventListenerDocument.md
Package: `@effect/platform-browser`<br />
Module: `BrowserStream`<br />

## BrowserStream.fromEventListenerDocument

Creates a `Stream` from document.addEventListener.

**Signature**

```ts
declare const fromEventListenerDocument: <K extends keyof DocumentEventMap>(type: K, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | "unbounded" | undefined; } | undefined) => Stream.Stream<DocumentEventMap[K], never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/BrowserStream.ts#L26)

Since v1.0.0
BrowserStream-fromEventListenerWindow.md
Package: `@effect/platform-browser`<br />
Module: `BrowserStream`<br />

## BrowserStream.fromEventListenerWindow

Creates a `Stream` from window.addEventListener.

**Signature**

```ts
declare const fromEventListenerWindow: <K extends keyof WindowEventMap>(type: K, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | "unbounded" | undefined; } | undefined) => Stream.Stream<WindowEventMap[K], never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/BrowserStream.ts#L12)

Since v1.0.0
BunHttpServer-layerContext.md
Package: `@effect/platform-bun`<br />
Module: `BunHttpServer`<br />

## BunHttpServer.layerContext

A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`
services.

The `FileSystem` service is a no-op implementation, so this layer is only
useful for platforms that have no file system.

**Signature**

```ts
declare const layerContext: Layer.Layer<Platform.HttpPlatform | Etag.Generator | BunContext.BunContext, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/BunHttpServer.ts#L78)

Since v1.0.0
BunHttpServer-layerTest.md
Package: `@effect/platform-bun`<br />
Module: `BunHttpServer`<br />

## BunHttpServer.layerTest

Layer starting a server on a random port and producing an `HttpClient`
with prepended url of the running http server.

**Signature**

```ts
declare const layerTest: Layer.Layer<Server.HttpServer | Platform.HttpPlatform | Etag.Generator | BunContext.BunContext | HttpClient.HttpClient, HttpServerError.ServeError, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/BunHttpServer.ts#L48)

Since v1.0.0
Cache-Cache.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.Cache

A `Cache` is defined in terms of a lookup function that, given a key of
type `Key`, can either fail with an error of type `Error` or succeed with a
value of type `Value`. Getting a value from the cache will either return
the previous result of the lookup function if it is available or else
compute a new result with the lookup function, put it in the cache, and
return it.

A cache also has a specified capacity and time to live. When the cache is
at capacity the least recently accessed values in the cache will be
removed to make room for new values. Getting a value with a life older than
the specified time to live will result in a new value being computed with
the lookup function and returned when available.

The cache is safe for concurrent access. If multiple fibers attempt to get
the same key the lookup function will only be computed once and the result
will be returned to all fibers.

**Signature**

```ts
export interface Cache<in out Key, in out Value, out Error = never>
  extends ConsumerCache<Key, Value, Error>, Cache.Variance<Key, Value, Error>
{
  /**
   * Retrieves the value associated with the specified key if it exists.
   * Otherwise computes the value with the lookup function, puts it in the
   * cache, and returns it.
   */
  get(key: Key): Effect.Effect<Value, Error>

  /**
   * Retrieves the value associated with the specified key if it exists as a left.
   * Otherwise computes the value with the lookup function, puts it in the
   * cache, and returns it as a right.
   */
  getEither(key: Key): Effect.Effect<Either<Value, Value>, Error>

  /**
   * Computes the value associated with the specified key, with the lookup
   * function, and puts it in the cache. The difference between this and
   * `get` method is that `refresh` triggers (re)computation of the value
   * without invalidating it in the cache, so any request to the associated
   * key can still be served while the value is being re-computed/retrieved
   * by the lookup function. Additionally, `refresh` always triggers the
   * lookup function, disregarding the last `Error`.
   */
  refresh(key: Key): Effect.Effect<void, Error>

  /**
   * Associates the specified value with the specified key in the cache.
   */
  set(key: Key, value: Value): Effect.Effect<void>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L58)

Since v2.0.0
Cache-CacheStats.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.CacheStats

`CacheStats` represents a snapshot of statistics for the cache as of a
point in time.

**Signature**

```ts
export interface CacheStats {
  readonly hits: number
  readonly misses: number
  readonly size: number
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L233)

Since v2.0.0
Cache-ConsumerCache.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.ConsumerCache

A ConsumerCache models a portion of a cache which is safe to share without allowing to create new values or access existing ones.

It can be used safely to give over control for request management without leaking writer side details.

**Signature**

```ts
export interface ConsumerCache<in out Key, out Value, out Error = never>
  extends Cache.ConsumerVariance<Key, Value, Error>
{
  /**
   * Retrieves the value associated with the specified key if it exists.
   * Otherwise returns `Option.none`.
   */
  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error>

  /**
   * Retrieves the value associated with the specified key if it exists and the
   * lookup function has completed. Otherwise returns `Option.none`.
   */
  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>>

  /**
   * Returns statistics for this cache.
   */
  readonly cacheStats: Effect.Effect<CacheStats>

  /**
   * Returns whether a value associated with the specified key exists in the
   * cache.
   */
  contains(key: Key): Effect.Effect<boolean>

  /**
   * Returns statistics for the specified entry.
   */
  entryStats(key: Key): Effect.Effect<Option.Option<EntryStats>>

  /**
   * Invalidates the value associated with the specified key.
   */
  invalidate(key: Key): Effect.Effect<void>

  /**
   * Invalidates the value associated with the specified key if the predicate holds.
   */
  invalidateWhen(key: Key, predicate: Predicate.Predicate<Value>): Effect.Effect<void>

  /**
   * Invalidates all values in the cache.
   */
  readonly invalidateAll: Effect.Effect<void>

  /**
   * Returns the approximate number of values in the cache.
   */
  readonly size: Effect.Effect<number>

  /**
   * Returns an approximation of the values in the cache.
   */
  readonly keys: Effect.Effect<Array<Key>>

  /**
   * Returns an approximation of the values in the cache.
   */
  readonly values: Effect.Effect<Array<Value>>

  /**
   * Returns an approximation of the values in the cache.
   */
  readonly entries: Effect.Effect<Array<[Key, Value]>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L100)

Since v2.0.0
Cache-EntryStats.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.EntryStats

Represents a snapshot of statistics for an entry in the cache.

**Signature**

```ts
export interface EntryStats {
  readonly loadedMillis: number
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L259)

Since v2.0.0
Cache-Lookup.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.Lookup

A `Lookup` represents a lookup function that, given a key of type `Key`, can
return an effect that will either produce a value of type `Value` or fail
with an error of type `Error` using an environment of type `Environment`.

**Signature**

```ts
type Lookup<Key, Value, Error, Environment> = (
  key: Key
) => Effect.Effect<Value, Error, Environment>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L279)

Since v2.0.0
Cache-make.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.make

Constructs a new cache with the specified capacity, time to live, and
lookup function.

**Signature**

```ts
declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly timeToLive: Duration.DurationInput; readonly lookup: Lookup<Key, Value, Error, Environment>; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L202)

Since v2.0.0
Cache-makeCacheStats.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.makeCacheStats

Constructs a new `CacheStats` from the specified values.

**Signature**

```ts
declare const makeCacheStats: (options: { readonly hits: number; readonly misses: number; readonly size: number; }) => CacheStats
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L245)

Since v2.0.0
Cache-makeEntryStats.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.makeEntryStats

Constructs a new `EntryStats` from the specified values.

**Signature**

```ts
declare const makeEntryStats: (loadedMillis: number) => EntryStats
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L269)

Since v2.0.0
Cache-makeWith.md
Package: `effect`<br />
Module: `Cache`<br />

## Cache.makeWith

Constructs a new cache with the specified capacity, time to live, and
lookup function, where the time to live can depend on the `Exit` value
returned by the lookup function.

**Signature**

```ts
declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L218)

Since v2.0.0
Cause-Cause.Variance.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Cause.Variance

This interface is used internally to manage the type variance of `Cause`.

**Signature**

```ts
export interface Variance<out E> {
    readonly [CauseTypeId]: {
      readonly _E: Covariant<E>
    }
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L272)

Since v2.0.0
Cause-Cause.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Cause

Represents the full history of a failure within an `Effect`.

**Details**

This type is a data structure that captures all information about why and how
an effect has failed, including parallel errors, sequential errors, defects,
and interruptions. It enables a "lossless" error model: no error-related
information is discarded, which helps in debugging and understanding the root
cause of failures.

**Signature**

```ts
type Cause<E> = | Empty
  | Fail<E>
  | Die
  | Interrupt
  | Sequential<E>
  | Parallel<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L254)

Since v2.0.0
Cause-CauseReducer.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.CauseReducer

Describes methods for reducing a `Cause<E>` into a value of type `Z` with
access to contextual information.

**Details**

This interface is meant for advanced transformations of `Cause`. By
implementing each method, you can define how different parts of the `Cause`
structure (like `Fail`, `Die`, or `Interrupt`) should be transformed into a
final type `Z`. The `context` parameter carries additional data needed during
this reduction.

**See**

- `reduceWithContext` Apply a `CauseReducer` to transform a `Cause`

**Signature**

```ts
export interface CauseReducer<in C, in E, in out Z> {
  emptyCase(context: C): Z
  failCase(context: C, error: E): Z
  dieCase(context: C, defect: unknown): Z
  interruptCase(context: C, fiberId: FiberId.FiberId): Z
  sequentialCase(context: C, left: Z, right: Z): Z
  parallelCase(context: C, left: Z, right: Z): Z
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L296)

Since v2.0.0
Cause-CauseTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.CauseTypeId

A unique symbol identifying the `Cause` type.

**Details**

This provides a symbol that helps identify instances of the `Cause` data
type. This can be used for advanced operations such as refining types or
building internal utilities that check whether an unknown value is a `Cause`.

**See**

- `isCause` Check if a value is a `Cause`

**Signature**

```ts
declare const CauseTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L56)

Since v2.0.0
Cause-Die.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Die

Represents an unexpected defect within a `Cause`.

**Details**

This interface models a `Cause` for errors that are typically unrecoverable or
unanticipatedlike runtime exceptions or bugs. When code "dies," it indicates a
severe failure that wasn't accounted for.

**See**

- `die` Construct a `Die` cause
- `isDieType` Check if a `Cause` is a `Die`

**Signature**

```ts
export interface Die extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Die"
  readonly defect: unknown
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L494)

Since v2.0.0
Cause-Empty.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Empty

Represents a lack of errors within a `Cause`.

**See**

- `empty` Construct a new `Empty` cause
- `isEmptyType` Check if a `Cause` is an `Empty` type

**Signature**

```ts
export interface Empty extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Empty"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L455)

Since v2.0.0
Cause-ExceededCapacityException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.ExceededCapacityException

An error that occurs when resource capacity is exceeded.

**Signature**

```ts
export interface ExceededCapacityException extends YieldableError {
  readonly _tag: "ExceededCapacityException"
  readonly [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L412)

Since v3.5.0
Cause-andThen.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.andThen

Sequences two `Cause`s. The second `Cause` can be dependent on the result of
the first `Cause`.

**Signature**

```ts
declare const andThen: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1049)

Since v2.0.0
Cause-as.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.as

Replaces any errors in a `Cause` with a provided constant error.

**Details**

This function transforms all `Fail` errors into the specified error value,
preserving the structure of the `Cause`. It's useful when you no longer need
the original error details but still want to keep the cause shape.

**See**

- `map` Apply a custom transformation to `Fail` errors

**Signature**

```ts
declare const as: { <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, error: E2): Cause<E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L999)

Since v2.0.0
Cause-contains.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.contains

Checks if the current `Cause` contains or is equal to another `Cause`.

**Details**

This function returns `true` if `that` cause is part of or the same as
the current `Cause`. It's useful when you need to check for specific
error patterns or deduplicate repeated failures.

**Signature**

```ts
declare const contains: { <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean; <E, E2>(self: Cause<E>, that: Cause<E2>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1084)

Since v2.0.0
Cause-defects.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.defects

Extracts all unrecoverable defects from a `Cause`.

**Details**

This function returns a chunk of values representing unexpected errors
(`Die`). It's handy for capturing or logging unanticipated failures that
might need special handling, such as bug reports.

**Signature**

```ts
declare const defects: <E>(self: Cause<E>) => Chunk.Chunk<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L832)

Since v2.0.0
Cause-die.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.die

Creates a `Die` cause from an unexpected error.

**Details**

This function wraps an unhandled or unknown defect (like a runtime crash)
into a `Cause`. It's useful for capturing unforeseen issues in a structured
way.

**See**

- `isDie` Check if a `Cause` contains a defect

**Signature**

```ts
declare const die: (defect: unknown) => Cause<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L607)

Since v2.0.0
Cause-dieOption.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.dieOption

Retrieves the first `Die` defect in a `Cause`, if present.

**Details**

This function returns an `Option` containing the first unexpected failure
(`Die`) discovered. It's helpful for diagnosing the primary defect in a chain
of errors.

**Signature**

```ts
declare const dieOption: <E>(self: Cause<E>) => Option.Option<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L904)

Since v2.0.0
Cause-empty.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.empty

Creates an `Empty` cause.

**Details**

This function returns a cause that signifies "no error." It's commonly used
to represent an absence of failure conditions.

**See**

- `isEmpty` Check if a `Cause` is empty

**Signature**

```ts
declare const empty: Cause<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L575)

Since v2.0.0
Cause-ExceededCapacityExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.ExceededCapacityExceptionTypeId

A unique symbol identifying the `ExceededCapacityException` type.

**Details**

This provides a symbol that identifies an `ExceededCapacityException`. It
denotes situations where a resource has exceeded its configured capacity
limit.

**See**

- `ExceededCapacityException` Create or work with an `ExceededCapacityException`

**Signature**

```ts
declare const ExceededCapacityExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L188)

Since v3.5.0
Cause-Fail.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Fail

Represents an expected error within a `Cause`.

**Details**

This interface models a `Cause` that carries an expected or known error of
type `E`. For example, if you validate user input and find it invalid, you
might store that error within a `Fail`.

**See**

- `fail` Construct a `Fail` cause
- `isFailType` Check if a `Cause` is a `Fail`

**Signature**

```ts
export interface Fail<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Fail"
  readonly error: E
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L474)

Since v2.0.0
Cause-IllegalArgumentException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.IllegalArgumentException

An error representing an invalid argument passed to a method.

**Details**

This interface is used for signaling that a function or method received an
argument that does not meet its preconditions.

**Signature**

```ts
export interface IllegalArgumentException extends YieldableError {
  readonly _tag: "IllegalArgumentException"
  readonly [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L373)

Since v2.0.0
Cause-IllegalArgumentExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.IllegalArgumentExceptionTypeId

A unique symbol identifying the `IllegalArgumentException` type.

**Details**

This provides a symbol that identifies an `IllegalArgumentException`. This is
often used in scenarios where invalid arguments are supplied to methods that
expect specific input.

**See**

- `IllegalArgumentException` Create or work with an `IllegalArgumentException`

**Signature**

```ts
declare const IllegalArgumentExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L122)

Since v2.0.0
Cause-Interrupt.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Interrupt

Represents fiber interruption within a `Cause`.

**Details**

This interface models a scenario where an effect was halted by an external
signal, carrying a `FiberId` that identifies which fiber was interrupted.
Interruption is a normal part of concurrency, used for cancellation or
resource cleanup.

**See**

- `interrupt` Construct an `Interrupt` cause
- `isInterruptType` Check if a `Cause` is an `Interrupt`

**Signature**

```ts
export interface Interrupt extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Interrupt"
  readonly fiberId: FiberId.FiberId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L515)

Since v2.0.0
Cause-InterruptedException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.InterruptedException

An error representing fiber interruption.

**Details**

This interface represents errors that occur when a fiber is forcefully
interrupted. Interruption can happen for various reasons, including
cancellations or system directives to halt operations. Code that deals with
concurrency might need to catch or handle these to ensure proper cleanup.

**Signature**

```ts
export interface InterruptedException extends YieldableError {
  readonly _tag: "InterruptedException"
  readonly [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L357)

Since v2.0.0
Cause-InterruptedExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.InterruptedExceptionTypeId

A unique symbol identifying the `InterruptedException` type.

**Details**

This provides a symbol that identifies an `InterruptedException`. This is
typically used internally to recognize when a fiber has been interrupted,
helping the framework handle interruption logic correctly.

**See**

- `InterruptedException` Create or work with an `InterruptedException`

**Signature**

```ts
declare const InterruptedExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L100)

Since v2.0.0
Cause-InvalidPubSubCapacityException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.InvalidPubSubCapacityException

An error indicating invalid capacity for a `PubSub`.

**Signature**

```ts
export interface InvalidPubSubCapacityException extends YieldableError {
  readonly _tag: "InvalidPubSubCapacityException"
  readonly [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L401)

Since v2.0.0
Cause-InvalidPubSubCapacityExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.InvalidPubSubCapacityExceptionTypeId

A unique symbol identifying the `InvalidPubSubCapacityException` type.

**Details**

This provides a symbol that identifies an `InvalidPubSubCapacityException`.
It indicates an error related to an invalid capacity passed to a `PubSub`
structure.

**See**

- `InvalidPubSubCapacityException` Create or work with an `InvalidPubSubCapacityException`

**Signature**

```ts
declare const InvalidPubSubCapacityExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L166)

Since v2.0.0
Cause-NoSuchElementException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.NoSuchElementException

An error that occurs when an expected element is missing.

**Details**

This interface indicates scenarios like looking up an item in a collection
or searching for data that should be present but isn't. It helps your code
signal a more specific issue rather than a general error.

**Signature**

```ts
export interface NoSuchElementException extends YieldableError {
  readonly _tag: "NoSuchElementException"
  readonly [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L390)

Since v2.0.0
Cause-NoSuchElementExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.NoSuchElementExceptionTypeId

A unique symbol identifying the `NoSuchElementException` type.

**Details**

This provides a symbol that identifies a `NoSuchElementException`. It helps
differentiate cases where a required element is missing within a data
structure.

**See**

- `NoSuchElementException` Create or work with a `NoSuchElementException`

**Signature**

```ts
declare const NoSuchElementExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L144)

Since v2.0.0
Cause-Parallel.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Parallel

Represents parallel composition of two `Cause`s.

**Details**

This interface captures failures that happen simultaneously. In scenarios
with concurrency, more than one operation can fail in parallel. Instead of
losing information, this structure stores both errors together.

**See**

- `parallel` Combine two `Cause`s in parallel
- `isParallelType` Check if a `Cause` is a `Parallel`

**Signature**

```ts
export interface Parallel<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Parallel"
  readonly left: Cause<E>
  readonly right: Cause<E>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L535)

Since v2.0.0
Cause-fail.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.fail

Creates a `Fail` cause from an expected error.

**Details**

This function constructs a `Cause` carrying an error of type `E`. It's used
when you want to represent a known or anticipated failure in your effectful
computations.

**See**

- `isFailure` Check if a `Cause` contains a failure

**Signature**

```ts
declare const fail: <E>(error: E) => Cause<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L591)

Since v2.0.0
Cause-failureOption.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.failureOption

Retrieves the first `Fail` error in a `Cause`, if present.

**Details**

This function returns an `Option` containing the first recoverable error
(`E`) from the cause. It's often used to quickly check if there's a primary
error to handle or display.

**Signature**

```ts
declare const failureOption: <E>(self: Cause<E>) => Option.Option<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L860)

Since v2.0.0
Cause-failureOrCause.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.failureOrCause

Splits a `Cause` into either its first `Fail` error or the rest of the cause
(which might only contain `Die` or `Interrupt`).

**Details**

This function either returns the checked error (`E`) or the remaining
`Cause<never>` with defects/interruptions. It helps you decide if there's a
recoverable path or if only unhandled issues remain.

**Signature**

```ts
declare const failureOrCause: <E>(self: Cause<E>) => Either.Either<Cause<never>, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L875)

Since v2.0.0
Cause-failures.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.failures

Extracts all recoverable errors of type `E` from a `Cause`.

**Details**

This function returns a chunk of errors, providing a list of all `Fail`
values found in the cause. It's useful for collecting all known failures for
logging or combined error handling.

**Signature**

```ts
declare const failures: <E>(self: Cause<E>) => Chunk.Chunk<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L818)

Since v2.0.0
Cause-filter.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.filter

Preserves parts of a `Cause` that match a given predicate.

**Details**

This function allows you to retain only the parts of a `Cause` structure that
match a specified predicate or refinement. Any parts of the `Cause` that do
not match the provided condition are excluded from the result.

You can use this function in two ways:
- With a `Predicate`: A function that evaluates whether a `Cause` should be
  retained based on its value.
- With a `Refinement`: A more specific predicate that can refine the type of
  the `Cause`.

This is useful when you need to extract specific types of errors, defects, or
interruptions from a `Cause` while discarding unrelated parts.

**Signature**

```ts
declare const filter: { <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>; <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>; <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>; <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1198)

Since v2.0.0
Cause-find.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.find

Searches a `Cause` using a partial function to extract information.

**Details**

This function allows you to search through a `Cause` using a custom partial
function. The partial function is applied to the `Cause`, and if it matches,
the result is returned wrapped in a `Some`. If no match is found, the result
is `None`.

This is particularly useful when you are only interested in specific types of
errors, defects, or interruption causes within a potentially complex `Cause`
structure. By leveraging a partial function, you can focus on extracting only
the relevant information you care about.

The partial function should return an `Option` indicating whether it matched
and the value it extracted.

**Signature**

```ts
declare const find: { <E, Z>(pf: (cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Option.Option<Z>; <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option.Option<Z>): Option.Option<Z>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1172)

Since v2.0.0
Cause-flatMap.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.flatMap

Transforms errors in a `Cause` into new causes.

**Details**

This function applies a function `f` to each `Fail` error, converting it into
a new `Cause`. This is especially powerful for merging or restructuring error
types while preserving or combining cause information.

**See**

- `map` Apply a simpler transformation to errors

**Signature**

```ts
declare const flatMap: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1037)

Since v2.0.0
Cause-flatten.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.flatten

Flattens a nested `Cause` structure.

**Details**

This function takes a `Cause<Cause<E>>` and merges the layers into a single
`Cause<E>`. It's useful for eliminating additional nesting created by
repeated transformations or compositions.

**See**

- `flatMap` Compose nested causes

**Signature**

```ts
declare const flatten: <E>(self: Cause<Cause<E>>) => Cause<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1070)

Since v2.0.0
Cause-flipCauseOption.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.flipCauseOption

Strips out failures with an error of `None` from a `Cause<Option<E>>`.

**Details**

This function turns a `Cause<Option<E>>` into an `Option<Cause<E>>`. If the
cause only contains failures of `None`, it becomes `None`; otherwise, it
returns a `Cause` of the remaining errors. It's helpful when working with
optional errors and filtering out certain error paths.

**Signature**

```ts
declare const flipCauseOption: <E>(self: Cause<Option.Option<E>>) => Option.Option<Cause<E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L890)

Since v2.0.0
Cause-interrupt.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.interrupt

Creates an `Interrupt` cause from a `FiberId`.

**Details**

This function represents a fiber that has been interrupted. It stores the
identifier of the interrupted fiber, enabling precise tracking of concurrent
cancellations.

**See**

- `isInterrupted` Check if a `Cause` contains an interruption

**Signature**

```ts
declare const interrupt: (fiberId: FiberId.FiberId) => Cause<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L623)

Since v2.0.0
Cause-interruptOption.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.interruptOption

Retrieves the first `Interrupt` in a `Cause`, if present.

**Details**

This function returns an `Option` with the first fiber interruption
discovered. This is particularly useful for concurrency analysis or debugging
cancellations.

**Signature**

```ts
declare const interruptOption: <E>(self: Cause<E>) => Option.Option<FiberId.FiberId>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L918)

Since v2.0.0
Cause-interruptors.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.interruptors

Collects all `FiberId`s responsible for interrupting a fiber.

**Details**

This function returns a set of IDs indicating which fibers caused
interruptions within this `Cause`. It's useful for debugging concurrency
issues or tracing cancellations.

**Signature**

```ts
declare const interruptors: <E>(self: Cause<E>) => HashSet.HashSet<FiberId.FiberId>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L846)

Since v2.0.0
Cause-isCause.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isCause

Checks if a value is a `Cause`.

**Signature**

```ts
declare const isCause: (u: unknown) => u is Cause<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L663)

Since v2.0.0
Cause-isDie.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isDie

Checks if a `Cause` contains a defect.

**Details**

This function returns `true` if the `Cause` includes any unexpected or
unhandled errors (`Die`). It's useful for differentiating known failures from
unexpected ones.

**Signature**

```ts
declare const isDie: <E>(self: Cause<E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L778)

Since v2.0.0
Cause-isDieType.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isDieType

Checks if a `Cause` is a `Die` type.

**See**

- `die` Create a new `Die` cause

**Signature**

```ts
declare const isDieType: <E>(self: Cause<E>) => self is Die
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L693)

Since v2.0.0
Cause-isEmpty.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isEmpty

Checks if a `Cause` is entirely empty.

**Details**

This function returns `true` if the `Cause` contains no errors, defects, or
interruptions. It's helpful for verifying if a computation truly had no
failures.

**Signature**

```ts
declare const isEmpty: <E>(self: Cause<E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L750)

Since v2.0.0
Cause-isEmptyType.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isEmptyType

Checks if a `Cause` is an `Empty` type.

**See**

- `empty` Create a new `Empty` cause

**Signature**

```ts
declare const isEmptyType: <E>(self: Cause<E>) => self is Empty
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L673)

Since v2.0.0
Cause-isExceededCapacityException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isExceededCapacityException

Checks if a given unknown value is an `ExceededCapacityException`.

**Signature**

```ts
declare const isExceededCapacityException: (u: unknown) => u is ExceededCapacityException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1492)

Since v3.5.0
Cause-isFailType.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isFailType

Checks if a `Cause` is a `Fail` type.

**See**

- `fail` Create a new `Fail` cause

**Signature**

```ts
declare const isFailType: <E>(self: Cause<E>) => self is Fail<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L683)

Since v2.0.0
Cause-isFailure.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isFailure

Checks if a `Cause` contains a failure.

**Details**

This function returns `true` if the `Cause` includes any `Fail` error. It's
commonly used to confirm whether a workflow encountered an anticipated error
versus just defects or interruptions.

**Signature**

```ts
declare const isFailure: <E>(self: Cause<E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L764)

Since v2.0.0
Cause-isIllegalArgumentException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isIllegalArgumentException

Checks if a given unknown value is an `IllegalArgumentException`.

**Signature**

```ts
declare const isIllegalArgumentException: (u: unknown) => u is IllegalArgumentException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1359)

Since v2.0.0
Cause-isInterruptType.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isInterruptType

Checks if a `Cause` is an `Interrupt` type.

**See**

- `interrupt` Create an `Interrupt` cause

**Signature**

```ts
declare const isInterruptType: <E>(self: Cause<E>) => self is Interrupt
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L703)

Since v2.0.0
Cause-isInterrupted.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isInterrupted

Checks if a `Cause` contains an interruption.

**Details**

This function returns `true` if the `Cause` includes any fiber interruptions.

**Signature**

```ts
declare const isInterrupted: <E>(self: Cause<E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L790)

Since v2.0.0
Cause-isInterruptedException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isInterruptedException

Checks if a given unknown value is an `InterruptedException`.

**Signature**

```ts
declare const isInterruptedException: (u: unknown) => u is InterruptedException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1336)

Since v2.0.0
Cause-isInterruptedOnly.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isInterruptedOnly

Checks if a `Cause` contains only interruptions.

**Details**

This function returns `true` if the `Cause` has been interrupted but does not
contain any other failures, such as `Fail` or `Die`. It's helpful for
verifying purely "cancellation" scenarios.

**Signature**

```ts
declare const isInterruptedOnly: <E>(self: Cause<E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L804)

Since v2.0.0
Cause-isNoSuchElementException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isNoSuchElementException

Checks if a given unknown value is a `NoSuchElementException`.

**Signature**

```ts
declare const isNoSuchElementException: (u: unknown) => u is NoSuchElementException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1381)

Since v2.0.0
Cause-isParallelType.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isParallelType

Checks if a `Cause` is a `Parallel` type.

**See**

- `parallel` Combine two `Cause`s in parallel

**Signature**

```ts
declare const isParallelType: <E>(self: Cause<E>) => self is Parallel<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L723)

Since v2.0.0
Cause-isRuntimeException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isRuntimeException

Checks if a given unknown value is a `RuntimeException`.

**Signature**

```ts
declare const isRuntimeException: (u: unknown) => u is RuntimeException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1404)

Since v2.0.0
Cause-isSequentialType.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isSequentialType

Checks if a `Cause` is a `Sequential` type.

**See**

- `sequential` Combine two `Cause`s sequentially

**Signature**

```ts
declare const isSequentialType: <E>(self: Cause<E>) => self is Sequential<E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L713)

Since v2.0.0
Cause-isTimeoutException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isTimeoutException

Checks if a given unknown value is a `TimeoutException`.

**Signature**

```ts
declare const isTimeoutException: (u: unknown) => u is TimeoutException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1426)

Since v3.15.0
Cause-isUnknownException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.isUnknownException

Checks if a given unknown value is an `UnknownException`.

**Signature**

```ts
declare const isUnknownException: (u: unknown) => u is UnknownException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1468)

Since v2.0.0
Cause-keepDefects.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.keepDefects

Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a
`Cause`.

**Details**

This function strips a cause of recoverable errors and interruptions, leaving
only unexpected failures. If no defects remain, it returns `None`. It's
valuable for focusing only on unanticipated problems when both known errors
and defects could occur.

**Signature**

```ts
declare const keepDefects: <E>(self: Cause<E>) => Option.Option<Cause<never>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L934)

Since v2.0.0
Cause-linearize.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.linearize

Linearizes a `Cause` into a set of parallel causes, each containing a
sequential chain of failures.

**Details**

This function reorganizes the cause structure so that you can analyze each
parallel branch separately, even if they have multiple sequential errors.

**Signature**

```ts
declare const linearize: <E>(self: Cause<E>) => HashSet.HashSet<Cause<E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L949)

Since v2.0.0
Cause-map.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.map

Transforms the errors in a `Cause` using a user-provided function.

**Details**

This function applies `f` to each `Fail` error while leaving defects (`Die`)
and interruptions untouched. It's useful for changing or simplifying error
types in your effectful workflows.

**See**

- `as` Replace errors with a single constant

**Signature**

```ts
declare const map: { <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1018)

Since v2.0.0
Cause-match.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.match

Transforms a `Cause` into a single value using custom handlers for each
possible case.

**Details**

This function processes a `Cause` by applying a set of custom handlers to
each possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,
`Sequential`, and `Parallel`. The result of this function is a single value
of type `Z`. This function allows you to define exactly how to handle each
part of a `Cause`, whether it's a failure, defect, interruption, or a
combination of these.

The options parameter provides handlers for:
- `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors
  occurred.
- `onFail`: Processes a failure with an error of type `E`.
- `onDie`: Processes a defect (unexpected error).
- `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the
  interruption.
- `onSequential`: Combines two sequential causes into a single value of type
  `Z`.
- `onParallel`: Combines two parallel causes into a single value of type `Z`.

**Signature**

```ts
declare const match: { <Z, E>(options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1232)

Since v2.0.0
Cause-originalError.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.originalError

Retrieves the original, unproxied error instance from an error object.

**Details**

This function returns the underlying error object without any
library-specific wrapping or proxying that might occur during error handling.
This can be essential if you need direct access to the error's native
properties, such as stack traces or custom data fields, for detailed
debugging or integration with external systems.

**Signature**

```ts
declare const originalError: <E>(obj: E) => E
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1555)

Since v2.0.0
Cause-parallel.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.parallel

Combines two `Cause`s in parallel.

**Details**

This function merges two errors that occurred simultaneously. Instead of
discarding one error, both are retained, allowing for richer error reporting
and debugging.

**See**

- `isParallelType` Check if a `Cause` is a `Parallel`

**Signature**

```ts
declare const parallel: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L639)

Since v2.0.0
Cause-pretty.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.pretty

Converts a `Cause` into a human-readable string.

**Details**

This function pretty-prints the entire `Cause`, including any failures,
defects, and interruptions. It can be especially helpful for logging,
debugging, or displaying structured errors to users.

You can optionally pass `options` to configure how the error cause is
rendered. By default, it includes essential details of all errors in the
`Cause`.

**See**

- `prettyErrors` Get a list of `PrettyError` objects instead of a single string.

**Signature**

```ts
declare const pretty: <E>(cause: Cause<E>, options?: { readonly renderErrorCause?: boolean | undefined; }) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1513)

Since v2.0.0
Cause-PrettyError.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.PrettyError

A shape for prettified errors, optionally including a source span.

**Signature**

```ts
export interface PrettyError extends Error {
  readonly span: Span | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1523)

Since v3.2.0
Cause-RuntimeException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.RuntimeException

An error representing a runtime error.

**Details**

This interface is used for errors that occur at runtime but are still
considered recoverable or typed.

**Signature**

```ts
export interface RuntimeException extends YieldableError {
  readonly _tag: "RuntimeException"
  readonly [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L339)

Since v2.0.0
Cause-RuntimeExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.RuntimeExceptionTypeId

A unique symbol identifying the `RuntimeException` type.

**Details**

This provides a symbol that identifies a `RuntimeException`. This is
typically used internally by the library to recognize checked exceptions that
occur during runtime.

**See**

- `RuntimeException` Create or work with a `RuntimeException`

**Signature**

```ts
declare const RuntimeExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L78)

Since v2.0.0
Cause-Sequential.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.Sequential

Represents sequential composition of two `Cause`s.

**Details**

This interface models the scenario where one error follows another in
sequence, such as when a main effect fails and then a finalizer also fails.
It ensures both errors are retained in the final `Cause`.

**See**

- `sequential` Combine two `Cause`s sequentially
- `isSequentialType` Check if a `Cause` is a `Sequential`

**Signature**

```ts
export interface Sequential<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Sequential"
  readonly left: Cause<E>
  readonly right: Cause<E>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L556)

Since v2.0.0
Cause-TimeoutException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.TimeoutException

An error representing a computation that timed out.

**Signature**

```ts
export interface TimeoutException extends YieldableError {
  readonly _tag: "TimeoutException"
  readonly [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L423)

Since v2.0.0
Cause-TimeoutExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.TimeoutExceptionTypeId

A unique symbol identifying the `TimeoutException` type.

**Details**

This provides a symbol that identifies a `TimeoutException`. It helps the
framework recognize errors related to operations that fail to complete within
a given timeframe.

**See**

- `TimeoutException` Create or work with a `TimeoutException`

**Signature**

```ts
declare const TimeoutExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L210)

Since v2.0.0
Cause-UnknownException.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.UnknownException

A checked exception for handling unknown or unexpected errors.

**Details**

This interface captures errors that don't fall under known categories. It is
especially helpful for wrapping low-level or third-party library errors that
might provide little or no context, such as from a rejected promise.

**Signature**

```ts
export interface UnknownException extends YieldableError {
  readonly _tag: "UnknownException"
  readonly [UnknownExceptionTypeId]: UnknownExceptionTypeId
  readonly error: unknown
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L440)

Since v2.0.0
Cause-UnknownExceptionTypeId.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.UnknownExceptionTypeId

A unique symbol identifying the `UnknownException` type.

**Details**

This provides a symbol that identifies an `UnknownException`. It is typically
used for generic or unexpected errors that do not fit other specific
exception categories.

**See**

- `UnknownException` Create or work with an `UnknownException`

**Signature**

```ts
declare const UnknownExceptionTypeId: unique symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L232)

Since v2.0.0
Cause-YieldableError.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.YieldableError

Represents an error object that can be yielded in `Effect.gen`.

**Signature**

```ts
export interface YieldableError extends Pipeable, Inspectable, Error {
  readonly [Effect.EffectTypeId]: Effect.Effect.VarianceStruct<never, this, never>
  readonly [Stream.StreamTypeId]: Stream.Stream.VarianceStruct<never, this, never>
  readonly [Sink.SinkTypeId]: Sink.Sink.VarianceStruct<never, unknown, never, this, never>
  readonly [Channel.ChannelTypeId]: Channel.Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>
  [Symbol.iterator](): Effect.EffectGenerator<Effect.Effect<never, this, never>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L311)

Since v2.0.0
Cause-prettyErrors.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.prettyErrors

Returns a list of prettified errors (`PrettyError`) from a `Cause`.

**Details**

This function inspects the entire `Cause` and produces an array of
`PrettyError` objects. Each object may include additional metadata, such as a
`Span`, to provide deeper insights into where and how the error occurred.

**Signature**

```ts
declare const prettyErrors: <E>(cause: Cause<E>) => Array<PrettyError>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1539)

Since v3.2.0
Cause-reduce.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.reduce

Combines all parts of a `Cause` into a single value by starting with an
initial value.

**Details**

This function processes a `Cause` by starting with an initial value (`zero`)
and applying a custom function (`pf`) to combine all elements of the `Cause`
into a single result of type `Z`. The custom function determines how each
part of the `Cause` contributes to the final result. The function can return
an `Option` to either continue combining values or skip specific parts of the
`Cause`.

This function is useful for tasks such as:
- Aggregating error messages from a `Cause` into a single string.
- Summarizing the structure of a `Cause` into a simplified result.
- Filtering or processing only specific parts of a `Cause`.

The reduction proceeds in a top-down manner, visiting all nodes in the
`Cause` structure. This gives you complete control over how each part of the
`Cause` contributes to the final result.

**Signature**

```ts
declare const reduce: { <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1281)

Since v2.0.0
Cause-reduceWithContext.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.reduceWithContext

Combines all parts of a `Cause` into a single value using a custom reducer
and a context.

**Details**

This function allows you to reduce a `Cause` into a single value of type `Z`
using a custom `CauseReducer`. A `CauseReducer` provides methods to handle
specific parts of the `Cause`, such as failures, defects, or interruptions.
Additionally, this function provides access to a `context` value, which can
be used to carry information or maintain state during the reduction process.

This is particularly useful when the reduction process needs additional
context or configuration, such as:
- Aggregating error details with dynamic formatting.
- Collecting logs or statistics about the `Cause`.
- Performing stateful transformations based on the `context`.

**See**

- `reduce` To reduce a `Cause` without additional context.

**Signature**

```ts
declare const reduceWithContext: { <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z; <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1309)

Since v2.0.0
Cause-sequential.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.sequential

Combines two `Cause`s sequentially.

**Details**

This function merges two errors that occurred in sequence, such as a main
error followed by a finalization error. It preserves both errors for complete
failure information.

**See**

- `isSequentialType` Check if a `Cause` is a `Sequential`

**Signature**

```ts
declare const sequential: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L655)

Since v2.0.0
Cause-size.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.size

Calculates the size of a `Cause`.

**Details**

This function returns the total number of `Cause` nodes in the semiring
structure, reflecting how many individual error elements are recorded.

**Signature**

```ts
declare const size: <E>(self: Cause<E>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L736)

Since v2.0.0
Cause-squash.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.squash

Extracts the most "important" defect from a `Cause`.

**Details**

This function reduces a `Cause` to a single, prioritized defect. It evaluates
the `Cause` in the following order of priority:

1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it returns
   the raw error value.
2. If there is no failure, it looks for the first defect (e.g., from
   `Effect.die`).
3. If neither of the above is present, and the `Cause` stems from an
   interruption, it creates and returns an `InterruptedException`.

This function ensures you can always extract a meaningful representation of
the primary issue from a potentially complex `Cause` structure.

**When to Use**

Use this function when you need to extract the most relevant error or defect
from a `Cause`, especially in scenarios where multiple errors or defects may
be present. It's particularly useful for simplifying error reporting or
logging.

**See**

- `squashWith` Allows transforming failures into defects when squashing.

**Signature**

```ts
declare const squash: <E>(self: Cause<E>) => unknown
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1119)

Since v2.0.0
Cause-squashWith.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.squashWith

Extracts the most "important" defect from a `Cause`, transforming failures
into defects using a provided function.

**Details**

This function reduces a `Cause` to a single, prioritized defect, while
allowing you to transform recoverable failures into defects through a custom
function. It processes the `Cause` in the following order:

1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies
   the provided function `f` to the error to transform it into a defect.
2. If there is no failure, it looks for the first defect (e.g., from
   `Effect.die`) and returns it.
3. If neither is present and the `Cause` stems from an interruption, it
   returns an `InterruptedException`.

This function is particularly useful when you need custom handling or
transformation of errors while processing a `Cause`.

**See**

- `squash` Extracts the most "important" defect without transforming failures.

**Signature**

```ts
declare const squashWith: { <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown; <E>(self: Cause<E>, f: (error: E) => unknown): unknown; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1146)

Since v2.0.0
Cause-stripFailures.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.stripFailures

Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects
(`Die`).

**Details**

This function is similar to `keepDefects` but returns a `Cause<never>`
directly, which can still store `Die` or finalizer-related defects. It's
helpful for analyzing only the irrecoverable portion of the error.

**Signature**

```ts
declare const stripFailures: <E>(self: Cause<E>) => Cause<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L964)

Since v2.0.0
Cause-stripSomeDefects.md
Package: `effect`<br />
Module: `Cause`<br />

## Cause.stripSomeDefects

Removes matching defects from a `Cause` using a partial function, returning
the remainder.

**Details**

This function applies a user-defined extraction function to each defect
(`Die`). If the function matches the defect, that defect is removed. If all
defects match, the result is `None`. Otherwise, you get a `Cause` with the
unmatched defects.

**Signature**

```ts
declare const stripSomeDefects: { (pf: (defect: unknown) => Option.Option<unknown>): <E>(self: Cause<E>) => Option.Option<Cause<E>>; <E>(self: Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause<E>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L980)

Since v2.0.0
Chainable-tap.md
Package: `@effect/typeclass`<br />
Module: `Chainable`<br />

## Chainable.tap

Returns an effect that effectfully "peeks" at the success of this effect.

**Signature**

```ts
declare const tap: <F extends TypeLambda>(F: Chainable<F>) => { <A, R2, O2, E2, _>(f: (a: A) => Kind<F, R2, O2, E2, _>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>; <R1, O1, E1, A, R2, O2, E2, _>(self: Kind<F, R1, O1, E1, A>, f: (a: A) => Kind<F, R2, O2, E2, _>): Kind<F, R1 & R2, O1 | O2, E1 | E2, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Chainable.ts#L42)

Since v0.24.0
Chainable-zipLeft.md
Package: `@effect/typeclass`<br />
Module: `Chainable`<br />

## Chainable.zipLeft

Sequences the specified effect after this effect, but ignores the value
produced by the effect.

**Signature**

```ts
declare const zipLeft: <F extends TypeLambda>(F: Chainable<F>) => { <R2, O2, E2, _>(that: Kind<F, R2, O2, E2, _>): <R1, O1, E1, A>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>; <R1, O1, E1, A, R2, O2, E2, _>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, _>): Kind<F, R1 & R2, O1 | O2, E1 | E2, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Chainable.ts#L23)

Since v0.24.0
Channel-Channel.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.Channel

A `Channel` is a nexus of I/O operations, which supports both reading and
writing. A channel may read values of type `InElem` and write values of type
`OutElem`. When the channel finishes, it yields a value of type `OutDone`. A
channel may fail with a value of type `OutErr`.

Channels are the foundation of Streams: both streams and sinks are built on
channels. Most users shouldn't have to use channels directly, as streams and
sinks are much more convenient and cover all common use cases. However, when
adding new stream and sink operators, or doing something highly specialized,
it may be useful to use channels directly.

Channels compose in a variety of ways:

 - **Piping**: One channel can be piped to another channel, assuming the
   input type of the second is the same as the output type of the first.
 - **Sequencing**: The terminal value of one channel can be used to create
   another channel, and both the first channel and the function that makes
   the second channel can be composed into a channel.
 - **Concatenating**: The output of one channel can be used to create other
   channels, which are all concatenated together. The first channel and the
   function that makes the other channels can be composed into a channel.

**Signature**

```ts
export interface Channel<
  out OutElem,
  in InElem = unknown,
  out OutErr = never,
  in InErr = unknown,
  out OutDone = void,
  in InDone = unknown,
  out Env = never
> extends
  Channel.Variance<
    OutElem,
    InElem,
    OutErr,
    InErr,
    OutDone,
    InDone,
    Env
  >,
  Pipeable
{
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: ChannelUnify<this>
  [Unify.ignoreSymbol]?: ChannelUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L75)

Since v2.0.0
Channel-ChannelException.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.ChannelException

Represents a generic checked exception which occurs when a `Channel` is
executed.

**Signature**

```ts
export interface ChannelException<out E> {
  readonly _tag: "ChannelException"
  readonly [ChannelExceptionTypeId]: ChannelExceptionTypeId
  readonly error: E
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L183)

Since v2.0.0
Channel-as.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.as

Returns a new channel that is the same as this one, except the terminal
value of the channel is the specified constant value.

This method produces the same result as mapping this channel to the
specified constant value.

**Signature**

```ts
declare const as: { <OutDone2>(value: OutDone2): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, value: OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L237)

Since v2.0.0
Channel-buffer.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.buffer

Creates a channel backed by a buffer. When the buffer is empty, the channel
will simply passthrough its input as output. However, when the buffer is
non-empty, the value inside the buffer will be passed along as output.

**Signature**

```ts
declare const buffer: <InElem, InErr, InDone>(options: { readonly empty: InElem; readonly isEmpty: Predicate<InElem>; readonly ref: Ref.Ref<InElem>; }) => Channel<InElem, InElem, InErr, InErr, InDone, InDone, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L265)

Since v2.0.0
Channel-catchAll.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.catchAll

Returns a new channel that is the same as this one, except if this channel
errors for any typed error, then the returned channel will switch over to
using the fallback channel returned by the specified error handler.

**Signature**

```ts
declare const catchAll: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L285)

Since v2.0.0
Channel-catchAllCause.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.catchAllCause

Returns a new channel that is the same as this one, except if this channel
errors for any typed error, then the returned channel will switch over to
using the fallback channel returned by the specified error handler.

**Signature**

```ts
declare const catchAllCause: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L321)

Since v2.0.0
Channel-collect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.collect

Returns a new channel, which is the same as this one, except its outputs
are filtered and transformed by the specified partial function.

**Signature**

```ts
declare const collect: { <OutElem, OutElem2>(pf: (o: OutElem) => Option.Option<OutElem2>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, never, unknown, void, unknown, never>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, pf: (o: OutElem) => Option.Option<OutElem2>): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L517)

Since v2.0.0
Channel-concatAll.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.concatAll

Concat sequentially a channel of channels.

**Signature**

```ts
declare const concatAll: <OutElem, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>, InElem, OutErr, InErr, any, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L355)

Since v2.0.0
Channel-concatAllWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.concatAllWith

Concat sequentially a channel of channels.

**Signature**

```ts
declare const concatAllWith: <OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, InElem, OutErr, InErr, OutDone2, InDone, Env, OutDone3>(channels: Channel<Channel<OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutDone, o1: OutDone) => OutDone, g: (o: OutDone, o2: OutDone2) => OutDone3) => Channel<OutElem, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L365)

Since v2.0.0
Channel-concatMap.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.concatMap

Returns a new channel whose outputs are fed to the specified factory
function, which creates new channels in response. These new channels are
sequentially concatenated together, and all their outputs appear as outputs
of the newly returned channel.

**Signature**

```ts
declare const concatMap: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): <Env, InErr, InElem, InDone, OutErr, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, unknown, InDone & InDone2, Env2 | Env>; <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, unknown, InDone & InDone2, Env | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L404)

Since v2.0.0
Channel-concatMapWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.concatMapWith

Returns a new channel whose outputs are fed to the specified factory
function, which creates new channels in response. These new channels are
sequentially concatenated together, and all their outputs appear as outputs
of the newly returned channel. The provided merging function is used to
merge the terminal values of all channels into the single terminal value of
the returned channel.

**Signature**

```ts
declare const concatMapWith: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L427)

Since v2.0.0
Channel-concatMapWithCustom.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.concatMapWithCustom

Returns a new channel whose outputs are fed to the specified factory
function, which creates new channels in response. These new channels are
sequentially concatenated together, and all their outputs appear as outputs
of the newly returned channel. The provided merging function is used to
merge the terminal values of all channels into the single terminal value of
the returned channel.

**Signature**

```ts
declare const concatMapWithCustom: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L470)

Since v2.0.0
Channel-concatOut.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.concatOut

Returns a new channel, which is the concatenation of all the channels that
are written out by this channel. This method may only be called on channels
that output other channels.

**Signature**

```ts
declare const concatOut: <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(self: Channel<Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L537)

Since v2.0.0
Channel-context.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.context

Accesses the whole context of the channel.

**Signature**

```ts
declare const context: <Env>() => Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L766)

Since v2.0.0
Channel-contextWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.contextWith

Accesses the context of the channel with the specified function.

**Signature**

```ts
declare const contextWith: <Env, OutDone>(f: (env: Context.Context<Env>) => OutDone) => Channel<never, unknown, never, unknown, OutDone, unknown, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L775)

Since v2.0.0
Channel-contextWithChannel.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.contextWithChannel

Accesses the context of the channel in the context of a channel.

**Signature**

```ts
declare const contextWithChannel: <Env, OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>(f: (env: Context.Context<Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L785)

Since v2.0.0
Channel-contextWithEffect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.contextWithEffect

Accesses the context of the channel in the context of an effect.

**Signature**

```ts
declare const contextWithEffect: <Env, OutDone, OutErr, Env1>(f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>) => Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L795)

Since v2.0.0
Channel-doneCollect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.doneCollect

Returns a new channel, which is the same as this one, except that all the
outputs are collected and bundled into a tuple together with the terminal
value of this channel.

As the channel returned from this channel collects all of this channel's
output into an in- memory chunk, it is not safe to call this method on
channels that output a large or unbounded number of values.

**Signature**

```ts
declare const doneCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L675)

Since v2.0.0
Channel-drain.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.drain

Returns a new channel which reads all the elements from upstream's output
channel and ignores them, then terminates with the upstream result value.

**Signature**

```ts
declare const drain: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L686)

Since v2.0.0
Channel-embedInput.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.embedInput

Returns a new channel which connects the given `AsyncInputProducer` as
this channel's input.

**Signature**

```ts
declare const embedInput: { <InErr, InElem, InDone>(input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): <OutElem, OutErr, OutDone, Env>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, OutErr, OutDone, Env, InErr, InElem, InDone>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>, input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L697)

Since v2.0.0
Channel-emitCollect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.emitCollect

Returns a new channel that collects the output and terminal value of this
channel, which it then writes as output of the returned channel.

**Signature**

```ts
declare const emitCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L716)

Since v2.0.0
Channel-ensuring.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.ensuring

Returns a new channel with an attached finalizer. The finalizer is
guaranteed to be executed so long as the channel begins execution (and
regardless of whether or not it completes).

**Signature**

```ts
declare const ensuring: { <Z, Env1>(finalizer: Effect.Effect<Z, never, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: Effect.Effect<Z, never, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L728)

Since v2.0.0
Channel-ensuringWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.ensuringWith

Returns a new channel with an attached finalizer. The finalizer is
guaranteed to be executed so long as the channel begins execution (and
regardless of whether or not it completes).

**Signature**

```ts
declare const ensuringWith: { <OutDone, OutErr, Env2>(finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): <OutElem, InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L748)

Since v2.0.0
Channel-fail.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fail

Constructs a channel that fails immediately with the specified error.

**Signature**

```ts
declare const fail: <E>(error: E) => Channel<never, unknown, E, unknown, never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L805)

Since v2.0.0
Channel-failCause.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.failCause

Constructs a channel that fails immediately with the specified `Cause`.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Channel<never, unknown, E, unknown, never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L822)

Since v2.0.0
Channel-failCauseSync.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.failCauseSync

Constructs a channel that succeeds immediately with the specified lazily
evaluated `Cause`.

**Signature**

```ts
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Channel<never, unknown, E, unknown, never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L832)

Since v2.0.0
Channel-failSync.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.failSync

Constructs a channel that succeeds immediately with the specified lazily
evaluated value.

**Signature**

```ts
declare const failSync: <E>(evaluate: LazyArg<E>) => Channel<never, unknown, E, unknown, never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L814)

Since v2.0.0
Channel-flatMap.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.flatMap

Returns a new channel, which sequentially combines this channel, together
with the provided factory function, which creates a second channel based on
the terminal value of this channel. The result is a channel that will first
perform the functions of this channel, before performing the functions of
the created channel (including yielding its terminal value).

**Signature**

```ts
declare const flatMap: { <OutDone, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L846)

Since v2.0.0
Channel-flatten.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.flatten

Returns a new channel, which flattens the terminal value of this channel.
This function may only be called if the terminal value of this channel is
another channel of compatible types.

**Signature**

```ts
declare const flatten: <OutElem, InElem, OutErr, InErr, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>, InDone, Env>) => Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L882)

Since v2.0.0
Channel-foldCauseChannel.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.foldCauseChannel

Folds over the result of this channel including any cause of termination.

**Signature**

```ts
declare const foldCauseChannel: { <OutErr, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1001)

Since v2.0.0
Channel-foldChannel.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.foldChannel

Folds over the result of this channel.

**Signature**

```ts
declare const foldChannel: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L922)

Since v2.0.0
Channel-fromEffect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fromEffect

Use an effect to end a channel.

**Signature**

```ts
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<never, unknown, E, unknown, A, unknown, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1084)

Since v2.0.0
Channel-fromEither.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fromEither

Constructs a channel from an `Either`.

**Signature**

```ts
declare const fromEither: <R, L>(either: Either.Either<R, L>) => Channel<never, unknown, L, unknown, R, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1094)

Since v2.0.0
Channel-fromInput.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fromInput

Construct a `Channel` from an `AsyncInputConsumer`.

**Signature**

```ts
declare const fromInput: <Err, Elem, Done>(input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>) => Channel<Elem, unknown, Err, unknown, Done, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1103)

Since v2.0.0
Channel-fromOption.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fromOption

Construct a `Channel` from an `Option`.

**Signature**

```ts
declare const fromOption: <A>(option: Option.Option<A>) => Channel<never, unknown, Option.Option<never>, unknown, A, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1133)

Since v2.0.0
Channel-fromPubSub.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fromPubSub

Construct a `Channel` from a `PubSub`.

**Signature**

```ts
declare const fromPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1113)

Since v2.0.0
Channel-fromPubSubScoped.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fromPubSubScoped

Construct a `Channel` from a `PubSub` within a scoped effect.

**Signature**

```ts
declare const fromPubSubScoped: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Effect.Effect<Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1123)

Since v2.0.0
Channel-fromQueue.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.fromQueue

Construct a `Channel` from a `Queue`.

**Signature**

```ts
declare const fromQueue: <Done, Err, Elem>(queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1143)

Since v2.0.0
Channel-interruptWhen.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.interruptWhen

Returns a new channel, which is the same as this one, except it will be
interrupted when the specified effect completes. If the effect completes
successfully before the underlying channel is done, then the returned
channel will yield the success value of the effect as its terminal value.
On the other hand, if the underlying channel finishes first, then the
returned channel will yield the success value of the underlying channel as
its terminal value.

**Signature**

```ts
declare const interruptWhen: { <OutDone1, OutErr1, Env1>(effect: Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, effect: Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1165)

Since v2.0.0
Channel-interruptWhenDeferred.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.interruptWhenDeferred

Returns a new channel, which is the same as this one, except it will be
interrupted when the specified deferred is completed. If the deferred is
completed before the underlying channel is done, then the returned channel
will yield the value of the deferred. Otherwise, if the underlying channel
finishes first, then the returned channel will yield the value of the
underlying channel.

**Signature**

```ts
declare const interruptWhenDeferred: { <OutDone1, OutErr1>(deferred: Deferred.Deferred<OutDone1, OutErr1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, deferred: Deferred.Deferred<OutDone1, OutErr1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1188)

Since v2.0.0
Channel-isChannelException.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.isChannelException

Returns `true` if the specified value is an `ChannelException`, `false`
otherwise.

**Signature**

```ts
declare const isChannelException: (u: unknown) => u is ChannelException<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2355)

Since v2.0.0
Channel-map.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.map

Returns a new channel, which is the same as this one, except the terminal
value of the returned channel is created by applying the specified function
to the terminal value of this channel.

**Signature**

```ts
declare const map: { <OutDone, OutDone2>(f: (out: OutDone) => OutDone2): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (out: OutDone) => OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1208)

Since v2.0.0
Channel-mapEffect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapEffect

Returns a new channel, which is the same as this one, except the terminal
value of the returned channel is created by applying the specified
effectful function to the terminal value of this channel.

**Signature**

```ts
declare const mapEffect: { <OutDone, OutDone1, OutErr1, Env1>(f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1228)

Since v2.0.0
Channel-mapError.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapError

Returns a new channel, which is the same as this one, except the failure
value of the returned channel is created by applying the specified function
to the failure value of this channel.

**Signature**

```ts
declare const mapError: { <OutErr, OutErr2>(f: (err: OutErr) => OutErr2): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (err: OutErr) => OutErr2): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1248)

Since v2.0.0
Channel-mapErrorCause.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapErrorCause

A more powerful version of `mapError` which also surfaces the `Cause`
of the channel failure.

**Signature**

```ts
declare const mapErrorCause: { <OutErr, OutErr2>(f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1267)

Since v2.0.0
Channel-mapInput.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapInput

Returns a new channel which is the same as this one but applies the given
function to the input channel's done value.

**Signature**

```ts
declare const mapInput: { <InDone0, InDone>(f: (a: InDone0) => InDone): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InDone0) => InDone): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L556)

Since v2.0.0
Channel-mapInputContext.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapInputContext

Transforms the context being provided to the channel with the specified
function.

**Signature**

```ts
declare const mapInputContext: { <Env0, Env>(f: (env: Context.Context<Env0>) => Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (env: Context.Context<Env0>) => Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1777)

Since v2.0.0
Channel-mapInputEffect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapInputEffect

Returns a new channel which is the same as this one but applies the given
effectual function to the input channel's done value.

**Signature**

```ts
declare const mapInputEffect: { <InDone0, InDone, InErr, Env1>(f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L575)

Since v2.0.0
Channel-mapInputError.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapInputError

Returns a new channel which is the same as this one but applies the given
function to the input channel's error value.

**Signature**

```ts
declare const mapInputError: { <InErr0, InErr>(f: (a: InErr0) => InErr): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InErr0) => InErr): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L594)

Since v2.0.0
Channel-mapInputErrorEffect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapInputErrorEffect

Returns a new channel which is the same as this one but applies the given
effectual function to the input channel's error value.

**Signature**

```ts
declare const mapInputErrorEffect: { <InErr0, InDone, InErr, Env1>(f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L613)

Since v2.0.0
Channel-mapInputIn.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapInputIn

Returns a new channel which is the same as this one but applies the given
function to the input channel's output elements.

**Signature**

```ts
declare const mapInputIn: { <InElem0, InElem>(f: (a: InElem0) => InElem): <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => InElem): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L632)

Since v2.0.0
Channel-mapInputInEffect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapInputInEffect

Returns a new channel which is the same as this one but applies the given
effectual function to the input channel's output elements.

**Signature**

```ts
declare const mapInputInEffect: { <InElem0, InElem, InErr, Env1>(f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): <OutElem, OutErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L651)

Since v2.0.0
Channel-mapOut.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapOut

Maps the output of this channel using the specified function.

**Signature**

```ts
declare const mapOut: { <OutElem, OutElem2>(f: (o: OutElem) => OutElem2): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => OutElem2): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1285)

Since v2.0.0
Channel-mapOutEffect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapOutEffect

Creates a channel that is like this channel but the given effectful function
gets applied to each emitted output element.

**Signature**

```ts
declare const mapOutEffect: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1304)

Since v2.0.0
Channel-mapOutEffectPar.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mapOutEffectPar

Creates a channel that is like this channel but the given ZIO function gets
applied to each emitted output element, taking `n` elements at once and
mapping them in parallel.

**Signature**

```ts
declare const mapOutEffectPar: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1324)

Since v2.0.0
Channel-mergeMap.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mergeMap

Returns a new channel which creates a new channel for each emitted element
and merges some of them together. Different merge strategies control what
happens if there are more than the given maximum number of channels gets
created. See `Channel.mergeAll`.

**Signature**

```ts
declare const mergeMap: { <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): Channel<OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, unknown, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1442)

Since v2.0.0
Channel-mergeOut.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mergeOut

Returns a new channel which merges a number of channels emitted by this
channel using the back pressuring merge strategy. See `Channel.mergeAll`.

**Signature**

```ts
declare const mergeOut: { (n: number): <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, n: number): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1471)

Since v2.0.0
Channel-mergeOutWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mergeOutWith

Returns a new channel which merges a number of channels emitted by this
channel using the back pressuring merge strategy and uses a given function
to merge each completed subchannel's result value. See
`Channel.mergeAll`.

**Signature**

```ts
declare const mergeOutWith: { <OutDone1>(n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>, n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1508)

Since v2.0.0
Channel-mergeWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.mergeWith

Returns a new channel, which is the merge of this channel and the specified
channel, where the behavior of the returned channel on left or right early
termination is decided by the specified `leftDone` and `rightDone` merge
decisions.

**Signature**

```ts
declare const mergeWith: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutErr2, OutDone2, OutErr3, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1547)

Since v2.0.0
Channel-never.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.never

Returns a channel that never completes

**Signature**

```ts
declare const never: Channel<never, unknown, never, unknown, never, unknown, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1616)

Since v2.0.0
Channel-orDie.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.orDie

Translates channel failure into death of the fiber, making all failures
unchecked and not a part of the type of the channel.

**Signature**

```ts
declare const orDie: { <E>(error: LazyArg<E>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, error: LazyArg<E>): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1625)

Since v2.0.0
Channel-orDieWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.orDieWith

Keeps none of the errors, and terminates the fiber with them, using the
specified function to convert the `OutErr` into a defect.

**Signature**

```ts
declare const orDieWith: { <OutErr>(f: (e: OutErr) => unknown): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (e: OutErr) => unknown): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1644)

Since v2.0.0
Channel-orElse.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.orElse

Returns a new channel that will perform the operations of this one, until
failure, and then it will switch over to the operations of the specified
fallback channel.

**Signature**

```ts
declare const orElse: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1664)

Since v2.0.0
Channel-pipeTo.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.pipeTo

Returns a new channel that pipes the output of this channel into the
specified channel. The returned channel has the input type of this channel,
and the output type of the specified channel, terminating with the value of
the specified channel.

**Signature**

```ts
declare const pipeTo: { <OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): <InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1701)

Since v2.0.0
Channel-pipeToOrFail.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.pipeToOrFail

Returns a new channel that pipes the output of this channel into the
specified channel and preserves this channel's failures without providing
them to the other channel for observation.

**Signature**

```ts
declare const pipeToOrFail: { <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): <InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1721)

Since v2.0.0
Channel-provideContext.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.provideContext

Provides the channel with its required context, which eliminates its
dependency on `Env`.

**Signature**

```ts
declare const provideContext: { <Env>(env: Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, env: Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1740)

Since v2.0.0
Channel-provideLayer.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.provideLayer

Provides a layer to the channel, which translates it to another level.

**Signature**

```ts
declare const provideLayer: { <Env, OutErr2, Env0>(layer: Layer.Layer<Env, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, layer: Layer.Layer<Env, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1758)

Since v2.0.0
Channel-provideService.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.provideService

Provides the effect with the single service it requires. If the effect
requires more than one service use `provideContext` instead.

**Signature**

```ts
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1815)

Since v2.0.0
Channel-provideSomeLayer.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.provideSomeLayer

Splits the context into two parts, providing one part using the
specified layer and leaving the remainder `Env0`.

**Signature**

```ts
declare const provideSomeLayer: { <R2, OutErr2, Env0>(layer: Layer.Layer<R2, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>, layer: Layer.Layer<R2, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1796)

Since v2.0.0
Channel-repeated.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.repeated

Creates a channel which repeatedly runs this channel.

**Signature**

```ts
declare const repeated: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1919)

Since v2.0.0
Channel-run.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.run

Runs a channel until the end is received.

**Signature**

```ts
declare const run: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1929)

Since v2.0.0
Channel-runCollect.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.runCollect

Run the channel until it finishes with a done value or fails with an error
and collects its emitted output elements.

The channel must not read any input.

**Signature**

```ts
declare const runCollect: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1942)

Since v2.0.0
Channel-runDrain.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.runDrain

Runs a channel until the end is received.

**Signature**

```ts
declare const runDrain: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1952)

Since v2.0.0
Channel-runScoped.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.runScoped

Run the channel until it finishes with a done value or fails with an error.
The channel must not read any input or write any output.

Closing the channel, which includes execution of all the finalizers
attached to the channel will be added to the current scope as a finalizer.

**Signature**

```ts
declare const runScoped: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env | Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1966)

Since v3.11.0
Channel-scoped.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.scoped

Use a scoped effect to emit an output element.

**Signature**

```ts
declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1976)

Since v2.0.0
Channel-scopedWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.scopedWith

Use a function that receives a scope and returns an effect to emit an output
element. The output element will be the result of the returned effect, if
successful.

**Signature**

```ts
declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1988)

Since v3.11.0
Channel-splitLines.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.splitLines

Splits strings on newlines. Handles both Windows newlines (`\r\n`) and UNIX
newlines (`\n`).

**Signature**

```ts
declare const splitLines: <Err, Done>() => Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1999)

Since v2.0.0
Channel-succeed.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.succeed

Constructs a channel that succeeds immediately with the specified value.

**Signature**

```ts
declare const succeed: <A>(value: A) => Channel<never, unknown, never, unknown, A, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2015)

Since v2.0.0
Channel-suspend.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.suspend

Lazily constructs a channel from the given side effect.

**Signature**

```ts
declare const suspend: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(evaluate: LazyArg<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2023)

Since v2.0.0
Channel-sync.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.sync

Constructs a channel that succeeds immediately with the specified lazy value.

**Signature**

```ts
declare const sync: <OutDone>(evaluate: LazyArg<OutDone>) => Channel<never, unknown, never, unknown, OutDone, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2033)

Since v2.0.0
Channel-toPubSub.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.toPubSub

Converts a `Channel` to a `PubSub`.

**Signature**

```ts
declare const toPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2043)

Since v2.0.0
Channel-toPull.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.toPull

Returns a scoped `Effect` that can be used to repeatedly pull elements from
the constructed `Channel`. The pull effect fails with the channel's failure
in case the channel fails, or returns either the channel's done value or an
emitted element.

**Signature**

```ts
declare const toPull: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Scope.Scope | Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2056)

Since v2.0.0
Channel-toPullIn.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.toPullIn

Returns an `Effect` that can be used to repeatedly pull elements from the
constructed `Channel` within the provided `Scope`. The pull effect fails
with the channel's failure in case the channel fails, or returns either the
channel's done value or an emitted element.

**Signature**

```ts
declare const toPullIn: { (scope: Scope.Scope): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, scope: Scope.Scope): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2070)

Since v3.11.0
Channel-toQueue.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.toQueue

Converts a `Channel` to a `Queue`.

**Signature**

```ts
declare const toQueue: <Done, Err, Elem>(queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2088)

Since v2.0.0
Channel-toSink.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.toSink

Converts this channel to a `Sink`.

**Signature**

```ts
declare const toSink: <OutElem, InElem, OutErr, InErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>) => Sink.Sink<OutDone, InElem, OutElem, OutErr, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2097)

Since v2.0.0
Channel-toStream.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.toStream

Converts this channel to a `Stream`.

**Signature**

```ts
declare const toStream: <OutElem, OutErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, unknown, OutErr, unknown, OutDone, unknown, Env>) => Stream.Stream<OutElem, OutErr, Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2107)

Since v2.0.0
Channel-unwrap.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.unwrap

Constructs a `Channel` from an effect that will result in a `Channel` if
successful.

**Signature**

```ts
declare const unwrap: <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(channel: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2127)

Since v2.0.0
Channel-unwrapScoped.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.unwrapScoped

Constructs a `Channel` from a scoped effect that will result in a
`Channel` if successful.

**Signature**

```ts
declare const unwrapScoped: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(self: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2138)

Since v2.0.0
Channel-unwrapScopedWith.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.unwrapScopedWith

Constructs a `Channel` from a function which receives a `Scope` and returns
an effect that will result in a `Channel` if successful.

**Signature**

```ts
declare const unwrapScopedWith: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2149)

Since v3.11.0
Channel-updateService.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.updateService

Updates a service in the context of this channel.

**Signature**

```ts
declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): <OutElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>, tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2159)

Since v2.0.0
Channel-withSpan.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.withSpan

Wraps the channel with a new span for tracing.

**Signature**

```ts
declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, name: string, options?: Tracer.SpanOptions | undefined): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2179)

Since v2.0.0
Channel-write.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.write

Writes a single value to the channel.

**Signature**

```ts
declare const write: <OutElem>(out: OutElem) => Channel<OutElem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2199)

Since v2.0.0
Channel-writeAll.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.writeAll

Writes a sequence of values to the channel.

**Signature**

```ts
declare const writeAll: <OutElems extends Array<any>>(...outs: OutElems) => Channel<OutElems[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2207)

Since v2.0.0
Channel-writeChunk.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.writeChunk

Writes a `Chunk` of values to the channel.

**Signature**

```ts
declare const writeChunk: <OutElem>(outs: Chunk.Chunk<OutElem>) => Channel<OutElem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2217)

Since v2.0.0
Channel-zip.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.zip

Returns a new channel that is the sequential composition of this channel
and the specified channel. The returned channel terminates with a tuple of
the terminal values of both channels.

**Signature**

```ts
declare const zip: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2229)

Since v2.0.0
Channel-zipLeft.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.zipLeft

Returns a new channel that is the sequential composition of this channel
and the specified channel. The returned channel terminates with the
terminal value of this channel.

**Signature**

```ts
declare const zipLeft: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2267)

Since v2.0.0
Channel-zipRight.md
Package: `effect`<br />
Module: `Channel`<br />

## Channel.zipRight

Returns a new channel that is the sequential composition of this channel
and the specified channel. The returned channel terminates with the
terminal value of that channel.

**Signature**

```ts
declare const zipRight: { <Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone1, InDone & InDone1, Env | Env1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2305)

Since v2.0.0
ChildExecutorDecision-Close.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.Close

Close the current substream with a given value and pass execution to the
next substream

**Signature**

```ts
export interface Close extends ChildExecutorDecision.Proto {
  readonly _tag: "Close"
  readonly value: unknown
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L54)

Since v2.0.0
ChildExecutorDecision-Continue.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.Continue

Continue executing the current substream

**Signature**

```ts
export interface Continue extends ChildExecutorDecision.Proto {
  readonly _tag: "Continue"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L43)

Since v2.0.0
ChildExecutorDecision-Yield.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.Yield

Pass execution to the next substream. This either pulls a new element
from upstream, or yields to an already created active substream.

**Signature**

```ts
export interface Yield extends ChildExecutorDecision.Proto {
  readonly _tag: "Yield"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L66)

Since v2.0.0
ChildExecutorDecision-isChildExecutorDecision.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.isChildExecutorDecision

Returns `true` if the specified value is a `ChildExecutorDecision`, `false`
otherwise.

**Signature**

```ts
declare const isChildExecutorDecision: (u: unknown) => u is ChildExecutorDecision
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L95)

Since v2.0.0
ChildExecutorDecision-isClose.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.isClose

Returns `true` if the specified `ChildExecutorDecision` is a `Close`, `false`
otherwise.

**Signature**

```ts
declare const isClose: (self: ChildExecutorDecision) => self is Close
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L113)

Since v2.0.0
ChildExecutorDecision-isContinue.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.isContinue

Returns `true` if the specified `ChildExecutorDecision` is a `Continue`,
`false` otherwise.

**Signature**

```ts
declare const isContinue: (self: ChildExecutorDecision) => self is Continue
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L104)

Since v2.0.0
ChildExecutorDecision-isYield.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.isYield

Returns `true` if the specified `ChildExecutorDecision` is a `Yield`, `false`
otherwise.

**Signature**

```ts
declare const isYield: (self: ChildExecutorDecision) => self is Yield
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L122)

Since v2.0.0
ChildExecutorDecision-match.md
Package: `effect`<br />
Module: `ChildExecutorDecision`<br />

## ChildExecutorDecision.match

Folds over a `ChildExecutorDecision` to produce a value of type `A`.

**Signature**

```ts
declare const match: { <A>(options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): (self: ChildExecutorDecision) => A; <A>(self: ChildExecutorDecision, options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L130)

Since v2.0.0
Chunk-append.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.append

Appends the specified element to the end of the `Chunk`.

**Signature**

```ts
declare const append: { <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>; <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L444)

Since v2.0.0
Chunk-appendAll.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.appendAll

Concatenates two chunks, combining their elements.
If either chunk is non-empty, the result is also a non-empty chunk.

**Example**

```ts
import { Chunk } from "effect"

const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray)

console.log(result)
// [ 1, 2, "a", "b" ]
```

**Signature**

```ts
declare const appendAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L624)

Since v2.0.0
Chunk-chunksOf.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.chunksOf

Groups elements in chunks of up to `n` elements.

**Signature**

```ts
declare const chunksOf: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L777)

Since v2.0.0
Chunk-compact.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.compact

Filter out optional values

**Signature**

```ts
declare const compact: <A>(self: Chunk<Option<A>>) => Chunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L719)

Since v2.0.0
Chunk-contains.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.contains

Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.

**Signature**

```ts
declare const contains: { <A>(a: A): (self: Chunk<A>) => boolean; <A>(self: Chunk<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1340)

Since v2.0.0
Chunk-containsWith.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.containsWith

Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.

**Signature**

```ts
declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Chunk<A>) => boolean; (self: Chunk<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1351)

Since v2.0.0
Chunk-dedupe.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.dedupe

Remove duplicates from an array, keeping the first occurrence of an element.

**Signature**

```ts
declare const dedupe: <A>(self: Chunk<A>) => Chunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1179)

Since v2.0.0
Chunk-dedupeAdjacent.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.dedupeAdjacent

Deduplicates adjacent elements that are identical.

**Signature**

```ts
declare const dedupeAdjacent: <A>(self: Chunk<A>) => Chunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1187)

Since v2.0.0
Chunk-difference.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.difference

Creates a `Chunk` of values not included in the other given `Chunk`.
The order and references of result values are determined by the first `Chunk`.

**Signature**

```ts
declare const difference: { <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1489)

Since v3.2.0
Chunk-differenceWith.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.differenceWith

Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Chunk`.

**Signature**

```ts
declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; (self: Chunk<A>, that: Chunk<A>): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1473)

Since v3.2.0
Chunk-drop.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.drop

Drops the first up to `n` elements from the chunk

**Signature**

```ts
declare const drop: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L511)

Since v2.0.0
Chunk-dropRight.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.dropRight

Drops the last `n` elements.

**Signature**

```ts
declare const dropRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L556)

Since v2.0.0
Chunk-dropWhile.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.dropWhile

Drops all elements so long as the predicate returns true.

**Signature**

```ts
declare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L566)

Since v2.0.0
Chunk-every.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.every

Check if a predicate holds true for every `Chunk` element.

**Signature**

```ts
declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>; <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1413)

Since v2.0.0
Chunk-filter.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.filter

Returns a filtered and mapped subset of the elements.

**Signature**

```ts
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L692)

Since v2.0.0
Chunk-filterMap.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.filterMap

Returns a filtered and mapped subset of the elements.

**Signature**

```ts
declare const filterMap: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L678)

Since v2.0.0
Chunk-filterMapWhile.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.filterMapWhile

Transforms all elements of the chunk for as long as the specified function returns some value

**Signature**

```ts
declare const filterMapWhile: { <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L708)

Since v2.0.0
Chunk-findFirst.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

**Signature**

```ts
declare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1365)

Since v2.0.0
Chunk-findFirstIndex.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.findFirstIndex

Return the first index for which a predicate holds.

**Signature**

```ts
declare const findFirstIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1378)

Since v2.0.0
Chunk-findLast.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.findLast

Find the last element for which a predicate holds.

**Signature**

```ts
declare const findLast: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1389)

Since v2.0.0
Chunk-findLastIndex.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.findLastIndex

Return the last index for which a predicate holds.

**Signature**

```ts
declare const findLastIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1402)

Since v2.0.0
Chunk-flatMap.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.flatMap

Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.

**Signature**

```ts
declare const flatMap: { <S extends Chunk<any>, T extends Chunk<any>>(f: (a: Chunk.Infer<S>, i: number) => T): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L727)

Since v2.0.0
Chunk-flatten.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.flatten

Flattens a chunk of chunks into a single chunk by concatenating all chunks.

**Signature**

```ts
declare const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L769)

Since v2.0.0
Chunk-forEach.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.forEach

Iterates over each element of a `Chunk` and applies a function to it.

**Details**

This function processes every element of the given `Chunk`, calling the
provided function `f` on each element. It does not return a new value;
instead, it is primarily used for side effects, such as logging or
accumulating data in an external variable.

**Signature**

```ts
declare const forEach: { <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void; <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L758)

Since v2.0.0
Chunk-fromIterable.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.fromIterable

Creates a new `Chunk` from an iterable collection of values.

**Signature**

```ts
declare const fromIterable: <A>(self: Iterable<A>) => Chunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L250)

Since v2.0.0
Chunk-get.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.get

This function provides a safe way to read a value at a particular index from a `Chunk`.

**Signature**

```ts
declare const get: { (index: number): <A>(self: Chunk<A>) => Option<A>; <A>(self: Chunk<A>, index: number): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L374)

Since v2.0.0
Chunk-getEquivalence.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.getEquivalence

Compares the two chunks of equal length using the specified function

**Signature**

```ts
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Chunk<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L118)

Since v2.0.0
Chunk-head.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.head

Returns the first element of this chunk if it exists.

**Signature**

```ts
declare const head: <A>(self: Chunk<A>) => Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L835)

Since v2.0.0
Chunk-headNonEmpty.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.headNonEmpty

Returns the first element of this non empty chunk.

**Signature**

```ts
declare const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L853)

Since v2.0.0
Chunk-intersection.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.intersection

Creates a Chunk of unique values that are included in all given Chunks.

The order and references of result values are determined by the Chunk.

**Signature**

```ts
declare const intersection: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L804)

Since v2.0.0
Chunk-isChunk.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.isChunk

Checks if `u` is a `Chunk<unknown>`

**Signature**

```ts
declare const isChunk: { <A>(u: Iterable<A>): u is Chunk<A>; (u: unknown): u is Chunk<unknown>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L214)

Since v2.0.0
Chunk-isEmpty.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.isEmpty

Determines if the chunk is empty.

**Signature**

```ts
declare const isEmpty: <A>(self: Chunk<A>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L819)

Since v2.0.0
Chunk-isNonEmpty.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.isNonEmpty

Determines if the chunk is not empty.

**Signature**

```ts
declare const isNonEmpty: <A>(self: Chunk<A>) => self is NonEmptyChunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L827)

Since v2.0.0
Chunk-join.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.join

Joins the elements together with "sep" in the middle.

**Signature**

```ts
declare const join: { (sep: string): (self: Chunk<string>) => string; (self: Chunk<string>, sep: string): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1444)

Since v2.0.0
Chunk-last.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.last

Returns the last element of this chunk if it exists.

**Signature**

```ts
declare const last: <A>(self: Chunk<A>) => Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L861)

Since v2.0.0
Chunk-lastNonEmpty.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.lastNonEmpty

Returns the last element of this non empty chunk.

**Signature**

```ts
declare const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L879)

Since v3.4.0
Chunk-make.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.make

Builds a `NonEmptyChunk` from an non-empty collection of elements.

**Signature**

```ts
declare const make: <As extends readonly [any, ...ReadonlyArray<any>]>(...as: As) => NonEmptyChunk<As[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L233)

Since v2.0.0
Chunk-makeBy.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.makeBy

Return a Chunk of length n with element i initialized with f(i).

**Note**. `n` is normalized to an integer >= 1.

**Signature**

```ts
declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>; <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1316)

Since v2.0.0
Chunk-map.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.map

Transforms the elements of a chunk using the specified mapping function.
If the input chunk is non-empty, the resulting chunk will also be non-empty.

**Example**

```ts
import { Chunk } from "effect"

const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)

console.log(result)
// { _id: 'Chunk', values: [ 2, 3 ] }
```

**Signature**

```ts
declare const map: { <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L937)

Since v2.0.0
Chunk-mapAccum.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.mapAccum

Statefully maps over the chunk, producing new elements of type `B`.

**Signature**

```ts
declare const mapAccum: { <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>]; <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L952)

Since v2.0.0
Chunk-modify.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.modify

Apply a function to the element at the specified index, creating a new `Chunk`,
or returning the input if the index is out of bounds.

**Signature**

```ts
declare const modify: { <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1281)

Since v2.0.0
Chunk-of.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.of

Builds a `NonEmptyChunk` from a single element.

**Signature**

```ts
declare const of: <A>(a: A) => NonEmptyChunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L242)

Since v2.0.0
Chunk-partition.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.partition

Separate elements based on a predicate that also exposes the index of the element.

**Signature**

```ts
declare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]; <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L966)

Since v2.0.0
Chunk-partitionMap.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.partitionMap

Partitions the elements of this chunk into two chunks using f.

**Signature**

```ts
declare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]; <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L993)

Since v2.0.0
Chunk-prepend.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.prepend

Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.

**Signature**

```ts
declare const prepend: { <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>; <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L455)

Since v2.0.0
Chunk-prependAll.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.prependAll

Prepends the specified prefix chunk to the beginning of the specified chunk.
If either chunk is non-empty, the result is also a non-empty chunk.

**Example**

```ts
import { Chunk } from "effect"

const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make("a", "b")), Chunk.toArray)

console.log(result)
// [ "a", "b", 1, 2 ]
```

**Signature**

```ts
declare const prependAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L597)

Since v2.0.0
Chunk-range.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.range

Create a non empty `Chunk` containing a range of integers, including both endpoints.

**Signature**

```ts
declare const range: (start: number, end: number) => NonEmptyChunk<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1327)

Since v2.0.0
Chunk-remove.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.remove

Delete the element at the specified index, creating a new `Chunk`.

**Signature**

```ts
declare const remove: { (i: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, i: number): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1236)

Since v2.0.0
Chunk-replace.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.replace

Change the element at the specified index, creating a new `Chunk`,
or returning the input if the index is out of bounds.

**Signature**

```ts
declare const replace: { <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>; <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1295)

Since v2.0.0
Chunk-reverse.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.reverse

Reverses the order of elements in a `Chunk`.
Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.

**Example**

```ts
import { Chunk } from "effect"

const chunk = Chunk.make(1, 2, 3)
const result = Chunk.reverse(chunk)

console.log(result)
// { _id: 'Chunk', values: [ 3, 2, 1 ] }
```

**Signature**

```ts
declare const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L366)

Since v2.0.0
Chunk-separate.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.separate

Partitions the elements of this chunk into two chunks.

**Signature**

```ts
declare const separate: <A, B>(self: Chunk<Either<B, A>>) => [Chunk<A>, Chunk<B>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1008)

Since v2.0.0
Chunk-size.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.size

Retireves the size of the chunk

**Signature**

```ts
declare const size: <A>(self: Chunk<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1020)

Since v2.0.0
Chunk-some.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.some

Check if a predicate holds true for some `Chunk` element.

**Signature**

```ts
declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1430)

Since v2.0.0
Chunk-sort.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.sort

Sort the elements of a Chunk in increasing order, creating a new Chunk.

**Signature**

```ts
declare const sort: { <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>; <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1028)

Since v2.0.0
Chunk-split.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.split

Splits this chunk into `n` equally sized chunks.

**Signature**

```ts
declare const split: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1082)

Since v2.0.0
Chunk-splitAt.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.splitAt

Returns two splits of this chunk at the specified index.

**Signature**

```ts
declare const splitAt: { (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1054)

Since v2.0.0
Chunk-splitNonEmptyAt.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.splitNonEmptyAt

Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` must be `>= 1`.

**Signature**

```ts
declare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1066)

Since v2.0.0
Chunk-splitWhere.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.splitWhere

Splits this chunk on the first element that matches this predicate.
Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.

**Signature**

```ts
declare const splitWhere: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1094)

Since v2.0.0
Chunk-tail.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.tail

Returns every elements after the first.

**Signature**

```ts
declare const tail: <A>(self: Chunk<A>) => Option<Chunk<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1115)

Since v2.0.0
Chunk-tailNonEmpty.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.tailNonEmpty

Returns every elements after the first.

**Signature**

```ts
declare const tailNonEmpty: <A>(self: NonEmptyChunk<A>) => Chunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1123)

Since v2.0.0
Chunk-take.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.take

Takes the first up to `n` elements from the chunk

**Signature**

```ts
declare const take: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L465)

Since v2.0.0
Chunk-takeRight.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.takeRight

Takes the last `n` elements.

**Signature**

```ts
declare const takeRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1131)

Since v2.0.0
Chunk-takeWhile.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.takeWhile

Takes all elements so long as the predicate returns true.

**Signature**

```ts
declare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1142)

Since v2.0.0
Chunk-toArray.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.toArray

Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty
(`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the
non-empty property is preserved.

**Signature**

```ts
declare const toArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L291)

Since v2.0.0
Chunk-toReadonlyArray.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.toReadonlyArray

Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is
non-empty (`NonEmptyChunk`), the function will return a
`NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.

**Signature**

```ts
declare const toReadonlyArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L326)

Since v2.0.0
Chunk-union.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.union

Creates a Chunks of unique values, in order, from all given Chunks.

**Signature**

```ts
declare const union: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1165)

Since v2.0.0
Chunk-unsafeFromArray.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.unsafeFromArray

Wraps an array into a chunk without copying, unsafe on mutable arrays

**Signature**

```ts
declare const unsafeFromArray: <A>(self: ReadonlyArray<A>) => Chunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L389)

Since v2.0.0
Chunk-unsafeFromNonEmptyArray.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.unsafeFromNonEmptyArray

Wraps an array into a chunk without copying, unsafe on mutable arrays

**Signature**

```ts
declare const unsafeFromNonEmptyArray: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyChunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L398)

Since v2.0.0
Chunk-unsafeGet.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.unsafeGet

Gets an element unsafely, will throw on out of bounds

**Signature**

```ts
declare const unsafeGet: { (index: number): <A>(self: Chunk<A>) => A; <A>(self: Chunk<A>, index: number): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L407)

Since v2.0.0
Chunk-unsafeHead.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.unsafeHead

Returns the first element of this chunk.

It will throw an error if the chunk is empty.

**Signature**

```ts
declare const unsafeHead: <A>(self: Chunk<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L845)

Since v2.0.0
Chunk-unsafeLast.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.unsafeLast

Returns the last element of this chunk.

It will throw an error if the chunk is empty.

**Signature**

```ts
declare const unsafeLast: <A>(self: Chunk<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L871)

Since v2.0.0
Chunk-unzip.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.unzip

Takes a `Chunk` of pairs and return two corresponding `Chunk`s.

Note: The function is reverse of `zip`.

**Signature**

```ts
declare const unzip: <A, B>(self: Chunk<readonly [A, B]>) => [Chunk<A>, Chunk<B>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1197)

Since v2.0.0
Chunk-zip.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.zip

Zips this chunk pointwise with the specified chunk.

**Signature**

```ts
declare const zip: { <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1223)

Since v2.0.0
Chunk-zipWith.md
Package: `effect`<br />
Module: `Chunk`<br />

## Chunk.zipWith

Zips this chunk pointwise with the specified chunk using the specified combiner.

**Signature**

```ts
declare const zipWith: { <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>; <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1208)

Since v2.0.0
CliApp-CliApp.md
Package: `@effect/cli`<br />
Module: `CliApp`<br />

## CliApp.CliApp

A `CliApp<A>` is a complete description of a command-line application.

**Signature**

```ts
export interface CliApp<A> extends Pipeable {
  readonly name: string
  readonly version: string
  readonly executable: string
  readonly command: Command<A>
  readonly summary: Span
  readonly footer: HelpDoc
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/CliApp.ts#L21)

Since v1.0.0
CliConfig-CliConfig.md
Package: `@effect/cli`<br />
Module: `CliConfig`<br />

## CliConfig.CliConfig

Represents how arguments from the command-line are to be parsed.

**Signature**

```ts
export interface CliConfig {
  /**
   * Whether or not the argument parser should be case sensitive.
   *
   * Defaults to `false`.
   */
  readonly isCaseSensitive: boolean
  /**
   * Levenstein distance threshold for when to show auto correct suggestions.
   *
   * Defaults to `2`.
   */
  readonly autoCorrectLimit: number
  /**
   * Whether or not to perform a final check of the command-line arguments for
   * a built-in option, even if the provided command is not valid.
   *
   * Defaults to `false`.
   */
  readonly finalCheckBuiltIn: boolean
  /**
   * Whether or not to display all the names of an option in the usage of a
   * particular command.
   *
   * Defaults to `true`.
   */
  readonly showAllNames: boolean
  /**
   * Whether or not to display built-in options in the help documentation
   * generated for a `Command`.
   *
   * Defaults to `true`.
   */
  readonly showBuiltIns: boolean
  /**
   * Whether or not to display the type of an option in the usage of a
   * particular command.
   *
   * Defaults to `true`.
   */
  readonly showTypes: boolean
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/CliConfig.ts#L14)

Since v1.0.0
Clipboard-layer.md
Package: `@effect/platform-browser`<br />
Module: `Clipboard`<br />

## Clipboard.layer

A layer that directly interfaces with the navigator.clipboard api

**Signature**

```ts
declare const layer: Layer.Layer<Clipboard, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/Clipboard.ts#L85)

Since v1.0.0
Clock-Clock.md
Package: `effect`<br />
Module: `Clock`<br />

## Clock.Clock

Represents a time-based clock which provides functionality related to time
and scheduling.

**Signature**

```ts
export interface Clock {
  readonly [ClockTypeId]: ClockTypeId
  /**
   * Unsafely returns the current time in milliseconds.
   */
  unsafeCurrentTimeMillis(): number
  /**
   * Returns the current time in milliseconds.
   */
  readonly currentTimeMillis: Effect.Effect<number>
  /**
   * Unsafely returns the current time in nanoseconds.
   */
  unsafeCurrentTimeNanos(): bigint
  /**
   * Returns the current time in nanoseconds.
   */
  readonly currentTimeNanos: Effect.Effect<bigint>
  /**
   * Asynchronously sleeps for the specified duration.
   */
  sleep(duration: Duration.Duration): Effect.Effect<void>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L29)

Since v2.0.0
ClusterError-AlreadyProcessingMessage.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.AlreadyProcessingMessage

Represents an error that occurs when the entity is already processing a
request.

**Signature**

```ts
declare class AlreadyProcessingMessage
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L199)

Since v1.0.0
ClusterError-EntityNotAssignedToRunner.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.EntityNotAssignedToRunner

Represents an error that occurs when a Runner receives a message for an entity
that it is not assigned to it.

**Signature**

```ts
declare class EntityNotAssignedToRunner
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L31)

Since v1.0.0
ClusterError-EntityNotManagedByRunner.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.EntityNotManagedByRunner

Represents an error that occurs when a Runner receives a message for an entity
that it is not responsible for managing.

**Signature**

```ts
declare class EntityNotManagedByRunner
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L55)

Since v1.0.0
ClusterError-MailboxFull.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.MailboxFull

Represents an error that occurs when the entities mailbox is full.

**Signature**

```ts
declare class MailboxFull
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L175)

Since v1.0.0
ClusterError-MalformedMessage.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.MalformedMessage

Represents an error that occurs when a message fails to be properly
deserialized by an entity.

**Signature**

```ts
declare class MalformedMessage
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L79)

Since v1.0.0
ClusterError-PersistenceError.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.PersistenceError

Represents an error that occurs when a message fails to be persisted into
cluster's mailbox storage.

**Signature**

```ts
declare class PersistenceError
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L112)

Since v1.0.0
ClusterError-RunnerNotRegistered.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.RunnerNotRegistered

Represents an error that occurs when a Runner is not registered with the shard
manager.

**Signature**

```ts
declare class RunnerNotRegistered
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L136)

Since v1.0.0
ClusterError-RunnerUnavailable.md
Package: `@effect/cluster`<br />
Module: `ClusterError`<br />

## ClusterError.RunnerUnavailable

Represents an error that occurs when a Runner is unresponsive.

**Signature**

```ts
declare class RunnerUnavailable
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ClusterError.ts#L152)

Since v1.0.0
Command-Command.Input.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.Command.Input

Configures the pipe that is established between the parent and child
processes' `stdin` stream.

**Signature**

```ts
type Input = CommandInput
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L52)

Since v1.0.0
Command-Command.Output.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.Command.Output

Configures the pipes that are established between the parent and child
processes `stderr` and `stdout` streams.

**Signature**

```ts
type Output = CommandOutput
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L60)

Since v1.0.0
Command-CommandInput.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.CommandInput

Configures the pipe that is established between the parent and child
processes' `stdin` stream.

Defaults to "pipe"

**Signature**

```ts
type CommandInput = "inherit" | "pipe" | Stream<Uint8Array, PlatformError>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L72)

Since v1.0.0
Command-CommandOutput.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.CommandOutput

Configures the pipes that are established between the parent and child
processes `stderr` and `stdout` streams.

Defaults to "pipe"

**Signature**

```ts
type CommandOutput = "inherit" | "pipe" | Sink<Uint8Array, Uint8Array>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L83)

Since v1.0.0
Command-env.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.env

Specify the environment variables that will be used when running this command.

**Signature**

```ts
declare const env: { (environment: Record<string, string | undefined>): (self: Command) => Command; (self: Command, environment: Record<string, string | undefined>): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L128)

Since v1.0.0
Command-exitCode.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.exitCode

Returns the exit code of the command after the process has completed
execution.

**Signature**

```ts
declare const exitCode: (self: Command) => Effect<ExitCode, PlatformError, CommandExecutor>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L140)

Since v1.0.0
Command-feed.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.feed

Feed a string to standard input (default encoding of UTF-8).

**Signature**

```ts
declare const feed: { (input: string): (self: Command) => Command; (self: Command, input: string): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L148)

Since v1.0.0
Command-flatten.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.flatten

Flatten this command to a non-empty array of standard commands.

For a `StandardCommand`, this simply returns a `1` element array
For a `PipedCommand`, all commands in the pipe will be extracted out into
a array from left to right

**Signature**

```ts
declare const flatten: (self: Command) => NonEmptyReadonlyArray<StandardCommand>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L163)

Since v1.0.0
Command-isCommand.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.isCommand

Returns `true` if the specified value is a `Command`, otherwise returns
`false`.

**Signature**

```ts
declare const isCommand: (u: unknown) => u is Command
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L120)

Since v1.0.0
Command-lines.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.lines

Runs the command returning the output as an array of lines with the specified
encoding.

**Signature**

```ts
declare const lines: (command: Command, encoding?: string) => Effect<Array<string>, PlatformError, CommandExecutor>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L172)

Since v1.0.0
Command-make.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.make

Create a command with the specified process name and an optional list of
arguments.

**Signature**

```ts
declare const make: (command: string, ...args: Array<string>) => Command
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L182)

Since v1.0.0
Command-pipeTo.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.pipeTo

Pipe one command to another command from left to right.

Conceptually, the equivalent of piping one shell command to another:

```sh
command1 | command2
```

**Signature**

```ts
declare const pipeTo: { (into: Command): (self: Command) => Command; (self: Command, into: Command): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L196)

Since v1.0.0
Command-runInShell.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.runInShell

Allows for specifying whether or not a `Command` should be run inside a
shell.

**Signature**

```ts
declare const runInShell: { (shell: string | boolean): (self: Command) => Command; (self: Command, shell: string | boolean): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L208)

Since v1.0.0
Command-start.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.start

Start running the command and return a handle to the running process.

**Signature**

```ts
declare const start: (command: Command) => Effect<Process, PlatformError, CommandExecutor | Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L219)

Since v1.0.0
Command-stderr.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.stderr

Specify the standard error stream for a command.

**Signature**

```ts
declare const stderr: { (stderr: Command.Output): (self: Command) => Command; (self: Command, stderr: Command.Output): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L259)

Since v1.0.0
Command-stdin.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.stdin

Specify the standard input stream for a command.

**Signature**

```ts
declare const stdin: { (stdin: Command.Input): (self: Command) => Command; (self: Command, stdin: Command.Input): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L270)

Since v1.0.0
Command-stdout.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.stdout

Specify the standard output stream for a command.

**Signature**

```ts
declare const stdout: { (stdout: Command.Output): (self: Command) => Command; (self: Command, stdout: Command.Output): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L281)

Since v1.0.0
Command-stream.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.stream

Start running the command and return the output as a `Stream`.

**Signature**

```ts
declare const stream: (command: Command) => Stream<Uint8Array, PlatformError, CommandExecutor>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L227)

Since v1.0.0
Command-streamLines.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.streamLines

Runs the command returning the output as an stream of lines with the
specified encoding.

**Signature**

```ts
declare const streamLines: (command: Command, encoding?: string) => Stream<string, PlatformError, CommandExecutor>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L236)

Since v1.0.0
Command-string.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.string

Runs the command returning the entire output as a string with the
specified encoding.

If an encoding is not specified, the encoding will default to `utf-8`.

**Signature**

```ts
declare const string: { (encoding?: string): (command: Command) => Effect<string, PlatformError, CommandExecutor>; (command: Command, encoding?: string): Effect<string, PlatformError, CommandExecutor>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L248)

Since v1.0.0
Command-workingDirectory.md
Package: `@effect/platform`<br />
Module: `Command`<br />

## Command.workingDirectory

Set the working directory that will be used when this command will be run.

For piped commands, the working directory of each command will be set to the
specified working directory.

**Signature**

```ts
declare const workingDirectory: { (cwd: string): (self: Command) => Command; (self: Command, cwd: string): Command; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Command.ts#L295)

Since v1.0.0
CommandDescriptor-Command.md
Package: `@effect/cli`<br />
Module: `CommandDescriptor`<br />

## CommandDescriptor.Command

A `Command` represents a command in a command-line application.

Every command-line application will have at least one command: the
application itself. Other command-line applications may support multiple
commands.

**Signature**

```ts
export interface Command<A> extends Command.Variance<A>, Pipeable {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/CommandDescriptor.ts#L45)

Since v1.0.0
Config-Config.Wrap.md
Package: `effect`<br />
Module: `Config`<br />

## Config.Config.Wrap

Wraps a nested structure, converting all primitives to a `Config`.

`Config.Wrap<{ key: string }>` becomes `{ key: Config<string> }`

To create the resulting config, use the `unwrap` constructor.

**Signature**

```ts
type Wrap<A> = [NonNullable<A>] extends [infer T] ? [IsPlainObject<T>] extends [true] ?
        | { readonly [K in keyof A]: Wrap<A[K]> }
        | Config<A>
    : Config<A>
    : Config<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L80)

Since v2.0.0
Config-Config.md
Package: `effect`<br />
Module: `Config`<br />

## Config.Config

A `Config` describes the structure of some configuration data.

**Signature**

```ts
export interface Config<out A> extends Config.Variance<A>, Effect.Effect<A, ConfigError.ConfigError> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L39)

Since v2.0.0
Config-all.md
Package: `effect`<br />
Module: `Config`<br />

## Config.all

Constructs a config from a tuple / struct / arguments of configs.

**Signature**

```ts
declare const all: <const Arg extends Iterable<Config<any>> | Record<string, Config<any>>>(arg: Arg) => Config<[Arg] extends [ReadonlyArray<Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : [Arg] extends [Iterable<Config<infer A>>] ? Array<A> : [Arg] extends [Record<string, Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L103)

Since v2.0.0
Config-array.md
Package: `effect`<br />
Module: `Config`<br />

## Config.array

Constructs a config for an array of values.

**Signature**

```ts
declare const array: <A>(config: Config<A>, name?: string) => Config<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L122)

Since v2.0.0
Config-boolean.md
Package: `effect`<br />
Module: `Config`<br />

## Config.boolean

Constructs a config for a boolean value.

**Signature**

```ts
declare const boolean: (name?: string) => Config<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L130)

Since v2.0.0
Config-branded.md
Package: `effect`<br />
Module: `Config`<br />

## Config.branded

Constructs a config for a branded value.

**Signature**

```ts
declare const branded: { <A, B extends Brand.Branded<A, any>>(constructor: Brand.Brand.Constructor<B>): (config: Config<A>) => Config<B>; <B extends Brand.Branded<string, any>>(name: string | undefined, constructor: Brand.Brand.Constructor<B>): Config<B>; <A, B extends Brand.Branded<A, any>>(config: Config<A>, constructor: Brand.Brand.Constructor<B>): Config<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L378)

Since v3.16.0
Config-chunk.md
Package: `effect`<br />
Module: `Config`<br />

## Config.chunk

Constructs a config for a sequence of values.

**Signature**

```ts
declare const chunk: <A>(config: Config<A>, name?: string) => Config<Chunk.Chunk<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L154)

Since v2.0.0
Config-date.md
Package: `effect`<br />
Module: `Config`<br />

## Config.date

Constructs a config for a date value.

**Signature**

```ts
declare const date: (name?: string) => Config<Date>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L162)

Since v2.0.0
Config-duration.md
Package: `effect`<br />
Module: `Config`<br />

## Config.duration

Constructs a config for a duration value.

**Signature**

```ts
declare const duration: (name?: string) => Config<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L220)

Since v2.5.0
Config-fail.md
Package: `effect`<br />
Module: `Config`<br />

## Config.fail

Constructs a config that fails with the specified message.

**Signature**

```ts
declare const fail: (message: string) => Config<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L170)

Since v2.0.0
Config-hashMap.md
Package: `effect`<br />
Module: `Config`<br />

## Config.hashMap

Constructs a config for a sequence of values.

**Signature**

```ts
declare const hashMap: <A>(config: Config<A>, name?: string) => Config<HashMap.HashMap<string, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L446)

Since v2.0.0
Config-hashSet.md
Package: `effect`<br />
Module: `Config`<br />

## Config.hashSet

Constructs a config for a sequence of values.

**Signature**

```ts
declare const hashSet: <A>(config: Config<A>, name?: string) => Config<HashSet.HashSet<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L398)

Since v2.0.0
Config-integer.md
Package: `effect`<br />
Module: `Config`<br />

## Config.integer

Constructs a config for a integer value.

**Signature**

```ts
declare const integer: (name?: string) => Config<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L186)

Since v2.0.0
Config-isConfig.md
Package: `effect`<br />
Module: `Config`<br />

## Config.isConfig

This function returns `true` if the specified value is an `Config` value,
`false` otherwise.

This function can be useful for checking the type of a value before
attempting to operate on it as an `Config` value. For example, you could
use `isConfig` to check the type of a value before using it as an
argument to a function that expects an `Config` value.

**Signature**

```ts
declare const isConfig: (u: unknown) => u is Config<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L234)

Since v2.0.0
Config-literal.md
Package: `effect`<br />
Module: `Config`<br />

## Config.literal

Constructs a config for a literal value.

**Example**

```ts
import { Config } from "effect"

const config = Config.literal("http", "https")("PROTOCOL")
```

**Signature**

```ts
declare const literal: <Literals extends ReadonlyArray<LiteralValue>>(...literals: Literals) => (name?: string) => Config<Literals[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L202)

Since v2.0.0
Config-logLevel.md
Package: `effect`<br />
Module: `Config`<br />

## Config.logLevel

Constructs a config for a `LogLevel` value.

**Signature**

```ts
declare const logLevel: (name?: string) => Config<LogLevel.LogLevel>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L212)

Since v2.0.0
Config-map.md
Package: `effect`<br />
Module: `Config`<br />

## Config.map

Returns a  config whose structure is the same as this one, but which produces
a different value, constructed using the specified function.

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L243)

Since v2.0.0
Config-mapAttempt.md
Package: `effect`<br />
Module: `Config`<br />

## Config.mapAttempt

Returns a config whose structure is the same as this one, but which may
produce a different value, constructed using the specified function, which
may throw exceptions that will be translated into validation errors.

**Signature**

```ts
declare const mapAttempt: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L256)

Since v2.0.0
Config-mapOrFail.md
Package: `effect`<br />
Module: `Config`<br />

## Config.mapOrFail

Returns a new config whose structure is the samea as this one, but which
may produce a different value, constructed using the specified fallible
function.

**Signature**

```ts
declare const mapOrFail: { <A, B>(f: (a: A) => Either.Either<B, ConfigError.ConfigError>): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => Either.Either<B, ConfigError.ConfigError>): Config<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L269)

Since v2.0.0
Config-nested.md
Package: `effect`<br />
Module: `Config`<br />

## Config.nested

Returns a config that has this configuration nested as a property of the
specified name.

**Signature**

```ts
declare const nested: { (name: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, name: string): Config<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L281)

Since v2.0.0
Config-nonEmptyString.md
Package: `effect`<br />
Module: `Config`<br />

## Config.nonEmptyString

Constructs a config for a non-empty string value.

**Signature**

```ts
declare const nonEmptyString: (name?: string) => Config<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L414)

Since v3.7.0
Config-number.md
Package: `effect`<br />
Module: `Config`<br />

## Config.number

Constructs a config for a float value.

**Signature**

```ts
declare const number: (name?: string) => Config<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L178)

Since v2.0.0
Config-option.md
Package: `effect`<br />
Module: `Config`<br />

## Config.option

Returns an optional version of this config, which will be `None` if the
data is missing from configuration, and `Some` otherwise.

**Signature**

```ts
declare const option: <A>(self: Config<A>) => Config<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L330)

Since v2.0.0
Config-orElse.md
Package: `effect`<br />
Module: `Config`<br />

## Config.orElse

Returns a config whose structure is preferentially described by this
config, but which falls back to the specified config if there is an issue
reading from this config.

**Signature**

```ts
declare const orElse: { <A2>(that: LazyArg<Config<A2>>): <A>(self: Config<A>) => Config<A2 | A>; <A, A2>(self: Config<A>, that: LazyArg<Config<A2>>): Config<A | A2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L294)

Since v2.0.0
Config-orElseIf.md
Package: `effect`<br />
Module: `Config`<br />

## Config.orElseIf

Returns configuration which reads from this configuration, but which falls
back to the specified configuration if reading from this configuration
fails with an error satisfying the specified predicate.

**Signature**

```ts
declare const orElseIf: { <A2>(options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): <A>(self: Config<A>) => Config<A>; <A, A2>(self: Config<A>, options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): Config<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L307)

Since v2.0.0
Config-port.md
Package: `effect`<br />
Module: `Config`<br />

## Config.port

Constructs a config for a network port [1, 65535].

**Signature**

```ts
declare const port: (name?: string) => Config<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L138)

Since v3.16.0
Config-primitive.md
Package: `effect`<br />
Module: `Config`<br />

## Config.primitive

Constructs a new primitive config.

**Signature**

```ts
declare const primitive: <A>(description: string, parse: (text: string) => Either.Either<A, ConfigError.ConfigError>) => Config<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L338)

Since v2.0.0
Config-redacted.md
Package: `effect`<br />
Module: `Config`<br />

## Config.redacted

Constructs a config for a redacted value.

**Signature**

```ts
declare const redacted: { (name?: string): Config<Redacted.Redacted>; <A>(config: Config<A>): Config<Redacted.Redacted<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L367)

Since v2.0.0
Config-repeat.md
Package: `effect`<br />
Module: `Config`<br />

## Config.repeat

Returns a config that describes a sequence of values, each of which has the
structure of this config.

**Signature**

```ts
declare const repeat: <A>(self: Config<A>) => Config<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L350)

Since v2.0.0
Config-secret.md
Package: `effect`<br />
Module: `Config`<br />

## ~~Config.secret~~

Constructs a config for a secret value.

**Signature**

```ts
declare const secret: (name?: string) => Config<Secret.Secret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L359)

Since v2.0.0
Config-string.md
Package: `effect`<br />
Module: `Config`<br />

## Config.string

Constructs a config for a string value.

**Signature**

```ts
declare const string: (name?: string) => Config<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L406)

Since v2.0.0
Config-succeed.md
Package: `effect`<br />
Module: `Config`<br />

## Config.succeed

Constructs a config which contains the specified value.

**Signature**

```ts
declare const succeed: <A>(value: A) => Config<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L422)

Since v2.0.0
Config-suspend.md
Package: `effect`<br />
Module: `Config`<br />

## Config.suspend

Lazily constructs a config.

**Signature**

```ts
declare const suspend: <A>(config: LazyArg<Config<A>>) => Config<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L430)

Since v2.0.0
Config-sync.md
Package: `effect`<br />
Module: `Config`<br />

## Config.sync

Constructs a config which contains the specified lazy value.

**Signature**

```ts
declare const sync: <A>(value: LazyArg<A>) => Config<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L438)

Since v2.0.0
Config-unwrap.md
Package: `effect`<br />
Module: `Config`<br />

## Config.unwrap

Constructs a config from some configuration wrapped with the `Wrap<A>` utility type.

For example:

```
import { Config, unwrap } from "./Config"

interface Options { key: string }

const makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)
```

**Signature**

```ts
declare const unwrap: <A>(wrapped: Config.Wrap<A>) => Config<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L464)

Since v2.0.0
Config-url.md
Package: `effect`<br />
Module: `Config`<br />

## Config.url

Constructs a config for an URL value.

**Signature**

```ts
declare const url: (name?: string) => Config<URL>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L146)

Since v3.11.0
Config-validate.md
Package: `effect`<br />
Module: `Config`<br />

## Config.validate

Returns a config that describes the same structure as this one, but which
performs validation during loading.

**Signature**

```ts
declare const validate: { <A, B extends A>(options: { readonly message: string; readonly validation: Refinement<A, B>; }): (self: Config<A>) => Config<B>; <A>(options: { readonly message: string; readonly validation: Predicate<A>; }): (self: Config<A>) => Config<A>; <A, B extends A>(self: Config<A>, options: { readonly message: string; readonly validation: Refinement<A, B>; }): Config<B>; <A>(self: Config<A>, options: { readonly message: string; readonly validation: Predicate<A>; }): Config<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L473)

Since v2.0.0
Config-withDefault.md
Package: `effect`<br />
Module: `Config`<br />

## Config.withDefault

Returns a config that describes the same structure as this one, but has the
specified default value in case the information cannot be found.

**Signature**

```ts
declare const withDefault: { <const A2>(def: A2): <A>(self: Config<A>) => Config<A2 | A>; <A, const A2>(self: Config<A>, def: A2): Config<A | A2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L504)

Since v2.0.0
Config-withDescription.md
Package: `effect`<br />
Module: `Config`<br />

## Config.withDescription

Adds a description to this configuration, which is intended for humans.

**Signature**

```ts
declare const withDescription: { (description: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, description: string): Config<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L515)

Since v2.0.0
Config-zip.md
Package: `effect`<br />
Module: `Config`<br />

## Config.zip

Returns a config that is the composition of this config and the specified
config.

**Signature**

```ts
declare const zip: { <B>(that: Config<B>): <A>(self: Config<A>) => Config<[A, B]>; <A, B>(self: Config<A>, that: Config<B>): Config<[A, B]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L527)

Since v2.0.0
Config-zipWith.md
Package: `effect`<br />
Module: `Config`<br />

## Config.zipWith

Returns a config that is the composes this config and the specified config
using the provided function.

**Signature**

```ts
declare const zipWith: { <B, A, C>(that: Config<B>, f: (a: A, b: B) => C): (self: Config<A>) => Config<C>; <A, B, C>(self: Config<A>, that: Config<B>, f: (a: A, b: B) => C): Config<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L539)

Since v2.0.0
ConfigError-ConfigError.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.ConfigError

The possible ways that loading configuration data may fail.

**Signature**

```ts
type ConfigError = | And
  | Or
  | InvalidData
  | MissingData
  | SourceUnavailable
  | Unsupported
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L25)

Since v2.0.0
ConfigError-isAnd.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isAnd

Returns `true` if the specified `ConfigError` is an `And`, `false` otherwise.

**Signature**

```ts
declare const isAnd: (self: ConfigError) => self is And
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L200)

Since v2.0.0
ConfigError-isConfigError.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isConfigError

Returns `true` if the specified value is a `ConfigError`, `false` otherwise.

**Signature**

```ts
declare const isConfigError: (u: unknown) => u is ConfigError
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L192)

Since v2.0.0
ConfigError-isInvalidData.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isInvalidData

Returns `true` if the specified `ConfigError` is an `InvalidData`, `false`
otherwise.

**Signature**

```ts
declare const isInvalidData: (self: ConfigError) => self is InvalidData
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L217)

Since v2.0.0
ConfigError-isMissingData.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isMissingData

Returns `true` if the specified `ConfigError` is an `MissingData`, `false`
otherwise.

**Signature**

```ts
declare const isMissingData: (self: ConfigError) => self is MissingData
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L226)

Since v2.0.0
ConfigError-isMissingDataOnly.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isMissingDataOnly

Returns `true` if the specified `ConfigError` contains only `MissingData` errors, `false` otherwise.

**Signature**

```ts
declare const isMissingDataOnly: (self: ConfigError) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L234)

Since v2.0.0
ConfigError-isOr.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isOr

Returns `true` if the specified `ConfigError` is an `Or`, `false` otherwise.

**Signature**

```ts
declare const isOr: (self: ConfigError) => self is Or
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L208)

Since v2.0.0
ConfigError-isSourceUnavailable.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isSourceUnavailable

Returns `true` if the specified `ConfigError` is a `SourceUnavailable`,
`false` otherwise.

**Signature**

```ts
declare const isSourceUnavailable: (self: ConfigError) => self is SourceUnavailable
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L243)

Since v2.0.0
ConfigError-isUnsupported.md
Package: `effect`<br />
Module: `ConfigError`<br />

## ConfigError.isUnsupported

Returns `true` if the specified `ConfigError` is an `Unsupported`, `false`
otherwise.

**Signature**

```ts
declare const isUnsupported: (self: ConfigError) => self is Unsupported
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L252)

Since v2.0.0
ConfigProvider-ConfigProvider.Flat.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.ConfigProvider.Flat

A simplified config provider that knows only how to deal with flat
(key/value) properties. Because these providers are common, there is
special support for implementing them.

**Signature**

```ts
export interface Flat {
    readonly [FlatConfigProviderTypeId]: FlatConfigProviderTypeId
    readonly patch: PathPatch.PathPatch
    load<A>(
      path: ReadonlyArray<string>,
      config: Config.Config.Primitive<A>,
      split?: boolean
    ): Effect.Effect<Array<A>, ConfigError.ConfigError>
    enumerateChildren(
      path: ReadonlyArray<string>
    ): Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L77)

Since v2.0.0
ConfigProvider-ConfigProvider.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.ConfigProvider

A ConfigProvider is a service that provides configuration given a description
of the structure of that configuration.

**Signature**

```ts
export interface ConfigProvider extends ConfigProvider.Proto, Pipeable {
  /**
   * Loads the specified configuration, or fails with a config error.
   */
  load<A>(config: Config.Config<A>): Effect.Effect<A, ConfigError.ConfigError>
  /**
   * Flattens this config provider into a simplified config provider that knows
   * only how to deal with flat (key/value) properties.
   */
  readonly flattened: ConfigProvider.Flat
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L45)

Since v2.0.0
ConfigProvider-constantCase.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.constantCase

Returns a new config provider that will automatically convert all property
names to constant case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

**Signature**

```ts
declare const constantCase: (self: ConfigProvider) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L222)

Since v2.0.0
ConfigProvider-fromEnv.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.fromEnv

A config provider that loads configuration from context variables

**Options**:

- `pathDelim`: The delimiter for the path segments (default: `"_"`).
- `seqDelim`: The delimiter for the sequence of values (default: `","`).

**Signature**

```ts
declare const fromEnv: (options?: Partial<ConfigProvider.FromEnvConfig>) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L183)

Since v2.0.0
ConfigProvider-fromFlat.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.fromFlat

Constructs a new `ConfigProvider` from a key/value (flat) provider, where
nesting is embedded into the string keys.

**Signature**

```ts
declare const fromFlat: (flat: ConfigProvider.Flat) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L192)

Since v2.0.0
ConfigProvider-fromJson.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.fromJson

Constructs a new `ConfigProvider` from a JSON object.

**Signature**

```ts
declare const fromJson: (json: unknown) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L200)

Since v2.0.0
ConfigProvider-fromMap.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.fromMap

Constructs a ConfigProvider using a map and the specified delimiter string,
which determines how to split the keys in the map into path segments.

**Signature**

```ts
declare const fromMap: (map: Map<string, string>, config?: Partial<ConfigProvider.FromMapConfig>) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L210)

Since v2.0.0
ConfigProvider-kebabCase.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.kebabCase

Returns a new config provider that will automatically convert all property
names to kebab case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

**Signature**

```ts
declare const kebabCase: (self: ConfigProvider) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L247)

Since v2.0.0
ConfigProvider-lowerCase.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.lowerCase

Returns a new config provider that will automatically convert all property
names to lower case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

**Signature**

```ts
declare const lowerCase: (self: ConfigProvider) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L258)

Since v2.0.0
ConfigProvider-make.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.make

Creates a new config provider.

**Signature**

```ts
declare const make: (options: { readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>; readonly flattened: ConfigProvider.Flat; }) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L147)

Since v2.0.0
ConfigProvider-makeFlat.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.makeFlat

Creates a new flat config provider.

**Signature**

```ts
declare const makeFlat: (options: { readonly load: <A>(path: ReadonlyArray<string>, config: Config.Config.Primitive<A>, split: boolean) => Effect.Effect<Array<A>, ConfigError.ConfigError>; readonly enumerateChildren: (path: ReadonlyArray<string>) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>; readonly patch: PathPatch.PathPatch; }) => ConfigProvider.Flat
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L160)

Since v2.0.0
ConfigProvider-mapInputPath.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.mapInputPath

Returns a new config provider that will automatically tranform all path
configuration names with the specified function. This can be utilized to
adapt the names of configuration properties from one naming convention to
another.

**Signature**

```ts
declare const mapInputPath: { (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, f: (path: string) => string): ConfigProvider; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L233)

Since v2.0.0
ConfigProvider-nested.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.nested

Returns a new config provider that will automatically nest all
configuration under the specified property name. This can be utilized to
aggregate separate configuration sources that are all required to load a
single configuration value.

**Signature**

```ts
declare const nested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L269)

Since v2.0.0
ConfigProvider-orElse.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.orElse

Returns a new config provider that preferentially loads configuration data
from this one, but which will fall back to the specified alternate provider
if there are any issues loading the configuration from this provider.

**Signature**

```ts
declare const orElse: { (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L282)

Since v2.0.0
ConfigProvider-snakeCase.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.snakeCase

Returns a new config provider that will automatically convert all property
names to upper case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

**Signature**

```ts
declare const snakeCase: (self: ConfigProvider) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L310)

Since v2.0.0
ConfigProvider-unnested.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.unnested

Returns a new config provider that will automatically un-nest all
configuration under the specified property name. This can be utilized to
de-aggregate separate configuration sources that are all required to load a
single configuration value.

**Signature**

```ts
declare const unnested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L296)

Since v2.0.0
ConfigProvider-upperCase.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.upperCase

Returns a new config provider that will automatically convert all property
names to upper case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

**Signature**

```ts
declare const upperCase: (self: ConfigProvider) => ConfigProvider
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L321)

Since v2.0.0
ConfigProvider-within.md
Package: `effect`<br />
Module: `ConfigProvider`<br />

## ConfigProvider.within

Returns a new config provider that transforms the config provider with the
specified function within the specified path.

**Signature**

```ts
declare const within: { (path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): ConfigProvider; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L330)

Since v2.0.0
ConfigProviderPathPatch-PathPatch.md
Package: `effect`<br />
Module: `ConfigProviderPathPatch`<br />

## ConfigProviderPathPatch.PathPatch

Represents a description of how to modify the path to a configuration
value.

**Signature**

```ts
type PathPatch = Empty | AndThen | MapName | Nested | Unnested
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L13)

Since v2.0.0
Context-GenericTag.md
Package: `effect`<br />
Module: `Context`<br />

## Context.GenericTag

Creates a new `Tag` instance with an optional key parameter.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)
```

**Signature**

```ts
declare const GenericTag: <Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L156)

Since v2.0.0
Context-Reference.md
Package: `effect`<br />
Module: `Context`<br />

## Context.Reference

Creates a context tag with a default value.

**Details**

`Context.Reference` allows you to create a tag that can hold a value. You can
provide a default value for the service, which will automatically be used
when the context is accessed, or override it with a custom implementation
when needed.

**Example** (Declaring a Tag with a default value)

```ts
import * as assert from "node:assert"
import { Context, Effect } from "effect"

class SpecialNumber extends Context.Reference<SpecialNumber>()(
  "SpecialNumber",
  { defaultValue: () => 2048 }
) {}

//       Effect<void, never, never>
//      
const program = Effect.gen(function* () {
  const specialNumber = yield* SpecialNumber
  console.log(`The special number is ${specialNumber}`)
})

// No need to provide the SpecialNumber implementation
Effect.runPromise(program)
// Output: The special number is 2048
```

**Example** (Overriding the default value)

```ts
import { Context, Effect } from "effect"

class SpecialNumber extends Context.Reference<SpecialNumber>()(
  "SpecialNumber",
  { defaultValue: () => 2048 }
) {}

const program = Effect.gen(function* () {
  const specialNumber = yield* SpecialNumber
  console.log(`The special number is ${specialNumber}`)
})

Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))
// Output: The special number is -1
```

**Signature**

```ts
declare const Reference: <Self>() => <const Id extends string, Service>(id: Id, options: { readonly defaultValue: () => Service; }) => ReferenceClass<Self, Id, Service>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L565)

Since v3.11.0
Context-add.md
Package: `effect`<br />
Module: `Context`<br />

## Context.add

Adds a service to a given `Context`.

**Example**

```ts
import * as assert from "node:assert"
import { Context, pipe } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const someContext = Context.make(Port, { PORT: 8080 })

const Services = pipe(
  someContext,
  Context.add(Timeout, { TIMEOUT: 5000 })
)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
```

**Signature**

```ts
declare const add: { <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>): <Services>(self: Context<Services>) => Context<Services | Tag.Identifier<T>>; <Services, T extends Tag<any, any>>(self: Context<Services>, tag: T, service: Tag.Service<T>): Context<Services | Tag.Identifier<T>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L292)

Since v2.0.0
Context-empty.md
Package: `effect`<br />
Module: `Context`<br />

## Context.empty

Returns an empty `Context`.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.isContext(Context.empty()), true)
```

**Signature**

```ts
declare const empty: () => Context<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L245)

Since v2.0.0
Context-get.md
Package: `effect`<br />
Module: `Context`<br />

## Context.get

Get a service from the context that corresponds to the given tag.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = pipe(
  Context.make(Port, { PORT: 8080 }),
  Context.add(Timeout, { TIMEOUT: 5000 })
)

assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
```

**Signature**

```ts
declare const get: { <I, S>(tag: Reference<I, S>): <Services>(self: Context<Services>) => S; <Services, I extends Services, S>(tag: Tag<I, S>): (self: Context<Services>) => S; <Services, I, S>(self: Context<Services>, tag: Reference<I, S>): S; <Services, I extends Services, S>(self: Context<Services>, tag: Tag<I, S>): S; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L326)

Since v2.0.0
Context-getOption.md
Package: `effect`<br />
Module: `Context`<br />

## Context.getOption

Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not
found, the `Option` object will be `None`.

**Example**

```ts
import * as assert from "node:assert"
import { Context, Option } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
```

**Signature**

```ts
declare const getOption: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L394)

Since v2.0.0
Context-getOrElse.md
Package: `effect`<br />
Module: `Context`<br />

## Context.getOrElse

Get a service from the context that corresponds to the given tag, or
use the fallback value.

**Signature**

```ts
declare const getOrElse: { <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B; <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L340)

Since v3.7.0
Context-isContext.md
Package: `effect`<br />
Module: `Context`<br />

## Context.isContext

Checks if the provided argument is a `Context`.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.isContext(Context.empty()), true)
```

**Signature**

```ts
declare const isContext: (input: unknown) => input is Context<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L204)

Since v2.0.0
Context-isReference.md
Package: `effect`<br />
Module: `Context`<br />

## Context.isReference

Checks if the provided argument is a `Reference`.

**Signature**

```ts
declare const isReference: (u: unknown) => u is Reference<any, any>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L229)

Since v3.11.0
Context-isTag.md
Package: `effect`<br />
Module: `Context`<br />

## Context.isTag

Checks if the provided argument is a `Tag`.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.isTag(Context.GenericTag("Tag")), true)
```

**Signature**

```ts
declare const isTag: (input: unknown) => input is Tag<any, any>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L220)

Since v2.0.0
Context-make.md
Package: `effect`<br />
Module: `Context`<br />

## Context.make

Creates a new `Context` with a single service associated to the tag.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
```

**Signature**

```ts
declare const make: <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>) => Context<Tag.Identifier<T>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L265)

Since v2.0.0
Context-merge.md
Package: `effect`<br />
Module: `Context`<br />

## Context.merge

Merges two `Context`s, returning a new `Context` containing the services of both.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const firstContext = Context.make(Port, { PORT: 8080 })
const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })

const Services = Context.merge(firstContext, secondContext)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
```

**Signature**

```ts
declare const merge: { <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>; <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L421)

Since v2.0.0
Context-mergeAll.md
Package: `effect`<br />
Module: `Context`<br />

## Context.mergeAll

Merges any number of `Context`s, returning a new `Context` containing the services of all.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
const Host = Context.GenericTag<{ HOST: string }>("Host")

const firstContext = Context.make(Port, { PORT: 8080 })
const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
const thirdContext = Context.make(Host, { HOST: "localhost" })

const Services = Context.mergeAll(firstContext, secondContext, thirdContext)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
assert.deepStrictEqual(Context.get(Services, Host), { HOST: "localhost" })
```

**Signature**

```ts
declare const mergeAll: <T extends Array<unknown>>(...ctxs: { [K in keyof T]: Context<T[K]>; }) => Context<T[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L451)

Since v3.12.0
Context-pick.md
Package: `effect`<br />
Module: `Context`<br />

## Context.pick

Returns a new `Context` that contains only the specified services.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Context, Option } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const someContext = pipe(
  Context.make(Port, { PORT: 8080 }),
  Context.add(Timeout, { TIMEOUT: 5000 })
)

const Services = pipe(someContext, Context.pick(Port))

assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
```

**Signature**

```ts
declare const pick: <Tags extends ReadonlyArray<Tag<any, any>>>(...tags: Tags) => <Services>(self: Context<Services>) => Context<Services & Tag.Identifier<Tags[number]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L479)

Since v2.0.0
Context-unsafeGet.md
Package: `effect`<br />
Module: `Context`<br />

## Context.unsafeGet

Get a service from the context that corresponds to the given tag.
This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.

For a safer version see `getOption`.

**Example**

```ts
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })
assert.throws(() => Context.unsafeGet(Services, Timeout))
```

**Signature**

```ts
declare const unsafeGet: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L368)

Since v2.0.0
Contravariant-contramapComposition.md
Package: `@effect/typeclass`<br />
Module: `Contravariant`<br />

## Contravariant.contramapComposition

Composing two contravariant functors yields a Covariant functor.

Returns a default binary `map` composition.

**Signature**

```ts
declare const contramapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Contravariant<F>, G: Contravariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Contravariant.ts#L26)

Since v0.24.0
Contravariant-imap.md
Package: `@effect/typeclass`<br />
Module: `Contravariant`<br />

## Contravariant.imap

Returns a default `imap` implementation.

**Signature**

```ts
declare const imap: <F extends TypeLambda>(contramap: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (b: B) => A) => Kind<F, R, O, E, B>) => Invariant<F>["imap"]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Contravariant.ts#L40)

Since v0.24.0
Cookies-empty.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.empty

An empty Cookies object

**Signature**

```ts
declare const empty: Cookies
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L296)

Since v1.0.0
Cookies-fromIterable.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.fromIterable

Create a Cookies object from an Iterable

**Signature**

```ts
declare const fromIterable: (cookies: Iterable<Cookie>) => Cookies
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L132)

Since v1.0.0
Cookies-fromReadonlyRecord.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.fromReadonlyRecord

Create a Cookies object from an Iterable

**Signature**

```ts
declare const fromReadonlyRecord: (cookies: Record.ReadonlyRecord<string, Cookie>) => Cookies
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L120)

Since v1.0.0
Cookies-fromSetCookie.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.fromSetCookie

Create a Cookies object from a set of Set-Cookie headers

**Signature**

```ts
declare const fromSetCookie: (headers: Iterable<string> | string) => Cookies
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L146)

Since v1.0.0
Cookies-get.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.get

Get a cookie from a Cookies object

**Signature**

```ts
declare const get: { (name: string): (self: Cookies) => Option.Option<Cookie>; (self: Cookies, name: string): Option.Option<Cookie>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L453)

Since v1.0.0
Cookies-getValue.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.getValue

Get a cookie from a Cookies object

**Signature**

```ts
declare const getValue: { (name: string): (self: Cookies) => Option.Option<string>; (self: Cookies, name: string): Option.Option<string>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L467)

Since v1.0.0
Cookies-makeCookie.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.makeCookie

Create a new cookie

**Signature**

```ts
declare const makeCookie: (name: string, value: string, options?: Cookie["options"] | undefined) => Either.Either<Cookie, CookiesError>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L326)

Since v1.0.0
Cookies-merge.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.merge

Combine two Cookies objects, removing duplicates from the first

**Signature**

```ts
declare const merge: { (that: Cookies): (self: Cookies) => Cookies; (self: Cookies, that: Cookies): Cookies; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L421)

Since v1.0.0
Cookies-parseHeader.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.parseHeader

Parse a cookie header into a record of key-value pairs

Adapted from https://github.com/fastify/fastify-cookie under MIT License

**Signature**

```ts
declare const parseHeader: (header: string) => Record<string, string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L704)

Since v1.0.0
Cookies-remove.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.remove

Remove a cookie by name

**Signature**

```ts
declare const remove: { (name: string): (self: Cookies) => Cookies; (self: Cookies, name: string): Cookies; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L439)

Since v1.0.0
Cookies-serializeCookie.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.serializeCookie

Serialize a cookie into a string

Adapted from https://github.com/fastify/fastify-cookie under MIT License

**Signature**

```ts
declare const serializeCookie: (self: Cookie) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L593)

Since v1.0.0
Cookies-set.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.set

Add a cookie to a Cookies object

**Signature**

```ts
declare const set: { (name: string, value: string, options?: Cookie["options"]): (self: Cookies) => Either.Either<Cookies, CookiesError>; (self: Cookies, name: string, value: string, options?: Cookie["options"]): Either.Either<Cookies, CookiesError>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L482)

Since v1.0.0
Cookies-setAll.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.setAll

Add multiple cookies to a Cookies object

**Signature**

```ts
declare const setAll: { (cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): (self: Cookies) => Either.Either<Cookies, CookiesError>; (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): Either.Either<Cookies, CookiesError>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L537)

Since v1.0.0
Cookies-setAllCookie.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.setAllCookie

Add multiple cookies to a Cookies object

**Signature**

```ts
declare const setAllCookie: { (cookies: Iterable<Cookie>): (self: Cookies) => Cookies; (self: Cookies, cookies: Iterable<Cookie>): Cookies; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L401)

Since v1.0.0
Cookies-setCookie.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.setCookie

Add a cookie to a Cookies object

**Signature**

```ts
declare const setCookie: { (cookie: Cookie): (self: Cookies) => Cookies; (self: Cookies, cookie: Cookie): Cookies; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L379)

Since v1.0.0
Cookies-toCookieHeader.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.toCookieHeader

Serialize a Cookies object into a Cookie header

**Signature**

```ts
declare const toCookieHeader: (self: Cookies) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L669)

Since v1.0.0
Cookies-toRecord.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.toRecord

To record

**Signature**

```ts
declare const toRecord: (self: Cookies) => Record<string, string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L678)

Since v1.0.0
Cookies-toSetCookieHeaders.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.toSetCookieHeaders

Serialize a Cookies object into Headers object containing one or more Set-Cookie headers

**Signature**

```ts
declare const toSetCookieHeaders: (self: Cookies) => Array<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L694)

Since v1.0.0
Cookies-unsafeMakeCookie.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.unsafeMakeCookie

Create a new cookie, throwing an error if invalid

**Signature**

```ts
declare const unsafeMakeCookie: (name: string, value: string, options?: Cookie["options"] | undefined) => Cookie
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L367)

Since v1.0.0
Cookies-unsafeSet.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.unsafeSet

Add a cookie to a Cookies object

**Signature**

```ts
declare const unsafeSet: { (name: string, value: string, options?: Cookie["options"]): (self: Cookies) => Cookies; (self: Cookies, name: string, value: string, options?: Cookie["options"]): Cookies; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L509)

Since v1.0.0
Cookies-unsafeSetAll.md
Package: `@effect/platform`<br />
Module: `Cookies`<br />

## Cookies.unsafeSetAll

Add multiple cookies to a Cookies object, throwing an error if invalid

**Signature**

```ts
declare const unsafeSetAll: { (cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): (self: Cookies) => Cookies; (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): Cookies; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Cookies.ts#L569)

Since v1.0.0
Covariant-imap.md
Package: `@effect/typeclass`<br />
Module: `Covariant`<br />

## Covariant.imap

Returns a default `imap` implementation.

**Signature**

```ts
declare const imap: <F extends TypeLambda>(map: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (a: A) => B) => Kind<F, R, O, E, B>) => Invariant<F>["imap"]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Covariant.ts#L38)

Since v0.24.0
Covariant-let.md
Package: `@effect/typeclass`<br />
Module: `Covariant`<br />

## Covariant.let

**Example**

```ts
import * as covariant from "@effect/typeclass/Covariant"
import type { HKT } from "effect"
import { dual, pipe } from "effect/Function"

interface MyData<A> {
  readonly value: A
}

interface MyDataTypeLambda extends HKT.TypeLambda {
  readonly type: MyData<this["Target"]>
}

const map: covariant.Covariant<MyDataTypeLambda>["map"] = dual(
  2,
  <A, B>(self: MyData<A>, f: (a: A) => B): MyData<B> => ({ value: f(self.value) })
)

const Covariant: covariant.Covariant<MyDataTypeLambda> = { imap: covariant.imap<MyDataTypeLambda>(map), map }

const notation = {
  Do: { value: {} } as MyData<{}>,
  let: covariant.let(Covariant)
}

console.log(pipe(notation.Do, notation.let("foo", () => "bar")))
// { value: { foo: "bar" } }
```

**Signature**

```ts
declare const let: <F extends TypeLambda>(F: Covariant<F>) => { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: A) => B): <R, O, E>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, { [K in keyof A | N]: K extends keyof A ? A[K] : B; }>; <R, O, E, A extends object, N extends string, B>(self: Kind<F, R, O, E, A>, name: Exclude<N, keyof A>, f: (a: A) => B): Kind<F, R, O, E, { [K in keyof A | N]: K extends keyof A ? A[K] : B; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Covariant.ts#L134)

Since v0.24.0
Covariant-mapComposition.md
Package: `@effect/typeclass`<br />
Module: `Covariant`<br />

## Covariant.mapComposition

Returns a default `map` composition.

**Signature**

```ts
declare const mapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Covariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Covariant.ts#L24)

Since v0.24.0
Cron-equals.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.equals

Checks if two `Cron`s are equal.

**Signature**

```ts
declare const equals: { (that: Cron): (self: Cron) => boolean; (self: Cron, that: Cron): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L552)

Since v2.0.0
Cron-isCron.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.isCron

Checks if a given value is a `Cron` instance.

**Signature**

```ts
declare const isCron: (u: unknown) => u is Cron
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L112)

Since v2.0.0
Cron-isParseError.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.isParseError

Returns `true` if the specified value is an `ParseError`, `false` otherwise.

**Signature**

```ts
declare const isParseError: (u: unknown) => u is ParseError
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L218)

Since v2.0.0
Cron-make.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.make

Creates a `Cron` instance.

**Signature**

```ts
declare const make: (values: { readonly seconds?: Iterable<number> | undefined; readonly minutes: Iterable<number>; readonly hours: Iterable<number>; readonly days: Iterable<number>; readonly months: Iterable<number>; readonly weekdays: Iterable<number>; readonly tz?: DateTime.TimeZone | undefined; }) => Cron
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L120)

Since v2.0.0
Cron-match.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.match

Checks if a given `Date` falls within an active `Cron` time window.

**Throws**

`IllegalArgumentException` if the given `DateTime.Input` is invalid.

**Example**

```ts
import * as assert from "node:assert"
import { Cron, Either } from "effect"

const cron = Either.getOrThrow(Cron.parse("0 4 8-14 * *"))
assert.deepStrictEqual(Cron.match(cron, new Date("2021-01-08 04:00:00")), true)
assert.deepStrictEqual(Cron.match(cron, new Date("2021-01-08 05:00:00")), false)
```

**Signature**

```ts
declare const match: (cron: Cron, date: DateTime.DateTime.Input) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L337)

Since v2.0.0
Cron-next.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.next

Returns the next run `Date` for the given `Cron` instance.

Uses the current time as a starting point if no value is provided for `now`.

**Throws**

`IllegalArgumentException` if the given `DateTime.Input` is invalid.
`Error` if the next run date cannot be found within 10,000 iterations.

**Example**

```ts
import * as assert from "node:assert"
import { Cron, Either } from "effect"

const after = new Date("2021-01-01 00:00:00")
const cron = Either.getOrThrow(Cron.parse("0 4 8-14 * *"))
assert.deepStrictEqual(Cron.next(cron, after), new Date("2021-01-08 04:00:00"))
```

**Signature**

```ts
declare const next: (cron: Cron, startFrom?: DateTime.DateTime.Input) => Date
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L396)

Since v2.0.0
Cron-parse.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.parse

Parses a cron expression into a `Cron` instance.

**Example**

```ts
import * as assert from "node:assert"
import { Cron, Either } from "effect"

// At 04:00 on every day-of-month from 8 through 14.
assert.deepStrictEqual(Cron.parse("0 0 4 8-14 * *"), Either.right(Cron.make({
  seconds: [0],
  minutes: [0],
  hours: [4],
  days: [8, 9, 10, 11, 12, 13, 14],
  months: [],
  weekdays: []
})))
```

**Signature**

```ts
declare const parse: (cron: string, tz?: DateTime.TimeZone | string) => Either.Either<Cron, ParseError>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L242)

Since v2.0.0
Cron-ParseError.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.ParseError

Represents a checked exception which occurs when decoding fails.

**Signature**

```ts
declare class ParseError
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L202)

Since v2.0.0
Cron-sequence.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.sequence

Returns an `IterableIterator` which yields the sequence of `Date`s that match the `Cron` instance.

**Signature**

```ts
declare const sequence: (cron: Cron, startFrom?: DateTime.DateTime.Input) => IterableIterator<Date>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L523)

Since v2.0.0
Cron-unsafeParse.md
Package: `effect`<br />
Module: `Cron`<br />

## Cron.unsafeParse

Parses a cron expression into a `Cron` instance.

**Details**

This function takes a cron expression as a string and attempts to parse it
into a `Cron` instance. If the expression is valid, the resulting `Cron`
instance will represent the schedule defined by the cron expression.

If the expression is invalid, the function throws a `ParseError`.

You can optionally provide a time zone (`tz`) to interpret the cron
expression in a specific time zone. If no time zone is provided, the cron
expression will use the default time zone.

**Example**

```ts
import { Cron } from "effect"

// At 04:00 on every day-of-month from 8 through 14.
console.log(Cron.unsafeParse("0 4 8-14 * *"))
// Output:
// {
//   _id: 'Cron',
//   tz: { _id: 'Option', _tag: 'None' },
//   seconds: [ 0 ],
//   minutes: [ 0 ],
//   hours: [ 4 ],
//   days: [
//      8,  9, 10, 11,
//     12, 13, 14
//   ],
//   months: [],
//   weekdays: []
// }
```

**Signature**

```ts
declare const unsafeParse: (cron: string, tz?: DateTime.TimeZone | string) => Cron
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L317)

Since v2.0.0
Data-Class.md
Package: `effect`<br />
Module: `Data`<br />

## Data.Class

Provides a constructor for a Case Class.

**Example**

```ts
import * as assert from "node:assert"
import { Data, Equal } from "effect"

class Person extends Data.Class<{ readonly name: string }> {}

// Creating instances of Person
const mike1 = new Person({ name: "Mike" })
const mike2 = new Person({ name: "Mike" })
const john = new Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)
```

**Signature**

```ts
declare const Class: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Readonly<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L204)

Since v2.0.0
Data-Error.md
Package: `effect`<br />
Module: `Data`<br />

## Data.Error

Provides a constructor for a Case Class.

**Signature**

```ts
declare const Error: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Cause.YieldableError & Readonly<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L553)

Since v2.0.0
Data-TaggedClass.md
Package: `effect`<br />
Module: `Data`<br />

## Data.TaggedClass

Provides a Tagged constructor for a Case Class.

**Example**

```ts
import * as assert from "node:assert"
import { Data, Equal } from "effect"

class Person extends Data.TaggedClass("Person")<{ readonly name: string }> {}

// Creating instances of Person
const mike1 = new Person({ name: "Mike" })
const mike2 = new Person({ name: "Mike" })
const john = new Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)

assert.deepStrictEqual(mike1._tag, "Person")
```

**Signature**

```ts
declare const TaggedClass: <Tag extends string>(tag: Tag) => new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => Readonly<A> & { readonly _tag: Tag; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L234)

Since v2.0.0
Data-TaggedEnum.md
Package: `effect`<br />
Module: `Data`<br />

## Data.TaggedEnum

Create a tagged enum data type, which is a union of `Data` structs.

```ts
import * as assert from "node:assert"
import { Data } from "effect"

type HttpError = Data.TaggedEnum<{
  BadRequest: { readonly status: 400, readonly message: string }
  NotFound: { readonly status: 404, readonly message: string }
}>

// Equivalent to:
type HttpErrorPlain =
  | {
    readonly _tag: "BadRequest"
    readonly status: 400
    readonly message: string
  }
  | {
    readonly _tag: "NotFound"
    readonly status: 404
    readonly message: string
  }
```

**Signature**

```ts
type TaggedEnum<A> = keyof A extends infer Tag ?
  Tag extends keyof A ? Types.Simplify<{ readonly _tag: Tag } & { readonly [K in keyof A[Tag]]: A[Tag][K] }>
  : never
  : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L284)

Since v2.0.0
Data-case.md
Package: `effect`<br />
Module: `Data`<br />

## Data.case

Provides a constructor for the specified `Case`.

**Example**

```ts
import * as assert from "node:assert"
import { Data, Equal } from "effect"

interface Person {
  readonly name: string
}

// Creating a constructor for the specified Case
const Person = Data.case<Person>()

// Creating instances of Person
const mike1 = Person({ name: "Mike" })
const mike2 = Person({ name: "Mike" })
const john = Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)

```

**Signature**

```ts
declare const case: <A>() => Case.Constructor<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L146)

Since v2.0.0
Data-tagged.md
Package: `effect`<br />
Module: `Data`<br />

## Data.tagged

Provides a tagged constructor for the specified `Case`.

**Example**

```ts
import * as assert from "node:assert"
import { Data } from "effect"

interface Person {
  readonly _tag: "Person" // the tag
  readonly name: string
}

const Person = Data.tagged<Person>("Person")

const mike = Person({ name: "Mike" })

assert.deepEqual(mike, { _tag: "Person", name: "Mike" })
```

**Signature**

```ts
declare const tagged: <A extends { readonly _tag: string; }>(tag: A["_tag"]) => Case.Constructor<A, "_tag">
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L172)

Since v2.0.0
Data-taggedEnum.md
Package: `effect`<br />
Module: `Data`<br />

## Data.taggedEnum

Create a constructor for a tagged union of `Data` structs.

You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to
the constructor.

**Example**

```ts
import { Data } from "effect"

const { BadRequest, NotFound } = Data.taggedEnum<
  | { readonly _tag: "BadRequest"; readonly status: 400; readonly message: string }
  | { readonly _tag: "NotFound"; readonly status: 404; readonly message: string }
>()

const notFound = NotFound({ status: 404, message: "Not Found" })
```

**Example**

```ts
import { Data } from "effect"

type MyResult<E, A> = Data.TaggedEnum<{
  Failure: { readonly error: E }
  Success: { readonly value: A }
}>
interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {
  readonly taggedEnum: MyResult<this["A"], this["B"]>
}
const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()

const success = Success({ value: 1 })
```

**Signature**

```ts
declare const taggedEnum: { <Z extends TaggedEnum.WithGenerics<1>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A>, Tag, Extract<TaggedEnum.Kind<Z, A>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<2>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B>, Tag, Extract<TaggedEnum.Kind<Z, A, B>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<3>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B, C>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<4>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B, C, D>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C, D>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C, D>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <A extends { readonly _tag: string; }>(): TaggedEnum.Constructor<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L456)

Since v2.0.0
DateTime-DateTime.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.DateTime

A `DateTime` represents a point in time. It can optionally have a time zone
associated with it.

**Signature**

```ts
type DateTime = Utc | Zoned
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L37)

Since v3.6.0
DateTime-add.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.add

Add the given `amount` of `unit`'s to a `DateTime`.

The time zone is taken into account when adding days, weeks, months, and
years.

**Example**

```ts
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.add({ minutes: 5 })
)
```

**Signature**

```ts
declare const add: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1311)

Since v3.6.0
DateTime-addDuration.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.addDuration

Add the given `Duration` to a `DateTime`.

**Example**

```ts
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.addDuration("5 minutes")
)
```

**Signature**

```ts
declare const addDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1268)

Since v3.6.0
DateTime-distance.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.distance

Calulate the difference between two `DateTime` values, returning the number
of milliseconds the `other` DateTime is from `self`.

If `other` is *after* `self`, the result will be a positive number.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns 60000
  DateTime.distance(now, other)
})
```

**Signature**

```ts
declare const distance: { (other: DateTime): (self: DateTime) => number; (self: DateTime, other: DateTime): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L676)

Since v3.6.0
DateTime-distanceDuration.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.distanceDuration

Calulate the distance between two `DateTime` values.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Duration.minutes(1)
  DateTime.distanceDuration(now, other)
})
```

**Signature**

```ts
declare const distanceDuration: { (other: DateTime): (self: DateTime) => Duration.Duration; (self: DateTime, other: DateTime): Duration.Duration; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L731)

Since v3.6.0
DateTime-distanceDurationEither.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.distanceDurationEither

Calulate the difference between two `DateTime` values.

If the `other` DateTime is before `self`, the result will be a negative
`Duration`, returned as a `Left`.

If the `other` DateTime is after `self`, the result will be a positive
`Duration`, returned as a `Right`.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Either.right(Duration.minutes(1))
  DateTime.distanceDurationEither(now, other)

  // returns Either.left(Duration.minutes(1))
  DateTime.distanceDurationEither(other, now)
})
```

**Signature**

```ts
declare const distanceDurationEither: { (other: DateTime): (self: DateTime) => Either.Either<Duration.Duration, Duration.Duration>; (self: DateTime, other: DateTime): Either.Either<Duration.Duration, Duration.Duration>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L708)

Since v3.6.0
DateTime-endOf.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.endOf

Converts a `DateTime` to the end of the given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-01T23:59:59.999Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
  DateTime.endOf("day"),
  DateTime.formatIso
)
```

**Signature**

```ts
declare const endOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1386)

Since v3.6.0
DateTime-format.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.format

Format a `DateTime` as a string using the `DateTimeFormat` API.

The `timeZone` option is set to the offset of the time zone.

Note: On Node versions < 22, fixed "Offset" zones will set the time zone to
"UTC" and use the adjusted `Date`.

**Signature**

```ts
declare const format: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }) | undefined): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1444)

Since v3.6.0
DateTime-formatIntl.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatIntl

Format a `DateTime` as a string using the `DateTimeFormat` API.

**Signature**

```ts
declare const formatIntl: { (format: Intl.DateTimeFormat): (self: DateTime) => string; (self: DateTime, format: Intl.DateTimeFormat): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1520)

Since v3.6.0
DateTime-formatIso.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatIso

Format a `DateTime` as a UTC ISO string.

**Signature**

```ts
declare const formatIso: (self: DateTime) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1531)

Since v3.6.0
DateTime-formatIsoDate.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatIsoDate

Format a `DateTime` as a time zone adjusted ISO date string.

**Signature**

```ts
declare const formatIsoDate: (self: DateTime) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1539)

Since v3.6.0
data-BigInt-MonoidMultiply.md
Package: `@effect/typeclass`<br />
Module: `BigInt`<br />

## BigInt.MonoidMultiply

`bigint` monoid under multiplication.

The `empty` value is `1n`.

**Example**

```ts
import { MonoidMultiply } from "@effect/typeclass/data/BigInt"

console.log(MonoidMultiply.combine(2n, 3n))
// 6n
console.log(MonoidMultiply.combine(2n, MonoidMultiply.empty))
// 2n
```

**Signature**

```ts
declare const MonoidMultiply: monoid.Monoid<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/BigInt.ts#L128)

Since v0.24.0
data-BigInt-MonoidSum.md
Package: `@effect/typeclass`<br />
Module: `BigInt`<br />

## BigInt.MonoidSum

`bigint` monoid under addition.

The `empty` value is `0n`.

**Example**

```ts
import { MonoidSum } from "@effect/typeclass/data/BigInt"

console.log(MonoidSum.combine(2n, 3n))
// 5n
console.log(MonoidSum.combine(2n, MonoidSum.empty))
// 2n
```

**Signature**

```ts
declare const MonoidSum: monoid.Monoid<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/BigInt.ts#L104)

Since v0.24.0
data-BigInt-SemigroupMax.md
Package: `@effect/typeclass`<br />
Module: `BigInt`<br />

## BigInt.SemigroupMax

A `Semigroup` that uses the maximum between two values.

**Example**

```ts
import { SemigroupMax } from "@effect/typeclass/data/BigInt"

console.log(SemigroupMax.combine(2n, 3n))
// 3n
```

**Signature**

```ts
declare const SemigroupMax: semigroup.Semigroup<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/BigInt.ts#L83)

Since v0.24.0
data-BigInt-SemigroupMin.md
Package: `@effect/typeclass`<br />
Module: `BigInt`<br />

## BigInt.SemigroupMin

A `Semigroup` that uses the minimum between two values.

**Example**

```ts
import { SemigroupMin } from "@effect/typeclass/data/BigInt"

console.log(SemigroupMin.combine(2n, 3n))
// 2n
```

**Signature**

```ts
declare const SemigroupMin: semigroup.Semigroup<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/BigInt.ts#L66)

Since v0.24.0
data-BigInt-SemigroupMultiply.md
Package: `@effect/typeclass`<br />
Module: `BigInt`<br />

## BigInt.SemigroupMultiply

`bigint` semigroup under multiplication.

**Signature**

```ts
declare const SemigroupMultiply: semigroup.Semigroup<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/BigInt.ts#L34)

Since v0.24.0
data-BigInt-SemigroupSum.md
Package: `@effect/typeclass`<br />
Module: `BigInt`<br />

## BigInt.SemigroupSum

`bigint` semigroup under addition.

**Example**

```ts
import { SemigroupSum } from "@effect/typeclass/data/BigInt"

console.log(SemigroupSum.combine(2n, 3n))
// 5n
```

**Signature**

```ts
declare const SemigroupSum: semigroup.Semigroup<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/BigInt.ts#L24)

Since v0.24.0
data-Boolean-MonoidEqv.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.MonoidEqv

`boolean` monoid under equivalence.

The `empty` value is `true`.

**Signature**

```ts
declare const MonoidEqv: monoid.Monoid<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L163)

Since v0.24.0
data-Boolean-MonoidEvery.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.MonoidEvery

`boolean` monoid under conjunction, see also `SemigroupEvery`.

The `empty` value is `true`.

**Signature**

```ts
declare const MonoidEvery: monoid.Monoid<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L133)

Since v0.24.0
data-Boolean-MonoidSome.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.MonoidSome

`boolean` monoid under disjunction, see also `SemigroupSome`.

The `empty` value is `false`.

**Signature**

```ts
declare const MonoidSome: monoid.Monoid<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L143)

Since v0.24.0
data-Boolean-MonoidXor.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.MonoidXor

`boolean` monoid under exclusive disjunction, see also `SemigroupXor`.

The `empty` value is `false`.

**Signature**

```ts
declare const MonoidXor: monoid.Monoid<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L153)

Since v0.24.0
data-Boolean-SemigroupEqv.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.SemigroupEqv

`boolean` semigroup under equivalence.

**Example**

```ts
import { SemigroupEqv } from "@effect/typeclass/data/Boolean"

console.log(SemigroupEqv.combine(true, true))
// true
console.log(SemigroupEqv.combine(true, false))
// false
console.log(SemigroupEqv.combine(false, true))
// false
console.log(SemigroupEqv.combine(false, false))
// true
```

**Signature**

```ts
declare const SemigroupEqv: semigroup.Semigroup<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L123)

Since v0.24.0
data-Boolean-SemigroupEvery.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.SemigroupEvery

`boolean` semigroup under conjunction.

**Example**

```ts
import { SemigroupEvery } from "@effect/typeclass/data/Boolean"

console.log(SemigroupEvery.combine(true, true))
// true
console.log(SemigroupEvery.combine(true, false))
// false
console.log(SemigroupEvery.combine(false, true))
// false
console.log(SemigroupEvery.combine(false, false))
// false
```

**Signature**

```ts
declare const SemigroupEvery: semigroup.Semigroup<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L28)

Since v0.24.0
data-Boolean-SemigroupSome.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.SemigroupSome

`boolean` semigroup under disjunction.

**Example**

```ts
import { SemigroupSome } from "@effect/typeclass/data/Boolean"

console.log(SemigroupSome.combine(true, true))
// true
console.log(SemigroupSome.combine(true, false))
// true
console.log(SemigroupSome.combine(false, true))
// true
console.log(SemigroupSome.combine(false, false))
// false
```

**Signature**

```ts
declare const SemigroupSome: semigroup.Semigroup<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L64)

Since v0.24.0
data-Boolean-SemigroupXor.md
Package: `@effect/typeclass`<br />
Module: `Boolean`<br />

## Boolean.SemigroupXor

`boolean` semigroup under exclusive disjunction.

**Example**

```ts
import { SemigroupXor } from "@effect/typeclass/data/Boolean"

console.log(SemigroupXor.combine(true, true))
// false
console.log(SemigroupXor.combine(true, false))
// true
console.log(SemigroupXor.combine(false, true))
// true
console.log(SemigroupXor.combine(false, false))
// false
```

**Signature**

```ts
declare const SemigroupXor: semigroup.Semigroup<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Boolean.ts#L100)

Since v0.24.0
data-Number-MonoidMax.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.MonoidMax

A `Monoid` that uses the maximum between two values.

The `empty` value is `Infinity`.

**Example**

```ts
import { MonoidMax } from "@effect/typeclass/data/Number"

console.log(MonoidMax.combine(2, 3))
// 3
console.log(MonoidMax.combine(2, MonoidMax.empty))
// 2
```

**Signature**

```ts
declare const MonoidMax: monoid.Monoid<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L184)

Since v0.24.0
data-Number-MonoidMin.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.MonoidMin

A `Monoid` that uses the minimum between two values.

The `empty` value is `-Infinity`.

**Example**

```ts
import { MonoidMin } from "@effect/typeclass/data/Number"

console.log(MonoidMin.combine(2, 3))
// 2
console.log(MonoidMin.combine(2, MonoidMin.empty))
// 2
```

**Signature**

```ts
declare const MonoidMin: monoid.Monoid<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L163)

Since v0.24.0
data-Number-MonoidMultiply.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.MonoidMultiply

`number` monoid under multiplication.

The `empty` value is `1`.

**Example**

```ts
import { MonoidMultiply } from "@effect/typeclass/data/Number"

console.log(MonoidMultiply.combine(2, 3))
// 6
console.log(MonoidMultiply.combine(2, MonoidMultiply.empty))
// 2
```

**Signature**

```ts
declare const MonoidMultiply: monoid.Monoid<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L142)

Since v0.24.0
data-Number-MonoidSum.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.MonoidSum

`number` monoid under addition.

The `empty` value is `0`.

**Example**

```ts
import { MonoidSum } from "@effect/typeclass/data/Number"

console.log(MonoidSum.combine(2, 3))
// 5
console.log(MonoidSum.combine(2, MonoidSum.empty))
// 2
```

**Signature**

```ts
declare const MonoidSum: monoid.Monoid<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L121)

Since v0.24.0
data-Number-SemigroupMax.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.SemigroupMax

A `Semigroup` that uses the maximum between two values.

**Example**

```ts
import { SemigroupMax } from "@effect/typeclass/data/Number"

console.log(SemigroupMax.combine(2, 3))
// 3
```

**Signature**

```ts
declare const SemigroupMax: semigroup.Semigroup<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L100)

Since v0.24.0
data-Number-SemigroupMin.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.SemigroupMin

A `Semigroup` that uses the minimum between two values.

**Example**

```ts
import { SemigroupMin } from "@effect/typeclass/data/Number"

console.log(SemigroupMin.combine(2, 3))
// 2
```

**Signature**

```ts
declare const SemigroupMin: semigroup.Semigroup<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L83)

Since v0.24.0
data-Number-SemigroupMultiply.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.SemigroupMultiply

`number` semigroup under multiplication.

**Example**

```ts
import { SemigroupMultiply } from "@effect/typeclass/data/Number"

console.log(SemigroupMultiply.combine(2, 3))
// 6
```

**Signature**

```ts
declare const SemigroupMultiply: semigroup.Semigroup<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L51)

Since v0.24.0
data-Number-SemigroupSum.md
Package: `@effect/typeclass`<br />
Module: `Number`<br />

## Number.SemigroupSum

`number` semigroup under addition.

**Example**

```ts
import { SemigroupSum } from "@effect/typeclass/data/Number"

console.log(SemigroupSum.combine(2, 3))
// 5
```

**Signature**

```ts
declare const SemigroupSum: semigroup.Semigroup<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Number.ts#L34)

Since v0.24.0
data-Ordering-Monoid.md
Package: `@effect/typeclass`<br />
Module: `Ordering`<br />

## Ordering.Monoid

`Monoid` instance for `Ordering`, returns the left-most non-zero `Ordering`.

The `empty` value is `0`.

**Example**

```ts
import { Monoid } from "@effect/typeclass/data/Ordering"

console.log(Monoid.combine(Monoid.empty, -1))
// -1
console.log(Monoid.combine(Monoid.empty, 1))
// 1
console.log(Monoid.combine(1, -1))
// 1
```

**Signature**

```ts
declare const Monoid: monoid.Monoid<Ordering>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Ordering.ts#L64)

Since v0.24.0
data-Ordering-Semigroup.md
Package: `@effect/typeclass`<br />
Module: `Ordering`<br />

## Ordering.Semigroup

`Semigroup` instance for `Ordering`, returns the left-most non-zero `Ordering`.

**Example**

```ts
import { Semigroup } from "@effect/typeclass/data/Ordering"

console.log(Semigroup.combine(0, -1))
// -1
console.log(Semigroup.combine(0, 1))
// 1
console.log(Semigroup.combine(1, -1))
// 1
```

**Signature**

```ts
declare const Semigroup: semigroup.Semigroup<Ordering>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Ordering.ts#L27)

Since v0.24.0
data-Record-getMonoidUnion.md
Package: `@effect/typeclass`<br />
Module: `Record`<br />

## Record.getMonoidUnion

A `Monoid` that creates a union of two records.

It allows combining two records where values for matching keys are combined using the provided `Monoid` instance.
If a key exists in only one of the records, that key-value pair is included as is in the resulting record.

The `empty` value for this `Monoid` is an empty record `{}`.

**Example**

```ts
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getMonoidUnion } from "@effect/typeclass/data/Record"

const monoid = getMonoidUnion(NumberInstances.MonoidSum)

console.log(monoid.combine({ a: 1 }, { a: 1, b: 3 }))
// { a: 2, b: 3 }

console.log(monoid.combine({ a: 1 }, monoid.empty))
// { a: 1 }
```

**Signature**

```ts
declare const getMonoidUnion: <A>(value: monoid.Monoid<A>) => monoid.Monoid<Record.ReadonlyRecord<string, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Record.ts#L260)

Since v0.29.4
data-Record-getSemigroupIntersection.md
Package: `@effect/typeclass`<br />
Module: `Record`<br />

## Record.getSemigroupIntersection

A `Semigroup` that creates an intersection of two records.

This `Semigroup` takes two records and combines them into a new record containing only the keys that are present in both records.
The values for matching keys are combined using the provided `Semigroup` instance.

**Example**

```ts
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getSemigroupIntersection } from "@effect/typeclass/data/Record"

console.log(getSemigroupIntersection(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
// { a: 2 }
```

**Signature**

```ts
declare const getSemigroupIntersection: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Record.ts#L284)

Since v0.29.4
data-Record-getSemigroupUnion.md
Package: `@effect/typeclass`<br />
Module: `Record`<br />

## Record.getSemigroupUnion

A `Semigroup` that creates a union of two records.

This `Semigroup` takes two records and combines them into a single record.
If a key exists in both records, the provided `Semigroup` instance is used to combine the values for that key.
If a key exists in only one of the records, that key-value pair is included as is in the resulting record.

For example, when using the `MonoidSum`, values for matching keys will be summed.

**Example**

```ts
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getSemigroupUnion } from "@effect/typeclass/data/Record"

console.log(getSemigroupUnion(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
// { a: 2, b: 3 }
```

**Signature**

```ts
declare const getSemigroupUnion: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Record.ts#L229)

Since v0.29.4
data-String-Monoid.md
Package: `@effect/typeclass`<br />
Module: `String`<br />

## String.Monoid

`string` monoid under concatenation.

The `empty` value is `''`.

**Signature**

```ts
declare const Monoid: monoid.Monoid<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/String.ts#L23)

Since v0.24.0
data-String-Semigroup.md
Package: `@effect/typeclass`<br />
Module: `String`<br />

## String.Semigroup

`string` semigroup under concatenation.

**Signature**

```ts
declare const Semigroup: semigroup.Semigroup<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/String.ts#L13)

Since v0.24.0
DateTime-formatIsoDateUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatIsoDateUtc

Format a `DateTime` as a UTC ISO date string.

**Signature**

```ts
declare const formatIsoDateUtc: (self: DateTime) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1547)

Since v3.6.0
DateTime-formatIsoOffset.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatIsoOffset

Format a `DateTime.Zoned` as a ISO string with an offset.

**Signature**

```ts
declare const formatIsoOffset: (self: DateTime) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1555)

Since v3.6.0
DateTime-formatIsoZoned.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatIsoZoned

Format a `DateTime.Zoned` as a string.

It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.

**Signature**

```ts
declare const formatIsoZoned: (self: Zoned) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1565)

Since v3.6.0
DateTime-formatLocal.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatLocal

Format a `DateTime` as a string using the `DateTimeFormat` API.

It will use the system's local time zone & locale.

**Signature**

```ts
declare const formatLocal: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }) | undefined): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1470)

Since v3.6.0
DateTime-formatUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.formatUtc

Format a `DateTime` as a string using the `DateTimeFormat` API.

This forces the time zone to be UTC.

**Signature**

```ts
declare const formatUtc: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }) | undefined): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1496)

Since v3.6.0
DateTime-getPart.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.getPart

Get a part of a `DateTime` as a number.

The part will be time zone adjusted.

**Example**

```ts
import * as assert from "node:assert"
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })
const year = DateTime.getPart(now, "year")
assert.strictEqual(year, 2024)
```

**Signature**

```ts
declare const getPart: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L954)

Since v3.6.0
DateTime-getPartUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.getPartUtc

Get a part of a `DateTime` as a number.

The part will be in the UTC time zone.

**Example**

```ts
import * as assert from "node:assert"
import { DateTime } from "effect"

const now = DateTime.unsafeMake({ year: 2024 })
const year = DateTime.getPartUtc(now, "year")
assert.strictEqual(year, 2024)
```

**Signature**

```ts
declare const getPartUtc: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L932)

Since v3.6.0
DateTime-layerCurrentZone.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.layerCurrentZone

Create a Layer from the given time zone.

**Signature**

```ts
declare const layerCurrentZone: (zone: TimeZone) => Layer.Layer<CurrentTimeZone>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1573)

Since v3.6.0
DateTime-layerCurrentZoneLocal.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.layerCurrentZoneLocal

Create a Layer from the systems local time zone.

**Signature**

```ts
declare const layerCurrentZoneLocal: Layer.Layer<CurrentTimeZone, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1601)

Since v3.6.0
DateTime-layerCurrentZoneNamed.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.layerCurrentZoneNamed

Create a Layer from the given IANA time zone identifier.

**Signature**

```ts
declare const layerCurrentZoneNamed: (zoneId: string) => Layer.Layer<CurrentTimeZone, IllegalArgumentException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1590)

Since v3.6.0
DateTime-layerCurrentZoneOffset.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.layerCurrentZoneOffset

Create a Layer from the given time zone offset.

**Signature**

```ts
declare const layerCurrentZoneOffset: (offset: number) => Layer.Layer<CurrentTimeZone>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1581)

Since v3.6.0
DateTime-make.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.make

Create a `DateTime` from one of the following:

- A `DateTime`
- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
- The `number` of milliseconds since the Unix epoch
- An object with the parts of a date
- A `string` that can be parsed by `Date.parse`

If the input is invalid, `None` will be returned.

**Example**

```ts
import { DateTime } from "effect"

// from Date
DateTime.make(new Date())

// from parts
DateTime.make({ year: 2024 })

// from string
DateTime.make("2024-01-01")
```

**Signature**

```ts
declare const make: <A extends DateTime.Input>(input: A) => Option.Option<DateTime.PreserveZone<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L400)

Since v3.6.0
DateTime-makeZoned.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.makeZoned

Create a `DateTime.Zoned` using `DateTime.make` and a time zone.

The input is treated as UTC and then the time zone is attached.

If the date time input or time zone is invalid, `None` will be returned.

**Example**

```ts
import { DateTime } from "effect"

DateTime.makeZoned(new Date(), { timeZone: "Europe/London" })
```

**Signature**

```ts
declare const makeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Option.Option<Zoned>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L365)

Since v3.6.0
DateTime-makeZonedFromString.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.makeZonedFromString

Create a `DateTime.Zoned` from a string.

It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.

**Signature**

```ts
declare const makeZonedFromString: (input: string) => Option.Option<Zoned>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L410)

Since v3.6.0
DateTime-mapEpochMillis.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.mapEpochMillis

Transform a `DateTime` by applying a function to the number of milliseconds
since the Unix epoch.

**Example**

```ts
import { DateTime } from "effect"

// add 10 milliseconds
DateTime.unsafeMake(0).pipe(
  DateTime.mapEpochMillis((millis) => millis + 10)
)
```

**Signature**

```ts
declare const mapEpochMillis: { (f: (millis: number) => number): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (millis: number) => number): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1187)

Since v3.6.0
DateTime-mutate.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.mutate

Modify a `DateTime` by applying a function to a cloned `Date` instance.

The `Date` will first have the time zone applied if possible, and then be
converted back to a `DateTime` within the same time zone.

**Signature**

```ts
declare const mutate: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1155)

Since v3.6.0
DateTime-mutateUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.mutateUtc

Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.

**Signature**

```ts
declare const mutateUtc: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1166)

Since v3.6.0
DateTime-nearest.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.nearest

Converts a `DateTime` to the nearest given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-02T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:01:00Z").pipe(
  DateTime.nearest("day"),
  DateTime.formatIso
)
```

**Signature**

```ts
declare const nearest: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1417)

Since v3.6.0
DateTime-now.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.now

Get the current time using the `Clock` service and convert it to a `DateTime`.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
})
```

**Signature**

```ts
declare const now: Effect.Effect<Utc, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L426)

Since v3.6.0
DateTime-nowAsDate.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.nowAsDate

Get the current time using the `Clock` service.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.nowAsDate
})
```

**Signature**

```ts
declare const nowAsDate: Effect.Effect<Date, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L442)

Since v3.14.0
DateTime-nowInCurrentZone.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.nowInCurrentZone

Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```

**Signature**

```ts
declare const nowInCurrentZone: Effect.Effect<Zoned, never, CurrentTimeZone>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1140)

Since v3.6.0
DateTime-removeTime.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.removeTime

Remove the time aspect of a `DateTime`, first adjusting for the time
zone. It will return a `DateTime.Utc` only containing the date.

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-01T00:00:00Z"
DateTime.unsafeMakeZoned("2024-01-01T05:00:00Z", {
  timeZone: "Pacific/Auckland",
  adjustForTimeZone: true
}).pipe(
  DateTime.removeTime,
  DateTime.formatIso
)
```

**Signature**

```ts
declare const removeTime: (self: DateTime) => Utc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L889)

Since v3.6.0
DateTime-setParts.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.setParts

Set the different parts of a `DateTime` as an object.

The Date will be time zone adjusted.

**Signature**

```ts
declare const setParts: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L967)

Since v3.6.0
DateTime-setPartsUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.setPartsUtc

Set the different parts of a `DateTime` as an object.

**Signature**

```ts
declare const setPartsUtc: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L978)

Since v3.6.0
DateTime-setZone.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.setZone

Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

  // set the time zone
  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)
})
```

**Signature**

```ts
declare const setZone: { (zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L491)

Since v3.6.0
DateTime-setZoneCurrent.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.setZoneCurrent

Set the time zone of a `DateTime` to the current time zone, which is
determined by the `CurrentTimeZone` service.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the time zone to "Europe/London"
  const zoned = yield* DateTime.setZoneCurrent(now)
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```

**Signature**

```ts
declare const setZoneCurrent: (self: DateTime) => Effect.Effect<Zoned, never, CurrentTimeZone>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1011)

Since v3.6.0
DateTime-setZoneNamed.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.setZoneNamed

Set the time zone of a `DateTime` from an IANA time zone identifier. If the
time zone is invalid, `None` will be returned.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  // set the time zone, returns an Option
  DateTime.setZoneNamed(now, "Europe/London")
})
```

**Signature**

```ts
declare const setZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Option.Option<Zoned>; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Option.Option<Zoned>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L616)

Since v3.6.0
DateTime-setZoneOffset.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.setZoneOffset

Add a fixed offset time zone to a `DateTime`.

The offset is in milliseconds.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the offset time zone in milliseconds
  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)
})
```

**Signature**

```ts
declare const setZoneOffset: { (offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L519)

Since v3.6.0
DateTime-startOf.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.startOf

Converts a `DateTime` to the start of the given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-01T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
  DateTime.startOf("day"),
  DateTime.formatIso
)
```

**Signature**

```ts
declare const startOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1355)

Since v3.6.0
DateTime-subtract.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.subtract

Subtract the given `amount` of `unit`'s from a `DateTime`.

**Example**

```ts
import { DateTime } from "effect"

// subtract 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.subtract({ minutes: 5 })
)
```

**Signature**

```ts
declare const subtract: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1331)

Since v3.6.0
DateTime-subtractDuration.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.subtractDuration

Subtract the given `Duration` from a `DateTime`.

**Example**

```ts
import { DateTime } from "effect"

// subtract 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.subtractDuration("5 minutes")
)
```

**Signature**

```ts
declare const subtractDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1288)

Since v3.6.0
DateTime-toDate.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.toDate

Convert a `DateTime` to a `Date`, applying the time zone first.

**Signature**

```ts
declare const toDate: (self: DateTime) => Date
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L841)

Since v3.6.0
DateTime-toDateUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.toDateUtc

Get the UTC `Date` of a `DateTime`.

**Signature**

```ts
declare const toDateUtc: (self: DateTime) => Date
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L833)

Since v3.6.0
DateTime-toEpochMillis.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.toEpochMillis

Get the milliseconds since the Unix epoch of a `DateTime`.

**Signature**

```ts
declare const toEpochMillis: (self: DateTime) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L867)

Since v3.6.0
DateTime-toParts.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.toParts

Get the different parts of a `DateTime` as an object.

The parts will be time zone adjusted.

**Signature**

```ts
declare const toParts: (self: DateTime) => DateTime.PartsWithWeekday
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L903)

Since v3.6.0
DateTime-toPartsUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.toPartsUtc

Get the different parts of a `DateTime` as an object.

The parts will be in UTC.

**Signature**

```ts
declare const toPartsUtc: (self: DateTime) => DateTime.PartsWithWeekday
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L913)

Since v3.6.0
DateTime-toUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.toUtc

For a `DateTime` returns a new `DateTime.Utc`.

**Example**

```ts
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })

// set as UTC
const utc: DateTime.Utc = DateTime.toUtc(now)
```

**Signature**

```ts
declare const toUtc: (self: DateTime) => Utc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L471)

Since v3.13.0
DateTime-unsafeFromDate.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.unsafeFromDate

Create a `DateTime` from a `Date`.

If the `Date` is invalid, an `IllegalArgumentException` will be thrown.

**Signature**

```ts
declare const unsafeFromDate: (date: Date) => Utc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L299)

Since v3.6.0
DateTime-unsafeMake.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.unsafeMake

Create a `DateTime` from one of the following:

- A `DateTime`
- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
- The `number` of milliseconds since the Unix epoch
- An object with the parts of a date
- A `string` that can be parsed by `Date.parse`

**Example**

```ts
import { DateTime } from "effect"

// from Date
DateTime.unsafeMake(new Date())

// from parts
DateTime.unsafeMake({ year: 2024 })

// from string
DateTime.unsafeMake("2024-01-01")
```

**Signature**

```ts
declare const unsafeMake: <A extends DateTime.Input>(input: A) => DateTime.PreserveZone<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L326)

Since v3.6.0
DateTime-unsafeMakeZoned.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.unsafeMakeZoned

Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone.

The input is treated as UTC and then the time zone is attached, unless
`adjustForTimeZone` is set to `true`. In that case, the input is treated as
already in the time zone.

**Example**

```ts
import { DateTime } from "effect"

DateTime.unsafeMakeZoned(new Date(), { timeZone: "Europe/London" })
```

**Signature**

```ts
declare const unsafeMakeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Zoned
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L344)

Since v3.6.0
DateTime-unsafeNow.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.unsafeNow

Get the current time using `Date.now`.

**Signature**

```ts
declare const unsafeNow: LazyArg<Utc>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L450)

Since v3.6.0
DateTime-unsafeSetZoneNamed.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.unsafeSetZoneNamed

Set the time zone of a `DateTime` from an IANA time zone identifier. If the
time zone is invalid, an `IllegalArgumentException` will be thrown.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  // set the time zone
  DateTime.unsafeSetZoneNamed(now, "Europe/London")
})
```

**Signature**

```ts
declare const unsafeSetZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L642)

Since v3.6.0
DateTime-withCurrentZone.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.withCurrentZone

Provide the `CurrentTimeZone` to an effect.

**Example**

```ts
import { DateTime, Effect } from "effect"

const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

Effect.gen(function* () {
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZone(zone))
```

**Signature**

```ts
declare const withCurrentZone: { (zone: TimeZone): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: TimeZone): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1030)

Since v3.6.0
DateTime-withCurrentZoneLocal.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.withCurrentZoneLocal

Provide the `CurrentTimeZone` to an effect, using the system's local time
zone.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneLocal)
```

**Signature**

```ts
declare const withCurrentZoneLocal: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1059)

Since v3.6.0
DateTime-withCurrentZoneNamed.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.withCurrentZoneNamed

Provide the `CurrentTimeZone` to an effect using an IANA time zone
identifier.

If the time zone is invalid, it will fail with an `IllegalArgumentException`.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```

**Signature**

```ts
declare const withCurrentZoneNamed: { (zone: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: string): Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1108)

Since v3.6.0
DateTime-withCurrentZoneOffset.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.withCurrentZoneOffset

Provide the `CurrentTimeZone` to an effect, using a offset.

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))
```

**Signature**

```ts
declare const withCurrentZoneOffset: { (offset: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, offset: number): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1079)

Since v3.6.0
DateTime-withDate.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.withDate

Using the time zone adjusted `Date`, apply a function to the `Date` and
return the result.

**Example**

```ts
import { DateTime } from "effect"

// get the time zone adjusted date in milliseconds
DateTime.unsafeMakeZoned(0, { timeZone: "Europe/London" }).pipe(
  DateTime.withDate((date) => date.getTime())
)
```

**Signature**

```ts
declare const withDate: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1208)

Since v3.6.0
DateTime-withDateUtc.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.withDateUtc

Using the time zone adjusted `Date`, apply a function to the `Date` and
return the result.

**Example**

```ts
import { DateTime } from "effect"

// get the date in milliseconds
DateTime.unsafeMake(0).pipe(
  DateTime.withDateUtc((date) => date.getTime())
)
```

**Signature**

```ts
declare const withDateUtc: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1229)

Since v3.6.0
DateTime-zonedOffset.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zonedOffset

Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.

**Signature**

```ts
declare const zonedOffset: (self: Zoned) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L849)

Since v3.6.0
DateTime-zonedOffsetIso.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zonedOffsetIso

Calculate the time zone offset of a `DateTime` in milliseconds.

The offset is formatted as "HH:MM".

**Signature**

```ts
declare const zonedOffsetIso: (self: Zoned) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L859)

Since v3.6.0
DateTime-zoneFromString.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zoneFromString

Try parse a TimeZone from a string

**Signature**

```ts
declare const zoneFromString: (zone: string) => Option.Option<TimeZone>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L579)

Since v3.6.0
DateTime-zoneMakeLocal.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zoneMakeLocal

Create a named time zone from the system's local time zone.

**Signature**

```ts
declare const zoneMakeLocal: () => TimeZone.Named
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L571)

Since v3.6.0
DateTime-zoneMakeNamed.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zoneMakeNamed

Create a named time zone from a IANA time zone identifier. If the time zone
is invalid, `None` will be returned.

**Signature**

```ts
declare const zoneMakeNamed: (zoneId: string) => Option.Option<TimeZone.Named>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L553)

Since v3.6.0
DateTime-zoneMakeNamedEffect.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zoneMakeNamedEffect

Create a named time zone from a IANA time zone identifier. If the time zone
is invalid, it will fail with an `IllegalArgumentException`.

**Signature**

```ts
declare const zoneMakeNamedEffect: (zoneId: string) => Effect.Effect<TimeZone.Named, IllegalArgumentException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L562)

Since v3.6.0
DateTime-zoneMakeOffset.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zoneMakeOffset

Create a fixed offset time zone.

**Signature**

```ts
declare const zoneMakeOffset: (offset: number) => TimeZone.Offset
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L544)

Since v3.6.0
DateTime-zoneToString.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zoneToString

Format a `TimeZone` as a string.

**Example**

```ts
import { DateTime, Effect } from "effect"

// Outputs "+03:00"
DateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))

// Outputs "Europe/London"
DateTime.zoneToString(DateTime.zoneUnsafeMakeNamed("Europe/London"))
```

**Signature**

```ts
declare const zoneToString: (self: TimeZone) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L597)

Since v3.6.0
DateTime-zoneUnsafeMakeNamed.md
Package: `effect`<br />
Module: `DateTime`<br />

## DateTime.zoneUnsafeMakeNamed

Attempt to create a named time zone from a IANA time zone identifier.

If the time zone is invalid, an `IllegalArgumentException` will be thrown.

**Signature**

```ts
declare const zoneUnsafeMakeNamed: (zoneId: string) => TimeZone.Named
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L536)

Since v3.6.0
Deferred-Deferred.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.Deferred

A `Deferred` represents an asynchronous variable that can be set exactly
once, with the ability for an arbitrary number of fibers to suspend (by
calling `Deferred.await`) and automatically resume when the variable is set.

`Deferred` can be used for building primitive actions whose completions
require the coordinated action of multiple fibers, and for building
higher-level concurrent or asynchronous structures.

**Signature**

```ts
export interface Deferred<in out A, in out E = never> extends Effect.Effect<A, E>, Deferred.Variance<A, E> {
  /** @internal */
  readonly state: MutableRef.MutableRef<internal.State<A, E>>
  /** @internal */
  readonly blockingOn: FiberId.FiberId
  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: DeferredUnify<this>
  readonly [Unify.ignoreSymbol]?: DeferredUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L40)

Since v2.0.0
Deferred-await.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.await

Retrieves the value of the `Deferred`, suspending the fiber running the
workflow until the result is available.

**Signature**

```ts
declare const await: <A, E>(self: Deferred<A, E>) => Effect.Effect<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L108)

Since v2.0.0
Deferred-complete.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.complete

Completes the deferred with the result of the specified effect. If the
deferred has already been completed, the method will produce false.

Note that `Deferred.completeWith` will be much faster, so consider using
that if you do not need to memoize the result of the specified effect.

**Signature**

```ts
declare const complete: { <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L121)

Since v2.0.0
Deferred-completeWith.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.completeWith

Completes the deferred with the result of the specified effect. If the
deferred has already been completed, the method will produce false.

**Signature**

```ts
declare const completeWith: { <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L133)

Since v2.0.0
Deferred-die.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.die

Kills the `Deferred` with the specified defect, which will be propagated to
all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const die: { (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, defect: unknown): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L205)

Since v2.0.0
Deferred-dieSync.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.dieSync

Kills the `Deferred` with the specified defect, which will be propagated to
all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const dieSync: { (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L217)

Since v2.0.0
Deferred-done.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.done

Exits the `Deferred` with the specified `Exit` value, which will be
propagated to all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const done: { <A, E>(exit: Exit.Exit<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, exit: Exit.Exit<A, E>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L145)

Since v2.0.0
Deferred-fail.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.fail

Fails the `Deferred` with the specified error, which will be propagated to
all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const fail: { <E>(error: E): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, error: E): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L157)

Since v2.0.0
Deferred-failCause.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.failCause

Fails the `Deferred` with the specified `Cause`, which will be propagated to
all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const failCause: { <E>(cause: Cause.Cause<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, cause: Cause.Cause<E>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L181)

Since v2.0.0
Deferred-failCauseSync.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.failCauseSync

Fails the `Deferred` with the specified `Cause`, which will be propagated to
all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const failCauseSync: { <E>(evaluate: LazyArg<Cause.Cause<E>>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L193)

Since v2.0.0
Deferred-failSync.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.failSync

Fails the `Deferred` with the specified error, which will be propagated to
all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const failSync: { <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L169)

Since v2.0.0
Deferred-interrupt.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.interrupt

Completes the `Deferred` with interruption. This will interrupt all fibers
waiting on the value of the `Deferred` with the `FiberId` of the fiber
calling this method.

**Signature**

```ts
declare const interrupt: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L230)

Since v2.0.0
Deferred-interruptWith.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.interruptWith

Completes the `Deferred` with interruption. This will interrupt all fibers
waiting on the value of the `Deferred` with the specified `FiberId`.

**Signature**

```ts
declare const interruptWith: { (fiberId: FiberId.FiberId): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, fiberId: FiberId.FiberId): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L239)

Since v2.0.0
Deferred-isDone.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.isDone

Returns `true` if this `Deferred` has already been completed with a value or
an error, `false` otherwise.

**Signature**

```ts
declare const isDone: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L251)

Since v2.0.0
Deferred-make.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.make

Creates a new `Deferred`.

**Signature**

```ts
declare const make: <A, E = never>() => Effect.Effect<Deferred<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L88)

Since v2.0.0
Deferred-makeAs.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.makeAs

Creates a new `Deferred` from the specified `FiberId`.

**Signature**

```ts
declare const makeAs: <A, E = never>(fiberId: FiberId.FiberId) => Effect.Effect<Deferred<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L96)

Since v2.0.0
Deferred-poll.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.poll

Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has
already been completed, `None` otherwise.

**Signature**

```ts
declare const poll: <A, E>(self: Deferred<A, E>) => Effect.Effect<Option.Option<Effect.Effect<A, E>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L260)

Since v2.0.0
Deferred-succeed.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.succeed

Completes the `Deferred` with the specified value.

**Signature**

```ts
declare const succeed: { <A>(value: A): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, value: A): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L270)

Since v2.0.0
Deferred-sync.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.sync

Completes the `Deferred` with the specified lazily evaluated value.

**Signature**

```ts
declare const sync: { <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L281)

Since v2.0.0
Deferred-unsafeDone.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.unsafeDone

Unsafely exits the `Deferred` with the specified `Exit` value, which will be
propagated to all fibers waiting on the value of the `Deferred`.

**Signature**

```ts
declare const unsafeDone: <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L301)

Since v2.0.0
Deferred-unsafeMake.md
Package: `effect`<br />
Module: `Deferred`<br />

## Deferred.unsafeMake

Unsafely creates a new `Deferred` from the specified `FiberId`.

**Signature**

```ts
declare const unsafeMake: <A, E = never>(fiberId: FiberId.FiberId) => Deferred<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L292)

Since v2.0.0
Differ-Differ.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.Differ

A `Differ<Value, Patch>` knows how to compare an old value and new value of
type `Value` to produce a patch of type `Patch` that describes the
differences between those values. A `Differ` also knows how to apply a patch
to an old value to produce a new value that represents the old value updated
with the changes described by the patch.

A `Differ` can be used to construct a `FiberRef` supporting compositional
updates using the `FiberRef.makePatch` constructor.

The `Differ` companion object contains constructors for `Differ` values for
common data types such as `Chunk`, `HashMap`, and `HashSet``. In addition,
`Differ`values can be transformed using the `transform` operator and combined
using the `orElseEither` and `zip` operators. This allows creating `Differ`
values for arbitrarily complex data types compositionally.

**Signature**

```ts
export interface Differ<in out Value, in out Patch> extends Pipeable {
  readonly [TypeId]: {
    readonly _V: Types.Invariant<Value>
    readonly _P: Types.Invariant<Patch>
  }
  readonly empty: Patch
  diff(oldValue: Value, newValue: Value): Patch
  combine(first: Patch, second: Patch): Patch
  patch(patch: Patch, oldValue: Value): Value
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L52)

Since v2.0.0
Differ-chunk.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.chunk

Constructs a differ that knows how to diff a `Chunk` of values given a
differ that knows how to diff the values.

**Signature**

```ts
declare const chunk: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<Chunk<Value>, Differ.Chunk.Patch<Value, Patch>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L334)

Since v2.0.0
Differ-combine.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.combine

Combines two patches to produce a new patch that describes the updates of
the first patch and then the updates of the second patch. The combine
operation should be associative. In addition, if the combine operation is
commutative then joining multiple fibers concurrently will result in
deterministic `FiberRef` values.

**Signature**

```ts
declare const combine: { <Patch>(first: Patch, second: Patch): <Value>(self: Differ<Value, Patch>) => Patch; <Value, Patch>(self: Differ<Value, Patch>, first: Patch, second: Patch): Patch; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L260)

Since v2.0.0
Differ-empty.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.empty

An empty patch that describes no changes.

**Signature**

```ts
declare const empty: <Value, Patch>(self: Differ<Value, Patch>) => Patch
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L224)

Since v2.0.0
Differ-environment.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.environment

Constructs a differ that knows how to diff `Env` values.

**Signature**

```ts
declare const environment: <A>() => Differ<Context<A>, Differ.Context.Patch<A, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L322)

Since v2.0.0
Differ-hashMap.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.hashMap

Constructs a differ that knows how to diff a `HashMap` of keys and values given
a differ that knows how to diff the values.

**Signature**

```ts
declare const hashMap: <Key, Value, Patch>(differ: Differ<Value, Patch>) => Differ<HashMap<Key, Value>, Differ.HashMap.Patch<Key, Value, Patch>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L345)

Since v2.0.0
Differ-hashSet.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.hashSet

Constructs a differ that knows how to diff a `HashSet` of values.

**Signature**

```ts
declare const hashSet: <Value>() => Differ<HashSet<Value>, Differ.HashSet.Patch<Value>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L355)

Since v2.0.0
Differ-make.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.make

Constructs a new `Differ`.

**Signature**

```ts
declare const make: <Value, Patch>(params: { readonly empty: Patch; readonly diff: (oldValue: Value, newValue: Value) => Patch; readonly combine: (first: Patch, second: Patch) => Patch; readonly patch: (patch: Patch, oldValue: Value) => Value; }) => Differ<Value, Patch>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L309)

Since v2.0.0
Differ-orElseEither.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.orElseEither

Combines this differ and the specified differ to produce a differ that
knows how to diff the sum of their values.

**Signature**

```ts
declare const orElseEither: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L366)

Since v2.0.0
Differ-patch.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.patch

Applies a patch to an old value to produce a new value that is equal to the
old value with the updates described by the patch.

**Signature**

```ts
declare const patch: { <Patch, Value>(patch: Patch, oldValue: Value): (self: Differ<Value, Patch>) => Value; <Patch, Value>(self: Differ<Value, Patch>, patch: Patch, oldValue: Value): Value; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L285)

Since v2.0.0
Differ-readonlyArray.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.readonlyArray

Constructs a differ that knows how to diff a `ReadonlyArray` of values.

**Signature**

```ts
declare const readonlyArray: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<ReadonlyArray<Value>, Differ.ReadonlyArray.Patch<Value, Patch>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L388)

Since v2.0.0
Differ-transform.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.transform

Transforms the type of values that this differ knows how to differ using
the specified functions that map the new and old value types to each other.

**Signature**

```ts
declare const transform: { <Value, Value2>(options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): <Patch>(self: Differ<Value, Patch>) => Differ<Value2, Patch>; <Value, Patch, Value2>(self: Differ<Value, Patch>, options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): Differ<Value2, Patch>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L398)

Since v2.0.0
Differ-update.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.update

Constructs a differ that just diffs two values by returning a function that
sets the value to the new value. This differ does not support combining
multiple updates to the value compositionally and should only be used when
there is no compositional way to update them.

**Signature**

```ts
declare const update: <A>() => Differ<A, (a: A) => A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L420)

Since v2.0.0
Differ-updateWith.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.updateWith

A variant of `update` that allows specifying the function that will be used
to combine old values with new values.

**Signature**

```ts
declare const updateWith: <A>(f: (x: A, y: A) => A) => Differ<A, (a: A) => A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L428)

Since v2.0.0
Differ-zip.md
Package: `effect`<br />
Module: `Differ`<br />

## Differ.zip

Combines this differ and the specified differ to produce a new differ that
knows how to diff the product of their values.

**Signature**

```ts
declare const zip: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L436)

Since v2.0.0
Doc-Annotated.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Annotated

Represents a document with an associated annotation.

**Signature**

```ts
export interface Annotated<A> extends Doc.Variance<A> {
  readonly _tag: "Annotated"
  readonly annotation: A
  readonly doc: Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L302)

Since v1.0.0
Doc-align.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.align

The `align` combinator lays out a document with the nesting level set to the
current column.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

// As an example, the documents below will be placed one above the other
// regardless of the current nesting level

// Without `align`ment, the second line is simply placed below everything
// that has been laid out so far
const unaligned = Doc.hsep([
  Doc.text("lorem"),
  Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")])
])

assert.strictEqual(
  Doc.render(unaligned, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor`
  )
)

// With `align`ment, the `vsep`ed documents all start at the same column
const aligned = Doc.hsep([
  Doc.text("lorem"),
  Doc.align(Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")]))
])

assert.strictEqual(
  Doc.render(aligned, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |      dolor`
  )
)
```

**Signature**

```ts
declare const align: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1715)

Since v1.0.0
Doc-alterAnnotations.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.alterAnnotations

Change the annotations of a document. Individual annotations can be removed,
changed, or replaced by multiple ones.

This is a general function that combines `unAnnotate` and `reAnnotate`, and
is useful for mapping semantic annotations (such as this is a keyword) to
display annotations (such as this is red and underlined) because some
backends may not care about certain annotations while others may.

Annotations earlier in the new list will be applied earlier, so returning
`[Bold, Green]` will result in a bold document that contains green text, and
not vice versa.

Since this traverses the entire document tree, including the parts that are
not rendered (due to other layouts having better fit), it is preferable to
reannotate a document **after** producing the layout by using
`alterAnnotations` from the `SimpleDocStream` module.

**Signature**

```ts
declare const alterAnnotations: { <A, B>(f: (a: A) => Iterable<B>): (self: Doc<A>) => Doc<B>; <A, B>(self: Doc<A>, f: (a: A) => Iterable<B>): Doc<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2088)

Since v1.0.0
Doc-angleBracketed.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.angleBracketed

Encloses the input document in angle brackets (`<>`).

**Signature**

```ts
declare const angleBracketed: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2288)

Since v1.0.0
Doc-annotate.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.annotate

Adds an annotation to a `Doc`. The annotation can then be used by the rendering
algorithm to, for example, add color to certain parts of the output.

**Note** This function is relevant only for custom formats with their own annotations,
and is not relevant for basic pretty printing.

**Signature**

```ts
declare const annotate: { <A>(annotation: A): (self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, annotation: A): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2062)

Since v1.0.0
Doc-backslash.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.backslash

A document containing a single `\` character.

**Signature**

```ts
declare const backslash: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L711)

Since v1.0.0
Doc-cat.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.cat

The `cat` combinator lays out two documents separated by nothing.

**Signature**

```ts
declare const cat: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L867)

Since v1.0.0
Doc-Cat.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Cat

Represents the concatenation of two documents.

**Signature**

```ts
export interface Cat<A> extends Doc.Variance<A> {
  readonly _tag: "Cat"
  readonly left: Doc<A>
  readonly right: Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L216)

Since v1.0.0
Doc-Char.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Char

Represents a document containing a single character.

**Invariants**
- Cannot be the newline (`"\n"`) character

**Signature**

```ts
export interface Char<A> extends Doc.Variance<A> {
  readonly _tag: "Char"
  readonly char: string
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L163)

Since v1.0.0
Doc-Column.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Column

Represents a document that reacts to the current cursor position.

**Signature**

```ts
export interface Column<A> extends Doc.Variance<A> {
  readonly _tag: "Column"
  readonly react: (position: number) => Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L258)

Since v1.0.0
Doc-Doc.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Doc

Represents a prettified document that has been annotated with data of type
`A`.

**Signature**

```ts
type Doc<A> = | Fail<A>
  | Empty<A>
  | Char<A>
  | Text<A>
  | Line<A>
  | FlatAlt<A>
  | Cat<A>
  | Nest<A>
  | Union<A>
  | Column<A>
  | WithPageWidth<A>
  | Nesting<A>
  | Annotated<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L56)

Since v1.0.0
Doc-Empty.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Empty

Represents the empty document.

Conceptually, the `Empty` document can be thought of as the unit of `Cat`.

**Signature**

```ts
export interface Empty<A> extends Doc.Variance<A> {
  readonly _tag: "Empty"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L150)

Since v1.0.0
Doc-Fail.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Fail

Represents a document that cannot be rendered. Generally occurs when
flattening a line. The layout algorithms will reject this document and choose
a more suitable rendering.

**Signature**

```ts
export interface Fail<A> extends Doc.Variance<A> {
  readonly _tag: "Fail"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L138)

Since v1.0.0
Doc-FlatAlt.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.FlatAlt

Represents a flattened alternative of two documents. The layout algorithms
will choose the first document, but when flattened (via `group`) the second
document will be preferreinternal.

The layout algorithms operate under the assumption that the first alternative
is less wide than the flattened second alternative.

**Signature**

```ts
export interface FlatAlt<A> extends Doc.Variance<A> {
  readonly _tag: "FlatAlt"
  readonly left: Doc<A>
  readonly right: Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L204)

Since v1.0.0
Doc-catWithLine.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.catWithLine

The `catWithLine` combinator concatenates two documents by placing a `line`
document between them.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithLine(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|a
     |b`
  )
)
```

**Signature**

```ts
declare const catWithLine: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L942)

Since v1.0.0
Doc-catWithLineBreak.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.catWithLineBreak

The `catWithLineBreak` combinator concatenates two documents by placing a
`lineBreak` document between them.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithLineBreak(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|a
     |b`
  )
)

assert.strictEqual(
  Doc.render(Doc.group(doc), { style: "pretty" }),
  "ab"
)
```

**Signature**

```ts
declare const catWithLineBreak: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L980)

Since v1.0.0
Doc-catWithSoftLine.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.catWithSoftLine

The `catWithSoftLine` combinator concatenates two documents by placing a
`softLine` document between them.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithSoftLine(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "a b"
)

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1 }
  }),
  String.stripMargin(
    `|a
     |b`
  )
)
```

**Signature**

```ts
declare const catWithSoftLine: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1021)

Since v1.0.0
Doc-catWithSoftLineBreak.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.catWithSoftLineBreak

The `catWithSoftLineBreak` combinator concatenates two documents by
placing a `softLineBreak` document between them.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithSoftLineBreak(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "ab"
)

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1 }
  }),
  String.stripMargin(
    `|a
     |b`
  )
)
```

**Signature**

```ts
declare const catWithSoftLineBreak: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1062)

Since v1.0.0
Doc-catWithSpace.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.catWithSpace

The `catWithSpace` combinator concatenates two documents by placing a
`space` document between them.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithSpace(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "a b"
)
```

**Signature**

```ts
declare const catWithSpace: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1091)

Since v1.0.0
Doc-cats.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.cats

The `cats` combinator will attempt to lay out a collection of documents
separated by nothing. If the output does not fit the page, then the documents
will be separated by newlines. This is what differentiates it from `vcat`,
which always lays out documents beneath one another.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hsep([
  Doc.text("Docs:"),
  Doc.cats(Doc.words("lorem ipsum dolor"))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "Docs: loremipsumdolor"
)

// If the document exceeds the width of the page, the documents are rendered
// one above another
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|Docs: lorem
     |ipsum
     |dolor`
  )
)
```

**Signature**

```ts
declare const cats: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L912)

Since v1.0.0
Doc-changesUponFlattening.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.changesUponFlattening

Select the first element of each `Union` and discard the first element of
each `FlatAlt` to produce a "flattened" version of the input document.

The result is `Flattened` if the element might change depending on the chosen
layout algorithm (i.e., the resulting document contains sub-documents that
may be rendered differently).

The result is `AlreadyFlat` if the document is static (i.e., the resulting
document contains only a plain `Empty` node).

`NeverFlat` is returned when the document cannot be flattened because it
contains either a hard `Line` or a `Fail`.

**Signature**

```ts
declare const changesUponFlattening: <A>(self: Doc<A>) => Flatten<Doc<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2046)

Since v1.0.0
Doc-char.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.char

A document containing a single character.

**Invariants**
- Cannot be the newline (`"\n"`) character

**Signature**

```ts
declare const char: (char: string) => Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L437)

Since v1.0.0
Doc-colon.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.colon

A document containing a single `:` character.

**Signature**

```ts
declare const colon: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L719)

Since v1.0.0
Doc-column.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.column

Lays out a document depending upon the column at which the document starts.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

// Example 1:
const example1 = Doc.column((l) =>
  Doc.hsep([Doc.text("Columns are"), Doc.text(`${l}-based`)])
)

assert.strictEqual(
  Doc.render(example1, { style: "pretty" }),
  "Columns are 0-based"
)

// Example 2:
const doc = Doc.hsep([
  Doc.text("prefix"),
  Doc.column((l) => Doc.text(`| <- column ${l}`))
])

const example2 = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example2, { style: "pretty" }),
  String.stripMargin(
    `|prefix | <- column 7
     |    prefix | <- column 11
     |        prefix | <- column 15`
  )
)
```

**Signature**

```ts
declare const column: <A>(react: (position: number) => Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1492)

Since v1.0.0
Doc-comma.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.comma

A document containing a single `,` character.

**Signature**

```ts
declare const comma: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L727)

Since v1.0.0
Doc-concatWith.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.concatWith

The `concatWith` combinator concatenates all documents in a collection
element-wise with the specified binary function.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc: Doc.Doc<never> = pipe(
  [Doc.char("a"), Doc.char("b")],
  Doc.concatWith((x, y) => Doc.catWithSpace(y)(x))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "a b"
)
```

**Signature**

```ts
declare const concatWith: { <A>(f: (left: Doc<A>, right: Doc<A>) => Doc<A>): (docs: Iterable<Doc<A>>) => Doc<A>; <A>(docs: Iterable<Doc<A>>, f: (left: Doc<A>, right: Doc<A>) => Doc<A>): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1120)

Since v1.0.0
Doc-curlyBraced.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.curlyBraced

Encloses the input document in curly braces (`{}`).

**Signature**

```ts
declare const curlyBraced: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2304)

Since v1.0.0
Doc-dot.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.dot

A document containing a single `.` character.

**Signature**

```ts
declare const dot: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L735)

Since v1.0.0
Doc-doubleQuoted.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.doubleQuoted

Encloses the input document in double quotes (`""`).

**Signature**

```ts
declare const doubleQuoted: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2272)

Since v1.0.0
Doc-dquote.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.dquote

A document containing a single `"` character.

**Signature**

```ts
declare const dquote: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L743)

Since v1.0.0
Doc-empty.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.empty

The `empty` document behaves like a document containing the empty string
(`""`), so it has a height of `1`.

This may lead to surprising behavior if the empty document is expected to
bear no weight inside certain layout functions, such as`vcat`, where it will
render an empty line of output.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.vsep([
  Doc.text("hello"),
  // `parentheses` for visibility purposes only
  Doc.parenthesized(Doc.empty),
  Doc.text("world")
])

const expected = `|hello
                  |()
                  |world`

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(expected)
)
```

**Signature**

```ts
declare const empty: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L500)

Since v1.0.0
Doc-encloseSep.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.encloseSep

The `encloseSep` combinator concatenates a collection of documents,
separating each document in the collection using the specified `sep`
document. After concatenation, the resulting document is enclosed by the
specified `left` and `right` documents.

To place the `sep` document at the end of each entry, see the `punctuate`
combinator.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("list"),
  Doc.align(
    pipe(
      ["1", "20", "300", "4000"].map(
        (n) => n.length === 1 ? Doc.char(n) : Doc.text(n)
      ),
      Doc.encloseSep(Doc.lbracket, Doc.rbracket, Doc.comma)
    )
  )
])

// The documents are laid out horizontally if the document fits the page
assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "list [1,20,300,4000]"
)

// Otherwise they are laid out vertically, with separators put in the front
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|list [1
     |     ,20
     |     ,300
     |     ,4000]`
  )
)
```

**Signature**

```ts
declare const encloseSep: { <A, B, C>(left: Doc<A>, right: Doc<B>, sep: Doc<C>): <D>(docs: Iterable<Doc<D>>) => Doc<A | B | C | D>; <A, B, C, D>(docs: Iterable<Doc<D>>, left: Doc<A>, right: Doc<B>, sep: Doc<C>): Doc<A | B | C | D>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1849)

Since v1.0.0
Doc-equalSign.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.equalSign

A document containing a single `=` character.

**Signature**

```ts
declare const equalSign: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L751)

Since v1.0.0
Doc-fail.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.fail

The `fail` document is a document that cannot be rendered.

Generally occurs when flattening a line. The layout algorithms will reject
this document and choose a more suitable rendering.

**Signature**

```ts
declare const fail: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L511)

Since v1.0.0
Doc-fill.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.fill

The `fill` combinator first lays out the document `x` and then appends
`space`s until the width of the document is equal to the specified `width`.
If the width of `x` is already larger than the specified `width`, nothing is
appended.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

type Signature = [name: string, type: string]

const signatures: Array<Signature> = [
  ["empty", "Doc"],
  ["nest", "Int -> Doc -> Doc"],
  ["fillSep", "[Doc] -> Doc"]
]

const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
  Doc.hsep([
    pipe(Doc.text(name), Doc.fill(5)),
    Doc.text("::"),
    Doc.text(type)
  ])

const doc = Doc.hsep([
  Doc.text("let"),
  Doc.align(Doc.vcat(signatures.map(prettySignature)))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|let empty :: Doc
     |    nest  :: Int -> Doc -> Doc
     |    fillSep :: [Doc] -> Doc`
  )
)
```

**Signature**

```ts
declare const fill: { (w: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, w: number): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1960)

Since v1.0.0
Doc-fillBreak.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.fillBreak

The `fillBreak` combinator first lays out the document `x` and then appends
`space`s until the width of the document is equal to the specified `width`.
If the width of `x` is already larger than the specified `width`, the nesting
level is increased by the specified `width` and a `line` is appended.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

type Signature = [name: string, type: string]

const signatures: Array<Signature> = [
  ["empty", "Doc"],
  ["nest", "Int -> Doc -> Doc"],
  ["fillSep", "[Doc] -> Doc"]
]

const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
  Doc.hsep([
    pipe(Doc.text(name), Doc.fillBreak(5)),
    Doc.text("::"),
    Doc.text(type)
  ])

const doc = Doc.hsep([
  Doc.text("let"),
  Doc.align(Doc.vcat(signatures.map(prettySignature)))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|let empty :: Doc
     |    nest  :: Int -> Doc -> Doc
     |    fillSep
     |          :: [Doc] -> Doc`
  )
)
```

**Signature**

```ts
declare const fillBreak: { (w: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, w: number): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2012)

Since v1.0.0
Doc-fillCat.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.fillCat

The `fillCat` combinator concatenates all documents in a collection
horizontally by placing a `empty` between each pair of documents as long as
they fit the page. Once the page width is exceeded, a `lineBreak` is inserted
and the process is repeated for all documents in the collection.

**Note**: the use of `lineBreak` means that if `group`ed, the documents will
be separated with `empty` instead of newlines. See `fillSep` if you want a
`space` instead.

**Signature**

```ts
declare const fillCat: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1191)

Since v1.0.0
Doc-fillSep.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.fillSep

The `fillSep` combinator concatenates all documents in a collection
horizontally by placing a `space` between each pair of documents as long as
they fit the page. Once the page width is exceeded, a `line` is inserted and
the process is repeated for all documents in the collection.

**Note**: the use of `line` means that if `group`ed, the documents will be
separated with a `space` instead of newlines. See `fillCat` if you do not
want a `space`.

**Signature**

```ts
declare const fillSep: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1300)

Since v1.0.0
Doc-flatAlt.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.flatAlt

The `flatAlt` document will render `left` by default. However, when
`group`ed, `y` will be preferred with `left` as the fallback for cases where
`y` does not fit onto the page.

**NOTE**:
Users should be careful to ensure that `left` is less wide than `right`.
Otherwise, if `right` ends up not fitting the page, then the layout
algorithms will fall back to an even wider layout.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const open = pipe(Doc.empty, Doc.flatAlt(Doc.text("{ ")))
const close = pipe(Doc.empty, Doc.flatAlt(Doc.text(" }")))
const separator = pipe(Doc.empty, Doc.flatAlt(Doc.text("; ")))

const prettyDo = <A>(documents: Array<Doc.Doc<A>>): Doc.Doc<A> => {
  return pipe(
    Doc.hsep([
      Doc.text("do"),
      pipe(
        documents,
        Doc.encloseSep(open, close, separator),
        Doc.align
      )
    ]),
    Doc.group
  )
}

const statements = [
  Doc.text("name:_ <- getArgs"),
  Doc.text("let greet = \"Hello, \" <> name"),
  Doc.text("putStrLn greet")
]

// If it fits, then the content is put onto a single line with the `{;}` style
assert.strictEqual(
  pipe(
    prettyDo(statements),
    Doc.render({
      style: "pretty",
      options: { lineWidth: 80 }
    })
  ),
  "do { name:_ <- getArgs; let greet = \"Hello, \" <> name; putStrLn greet }"
)

// When there is not enough space, the content is broken up onto multiple lines
assert.strictEqual(
  pipe(
    prettyDo(statements),
    Doc.render({
      style: "pretty",
      options: { lineWidth: 10 }
    })
  ),
  String.stripMargin(
    `|do name:_ <- getArgs
     |   let greet = "Hello, " <> name
     |   putStrLn greet`
  )
)
```

**Signature**

```ts
declare const flatAlt: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1421)

Since v1.0.0
Doc-flatten.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.flatten

Flattens a document but does not report changes.

**Signature**

```ts
declare const flatten: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2027)

Since v1.0.0
Doc-group.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.group

The `group` combinator attempts to lay out a document onto a single line by
removing the contained line breaks. If the result does not fit the page, or
if a `hardLine` prevents flattening the document, `x` is laid out without
any changes.

The `group` function is key to layouts that adapt to available space nicely.

**Signature**

```ts
declare const group: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1446)

Since v1.0.0
Doc-hang.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.hang

The `hang` combinator lays out a document with the nesting level set to
the *current column* plus the specified `indent`. Negative values for
`indent` are allowed and decrease the nesting level accordingly.

This differs from the `nest` combinator, which is based on the *current
nesting level* plus the specified `indent`. When you"re not sure, try the
more efficient combinator (`nest`) first.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("prefix"),
  pipe(Doc.reflow("Indenting these words with hang"), Doc.hang(4))
])

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 24 }
  }),
  String.stripMargin(
    `|prefix Indenting these
     |           words with
     |           hang`
  )
)
```

**Signature**

```ts
declare const hang: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1754)

Since v1.0.0
Doc-hardLine.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.hardLine

The `hardLine` document is always laid out as a line break, regardless of
space or whether or not the document was `group`"ed.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.hardLine,
  Doc.text("dolor sit amet")
])

// Even with enough space, a line break is introduced
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1000 }
  }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
```

**Signature**

```ts
declare const hardLine: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L703)

Since v1.0.0
Doc-hcat.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.hcat

The `hcat` combinator concatenates all documents in a collection horizontally
without any spacing.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat(Doc.words("lorem ipsum dolor"))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "loremipsumdolor"
)
```

**Signature**

```ts
declare const hcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1176)

Since v1.0.0
Doc-hsep.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.hsep

The `hsep` combinator concatenates all documents in a collection horizontally
by placing a `space` between each pair of documents.

For automatic line breaks, consider using `fillSep`.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc: Doc.Doc<never> = Doc.hsep(Doc.words("lorem ipsum dolor sit amet"))

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "lorem ipsum dolor sit amet"
)

// The `hsep` combinator will not introduce line breaks on its own, even when
// the page is too narrow
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 5 }
  }),
  "lorem ipsum dolor sit amet"
)
```

**Signature**

```ts
declare const hsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1232)

Since v1.0.0
Doc-indent.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.indent

The `indent` combinator indents a document by the specified `indent`
beginning from the current cursor position.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hcat([
  Doc.text("prefix"),
  pipe(Doc.reflow("The indent function indents these words!"), Doc.indent(4))
])

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 24 }
  }),
  String.stripMargin(
    `|prefix    The indent
     |          function
     |          indents these
     |          words!`
  )
)
```

**Signature**

```ts
declare const indent: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1792)

Since v1.0.0
Doc-isAnnotated.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isAnnotated

Returns `true` if the specified `Doc` is a `Annotated`, `false` otherwise.

**Signature**

```ts
declare const isAnnotated: <A>(self: Doc<A>) => self is Annotated<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L422)

Since v1.0.0
Doc-isCat.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isCat

Returns `true` if the specified `Doc` is a `Cat`, `false` otherwise.

**Signature**

```ts
declare const isCat: <A>(self: Doc<A>) => self is Cat<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L374)

Since v1.0.0
Doc-isChar.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isChar

Returns `true` if the specified `Doc` is a `Char`, `false` otherwise.

**Signature**

```ts
declare const isChar: <A>(self: Doc<A>) => self is Char<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L342)

Since v1.0.0
Doc-isColumn.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isColumn

Returns `true` if the specified `Doc` is a `Column`, `false` otherwise.

**Signature**

```ts
declare const isColumn: <A>(self: Doc<A>) => self is Column<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L398)

Since v1.0.0
Doc-isDoc.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isDoc

Returns `true` if the specified value is a `Doc`, `false` otherwise.

**Signature**

```ts
declare const isDoc: (u: unknown) => u is Doc<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L318)

Since v1.0.0
Doc-isEmpty.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isEmpty

Returns `true` if the specified `Doc` is an `Empty`, `false` otherwise.

**Signature**

```ts
declare const isEmpty: <A>(self: Doc<A>) => self is Empty<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L334)

Since v1.0.0
Doc-isFail.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isFail

Returns `true` if the specified `Doc` is a `Fail`, `false` otherwise.

**Signature**

```ts
declare const isFail: <A>(self: Doc<A>) => self is Fail<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L326)

Since v1.0.0
Doc-isFlatAlt.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isFlatAlt

Returns `true` if the specified `Doc` is a `FlatAlt`, `false` otherwise.

**Signature**

```ts
declare const isFlatAlt: <A>(self: Doc<A>) => self is FlatAlt<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L366)

Since v1.0.0
Doc-isLine.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isLine

Returns `true` if the specified `Doc` is a `Line`, `false` otherwise.

**Signature**

```ts
declare const isLine: <A>(self: Doc<A>) => self is Line<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L358)

Since v1.0.0
Doc-isNest.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isNest

Returns `true` if the specified `Doc` is a `Nest`, `false` otherwise.

**Signature**

```ts
declare const isNest: <A>(self: Doc<A>) => self is Nest<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L382)

Since v1.0.0
Doc-isNesting.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isNesting

Returns `true` if the specified `Doc` is a `Nesting`, `false` otherwise.

**Signature**

```ts
declare const isNesting: <A>(self: Doc<A>) => self is Nesting<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L414)

Since v1.0.0
Doc-Line.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Line

Represents a document that contains a hard line break.

**Signature**

```ts
export interface Line<A> extends Doc.Variance<A> {
  readonly _tag: "Line"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L189)

Since v1.0.0
Doc-Nest.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Nest

Represents a document that is indented by a certain number of columns.

**Signature**

```ts
export interface Nest<A> extends Doc.Variance<A> {
  readonly _tag: "Nest"
  readonly indent: number
  readonly doc: Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L228)

Since v1.0.0
Doc-Nesting.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Nesting

Represents a document that reacts to the current nesting level.

**Signature**

```ts
export interface Nesting<A> extends Doc.Variance<A> {
  readonly _tag: "Nesting"
  readonly react: (level: number) => Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L291)

Since v1.0.0
Doc-Text.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Text

Represents a document containing a string of text.

**Invariants**
- Text cannot be less than two characters long
- Text cannot contain a newline (`"\n"`) character

**Signature**

```ts
export interface Text<A> extends Doc.Variance<A> {
  readonly _tag: "Text"
  readonly text: string
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L178)

Since v1.0.0
Doc-Union.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.Union

Represents the union of two documents. Used to implement layout alternatives
for `group`.

**Invariants**
- The first lines of the first document should be longer than the first lines
  of the second document so that the layout algorithm can pick the document
  with the best fit.

**Signature**

```ts
export interface Union<A> extends Doc.Variance<A> {
  readonly _tag: "Union"
  readonly left: Doc<A>
  readonly right: Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L246)

Since v1.0.0
Doc-WithPageWidth.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.WithPageWidth

Represents a document that reacts to the current page width.

**Signature**

```ts
export interface WithPageWidth<A> extends Doc.Variance<A> {
  readonly _tag: "WithPageWidth"
  readonly react: (pageWidth: PageWidth) => Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L280)

Since v1.0.0
Doc-isText.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isText

Returns `true` if the specified `Doc` is a `Text`, `false` otherwise.

**Signature**

```ts
declare const isText: <A>(self: Doc<A>) => self is Text<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L350)

Since v1.0.0
Doc-isUnion.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isUnion

Returns `true` if the specified `Doc` is a `Union`, `false` otherwise.

**Signature**

```ts
declare const isUnion: <A>(self: Doc<A>) => self is Union<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L390)

Since v1.0.0
Doc-isWithPageWidth.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.isWithPageWidth

Returns `true` if the specified `Doc` is a `WithPageWidth`, `false` otherwise.

**Signature**

```ts
declare const isWithPageWidth: <A>(self: Doc<A>) => self is WithPageWidth<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L406)

Since v1.0.0
Doc-langle.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.langle

A document containing a single `<` character.

**Signature**

```ts
declare const langle: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L759)

Since v1.0.0
Doc-lbrace.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.lbrace

A document containing a single `{` character.

**Signature**

```ts
declare const lbrace: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L767)

Since v1.0.0
Doc-lbracket.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.lbracket

A document containing a single `[` character.

**Signature**

```ts
declare const lbracket: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L775)

Since v1.0.0
Doc-line.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.line

The `line` document advances to the next line and indents to the current
nesting level. However, `line` will behave like `space` if the line break is
undone by `group`.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.line,
  Doc.text("dolor sit amet")
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
assert.strictEqual(
  Doc.render(Doc.group(doc), { style: "pretty" }),
  "lorem ipsum dolor sit amet"
)
```

**Signature**

```ts
declare const line: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L546)

Since v1.0.0
Doc-lineBreak.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.lineBreak

The `lineBreak` document is like `line` but behaves like `empty` if the line
break is undone by `group` (instead of `space`).

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.lineBreak,
  Doc.text("dolor sit amet")
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
assert.strictEqual(
  Doc.render(Doc.group(doc), { style: "pretty" }),
  "lorem ipsumdolor sit amet"
)
```

**Signature**

```ts
declare const lineBreak: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L580)

Since v1.0.0
Doc-list.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.list

A Haskell-inspired variant of `encloseSep` that uses a comma as the separator
and braces as the enclosure for a collection of documents.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.list(
  ["1", "20", "300", "4000"].map(
    (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))
  )
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "[1, 20, 300, 4000]"
)
```

**Signature**

```ts
declare const list: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1882)

Since v1.0.0
Doc-lparen.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.lparen

A document containing a single `(` character.

**Signature**

```ts
declare const lparen: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L783)

Since v1.0.0
Doc-nest.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.nest

Lays out a document with the current nesting level (indentation
of the following lines) increased by the specified `indent`.
Negative values are allowed and will decrease the nesting level
accordingly.

See also:
* `hang`: nest a document relative to the current cursor
position instead of the current nesting level
* `align`: set the nesting level to the current cursor
position
* `indent`: increase the indentation on the spot, padding
any empty space with spaces

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.vsep([
  pipe(Doc.vsep(Doc.words("lorem ipsum dolor")), Doc.nest(4)),
  Doc.text("sit"),
  Doc.text("amet")
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |    ipsum
     |    dolor
     |sit
     |amet`
  )
)
```

**Signature**

```ts
declare const nest: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1664)

Since v1.0.0
Doc-nesting.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.nesting

Lays out a document depending upon the current nesting level (i.e., the
current indentation of the document).

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("prefix"),
  Doc.nesting((l) => Doc.squareBracketed(Doc.text(`Nested: ${l}`)))
])

const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example, { style: "pretty" }),
  String.stripMargin(
    `|prefix [Nested: 0]
     |    prefix [Nested: 4]
     |        prefix [Nested: 8]`
  )
)
```

**Signature**

```ts
declare const nesting: <A>(react: (level: number) => Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1524)

Since v1.0.0
Doc-pageWidth.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.pageWidth

Lays out a document according to the document"s`PageWidth`.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("prefix"),
  Doc.pageWidth((pageWidth) => {
    switch (pageWidth._tag) {
      case "AvailablePerLine": {
        const { lineWidth, ribbonFraction } = pageWidth
        return Doc.squareBracketed(
          Doc.text(`Width: ${lineWidth}, Ribbon Fraction: ${ribbonFraction}`)
        )
      }
      case "Unbounded": {
        return Doc.empty
      }
    }
  })
])

const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example, {
    style: "pretty",
    options: { lineWidth: 32 }
  }),
  String.stripMargin(
    `|prefix [Width: 32, Ribbon Fraction: 1]
     |    prefix [Width: 32, Ribbon Fraction: 1]
     |        prefix [Width: 32, Ribbon Fraction: 1]`
  )
)
```

**Signature**

```ts
declare const pageWidth: <A>(react: (pageWidth: PageWidth) => Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1616)

Since v1.0.0
Doc-parenthesized.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.parenthesized

Encloses the input document in parentheses (`()`).

**Signature**

```ts
declare const parenthesized: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2280)

Since v1.0.0
Doc-punctuate.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.punctuate

The `punctuate` combinator appends the `punctuator` document to all but the
last document in a collection of documents. The separators are places after
the document entries, which can be observed if the result is oriented
vertically.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const docs = pipe(
  Doc.words("lorem ipsum dolor sit amet"),
  Doc.punctuate(Doc.comma)
)

assert.strictEqual(
  Doc.render(Doc.hsep(docs), { style: "pretty" }),
  "lorem, ipsum, dolor, sit, amet"
)

// The separators are put at the end of the entries, which can be better
// visualzied if the documents are rendered vertically
assert.strictEqual(
  Doc.render(Doc.vsep(docs), { style: "pretty" }),
  String.stripMargin(
    `|lorem,
     |ipsum,
     |dolor,
     |sit,
     |amet`
  )
)
```

**Signature**

```ts
declare const punctuate: { <A, B>(punctuator: Doc<A>): (docs: Iterable<Doc<B>>) => ReadonlyArray<Doc<A | B>>; <A, B>(docs: Iterable<Doc<B>>, punctuator: Doc<A>): ReadonlyArray<Doc<A | B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2433)

Since v1.0.0
Doc-rangle.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.rangle

A document containing a single `>` character.

**Signature**

```ts
declare const rangle: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L791)

Since v1.0.0
Doc-rbrace.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.rbrace

A document containing a single `}` character.

**Signature**

```ts
declare const rbrace: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L799)

Since v1.0.0
Doc-rbracket.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.rbracket

A document containing a single `]` character.

**Signature**

```ts
declare const rbracket: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L807)

Since v1.0.0
Doc-reAnnotate.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.reAnnotate

Changes the annotation of a document. Useful for modifying documents embedded
with one form of annotation with a more general annotation.

**Note** that with each invocation, the entire document tree is traversed.
If possible, it is preferable to reannotate a document after producing the
layout using `reAnnotateS`.

**Signature**

```ts
declare const reAnnotate: { <A, B>(f: (a: A) => B): (self: Doc<A>) => Doc<B>; <A, B>(self: Doc<A>, f: (a: A) => B): Doc<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2104)

Since v1.0.0
Doc-reflow.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.reflow

Splits a string of words into individual `Text` documents using the specified
`char` to split on (defaults to `" "`). In addition, a `softLine` is inserted
in between each word so that if the text exceeds the available width it will
be broken into multiple lines.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.reflow(
  "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " +
    "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
)

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 32 }
  }),
  String.stripMargin(
    `|Lorem ipsum dolor sit amet,
     |consectetur adipisicing elit,
     |sed do eiusmod tempor incididunt
     |ut labore et dolore magna
     |aliqua.`
  )
)
```

**Signature**

```ts
declare const reflow: (s: string, char?: string) => Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2391)

Since v1.0.0
Doc-rparen.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.rparen

A document containing a single `)` character.

**Signature**

```ts
declare const rparen: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L815)

Since v1.0.0
Doc-semi.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.semi

A document containing a single `;` character.

**Signature**

```ts
declare const semi: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L823)

Since v1.0.0
Doc-seps.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.seps

The `seps` combinator will attempt to lay out a collection of documents
separated by `space`s. If the output does not fit the page, then the
documents will be separated by newlines. This is what differentiates it from
`vsep`, which always lays out documents beneath one another.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hsep([
  Doc.text("prefix"),
  Doc.seps(Doc.words("text to lay out"))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "prefix text to lay out"
)

// If the page width is too narrow, documents are separated by newlines
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 20 }
  }),
  String.stripMargin(
    `|prefix text
     |to
     |lay
     |out`
  )
)
```

**Signature**

```ts
declare const seps: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1342)

Since v1.0.0
Doc-singleQuoted.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.singleQuoted

Encloses the input document in single quotes (`""`).

**Signature**

```ts
declare const singleQuoted: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2264)

Since v1.0.0
Doc-slash.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.slash

A document containing a single `/` character.

**Signature**

```ts
declare const slash: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L831)

Since v1.0.0
Doc-softLine.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.softLine

The `softLine` document behaves like `space` if the resulting output fits
onto the page, otherwise it behaves like `line`.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.softLine,
  Doc.text("dolor sit amet")
])

// Here we have enough space to put everything onto one line
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "lorem ipsum dolor sit amet"
)

// If the page width is narrowed to `10`, the layout algorithm will
// introduce a line break
assert.strictEqual(
  Doc.render(Doc.group(doc), {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
```

**Signature**

```ts
declare const softLine: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L624)

Since v1.0.0
Doc-softLineBreak.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.softLineBreak

The `softLineBreak` document is similar to `softLine`, but behaves like
`empty` if the resulting output does not fit onto the page (instead of
`space`).

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("ThisText"),
  Doc.softLineBreak,
  Doc.text("IsWayTooLong")
])

// With enough space, we get direct concatenation of documents:
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "ThisTextIsWayTooLong"
)

// If the page width is narrowed to `10`, the layout algorithm will
// introduce a line break
assert.strictEqual(
  Doc.render(Doc.group(doc), {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|ThisText
     |IsWayTooLong`
  )
)
```

**Signature**

```ts
declare const softLineBreak: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L669)

Since v1.0.0
Doc-space.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.space

A document containing a single ` ` character.

**Signature**

```ts
declare const space: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L847)

Since v1.0.0
Doc-spaces.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.spaces

The `spaces` combinator lays out a document containing `n` spaces. Negative
values for `n` count as `0` spaces.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.squareBracketed(Doc.doubleQuoted(Doc.spaces(5)))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "[\"     \"]"
)
```

**Signature**

```ts
declare const spaces: (n: number) => Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2326)

Since v1.0.0
Doc-squareBracketed.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.squareBracketed

Encloses the input document in square brackets (`[]`).

**Signature**

```ts
declare const squareBracketed: <A>(self: Doc<A>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2296)

Since v1.0.0
Doc-squote.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.squote

A document containing a single `"` character.

**Signature**

```ts
declare const squote: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L839)

Since v1.0.0
Doc-string.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.string

Constructs a document containing a string of text.

**Note**: newline characters (`\n`) contained in the provided string will be
disregarded (i.e. not rendered) in the output document.

**Signature**

```ts
declare const string: (str: string) => Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L460)

Since v1.0.0
Doc-surround.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.surround

The `surround` combinator encloses a document in between `left` and `right`
documents.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc = pipe(
  Doc.char("-"),
  Doc.surround(Doc.char("A"), Doc.char("Z"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "A-Z"
)
```

**Signature**

```ts
declare const surround: { <A, B, C>(left: Doc<A>, right: Doc<B>): (self: Doc<C>) => Doc<A | B | C>; <A, B, C>(self: Doc<C>, left: Doc<A>, right: Doc<B>): Doc<A | B | C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2253)

Since v1.0.0
Doc-text.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.text

A document containing a string of text.

**Invariants**
- Text cannot be less than two characters long
- Text cannot contain a newline (`"\n"`) character

**Signature**

```ts
declare const text: (text: string) => Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L449)

Since v1.0.0
Doc-tupled.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.tupled

A Haskell-inspired variant of `encloseSep` that uses a comma as the separator
and parentheses as the enclosure for a collection of documents.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.tupled(
  ["1", "20", "300", "4000"].map(
    (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))
  )
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "(1, 20, 300, 4000)"
)
```

**Signature**

```ts
declare const tupled: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1908)

Since v1.0.0
Doc-unAnnotate.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.unAnnotate

Removes all annotations from a document.

**Note**: with each invocation, the entire document tree is traversed.
If possible, it is preferable to unannotate a document after producing the
layout using `unAnnotateS`.

**Signature**

```ts
declare const unAnnotate: <A>(self: Doc<A>) => Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2119)

Since v1.0.0
Doc-vbar.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.vbar

A document containing a single `|` character.

**Signature**

```ts
declare const vbar: Doc<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L855)

Since v1.0.0
Doc-vcat.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.vcat

The `vcat` combinator concatenates all documents in a collection vertically.
If the output is grouped then the line breaks are removed.

In other words `vcat` is like `vsep`, with newlines removed instead of
replaced by spaces.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.vcat(Doc.words("lorem ipsum dolor"))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |ipsum
     |dolor`
  )
)
```

**Signature**

```ts
declare const vcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1153)

Since v1.0.0
Doc-vsep.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.vsep

The `vsep` combinator concatenates all documents in a collection vertically.
If a `group` undoes the line breaks inserted by `vsep`, the documents are
separated with a space instead.

When a `vsep` is `group`ed, the documents are separated with a `space` if the
layoutfits the page, otherwise nothing is done. See the `sep` convenience
function for this use case.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const unaligned = Doc.hsep([
  Doc.text("prefix"),
  Doc.vsep(Doc.words("text to lay out"))
])

assert.strictEqual(
  Doc.render(unaligned, { style: "pretty" }),
  String.stripMargin(
    `|prefix text
     |to
     |lay
     |out`
  )
)

// The `align` function can be used to align the documents under their first
// element
const aligned = Doc.hsep([
  Doc.text("prefix"),
  Doc.align(Doc.vsep(Doc.words("text to lay out")))
])

assert.strictEqual(
  Doc.render(aligned, { style: "pretty" }),
  String.stripMargin(
    `|prefix text
     |       to
     |       lay
     |       out`
  )
)
```

**Signature**

```ts
declare const vsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1285)

Since v1.0.0
Doc-width.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.width

The `width` combinator makes the column width of a document available to the
document while rendering.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const annotate = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  pipe(
    Doc.squareBracketed(doc),
    Doc.width((w) => Doc.text(` <- width: ${w}`))
  )

const docs = [
  Doc.text("---"),
  Doc.text("------"),
  Doc.indent(Doc.text("---"), 3),
  Doc.vsep([Doc.text("---"), Doc.indent(Doc.text("---"), 4)])
]

const doc = Doc.align(Doc.vsep(docs.map(annotate)))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|[---] <- width: 5
     |[------] <- width: 8
     |[   ---] <- width: 8
     |[---
     |    ---] <- width: 8`
  )
)
```

**Signature**

```ts
declare const width: { <A, B>(react: (width: number) => Doc<B>): (self: Doc<A>) => Doc<A | B>; <A, B>(self: Doc<A>, react: (width: number) => Doc<B>): Doc<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L1567)

Since v1.0.0
Doc-words.md
Package: `@effect/printer`<br />
Module: `Doc`<br />

## Doc.words

Splits a string of words into individual `Text` documents using the
specified `char` to split on (defaults to `" "`).

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.tupled(Doc.words("lorem ipsum dolor"))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "(lorem, ipsum, dolor)"
)
```

**Signature**

```ts
declare const words: (s: string, char?: string) => ReadonlyArray<Doc<never>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Doc.ts#L2354)

Since v1.0.0
DocStream-CharStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.CharStream

Represents a `Doc` containing a single character.

**Signature**

```ts
export interface CharStream<A> extends DocStream.Variance<A> {
  readonly _tag: "CharStream"
  readonly char: string
  readonly stream: DocStream<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L106)

Since v1.0.0
DocStream-DocStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.DocStream

Represents a document that has been laid out and can be processed used by the
rendering algorithms.

A simplified view is that a `Doc` is equivalent to an array of `DocStream`,
and the layout algorithms simply pick a `DocStream` based upon which instance
best fits the layout constraints. Therefore, a `DocStream` has all complexity
contained in a `Doc` resolved, making it very easy to convert to other
formats, such as plaintext or terminal output.

**Signature**

```ts
type DocStream<A> = | FailedStream<A>
  | EmptyStream<A>
  | CharStream<A>
  | TextStream<A>
  | LineStream<A>
  | PushAnnotationStream<A>
  | PopAnnotationStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L42)

Since v1.0.0
DocStream-alterAnnotations.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.alterAnnotations

Changes the annotation of a document to a different annotation, or to
none at all.

**Signature**

```ts
declare const alterAnnotations: { <A, B>(f: (a: A) => Option<B>): (self: DocStream<A>) => DocStream<B>; <A, B>(self: DocStream<A>, f: (a: A) => Option<B>): DocStream<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L302)

Since v1.0.0
DocStream-EmptyStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.EmptyStream

Represents the an empty `Doc`.

**Signature**

```ts
export interface EmptyStream<A> extends DocStream.Variance<A> {
  readonly _tag: "EmptyStream"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L96)

Since v1.0.0
DocStream-FailedStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.FailedStream

Represents a `Doc` that failed to be laid out.

**Signature**

```ts
export interface FailedStream<A> extends DocStream.Variance<A> {
  readonly _tag: "FailedStream"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L86)

Since v1.0.0
DocStream-LineStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.LineStream

Represents a `Doc` containing a single line. The `indentation`
represents the indentation level for the subsequent line in the
`Doc`.

**Signature**

```ts
export interface LineStream<A> extends DocStream.Variance<A> {
  readonly _tag: "LineStream"
  readonly indentation: number
  readonly stream: DocStream<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L132)

Since v1.0.0
DocStream-PopAnnotationStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.PopAnnotationStream

Represents the removal of a previously pushed annotation from a `Doc`.

**Signature**

```ts
export interface PopAnnotationStream<A> extends DocStream.Variance<A> {
  readonly _tag: "PopAnnotationStream"
  readonly stream: DocStream<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L156)

Since v1.0.0
DocStream-PushAnnotationStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.PushAnnotationStream

Represents the addition of an annotation of type `A` to a `Doc`.

**Signature**

```ts
export interface PushAnnotationStream<A> extends DocStream.Variance<A> {
  readonly _tag: "PushAnnotationStream"
  readonly annotation: A
  readonly stream: DocStream<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L144)

Since v1.0.0
DocStream-TextStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.TextStream

Represents a `Doc` containing a string of text.

**Signature**

```ts
export interface TextStream<A> extends DocStream.Variance<A> {
  readonly _tag: "TextStream"
  readonly text: string
  readonly stream: DocStream<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L118)

Since v1.0.0
DocStream-isCharStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isCharStream

Returns `true` if the specified `DocStream` is a `CharStream`, `false` otherwise.

**Signature**

```ts
declare const isCharStream: <A>(self: DocStream<A>) => self is CharStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L195)

Since v1.0.0
DocStream-isDocStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isDocStream

Returns `true` if the specified value is a `DocStream`, `false` otherwise.

**Signature**

```ts
declare const isDocStream: (u: unknown) => u is DocStream<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L171)

Since v1.0.0
DocStream-isEmptyStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isEmptyStream

Returns `true` if the specified `DocStream` is a `EmptyStream`, `false` otherwise.

**Signature**

```ts
declare const isEmptyStream: <A>(self: DocStream<A>) => self is EmptyStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L187)

Since v1.0.0
DocStream-isFailedStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isFailedStream

Returns `true` if the specified `DocStream` is a `FailedStream`, `false` otherwise.

**Signature**

```ts
declare const isFailedStream: <A>(self: DocStream<A>) => self is FailedStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L179)

Since v1.0.0
DocStream-isLineStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isLineStream

Returns `true` if the specified `DocStream` is a `LineStream`, `false` otherwise.

**Signature**

```ts
declare const isLineStream: <A>(self: DocStream<A>) => self is LineStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L211)

Since v1.0.0
DocStream-isPopAnnotationStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isPopAnnotationStream

Returns `true` if the specified `DocStream` is a `PopAnnotationStream`, `false` otherwise.

**Signature**

```ts
declare const isPopAnnotationStream: <A>(self: DocStream<A>) => self is PopAnnotationStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L229)

Since v1.0.0
DocStream-isPushAnnotationStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isPushAnnotationStream

Returns `true` if the specified `DocStream` is a `PushAnnotationStream`, `false` otherwise.

**Signature**

```ts
declare const isPushAnnotationStream: <A>(self: DocStream<A>) => self is PushAnnotationStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L219)

Since v1.0.0
DocStream-isTextStream.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.isTextStream

Returns `true` if the specified `DocStream` is a `TextStream`, `false` otherwise.

**Signature**

```ts
declare const isTextStream: <A>(self: DocStream<A>) => self is TextStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L203)

Since v1.0.0
DocStream-reAnnotate.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.reAnnotate

Modify the annotations of a document.

**Signature**

```ts
declare const reAnnotate: { <A, B>(f: (a: A) => B): (self: DocStream<A>) => DocStream<B>; <A, B>(self: DocStream<A>, f: (a: A) => B): DocStream<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L313)

Since v1.0.0
DocStream-unAnnotate.md
Package: `@effect/printer`<br />
Module: `DocStream`<br />

## DocStream.unAnnotate

Remove all annotations from a document.

**Signature**

```ts
declare const unAnnotate: <A>(self: DocStream<A>) => DocStream<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocStream.ts#L324)

Since v1.0.0
DocTree-DocTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.DocTree

Represents a document that has been laid out into a tree-like structure.

A `DocStream` is a linked list of different annotated cons cells (i.e.
`TextStream` and then some further `DocStream`, `LineStream` and then some
further `DocStream`, etc.). The `DocStream` format is quite suitable as a
target for a layout engine, but is not suitable for rendering to a more
structured format, such as HTML, where we do not want to perform a lookahead
until the end of some pre-defined markup. These formats would benefit more
from a tree-like structure that explicitly marks its contents as annotated.
A `DocTree` is therefore much more suitable for this use case.

**Signature**

```ts
type DocTree<A> = | EmptyTree<A>
  | CharTree<A>
  | TextTree<A>
  | LineTree<A>
  | AnnotationTree<A>
  | ConcatTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L44)

Since v1.0.0
DocTree-alterAnnotations.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.alterAnnotations

Change the annotation of a document to a different annotation, or none at
all.

**Signature**

```ts
declare const alterAnnotations: { <A, B>(f: (a: A) => Iterable<B>): (self: DocTree<A>) => DocTree<B>; <A, B>(self: DocTree<A>, f: (a: A) => Iterable<B>): DocTree<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L251)

Since v1.0.0
DocTree-annotation.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.annotation

Annotate the specified `DocTree` with an annotation of type `A`.

**Signature**

```ts
declare const annotation: { <A>(annotation: A): <B>(self: DocTree<B>) => DocTree<A | B>; <A, B>(self: DocTree<A>, annotation: B): DocTree<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L227)

Since v1.0.0
DocTree-concat.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.concat

Horizontally concatenates multiple `DocTree`s.

**Signature**

```ts
declare const concat: <A>(trees: ReadonlyArray<DocTree<A>>) => DocTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L238)

Since v1.0.0
DocTree-isAnnotationTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.isAnnotationTree

Returns `true` if the specified `DocTree` is an `AnnotationTree`, `false` otherwise.

**Signature**

```ts
declare const isAnnotationTree: <A>(self: DocTree<A>) => self is AnnotationTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L183)

Since v1.0.0
DocTree-isCharTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.isCharTree

Returns `true` if the specified `DocTree` is an `CharTree`, `false` otherwise.

**Signature**

```ts
declare const isCharTree: <A>(self: DocTree<A>) => self is CharTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L159)

Since v1.0.0
DocTree-isConcatTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.isConcatTree

Returns `true` if the specified `DocTree` is an `ConcatTree`, `false` otherwise.

**Signature**

```ts
declare const isConcatTree: <A>(self: DocTree<A>) => self is ConcatTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L191)

Since v1.0.0
DocTree-isDocTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.isDocTree

Returns `true` if the specified value is a `DocTree`, `false` otherwise.

**Signature**

```ts
declare const isDocTree: (u: unknown) => u is DocTree<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L143)

Since v1.0.0
DocTree-isEmptyTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.isEmptyTree

Returns `true` if the specified `DocTree` is an `EmptyTree`, `false` otherwise.

**Signature**

```ts
declare const isEmptyTree: <A>(self: DocTree<A>) => self is EmptyTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L151)

Since v1.0.0
DocTree-isLineTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.isLineTree

Returns `true` if the specified `DocTree` is an `LineTree`, `false` otherwise.

**Signature**

```ts
declare const isLineTree: <A>(self: DocTree<A>) => self is LineTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L175)

Since v1.0.0
DocTree-isTextTree.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.isTextTree

Returns `true` if the specified `DocTree` is an `TextTree`, `false` otherwise.

**Signature**

```ts
declare const isTextTree: <A>(self: DocTree<A>) => self is TextTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L167)

Since v1.0.0
DocTree-reAnnotate.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.reAnnotate

Change the annotation of a `DocTree`.

**Signature**

```ts
declare const reAnnotate: { <A, B>(f: (a: A) => B): (self: DocTree<A>) => DocTree<B>; <A, B>(self: DocTree<A>, f: (a: A) => B): DocTree<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L262)

Since v1.0.0
DocTree-renderSimplyDecorated.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.renderSimplyDecorated

The simplest possible tree-based renderer.

For example, here is a document annotated with `void` and thee behavior is
to surround annotated regions with >>> and <<<.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as DocTree from "@effect/printer/DocTree"
import * as Layout from "@effect/printer/Layout"
import { identity, pipe } from "effect/Function"
import * as String from "@effect/typeclass/data/String"

const doc: Doc.Doc<void> = Doc.hsep([
  Doc.text("hello"),
  pipe(
    Doc.text("world"),
    Doc.annotate(undefined),
    Doc.cat(Doc.char("!"))
  )
])

const tree = DocTree.treeForm(Layout.pretty(Layout.defaultOptions)(doc))

const rendered = pipe(
  tree,
  DocTree.renderSimplyDecorated(String.Monoid, identity, (_, x) => `>>>${x}<<<`)
)

assert.strictEqual(
  rendered,
  "hello >>>world<<<!"
)
```

**Signature**

```ts
declare const renderSimplyDecorated: { <A, M>(M: monoid.Monoid<M>, renderText: (text: string) => M, renderAnnotation: (annotation: A, out: M) => M): (self: DocTree<A>) => M; <A, M>(self: DocTree<A>, M: monoid.Monoid<M>, renderText: (text: string) => M, renderAnnotation: (annotation: A, out: M) => M): M; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L332)

Since v1.0.0
DocTree-treeForm.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.treeForm

Converts a `DocStream<A>` into a `DocTree<A>`.

**Signature**

```ts
declare const treeForm: <A>(stream: DocStream.DocStream<A>) => DocTree<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L356)

Since v1.0.0
DocTree-unAnnotate.md
Package: `@effect/printer`<br />
Module: `DocTree`<br />

## DocTree.unAnnotate

Remove all annotations from a `DocTree`.

**Signature**

```ts
declare const unAnnotate: <A>(self: DocTree<A>) => DocTree<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/DocTree.ts#L273)

Since v1.0.0
Duration-between.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.between

Checks if a `Duration` is between a `minimum` and `maximum` value.

**Signature**

```ts
declare const between: { (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => boolean; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L520)

Since v2.0.0
Duration-format.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.format

Converts a `Duration` to a human readable string.

**Example**

```ts
import { Duration } from "effect"

Duration.format(Duration.millis(1000)) // "1s"
Duration.format(Duration.millis(1001)) // "1s 1ms"
```

**Signature**

```ts
declare const format: (self: DurationInput) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L819)

Since v2.0.0
Duration-formatIso.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.formatIso

Formats a Duration into an ISO8601 duration string.

Months are assumed to be 30 days and years are assumed to be 365 days.

Returns `Option.none()` if the duration is infinite.

**Example**

```ts
import { Duration, Option } from "effect"

Duration.formatIso(Duration.days(1)) // => Option.some("P1D")
Duration.formatIso(Duration.minutes(90)) // => Option.some("PT1H30M")
Duration.formatIso(Duration.millis(1500)) // => Option.some("PT1.5S")
Duration.formatIso(Duration.infinity) // => Option.none()
```

**Signature**

```ts
declare const formatIso: (self: DurationInput) => Option.Option<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L958)

Since v3.13.0
Duration-fromIso.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.fromIso

Parses an ISO8601 duration string into a `Duration`.

Months are assumed to be 30 days and years are assumed to be 365 days.

**Example**

```ts
import { Duration, Option } from "effect"

Duration.fromIso("P1D") // => Option.some(Duration.days(1))
Duration.fromIso("PT1H") // => Option.some(Duration.hours(1))
Duration.fromIso("PT1M") // => Option.some(Duration.minutes(1))
Duration.fromIso("PT1.5S") // => Option.some(Duration.seconds(1.5))
```

**Signature**

```ts
declare const fromIso: (iso: string) => Option.Option<Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L981)

Since v3.13.0
Duration-parts.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.parts

Converts a `Duration` to its parts.

**Signature**

```ts
declare const parts: (self: DurationInput) => { days: number; hours: number; minutes: number; seconds: number; millis: number; nanos: number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L769)

Since v3.8.0
Duration-toNanos.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.toNanos

Get the duration in nanoseconds as a bigint.

If the duration is infinite, returns `Option.none()`

**Signature**

```ts
declare const toNanos: (self: DurationInput) => Option.Option<bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L362)

Since v2.0.0
Duration-unsafeFormatIso.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.unsafeFormatIso

Formats a Duration into an ISO8601 duration string.

Months are assumed to be 30 days and years are assumed to be 365 days.

Milliseconds and nanoseconds are expressed as fractional seconds.

**Throws**

`RangeError` If the duration is not finite.

**Example**

```ts
import { Duration } from "effect"

Duration.unsafeFormatIso(Duration.days(1)) // => "P1D"
Duration.unsafeFormatIso(Duration.minutes(90)) // => "PT1H30M"
Duration.unsafeFormatIso(Duration.millis(1500)) // => "PT1.5S"
```

**Signature**

```ts
declare const unsafeFormatIso: (self: DurationInput) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L878)

Since v3.13.0
Duration-unsafeToNanos.md
Package: `effect`<br />
Module: `Duration`<br />

## Duration.unsafeToNanos

Get the duration in nanoseconds as a bigint.

If the duration is infinite, it throws an error.

**Signature**

```ts
declare const unsafeToNanos: (self: DurationInput) => bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L382)

Since v2.0.0
Effect-acquireRelease.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.acquireRelease

Creates a scoped resource using an `acquire` and `release` effect.

**Details**

This function helps manage resources by combining two `Effect` values: one
for acquiring the resource and one for releasing it.

`acquireRelease` does the following:

  1. Ensures that the effect that acquires the resource will not be
     interrupted. Note that acquisition may still fail due to internal
     reasons (such as an uncaught exception).
  2. Ensures that the `release` effect will not be interrupted, and will be
     executed as long as the acquisition effect successfully acquires the
     resource.

If the `acquire` function succeeds, the `release` function is added to the
list of finalizers for the scope. This ensures that the release will happen
automatically when the scope is closed.

Both `acquire` and `release` run uninterruptibly, meaning they cannot be
interrupted while they are executing.

Additionally, the `release` function can be influenced by the exit value when
the scope closes, allowing for custom handling of how the resource is
released based on the execution outcome.

**When to Use**

This function is used to ensure that an effect that represents the
acquisition of a resource (for example, opening a file, launching a thread,
etc.) will not be interrupted, and that the resource will always be released
when the `Effect` completes execution.

**Example** (Defining a Simple Resource)

```ts
import { Effect } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

// Create the resource management workflow
//
//       Effect<MyResource, Error, Scope>
//      
const resource = Effect.acquireRelease(acquire, release)
```

**See**

- `acquireUseRelease` for a version that automatically handles the scoping of resources.

**Signature**

```ts
declare const acquireRelease: { <A, X, R2>(release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5460)

Since v2.0.0
Effect-acquireReleaseInterruptible.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.acquireReleaseInterruptible

Creates a scoped resource with an interruptible acquire action.

**Details**

This function is similar to `acquireRelease`, but it allows the
acquisition of the resource to be interrupted. The `acquire` effect, which
represents the process of obtaining the resource, can be interrupted if
necessary.

**Signature**

```ts
declare const acquireReleaseInterruptible: { <X, R2>(release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5483)

Since v2.0.0
Effect-acquireUseRelease.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.acquireUseRelease

Many real-world operations involve working with resources that must be released when no longer needed, such as:

- Database connections
- File handles
- Network requests

This function ensures that a resource is:

1. **Acquired** properly.
2. **Used** for its intended purpose.
3. **Released** even if an error occurs.

**Example** (Automatically Managing Resource Lifetime)

```ts
import { Effect, Console } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

const use = (res: MyResource) => Console.log(`content is ${res.contents}`)

//       Effect<void, Error, never>
//      
const program = Effect.acquireUseRelease(acquire, use, release)

Effect.runPromise(program)
// Output:
// Resource acquired
// content is lorem ipsum
// Resource released
```

**Signature**

```ts
declare const acquireUseRelease: { <A2, E2, R2, A, X, R3>(use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, X, R3>(acquire: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): Effect<A2, E | E2, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5557)

Since v2.0.0
Effect-addFinalizer.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.addFinalizer

Ensures a finalizer is added to the scope of the calling effect, guaranteeing
it runs when the scope is closed.

**Details**

This function adds a finalizer that will execute whenever the scope of the
effect is closed, regardless of whether the effect succeeds, fails, or is
interrupted. The finalizer receives the `Exit` value of the effect's scope,
allowing it to react differently depending on how the effect concludes.

Finalizers are a reliable way to manage resource cleanup, ensuring that
resources such as file handles, network connections, or database transactions
are properly closed even in the event of an unexpected interruption or error.

Finalizers operate in conjunction with Effect's scoped resources. If an
effect with a finalizer is wrapped in a scope, the finalizer will execute
automatically when the scope ends.

**Example** (Adding a Finalizer on Success)

```ts
import { Effect, Console } from "effect"

//       Effect<string, never, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return "some result"
})

// Wrapping the effect in a scope
//
//       Effect<string, never, never>
//      
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Success
// { _id: 'Exit', _tag: 'Success', value: 'some result' }
```

**Example** (Adding a Finalizer on Failure)

```ts
import { Effect, Console } from "effect"

//       Effect<never, string, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.fail("Uh oh!")
})

// Wrapping the effect in a scope
//
//       Effect<never, string, never>
//      
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }
```

**Example** (Adding a Finalizer on Interruption)

```ts
import { Effect, Console } from "effect"

//       Effect<never, never, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.interrupt
})

// Wrapping the effect in a scope
//
//       Effect<never, never, never>
//      
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Interrupt',
//     fiberId: {
//       _id: 'FiberId',
//       _tag: 'Runtime',
//       id: 0,
//       startTimeMillis: ...
//     }
//   }
// }
```

**See**

- `onExit` for attaching a finalizer directly to an effect.

**Signature**

```ts
declare const addFinalizer: <X, R>(finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5688)

Since v2.0.0
Effect-all.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.all

Combines multiple effects into one, returning results based on the input
structure.

**Details**

Use this function when you need to run multiple effects and combine their
results into a single output. It supports tuples, iterables, structs, and
records, making it flexible for different input types.

For instance, if the input is a tuple:

```ts
//          a tuple of effects
//         
Effect.all([effect1, effect2, ...])
```

the effects are executed sequentially, and the result is a new effect
containing the results as a tuple. The results in the tuple match the order
of the effects passed to `Effect.all`.

**Concurrency**

You can control the execution order (e.g., sequential vs. concurrent) using
the `concurrency` option.

**Short-Circuiting Behavior**

This function stops execution on the first error it encounters, this is
called "short-circuiting". If any effect in the collection fails, the
remaining effects will not run, and the error will be propagated. To change
this behavior, you can use the `mode` option, which allows all effects to run
and collect results as `Either` or `Option`.

**The `mode` option**

The `{ mode: "either" }` option changes the behavior of `Effect.all` to
ensure all effects run, even if some fail. Instead of stopping on the first
failure, this mode collects both successes and failures, returning an array
of `Either` instances where each result is either a `Right` (success) or a
`Left` (failure).

Similarly, the `{ mode: "validate" }` option uses `Option` to indicate
success or failure. Each effect returns `None` for success and `Some` with
the error for failure.

**Example** (Combining Effects in Tuples)

```ts
import { Effect, Console } from "effect"

const tupleOfEffects = [
  Effect.succeed(42).pipe(Effect.tap(Console.log)),
  Effect.succeed("Hello").pipe(Effect.tap(Console.log))
] as const

//       Effect<[number, string], never, never>
//      
const resultsAsTuple = Effect.all(tupleOfEffects)

Effect.runPromise(resultsAsTuple).then(console.log)
// Output:
// 42
// Hello
// [ 42, 'Hello' ]
```

**Example** (Combining Effects in Iterables)

```ts
import { Effect, Console } from "effect"

const iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(
  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))
)

//       Effect<number[], never, never>
//      
const resultsAsArray = Effect.all(iterableOfEffects)

Effect.runPromise(resultsAsArray).then(console.log)
// Output:
// 1
// 2
// 3
// [ 1, 2, 3 ]
```

**Example** (Combining Effects in Structs)

```ts
import { Effect, Console } from "effect"

const structOfEffects = {
  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
  b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
}

//       Effect<{ a: number; b: string; }, never, never>
//      
const resultsAsStruct = Effect.all(structOfEffects)

Effect.runPromise(resultsAsStruct).then(console.log)
// Output:
// 42
// Hello
// { a: 42, b: 'Hello' }
```

**Example** (Combining Effects in Records)

```ts
import { Effect, Console } from "effect"

const recordOfEffects: Record<string, Effect.Effect<number>> = {
  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),
  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))
}

//       Effect<{ [x: string]: number; }, never, never>
//      
const resultsAsRecord = Effect.all(recordOfEffects)

Effect.runPromise(resultsAsRecord).then(console.log)
// Output:
// 1
// 2
// { key1: 1, key2: 2 }
```

**Example** (Short-Circuiting Behavior)

```ts
import { Effect, Console } from "effect"

const program = Effect.all([
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  // Won't execute due to earlier failure
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
])

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }
// }
```

**Example** (Collecting Results with `mode: "either"`)

```ts
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "either" })

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: [
//     { _id: 'Either', _tag: 'Right', right: 'Task1' },
//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },
//     { _id: 'Either', _tag: 'Right', right: 'Task3' }
//   ]
// }
```

**Example** (Collecting Results with `mode: "validate"`)

```ts
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "validate" })

Effect.runPromiseExit(program).then((result) => console.log("%o", result))
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [
//       { _id: 'Option', _tag: 'None' },
//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },
//       { _id: 'Option', _tag: 'None' }
//     ]
//   }
// }
```

**See**

- `forEach` for iterating over elements and applying an effect.
- `allWith` for a data-last version of this function.

**Signature**

```ts
declare const all: <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L825)

Since v2.0.0
Effect-allSuccesses.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.allSuccesses

Evaluates and runs each effect in the iterable, collecting only the
successful results while discarding failures.

**Details**

This function function processes an iterable of effects and runs each one. If
an effect is successful, its result is collected; if it fails, the result is
discarded. This ensures that only successful outcomes are kept.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Effect } from "effect"

const tasks = [
  Effect.succeed(1),
  Effect.fail("Error 1"),
  Effect.succeed(2),
  Effect.fail("Error 2")
]

const program = Effect.gen(function*() {
  const successfulResults = yield* Effect.allSuccesses(tasks)
  console.log(successfulResults)
})

Effect.runFork(program)
// Output: [1, 2]

```

**Signature**

```ts
declare const allSuccesses: <X extends Effect<any, any, any>>(elements: Iterable<X>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined) => Effect<Array<Effect.Success<X>>, never, Effect.Context<X>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1032)

Since v2.0.0
Effect-allWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.allWith

A data-last version of `all`, designed for use in pipelines.

**When to Use**

This function enables you to combine multiple effects and customize execution
options such as concurrency levels. This version is useful in functional
pipelines where you first define your data and then apply operations to it.

**Example**

```ts
import { Effect, pipe } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)

const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = pipe(
  [task1, task2],
  // Run both effects concurrently using the concurrent option
  Effect.allWith({ concurrency: 2 })
)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task2 done"
// timestamp=... level=INFO fiber=#2 message="task1 done"
// [ 1, 'hello' ]
```

**Signature**

```ts
declare const allWith: <O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(options?: O) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(arg: Arg) => All.Return<Arg, O>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L876)

Since v2.0.0
Effect-allowInterrupt.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.allowInterrupt

Allows interruption of the current fiber, even in uninterruptible regions.

**Details**

This effect checks whether any other fibers are attempting to interrupt the
current fiber. If so, it allows the current fiber to perform a
self-interruption.

**When to Use**

This is useful in situations where you want to allow interruption to happen
even in regions of the code that are normally uninterruptible.

**Signature**

```ts
declare const allowInterrupt: Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4731)

Since v2.0.0
Effect-andThen.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.andThen

Chains two actions, where the second action can depend on the result of the
first.

**Syntax**

```ts
const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
// or
const transformedEffect = Effect.andThen(myEffect, anotherEffect)
// or
const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))
```

**When to Use**

Use `andThen` when you need to run multiple actions in sequence, with the
second action depending on the result of the first. This is useful for
combining effects or handling computations that must happen in order.

**Details**

The second action can be:

- A constant value (similar to `as`)
- A function returning a value (similar to `map`)
- A `Promise`
- A function returning a `Promise`
- An `Effect`
- A function returning an `Effect` (similar to `flatMap`)

**Note:** `andThen` works well with both `Option` and `Either` types,
treating them as effects.

**Example** (Applying a Discount Based on Fetched Amount)

```ts
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Using Effect.map and Effect.flatMap
const result1 = pipe(
  fetchTransactionAmount,
  Effect.map((amount) => amount * 2),
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result1).then(console.log)
// Output: 190

// Using Effect.andThen
const result2 = pipe(
  fetchTransactionAmount,
  Effect.andThen((amount) => amount * 2),
  Effect.andThen((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result2).then(console.log)
// Output: 190
```

**Signature**

```ts
declare const andThen: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8935)

Since v2.0.0
Effect-annotateCurrentSpan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.annotateCurrentSpan

Adds annotations to the currently active span for traceability.

**Details**

This function adds key-value annotations to the currently active span in the
effect's trace. These annotations help provide more context about the
operation being executed at a specific point in time. Unlike
`annotateSpans`, which applies to all spans in an effect, this function
focuses solely on the active span.

You can either pass a single key-value pair or a record of key-value pairs to
annotate the span. These annotations are useful for adding metadata to
operations, especially in systems with detailed observability requirements.

**Signature**

```ts
declare const annotateCurrentSpan: { (key: string, value: unknown): Effect<void>; (values: Record<string, unknown>): Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12969)

Since v2.0.0
Effect-annotateLogs.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.annotateLogs

Adds custom annotations to log entries generated within an effect.

**Details**

This function allows you to enhance log messages by appending additional
context in the form of key-value pairs. These annotations are included in
every log message created during the execution of the effect, making the logs
more informative and easier to trace.

The annotations can be specified as a single key-value pair or as a record of
multiple key-value pairs. This is particularly useful for tracking
operations, debugging, or associating specific metadata with logs for better
observability.

The annotated key-value pairs will appear alongside the log message in the
output.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("message1")
  yield* Effect.log("message2")
}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234
// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234
```

**See**

- `annotateLogsScoped` to add log annotations with a limited scope.

**Signature**

```ts
declare const annotateLogs: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11083)

Since v2.0.0
Effect-Do.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

**See**

- `bind`
- `bindTo`
- `let`

**Signature**

```ts
declare const Do: Effect<{}, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7851)

Since v2.0.0
Effect-annotateLogsScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.annotateLogsScoped

Adds log annotations with a limited scope to enhance contextual logging.

**Details**

This function allows you to apply key-value annotations to log entries
generated within a specific scope of your effect computations. The
annotations are restricted to the defined `Scope`, ensuring that they are
only applied to logs produced during that scope. Once the scope ends, the
annotations are automatically removed, making it easier to manage
context-specific logging without affecting other parts of your application.

The annotations can be provided as a single key-value pair or as a record of
multiple key-value pairs. This flexibility enables fine-grained control over
the additional metadata included in logs for specific tasks or operations.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("no annotations")
  yield* Effect.annotateLogsScoped({ key: "value" })
  yield* Effect.log("message1") // Annotation is applied to this log
  yield* Effect.log("message2") // Annotation is applied to this log
}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="no annotations"
// timestamp=... level=INFO fiber=#0 message=message1 key=value
// timestamp=... level=INFO fiber=#0 message=message2 key=value
// timestamp=... level=INFO fiber=#0 message="no annotations again"
```

**See**

- `annotateLogs` to add custom annotations to log entries generated within an effect.

**Signature**

```ts
declare const annotateLogsScoped: { (key: string, value: unknown): Effect<void, never, Scope.Scope>; (values: Record<string, unknown>): Effect<void, never, Scope.Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11130)

Since v3.1.0
Effect-annotateSpans.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.annotateSpans

Adds annotations to each span in the effect for enhanced traceability.

**Details**

This function lets you attach key-value annotations to all spans generated
during the execution of an effect. Annotations provide additional context,
such as metadata or labels, which can help you understand and debug
asynchronous workflows more effectively.

You can either pass a single key-value pair or a record of key-value pairs to
annotate the spans. These annotations can then be visualized in tracing tools
that support span annotations.

**Signature**

```ts
declare const annotateSpans: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12944)

Since v2.0.0
Effect-ap.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.ap

Applies the function produced by one effect to the value produced by another effect.

**Details**

This function combines two effects:
- The first effect produces a function of type `(a: A) => B`.
- The second effect produces a value of type `A`.

Once both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.

**Signature**

```ts
declare const ap: { <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E | E2, R | R2>; <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12776)

Since v2.0.0
Effect-as.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.as

Replaces the value inside an effect with a constant value.

**Details**

This function allows you to ignore the original value inside an effect and
replace it with a constant value.

**When to Use**

It is useful when you no longer need the value produced by an effect but want
to ensure that the effect completes successfully with a specific constant
result instead. For instance, you can replace the value produced by a
computation with a predefined value, ignoring what was calculated before.

**Example** (Replacing a Value)

```ts
import { pipe, Effect } from "effect"

// Replaces the value 5 with the constant "new value"
const program = pipe(Effect.succeed(5), Effect.as("new value"))

Effect.runPromise(program).then(console.log)
// Output: "new value"
```

**Signature**

```ts
declare const as: { <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5049)

Since v2.0.0
Effect-asSome.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.asSome

This function maps the success value of an `Effect` value to a `Some` value
in an `Option` value. If the original `Effect` value fails, the returned
`Effect` value will also fail.

**Signature**

```ts
declare const asSome: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5062)

Since v2.0.0
Effect-asSomeError.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.asSomeError

This function maps the error value of an `Effect` value to a `Some` value
in an `Option` value. If the original `Effect` value succeeds, the returned
`Effect` value will also succeed.

**Signature**

```ts
declare const asSomeError: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Option.Option<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5072)

Since v2.0.0
Effect-asVoid.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.asVoid

This function maps the success value of an `Effect` value to `void`. If the
original `Effect` value succeeds, the returned `Effect` value will also
succeed. If the original `Effect` value fails, the returned `Effect` value
will fail with the same error.

**Signature**

```ts
declare const asVoid: <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5083)

Since v2.0.0
Effect-async.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.async

Creates an `Effect` from a callback-based asynchronous function.

**Details**

The `resume` function:
- Must be called exactly once. Any additional calls will be ignored.
- Can return an optional `Effect` that will be run if the `Fiber` executing
  this `Effect` is interrupted. This can be useful in scenarios where you
  need to handle resource cleanup if the operation is interrupted.
- Can receive an `AbortSignal` to handle interruption if needed.

The `FiberId` of the fiber that may complete the async callback may also be
specified using the `blockingOn` argument. This is called the "blocking
fiber" because it suspends the fiber executing the `async` effect (i.e.
semantically blocks the fiber from making progress). Specifying this fiber id
in cases where it is known will improve diagnostics, but not affect the
behavior of the returned effect.

**When to Use**

Use `Effect.async` when dealing with APIs that use callback-style instead of
`async/await` or `Promise`.

**Example** (Wrapping a Callback API)

```ts
import { Effect } from "effect"
import * as NodeFS from "node:fs"

const readFile = (filename: string) =>
  Effect.async<Buffer, Error>((resume) => {
    NodeFS.readFile(filename, (error, data) => {
      if (error) {
        // Resume with a failed Effect if an error occurs
        resume(Effect.fail(error))
      } else {
        // Resume with a succeeded Effect if successful
        resume(Effect.succeed(data))
      }
    })
  })

//       Effect<Buffer, Error, never>
//      
const program = readFile("example.txt")
```

**Example** (Handling Interruption with Cleanup)

```ts
import { Effect, Fiber } from "effect"
import * as NodeFS from "node:fs"

// Simulates a long-running operation to write to a file
const writeFileWithCleanup = (filename: string, data: string) =>
  Effect.async<void, Error>((resume) => {
    const writeStream = NodeFS.createWriteStream(filename)

    // Start writing data to the file
    writeStream.write(data)

    // When the stream is finished, resume with success
    writeStream.on("finish", () => resume(Effect.void))

    // In case of an error during writing, resume with failure
    writeStream.on("error", (err) => resume(Effect.fail(err)))

    // Handle interruption by returning a cleanup effect
    return Effect.sync(() => {
      console.log(`Cleaning up ${filename}`)
      NodeFS.unlinkSync(filename)
    })
  })

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(
    writeFileWithCleanup("example.txt", "Some long data...")
  )
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber) // This will trigger the cleanup
})

// Run the program
Effect.runPromise(program)
// Output:
// Cleaning up example.txt
```

**Example** (Handling Interruption with AbortSignal)

```ts
import { Effect, Fiber } from "effect"

// A task that supports interruption using AbortSignal
const interruptibleTask = Effect.async<void, Error>((resume, signal) => {
  // Handle interruption
  signal.addEventListener("abort", () => {
    console.log("Abort signal received")
    clearTimeout(timeoutId)
  })

  // Simulate a long-running task
  const timeoutId = setTimeout(() => {
    console.log("Operation completed")
    resume(Effect.void)
  }, 2000)
})

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(interruptibleTask)
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber)
})

// Run the program
Effect.runPromise(program)
// Output:
// Abort signal received
```

**Signature**

```ts
declare const async: <A, E = never, R = never>(resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>, blockingOn?: FiberId.FiberId) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2488)

Since v2.0.0
Effect-asyncEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.asyncEffect

A variant of `async` where the registration function may return an `Effect`.

**Signature**

```ts
declare const asyncEffect: <A, E, R, R3, E2, R2>(register: (callback: (_: Effect<A, E, R>) => void) => Effect<Effect<void, never, R3> | void, E2, R2>) => Effect<A, E | E2, R | R2 | R3>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2499)

Since v2.0.0
Effect-awaitAllChildren.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.awaitAllChildren

Returns a new effect that will not succeed with its value before first
waiting for the end of all child fibers forked by the effect.

**Signature**

```ts
declare const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6156)

Since v2.0.0
Effect-bind.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

**See**

- `Do`
- `bindTo`
- `let`

**Signature**

```ts
declare const bind: { <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E1, R2 | R1>; <A extends object, N extends string, E1, R1, B, E2, R2>(self: Effect<A, E1, R1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E1 | E2, R1 | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7885)

Since v2.0.0
Effect-bindAll.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.bindAll

`bindAll` combines `all` with `bind`. It is useful
when you want to concurrently run multiple effects and then combine their
results in a Do notation pipeline.

**Example**

```ts
import * as assert from "node:assert"
import { Effect, Either, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bindAll(({ x }) => ({
    a: Effect.succeed(x),
    b: Effect.fail("oops"),
  }), { concurrency: 2, mode: "either" })
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })
```

**Signature**

```ts
declare const bindAll: { <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | O): <E1, R1>(self: Effect<A, E1, R1>) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>, E1, R1>(self: Effect<A, E1, R1>, f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7922)

Since v3.7.0
Effect-bindTo.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

**See**

- `Do`
- `bind`
- `let`

**Signature**

```ts
declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A; }, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8005)

Since v2.0.0
Effect-cached.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.cached

Returns an effect that lazily computes a result and caches it for subsequent
evaluations.

**Details**

This function wraps an effect and ensures that its result is computed only
once. Once the result is computed, it is cached, meaning that subsequent
evaluations of the same effect will return the cached result without
re-executing the logic.

**When to Use**

Use this function when you have an expensive or time-consuming operation that
you want to avoid repeating. The first evaluation will compute the result,
and all following evaluations will immediately return the cached value,
improving performance and reducing unnecessary work.

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  console.log("non-cached version:")
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  console.log("cached version:")
  const cached = yield* Effect.cached(expensiveTask)
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
// Output:
// non-cached version:
// expensive task...
// result 1
// expensive task...
// result 2
// cached version:
// expensive task...
// result 3
// result 3
```

**See**

- `cachedWithTTL` for a similar function that includes a
time-to-live duration for the cached value.
- `cachedInvalidateWithTTL` for a similar function that includes an
additional effect for manually invalidating the cached value.

**Signature**

```ts
declare const cached: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L500)

Since v2.0.0
Effect-cachedFunction.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.cachedFunction

Returns a memoized version of a function with effects, reusing results for
the same inputs.

**Details**

This function creates a memoized version of a given function that performs an
effect. Memoization ensures that once a result is computed for a specific
input, it is stored and reused for subsequent calls with the same input,
reducing the need to recompute the result.

The function can optionally take an `Equivalence` parameter to
determine how inputs are compared for caching purposes.

**When to Use**

Use this function when you have a function that performs an effect and you
want to avoid recomputing the result for the same input multiple times.

It's ideal for functions that produce deterministic results based on their
inputs, and you want to improve performance by caching the output.

This is particularly useful in scenarios where the function involves
expensive calculations or operations that should be avoided after the first
execution with the same parameters.

**Example**

```ts
import { Effect, Random } from "effect"

const program = Effect.gen(function* () {
  const randomNumber = (n: number) => Random.nextIntBetween(1, n)
  console.log("non-memoized version:")
  console.log(yield* randomNumber(10))
  console.log(yield* randomNumber(10))

  console.log("memoized version:")
  const memoized = yield* Effect.cachedFunction(randomNumber)
  console.log(yield* memoized(10))
  console.log(yield* memoized(10))
})

Effect.runFork(program)
// Example Output:
// non-memoized version:
// 2
// 8
// memoized version:
// 5
// 5
```

**Signature**

```ts
declare const cachedFunction: <A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L558)

Since v2.0.0
Effect-cachedInvalidateWithTTL.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.cachedInvalidateWithTTL

Caches an effect's result for a specified duration and allows manual
invalidation before expiration.

**Details**

This function behaves similarly to `cachedWithTTL` by caching the
result of an effect for a specified period of time. However, it introduces an
additional feature: it provides an effect that allows you to manually
invalidate the cached result before it naturally expires.

This gives you more control over the cache, allowing you to refresh the
result when needed, even if the original cache has not yet expired.

Once the cache is invalidated, the next time the effect is evaluated, the
result will be recomputed, and the cache will be refreshed.

**When to Use**

Use this function when you have an effect whose result needs to be cached for
a certain period, but you also want the option to refresh the cache manually
before the expiration time.

This is useful when you need to ensure that the cached data remains valid for
a certain period but still want to invalidate it if the underlying data
changes or if you want to force a recomputation.

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(
    expensiveTask,
    "1 hour"
  )
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* invalidate
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
// Output:
// expensive task...
// result 1
// result 1
// expensive task...
// result 2
```

**See**

- `cached` for a similar function that caches the result
indefinitely.
- `cachedWithTTL` for a similar function that caches the result for
a specified duration but does not include an effect for manual invalidation.

**Signature**

```ts
declare const cachedInvalidateWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E>, Effect<void>], never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<[Effect<A, E>, Effect<void>], never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L426)

Since v2.0.0
Effect-cachedWithTTL.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.cachedWithTTL

Returns an effect that caches its result for a specified `Duration`,
known as "timeToLive" (TTL).

**Details**

This function is used to cache the result of an effect for a specified amount
of time. This means that the first time the effect is evaluated, its result
is computed and stored.

If the effect is evaluated again within the specified `timeToLive`, the
cached result will be used, avoiding recomputation.

After the specified duration has passed, the cache expires, and the effect
will be recomputed upon the next evaluation.

**When to Use**

Use this function when you have an effect that involves costly operations or
computations, and you want to avoid repeating them within a short time frame.

It's ideal for scenarios where the result of an effect doesn't change
frequently and can be reused for a specified duration.

By caching the result, you can improve efficiency and reduce unnecessary
computations, especially in performance-critical applications.

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* Effect.sleep("100 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
// Output:
// expensive task...
// result 1
// result 1
// expensive task...
// result 2
```

**See**

- `cached` for a similar function that caches the result
indefinitely.
- `cachedInvalidateWithTTL` for a similar function that includes an
additional effect for manually invalidating the cached value.

**Signature**

```ts
declare const cachedWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<Effect<A, E>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L351)

Since v2.0.0
Effect-catch.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catch

Recovers from a specified error by catching it and handling it with a provided function.

**Details**

This function allows you to recover from specific errors that occur during
the execution of an effect. It works by catching a specific type of error
(identified by a discriminator) and then handling it using a provided
handler function. The handler can return a new effect that helps recover
from the error, allowing the program to continue. If the error doesn't
match the specified type, the function allows the original effect to
continue as it was.

**Example**

```ts
import { Console, Effect } from "effect"

class NetworkError {
  readonly _tag = "NetworkError"
}
class ValidationError {
  readonly _tag = "ValidationError"
}

// Simulate an effect that may fail
const task: Effect.Effect<never, NetworkError | ValidationError, never> = Effect.fail(new NetworkError())

const program = Effect.gen(function*() {
  const result = yield* Effect.catch(task, "_tag", {
    failure: "NetworkError",
    onFailure: (error) => Effect.succeed(`recovered from error: ${error._tag}`)
  })
  console.log(`Result: ${result}`)
})

Effect.runFork(program)
// Output: Result: recovered from error: NetworkError
```

**See**

- `catchTag` for a version that can recover from errors based on a `_tag` discriminator.

**Signature**

```ts
declare const catch: { <N extends keyof E, K extends E[N] & string, E, A1, E1, R1>(discriminator: N, options: { readonly failure: K; readonly onFailure: (error: Extract<E, { [n in N]: K; }>) => Effect<A1, E1, R1>; }): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { [n in N]: K; }>, R1 | R>; <A, E, R, N extends keyof E, K extends E[N] & string, A1, E1, R1>(self: Effect<A, E, R>, discriminator: N, options: { readonly failure: K; readonly onFailure: (error: Extract<E, { [n in N]: K; }>) => Effect<A1, E1, R1>; }): Effect<A | A1, E1 | Exclude<E, { [n in N]: K; }>, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3414)

Since v2.0.0
Effect-catchAll.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchAll

Handles all errors in an effect by providing a fallback effect.

**Details**

This function catches any errors that may occur during the execution of an
effect and allows you to handle them by specifying a fallback effect. This
ensures that the program continues without failing by recovering from errors
using the provided fallback logic.

**Note**: This function only handles recoverable errors. It will not recover
from unrecoverable defects.

**Example** (Providing Recovery Logic for Recoverable Errors)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = program.pipe(
  Effect.catchAll((error) =>
    Effect.succeed(`Recovering from ${error._tag}`)
  )
)
```

**See**

- `catchAllCause` for a version that can recover from both
recoverable and unrecoverable errors.

**Signature**

```ts
declare const catchAll: { <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3472)

Since v2.0.0
Effect-catchAllCause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchAllCause

Handles both recoverable and unrecoverable errors by providing a recovery
effect.

**When to Use**

The `catchAllCause` function allows you to handle all errors, including
unrecoverable defects, by providing a recovery effect. The recovery logic is
based on the `Cause` of the error, which provides detailed information about
the failure.

**When to Recover from Defects**

Defects are unexpected errors that typically shouldn't be recovered from, as
they often indicate serious issues. However, in some cases, such as
dynamically loaded plugins, controlled recovery might be needed.

**Example** (Recovering from All Errors)

```ts
import { Cause, Effect } from "effect"

// Define an effect that may fail with a recoverable or unrecoverable error
const program = Effect.fail("Something went wrong!")

// Recover from all errors by examining the cause
const recovered = program.pipe(
  Effect.catchAllCause((cause) =>
    Cause.isFailure(cause)
      ? Effect.succeed("Recovered from a regular error")
      : Effect.succeed("Recovered from a defect")
  )
)

Effect.runPromise(recovered).then(console.log)
// Output: "Recovered from a regular error"
```

**Signature**

```ts
declare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3518)

Since v2.0.0
Effect-catchAllDefect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchAllDefect

Recovers from all defects using a provided recovery function.

**When to Use**

There is no sensible way to recover from defects. This method should be used
only at the boundary between Effect and an external system, to transmit
information on a defect for diagnostic or explanatory purposes.

**Details**

`catchAllDefect` allows you to handle defects, which are unexpected errors
that usually cause the program to terminate. This function lets you recover
from these defects by providing a function that handles the error. However,
it does not handle expected errors (like those from `fail`) or
execution interruptions (like those from `interrupt`).

**When to Recover from Defects**

Defects are unexpected errors that typically shouldn't be recovered from, as
they often indicate serious issues. However, in some cases, such as
dynamically loaded plugins, controlled recovery might be needed.

**Example** (Handling All Defects)

```ts
import { Effect, Cause, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchAllDefect(task, (defect) => {
  if (Cause.isRuntimeException(defect)) {
    return Console.log(
      `RuntimeException defect caught: ${defect.message}`
    )
  }
  return Console.log("Unknown defect caught.")
})

// We get an Exit.Success because we caught all defects
Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }
```

**Signature**

```ts
declare const catchAllDefect: { <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3582)

Since v2.0.0
Effect-catchIf.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchIf

Recovers from specific errors based on a predicate.

**When to Use**

`catchIf` works similarly to `catchSome`, but it allows you to
recover from errors by providing a predicate function. If the predicate
matches the error, the recovery effect is applied. This function doesn't
alter the error type, so the resulting effect still carries the original
error type unless a user-defined type guard is used to narrow the type.

**Example** (Catching Specific Errors with a Predicate)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, ValidationError, never>
//      
const recovered = program.pipe(
  Effect.catchIf(
    // Only handle HttpError errors
    (error) => error._tag === "HttpError",
    () => Effect.succeed("Recovering from HttpError")
  )
)
```

**Signature**

```ts
declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<E>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3644)

Since v2.0.0
Effect-catchSome.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchSome

Catches and recovers from specific types of errors, allowing you to attempt
recovery only for certain errors.

**Details**

`catchSome` lets you selectively catch and handle errors of certain
types by providing a recovery effect for specific errors. If the error
matches a condition, recovery is attempted; if not, it doesn't affect the
program. This function doesn't alter the error type, meaning the error type
remains the same as in the original effect.

**Example** (Handling Specific Errors with Effect.catchSome)

```ts
import { Effect, Random, Option } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, HttpError | ValidationError, never>
//      
const recovered = program.pipe(
  Effect.catchSome((error) => {
    // Only handle HttpError errors
    if (error._tag === "HttpError") {
      return Option.some(Effect.succeed("Recovering from HttpError"))
    } else {
      return Option.none()
    }
  })
)
```

**See**

- `catchIf` for a version that allows you to recover from errors based on a predicate.

**Signature**

```ts
declare const catchSome: { <E, A2, E2, R2>(pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3723)

Since v2.0.0
Effect-catchSomeCause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchSomeCause

Recovers from specific causes using a provided partial function.

**See**

- `catchSome` for a version that allows you to recover from errors.
- `catchSomeDefect` for a version that allows you to recover from defects.

**Signature**

```ts
declare const catchSomeCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): Effect<A2 | A, E | E2, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3742)

Since v2.0.0
Effect-catchSomeDefect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchSomeDefect

Recovers from specific defects using a provided partial function.

**Details**

`catchSomeDefect` allows you to handle specific defects, which are
unexpected errors that can cause the program to stop. It uses a partial
function to catch only certain defects and ignores others. The function does
not handle expected errors (such as those caused by `fail`) or
interruptions in execution (like those caused by `interrupt`).

This function provides a way to handle certain types of defects while
allowing others to propagate and cause failure in the program.

**Note**: There is no sensible way to recover from defects. This method
should be used only at the boundary between Effect and an external system, to
transmit information on a defect for diagnostic or explanatory purposes.

**How the Partial Function Works**

The function provided to `catchSomeDefect` acts as a filter and a handler for defects:
- It receives the defect as an input.
- If the defect matches a specific condition (e.g., a certain error type), the function returns
  an `Option.some` containing the recovery logic.
- If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.

**Example** (Handling Specific Defects)

```ts
import { Effect, Cause, Option, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchSomeDefect(task, (defect) => {
  if (Cause.isIllegalArgumentException(defect)) {
    return Option.some(
      Console.log(
        `Caught an IllegalArgumentException defect: ${defect.message}`
      )
    )
  }
  return Option.none()
})

// Since we are only catching IllegalArgumentException
// we will get an Exit.Failure because we simulated a runtime error.
Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: { _tag: 'RuntimeException' }
//   }
// }
```

**Signature**

```ts
declare const catchSomeDefect: { <A2, E2, R2>(pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3815)

Since v2.0.0
Effect-catchTag.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchTag

Catches and handles specific errors by their `_tag` field, which is used as a
discriminator.

**When to Use**

`catchTag` is useful when your errors are tagged with a readonly `_tag` field
that identifies the error type. You can use this function to handle specific
error types by matching the `_tag` value. This allows for precise error
handling, ensuring that only specific errors are caught and handled.

The error type must have a readonly `_tag` field to use `catchTag`. This
field is used to identify and match errors.

**Example** (Handling Errors by Tag)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, ValidationError, never>
//      
const recovered = program.pipe(
  // Only handle HttpError errors
  Effect.catchTag("HttpError", (_HttpError) =>
    Effect.succeed("Recovering from HttpError")
  )
)
```

**See**

- `catchTags` for a version that allows you to handle multiple error
types at once.

**Signature**

```ts
declare const catchTag: { <E, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>>(...tags: K): <A, R>(self: Effect<A, E, R> & "missing error handler") => never; <E, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>, A1, E1, R1>(...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number]; }>) => Effect<A1, E1, R1>]): <A, R>(self: Effect<A, E, R>) => Effect<A | A1, Exclude<E, { _tag: K[number]; }> | E1, R | R1>; <A, E, R, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>>(self: Effect<A, E, R> & "missing error handler", ...tags: K): never; <A, E, R, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>, R1, E1, A1>(self: Effect<A, E, R>, ...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number]; }>) => Effect<A1, E1, R1>]): Effect<A | A1, Exclude<E, { _tag: K[number]; }> | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3882)

Since v2.0.0
Effect-catchTags.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.catchTags

Handles multiple errors in a single block of code using their `_tag` field.

**When to Use**

`catchTags` is a convenient way to handle multiple error types at
once. Instead of using `catchTag` multiple times, you can pass an
object where each key is an error type's `_tag`, and the value is the handler
for that specific error. This allows you to catch and recover from multiple
error types in a single call.

The error type must have a readonly `_tag` field to use `catchTag`. This
field is used to identify and match errors.

**Example** (Handling Multiple Tagged Error Types at Once)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = program.pipe(
  Effect.catchTags({
    HttpError: (_HttpError) =>
      Effect.succeed(`Recovering from HttpError`),
    ValidationError: (_ValidationError) =>
      Effect.succeed(`Recovering from ValidationError`)
  })
)
```

**Signature**

```ts
declare const catchTags: { <E, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3955)

Since v2.0.0
Effect-cause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.cause

Retrieves the cause of a failure in an effect.

**Details**

This function allows you to expose the detailed cause of an effect, which
includes a more precise representation of failures, such as error messages
and defects.

**When to Use**

This function is helpful when you need to inspect the cause of a failure in
an effect, giving you more information than just the error message. It can be
used to log, handle, or analyze failures in more detail, including
distinguishing between different types of defects (e.g., runtime exceptions,
interruptions, etc.).

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<void, never, never>
//      
const recovered = Effect.gen(function* () {
  const cause = yield* Effect.cause(program)
  yield* Console.log(cause)
})
```

**Signature**

```ts
declare const cause: <A, E, R>(self: Effect<A, E, R>) => Effect<Cause.Cause<E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4042)

Since v2.0.0
Effect-checkInterruptible.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.checkInterruptible

Checks if interruption is allowed and executes a callback accordingly.

**Details**

This function checks the current interrupt status of the running fiber. It
then calls the provided callback, passing a boolean indicating whether
interruption is allowed.

**When to Use**

This is useful for handling specific logic based on whether the current
operation can be interrupted, such as when performing asynchronous operations
or handling cancellation.

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.checkInterruptible((isInterruptible) => {
    if (isInterruptible) {
      return Console.log("You can interrupt this operation.")
    } else {
      return Console.log("This operation cannot be interrupted.")
    }
  })
})

Effect.runPromise(program)
// Output: You can interrupt this operation.

Effect.runPromise(program.pipe(Effect.uninterruptible))
// Output: This operation cannot be interrupted.

```

**Signature**

```ts
declare const checkInterruptible: <A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4774)

Since v2.0.0
Effect-clock.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.clock

Retrieves the `Clock` service from the context.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  const clock = yield* Effect.clock
  const currentTime = yield* clock.currentTimeMillis
  console.log(`Current time in milliseconds: ${currentTime}`)
})

Effect.runFork(program)
// Example Output:
// Current time in milliseconds: 1735484796134
```

**Signature**

```ts
declare const clock: Effect<Clock.Clock, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6747)

Since v2.0.0
Effect-clockWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.clockWith

Retrieves the `Clock` service from the context and provides it to the
specified effectful function.

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.clockWith((clock) =>
  clock.currentTimeMillis.pipe(
    Effect.map((currentTime) => `Current time is: ${currentTime}`),
    Effect.tap(Console.log)
  )
)

Effect.runFork(program)
// Example Output:
// Current time is: 1735484929744
```

**Signature**

```ts
declare const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6773)

Since v2.0.0
Effect-configProviderWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.configProviderWith

Allows working with the default configuration provider.

**Details**

This function retrieves the default configuration provider and passes it to
the provided function, which can use it to perform computations or retrieve
configuration values. The function can return an effect that leverages the
configuration provider for its operations.

**Signature**

```ts
declare const configProviderWith: <A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7335)

Since v2.0.0
Effect-console.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.console

Retreives the `Console` service from the context

**Signature**

```ts
declare const console: Effect<Console, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6803)

Since v2.0.0
Effect-consoleWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.consoleWith

Retreives the `Console` service from the context and provides it to the
specified effectful function.

**Signature**

```ts
declare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6812)

Since v2.0.0
Effect-context.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.context

Accesses the full context of the effect.

**Details**

This function provides the ability to access the entire context required by
an effect. The context is a container that holds dependencies or environment
values needed by an effect to run. By using this function, you can retrieve
and work with the context directly within an effect.

**Signature**

```ts
declare const context: <R>() => Effect<Context.Context<R>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7408)

Since v2.0.0
Effect-contextWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.contextWith

Accesses the context and applies a transformation function.

**Details**

This function retrieves the context of the effect and applies a pure
transformation function to it. The result of the transformation is then
returned within the effect.

**See**

- `contextWithEffect` for a version that allows effectful transformations.

**Signature**

```ts
declare const contextWith: <R, A>(f: (context: Context.Context<R>) => A) => Effect<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7424)

Since v2.0.0
Effect-contextWithEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.contextWithEffect

Accesses the context and performs an effectful transformation.

**Details**

This function retrieves the context and allows you to transform it
effectually using another effect. It is useful when the transformation
involves asynchronous or effectful operations.

**See**

- `contextWith` for a version that allows pure transformations.

**Signature**

```ts
declare const contextWithEffect: <R2, A, E, R>(f: (context: Context.Context<R2>) => Effect<A, E, R>) => Effect<A, E, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7440)

Since v2.0.0
Effect-custom.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.custom

Low level constructor that enables for custom stack tracing cutpoints.

It is meant to be called with a bag of instructions that become available in
the "this" of the effect.

**Example**

```ts
import { Effect } from "effect"

const throwingFunction = () => { throw new Error() }
const blowUp = Effect.custom(throwingFunction, function() {
  return Effect.succeed(this.effect_instruction_i0())
})
```

**Signature**

```ts
declare const custom: { <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, A, E, R>(i0: X, i1: Y, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, Z, A, E, R>(i0: X, i1: Y, i2: Z, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z; }) => Effect<A, E, R>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2523)

Since v2.0.0
Effect-daemonChildren.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.daemonChildren

Returns a new workflow that will not supervise any fibers forked by this
workflow.

**Signature**

```ts
declare const daemonChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6165)

Since v2.0.0
Effect-delay.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.delay

Delays the execution of an effect by a specified `Duration`.

**Details

This function postpones the execution of the provided effect by the specified
duration. The duration can be provided in various formats supported by the
`Duration` module.

Internally, this function does not block the thread; instead, it uses an
efficient, non-blocking mechanism to introduce the delay.

**Example**

```ts
import { Console, Effect } from "effect"

const task = Console.log("Task executed")

const program = Console.log("start").pipe(
  Effect.andThen(
    // Delays the log message by 2 seconds
    task.pipe(Effect.delay("2 seconds"))
  )
)

Effect.runFork(program)
// Output:
// start
// Task executed
```

**Signature**

```ts
declare const delay: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6871)

Since v2.0.0
Effect-descriptor.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.descriptor

Constructs an effect with information about the current `Fiber`.

**Signature**

```ts
declare const descriptor: Effect<Fiber.Fiber.Descriptor, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6173)

Since v2.0.0
Effect-descriptorWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.descriptorWith

Constructs an effect based on information about the current `Fiber`.

**Signature**

```ts
declare const descriptorWith: <A, E, R>(f: (descriptor: Fiber.Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6181)

Since v2.0.0
Effect-die.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.die

Creates an effect that terminates a fiber with a specified error.

**Details**

This function is used to signal a defect, which represents a critical and
unexpected error in the code. When invoked, it produces an effect that does
not handle the error and instead terminates the fiber.

The error channel of the resulting effect is of type `never`, indicating that
it cannot recover from this failure.

**When to Use**

Use this function when encountering unexpected conditions in your code that
should not be handled as regular errors but instead represent unrecoverable
defects.

**Example** (Terminating on Division by Zero with a Specified Error)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.die(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = divide(1, 0)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...
```

**See**

- `dieSync` for a variant that throws a specified error, evaluated
lazily.
- `dieMessage` for a variant that throws a `RuntimeException` with a
message.

**Signature**

```ts
declare const die: (defect: unknown) => Effect<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2647)

Since v2.0.0
Effect-dieMessage.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.dieMessage

Creates an effect that terminates a fiber with a `RuntimeException`
containing the specified message.

**Details**

This function is used to signal a defect, representing a critical and
unexpected error in the code. When invoked, it produces an effect that
terminates the fiber with a `RuntimeException` carrying the given message.

The resulting effect has an error channel of type `never`, indicating it does
not handle or recover from the error.

**When to Use**

Use this function when you want to terminate a fiber due to an unrecoverable
defect and include a clear explanation in the message.

**Example** (Terminating on Division by Zero with a Specified Message)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.dieMessage("Cannot divide by zero")
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = divide(1, 0)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) RuntimeException: Cannot divide by zero
//   ...stack trace...
```

**See**

- `die` for a variant that throws a specified error.
- `dieSync` for a variant that throws a specified error, evaluated
lazily.

**Signature**

```ts
declare const dieMessage: (message: string) => Effect<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2694)

Since v2.0.0
Effect-dieSync.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.dieSync

Creates an effect that dies with the specified error, evaluated lazily.

**Details**

This function allows you to create an effect that will terminate with a fatal error.
The error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.

**See**

- `die` if you don't need to evaluate the error lazily.

**Signature**

```ts
declare const dieSync: (evaluate: LazyArg<unknown>) => Effect<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2709)

Since v2.0.0
Effect-diffFiberRefs.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.diffFiberRefs

Returns a new workflow that executes this one and captures the changes in
`FiberRef` values.

**Signature**

```ts
declare const diffFiberRefs: <A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6191)

Since v2.0.0
Effect-disconnect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.disconnect

Provides a way to handle timeouts in uninterruptible effects, allowing them
to continue in the background while the main control flow proceeds with the
timeout error.

**Details**

The `disconnect` function allows an uninterruptible effect to continue
running in the background, while enabling the main control flow to
immediately recognize a timeout condition. This is useful when you want to
avoid blocking the program due to long-running tasks, especially when those
tasks do not need to affect the flow of the rest of the program.

Without `disconnect`, an uninterruptible effect will ignore the
timeout and continue executing until it completes. The timeout error will
only be assessed after the effect finishes, which can cause delays in
recognizing a timeout.

With `disconnect`, the uninterruptible effect proceeds in the
background while the main program flow can immediately handle the timeout
error or trigger alternative logic. This enables faster timeout handling
without waiting for the completion of the long-running task.

**Example**

```ts
import { Effect } from "effect"

const longRunningTask = Effect.gen(function* () {
  console.log("Start heavy processing...")
  yield* Effect.sleep("5 seconds") // Simulate a long process
  console.log("Heavy processing done.")
  return "Data processed"
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  // Allows the task to finish in the background if it times out
  Effect.disconnect,
  Effect.timeout("1 second")
)

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start heavy processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
// Heavy processing done.
```

**See**

- `timeout` for a version that interrupts the effect.
- `uninterruptible` for creating an uninterruptible effect.

**Signature**

```ts
declare const disconnect: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4840)

Since v2.0.0
Effect-dropUntil.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.dropUntil

Drops elements until the effectful predicate returns `true`.

**Details**

This function processes a collection of elements and uses an effectful
predicate to determine when to stop dropping elements. It drops elements from
the beginning of the collection until the predicate returns `true`.

The predicate is a function that takes an element and its index in the
collection and returns an effect that evaluates to a boolean.

Once the predicate returns `true`, the remaining elements of the collection
are returned.

**Note**: The first element for which the predicate returns `true` is also
dropped.

**When to Use**

This function allows you to conditionally skip over a part of the collection
based on some criteria defined in the predicate.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.dropUntil(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [5, 6]
```

**See**

- `dropWhile` for a similar function that drops elements while the
predicate returns `true`.

**Signature**

```ts
declare const dropUntil: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1089)

Since v2.0.0
Effect-dropWhile.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.dropWhile

Drops elements as long as the predicate returns `true`.

**Details**

This function processes a collection of elements and uses a predicate to
decide whether to drop an element.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

As long as the predicate returns `true`, elements will continue to be dropped
from the collection.

Once the predicate returns `false`, the remaining elements are kept.

**When to Use**

This function allows you to discard elements from the start of a collection
based on a condition, and only keep the rest when the condition no longer
holds.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.dropWhile(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [4, 5, 6]
```

**See**

- `dropUntil` for a similar function that drops elements until the
predicate returns `true`.

**Signature**

```ts
declare const dropWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1141)

Since v2.0.0
Effect-Effect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.Effect

The `Effect` interface defines a value that describes a workflow or job,
which can succeed or fail.

**Details**

The `Effect` interface represents a computation that can model a workflow
involving various types of operations, such as synchronous, asynchronous,
concurrent, and parallel interactions. It operates within a context of type
`R`, and the result can either be a success with a value of type `A` or a
failure with an error of type `E`. The `Effect` is designed to handle complex
interactions with external resources, offering advanced features such as
fiber-based concurrency, scheduling, interruption handling, and scalability.
This makes it suitable for tasks that require fine-grained control over
concurrency and error management.

To execute an `Effect` value, you need a `Runtime`, which provides the
environment necessary to run and manage the computation.

**Signature**

```ts
export interface Effect<out A, out E = never, out R = never> extends Effect.Variance<A, E, R>, Pipeable {
  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: EffectUnify<this>
  readonly [Unify.ignoreSymbol]?: EffectUnifyIgnore
  [Symbol.iterator](): EffectGenerator<Effect<A, E, R>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L111)

Since v2.0.0
Effect-FunctionWithSpanOptions.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.FunctionWithSpanOptions

Wraps a function that returns an effect with a new span for tracing.

**Signature**

```ts
export interface FunctionWithSpanOptions {
  readonly name: string
  readonly attributes?: Record<string, unknown> | undefined
  readonly links?: ReadonlyArray<Tracer.SpanLink> | undefined
  readonly parent?: Tracer.AnySpan | undefined
  readonly root?: boolean | undefined
  readonly context?: Context.Context<never> | undefined
  readonly kind?: Tracer.SpanKind | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13096)

Since v3.2.0
Effect-either.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.either

Encapsulates both success and failure of an `Effect` into an `Either` type.

**Details**

This function converts an effect that may fail into an effect that always
succeeds, wrapping the outcome in an `Either` type. The result will be
`Either.Left` if the effect fails, containing the recoverable error, or
`Either.Right` if it succeeds, containing the result.

Using this function, you can handle recoverable errors explicitly without
causing the effect to fail. This is particularly useful in scenarios where
you want to chain effects and manage both success and failure in the same
logical flow.

It's important to note that unrecoverable errors, often referred to as
"defects," are still thrown and not captured within the `Either` type. Only
failures that are explicitly represented as recoverable errors in the effect
are encapsulated.

The resulting effect cannot fail directly because all recoverable failures
are represented inside the `Either` type.

**Example**

```ts
import { Effect, Either, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = Effect.gen(function* () {
  //       Either<string, HttpError | ValidationError>
  //      
  const failureOrSuccess = yield* Effect.either(program)
  return Either.match(failureOrSuccess, {
    onLeft: (error) => `Recovering from ${error._tag}`,
    onRight: (value) => value // Do nothing in case of success
  })
})
```

**See**

- `option` for a version that uses `Option` instead.
- `exit` for a version that encapsulates both recoverable errors and defects in an `Exit`.

**Signature**

```ts
declare const either: <A, E, R>(self: Effect<A, E, R>) => Effect<Either.Either<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8187)

Since v2.0.0
Effect-ensuring.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.ensuring

Guarantees the execution of a finalizer when an effect starts execution.

**Details**

This function allows you to specify a `finalizer` effect that will always be
run once the effect starts execution, regardless of whether the effect
succeeds, fails, or is interrupted.

**When to Use**

This is useful when you need to ensure that certain cleanup or final steps
are executed in all cases, such as releasing resources or performing
necessary logging.

While this function provides strong guarantees about executing the finalizer,
it is considered a low-level tool, which may not be ideal for more complex
resource management. For higher-level resource management with automatic
acquisition and release, see the `acquireRelease` family of functions.
For use cases where you need access to the result of an effect, consider
using `onExit`.

**Example** (Running a Finalizer in All Outcomes)

```ts
import { Console, Effect } from "effect"

// Define a cleanup effect
const handler = Effect.ensuring(Console.log("Cleanup completed"))

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed
```

**See**

- `onExit` for a version that provides access to the result of an
effect.

**Signature**

```ts
declare const ensuring: { <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5762)

Since v2.0.0
Effect-ensuringChild.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.ensuringChild

Acts on the children of this fiber (collected into a single fiber),
guaranteeing the specified callback will be invoked, whether or not this
effect succeeds.

**Signature**

```ts
declare const ensuringChild: { <X, R2>(f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6203)

Since v2.0.0
Effect-ensuringChildren.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.ensuringChildren

Acts on the children of this fiber, guaranteeing the specified callback
will be invoked, whether or not this effect succeeds.

**Signature**

```ts
declare const ensuringChildren: { <X, R2>(children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6220)

Since v2.0.0
Effect-eventually.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.eventually

Runs an effect repeatedly until it succeeds, ignoring errors.

**Details**

This function takes an effect and runs it repeatedly until the effect
successfully completes. If the effect fails, it will ignore the error and
retry the operation. This is useful when you need to perform a task that may
fail occasionally, but you want to keep trying until it eventually succeeds.
It works by repeatedly executing the effect until it no longer throws an
error.

**When to Use**

Use this function when you want to retry an operation multiple times until it
succeeds. It is helpful in cases where the operation may fail temporarily
(e.g., a network request), and you want to keep trying without handling or
worrying about the errors.

**Example**

```ts
import { Effect } from "effect"

let counter = 0

const effect = Effect.try(() => {
  counter++
  if (counter < 3) {
    console.log("running effect")
    throw new Error("error")
  } else {
    console.log("effect done")
    return "some result"
  }
})

const program = Effect.eventually(effect)

Effect.runPromise(program).then(console.log)
// Output:
// running effect
// running effect
// effect done
// some result
```

**Signature**

```ts
declare const eventually: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4094)

Since v2.0.0
Effect-every.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.every

Determines whether all elements of the iterable satisfy the effectful
predicate.

**Details**

This function checks whether every element in a given collection (an
iterable) satisfies a condition defined by an effectful predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function will process each element and return `true` if all elements
satisfy the predicate; otherwise, it returns `false`.

**When to Use**

This function is useful when you need to verify that all items in a
collection meet certain criteria, even when the evaluation of each item
involves effects, such as asynchronous checks or complex computations.

**Example**

```ts
import { Effect } from "effect"

const numbers = [2, 4, 6, 8]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function*() {
  const allEven = yield* Effect.every(numbers, predicate)
  console.log(allEven)
})

Effect.runFork(program)
// Output: true
```

**See**

- `exists` for a similar function that returns a boolean indicating
whether **any** element satisfies the predicate.

**Signature**

```ts
declare const every: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1299)

Since v2.0.0
Effect-exists.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.exists

Determines whether any element of the iterable satisfies the effectual
predicate.

**Details**

This function checks whether any element in a given collection (an iterable)
satisfies a condition defined by an effectful predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function will process each element, and if any element satisfies the
predicate (returns `true`), the function will immediately return `true`.

If none of the elements satisfy the condition, it will return `false`.

**When to Use**

This function allows you to quickly check for a condition in a collection
without having to manually iterate over it.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4]
const predicate = (n: number, i: number) => Effect.succeed(n > 2)

const program = Effect.gen(function*() {
  const hasLargeNumber = yield* Effect.exists(numbers, predicate)
  console.log(hasLargeNumber)
})

Effect.runFork(program)
// Output: true
```

**See**

- `every` for a similar function that checks if **all** elements
satisfy the predicate.

**Signature**

```ts
declare const exists: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<boolean, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1349)

Since v2.0.0
Effect-exit.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.exit

Encapsulates both success and failure of an `Effect` using the `Exit` type.

**Details**

This function converts an effect into one that always succeeds, wrapping its
outcome in the `Exit` type. The `Exit` type provides explicit handling of
both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including
defects (unrecoverable errors).

Unlike `either` or `option`, this function also encapsulates
defects, which are typically unrecoverable and would otherwise terminate the
effect. With the `Exit` type, defects are represented in `Exit.Failure`,
allowing for detailed introspection and structured error handling.

This makes the resulting effect robust and incapable of direct failure (its
error type is `never`). It is particularly useful for workflows where all
outcomes, including unexpected defects, must be managed and analyzed.

**Example**

```ts
import { Effect, Cause, Console, Exit } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.gen(function* () {
  const exit = yield* Effect.exit(task)
  if (Exit.isFailure(exit)) {
    const cause = exit.cause
    if (
      Cause.isDieType(cause) &&
      Cause.isRuntimeException(cause.defect)
    ) {
      yield* Console.log(
        `RuntimeException defect caught: ${cause.defect.message}`
      )
    } else {
      yield* Console.log("Unknown failure caught.")
    }
  }
})

// We get an Exit.Success because we caught all failures
Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }
```

**See**

- `option` for a version that uses `Option` instead.
- `either` for a version that uses `Either` instead.

**Signature**

```ts
declare const exit: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8250)

Since v2.0.0
Effect-fail.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.fail

Creates an `Effect` that represents a recoverable error.

**When to Use**

Use this function to explicitly signal an error in an `Effect`. The error
will keep propagating unless it is handled. You can handle the error with
functions like `catchAll` or `catchTag`.

**Example** (Creating a Failed Effect)

```ts
import { Effect } from "effect"

//       Effect<never, Error, never>
//      
const failure = Effect.fail(
  new Error("Operation failed due to network error")
)
```

**See**

- `succeed` to create an effect that represents a successful value.

**Signature**

```ts
declare const fail: <E>(error: E) => Effect<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2575)

Since v2.0.0
Effect-failCause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.failCause

Creates an `Effect` that fails with the specified `Cause`.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Effect<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2591)

Since v2.0.0
Effect-failCauseSync.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.failCauseSync

Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.

**Signature**

```ts
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Effect<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2599)

Since v2.0.0
Effect-failSync.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.failSync

Creates an `Effect` that fails with the specified error, evaluated lazily.

**Signature**

```ts
declare const failSync: <E>(evaluate: LazyArg<E>) => Effect<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2583)

Since v2.0.0
Effect-filter.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filter

Filters an iterable using the specified effectful predicate.

**Details**

This function filters a collection (an iterable) by applying an effectful
predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function processes each element in the collection and keeps only those
that satisfy the condition defined by the predicate.

**Options**

You can also adjust the behavior with options such as concurrency, batching,
or whether to negate the condition.

**When to Use**

This function allows you to selectively keep or remove elements based on a
condition that may involve asynchronous or side-effect-causing operations.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function*() {
  const result = yield* Effect.filter(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [2, 4]
```

**Signature**

```ts
declare const filter: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1417)

Since v2.0.0
Effect-filterEffectOrElse.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filterEffectOrElse

Filters an effect with an effectful predicate, falling back to an alternative
effect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect falls back to the `orElse`
effect. The `orElse` effect can produce an alternative value or perform
additional computations.

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrElse with an effectful predicate
  Effect.filterEffectOrElse({
    predicate: (user) => Effect.succeed(user !== null),
    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))
  }),
)
```

**Signature**

```ts
declare const filterEffectOrElse: { <A, E2, R2, A2, E3, R3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>; }): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2 | E3, R | R2 | R3>; <A, E, R, E2, R2, A2, E3, R3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orElse: (a: A) => Effect<A2, E3, R3>; }): Effect<A | A2, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8542)

Since v3.13.0
Effect-filterEffectOrFail.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filterEffectOrFail

Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect fails with a custom error
generated by the `orFailWith` function.

**When to Use**

This is useful for enforcing constraints and treating violations as
recoverable errors.

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrFail with an effectful predicate
  Effect.filterEffectOrFail({
    predicate: (user) => Effect.succeed(user !== null),
    orFailWith: () => new Error("Unauthorized")
  }),
)
```

**Signature**

```ts
declare const filterEffectOrFail: { <A, E2, R2, E3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orFailWith: (a: NoInfer<A>) => E3; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R | R2>; <A, E, R, E2, R2, E3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3; }): Effect<A, E | E2 | E3, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8598)

Since v3.13.0
Effect-filterMap.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filterMap

Filters and maps elements sequentially in one operation.

This function processes each element one by one. It applies a function that
returns an `Option` to each element. If the function returns `Some`, the
element is kept; if it returns `None`, the element is removed. The operation
is done sequentially for each element.

**Example**

```ts
import { Console, Effect, Option } from "effect"

const task = (n: number) =>
  Effect.succeed(n).pipe(
    Effect.delay(1000 - (n * 100)),
    Effect.tap(Console.log(`task${n} done`))
  )

const program = Effect.filterMap(
  [task(1), task(2), task(3), task(4)],
  (n) => n % 2 === 0 ? Option.some(n) : Option.none()
)

Effect.runPromise(program).then(console.log)
// Output:
// task1 done
// task2 done
// task3 done
// task4 done
// [ 2, 4 ]
```

**Signature**

```ts
declare const filterMap: { <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option.Option<B>): (elements: Iterable<Eff>) => Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option.Option<B>): Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1475)

Since v2.0.0
Effect-filterOrDie.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filterOrDie

Filters an effect, dying with a custom defect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect dies with a custom defect
generated by the `orDieWith` function.

**When to Use**

This is useful for enforcing constraints on values and treating violations as
fatal program errors.

**Signature**

```ts
declare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8352)

Since v2.0.0
Effect-filterOrDieMessage.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filterOrDieMessage

Filters an effect, dying with a custom message if the predicate fails.

**Details**

This function works like `filterOrDie` but allows you to specify a
custom error message to describe the reason for the failure. The message is
included in the defect when the predicate evaluates to `false`.

**Signature**

```ts
declare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8381)

Since v2.0.0
Effect-filterOrElse.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filterOrElse

Filters an effect, providing an alternative effect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, it executes the `orElse` effect instead. The
`orElse` effect can produce an alternative value or perform additional
computations.

**Signature**

```ts
declare const filterOrElse: { <A, C, E2, R2, B extends A>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>; <A, C, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A | C, E2 | E, R2 | R>; <A, E, R, C, E2, R2, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orElse: (a: EqualsWith<A, B, A, Exclude<A, B>>) => Effect<C, E2, R2>): Effect<B | C, E | E2, R | R2>; <A, E, R, C, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => Effect<C, E2, R2>): Effect<A | C, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8404)

Since v2.0.0
Effect-filterOrFail.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.filterOrFail

Filters an effect, failing with a custom error if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect fails with a custom error
generated by the `orFailWith` function.

**When to Use**

This is useful for enforcing constraints and treating violations as
recoverable errors.

**Providing a Guard**

In addition to the filtering capabilities discussed earlier, you have the
option to further refine and narrow down the type of the success channel by
providing a [user-defined type
guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
Let's explore this concept through an example:

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterOrFail with a custom type guard to ensure user is not null
  Effect.filterOrFail(
    (user): user is User => user !== null, // Type guard
    () => new Error("Unauthorized")
  ),
  // 'user' now has the type `User` (not `User | null`)
  Effect.andThen((user) => user.name)
)
```

**Signature**

```ts
declare const filterOrFail: { <A, E2, B extends A>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; <A, E, R, E2, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E2): Effect<B, E2 | E, R>; <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E2 | E, R>; <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementException | E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<B, E | Cause.NoSuchElementException, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, E | Cause.NoSuchElementException, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8475)

Since v2.0.0
Effect-finalizersMask.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.finalizersMask

Applies a custom execution strategy to finalizers within a scoped workflow.

**Details**

This function allows you to control how finalizers are executed in a scope by
applying a specified `ExecutionStrategy`. The `strategy` can dictate whether
finalizers run (e.g., sequentially or in parallel).

Additionally, the function provides a `restore` operation, which ensures that
the effect passed to it is executed under the default execution strategy.

**Signature**

```ts
declare const finalizersMask: (strategy: ExecutionStrategy) => <A, E, R>(self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6013)

Since v2.0.0
Effect-findFirst.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.findFirst

Returns the first element that satisfies the effectful predicate.

**Details**

This function processes a collection of elements and applies an effectful
predicate to each element.

The predicate is a function that takes an element and its index in the
collection, and it returns an effect that evaluates to a boolean.

The function stops as soon as it finds the first element for which the
predicate returns `true` and returns that element wrapped in an `Option`.

If no element satisfies the predicate, the result will be `None`.

**When to Use**

This function allows you to efficiently find an element that meets a specific
condition, even when the evaluation involves effects like asynchronous
operations or side effects.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.findFirst(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: { _id: 'Option', _tag: 'Some', value: 4 }
```

**Signature**

```ts
declare const findFirst: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option.Option<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1527)

Since v2.0.0
Effect-firstSuccessOf.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.firstSuccessOf

Runs a sequence of effects and returns the result of the first successful
one.

**Details**

This function allows you to execute a collection of effects in sequence,
stopping at the first success. If an effect succeeds, its result is
immediately returned, and no further effects in the sequence are executed.
However, if all the effects fail, the function will return the error of the
last effect.

The execution is sequential, meaning that effects are evaluated one at a time
in the order they are provided. This ensures predictable behavior and avoids
unnecessary computations.

If the collection of effects is empty, an `IllegalArgumentException` is
thrown, indicating that the operation is invalid without any effects to try.

**When to Use**

This is particularly useful when you have multiple fallback strategies or
alternative sources to obtain a result, such as attempting multiple APIs,
retrieving configurations, or accessing resources in a prioritized manner.

**Example**

```ts
import { Effect, Console } from "effect"

interface Config {
  host: string
  port: number
  apiKey: string
}

// Create a configuration object with sample values
const makeConfig = (name: string): Config => ({
  host: `${name}.example.com`,
  port: 8080,
  apiKey: "12345-abcde"
})

// Simulate retrieving configuration from a remote node
const remoteConfig = (name: string): Effect.Effect<Config, Error> =>
  Effect.gen(function* () {
    // Simulate node3 being the only one with available config
    if (name === "node3") {
      yield* Console.log(`Config for ${name} found`)
      return makeConfig(name)
    } else {
      yield* Console.log(`Unavailable config for ${name}`)
      return yield* Effect.fail(new Error(`Config not found for ${name}`))
    }
  })

// Define the master configuration and potential fallback nodes
const masterConfig = remoteConfig("master")
const nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)

// Attempt to find a working configuration,
// starting with the master and then falling back to other nodes
const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])

// Run the effect to retrieve the configuration
const result = Effect.runSync(config)

console.log(result)
// Output:
// Unavailable config for master
// Unavailable config for node1
// Unavailable config for node2
// Config for node3 found
// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }
```

**Signature**

```ts
declare const firstSuccessOf: <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11552)

Since v2.0.0
Effect-flatMap.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.flatMap

Chains effects to produce new `Effect` instances, useful for combining
operations that depend on previous results.

**Syntax**

```ts
const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
// or
const flatMappedEffect = Effect.flatMap(myEffect, transformation)
// or
const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
```

**Details**

`flatMap` lets you sequence effects so that the result of one effect can be
used in the next step. It is similar to `flatMap` used with arrays but works
specifically with `Effect` instances, allowing you to avoid deeply nested
effect structures.

Since effects are immutable, `flatMap` always returns a new effect instead of
changing the original one.

**When to Use**

Use `flatMap` when you need to chain multiple effects, ensuring that each
step produces a new `Effect` while flattening any nested effects that may
occur.

**Example**

```ts
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Chaining the fetch and discount application using `flatMap`
const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
// Output: 95
```

**See**

- `tap` for a version that ignores the result of the effect.

**Signature**

```ts
declare const flatMap: { <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8855)

Since v2.0.0
Effect-flip.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.flip

Swaps the success and error channels of an effect.

**Details**

This function reverses the flow of an effect by swapping its success and
error channels. The success value becomes an error, and the error value
becomes a success.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<string, number, never>
//      
const flipped = Effect.flip(program)
```

**Signature**

```ts
declare const flip: <A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5111)

Since v2.0.0
Effect-flipWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.flipWith

Swaps the error/value parameters, applies the function `f` and flips the
parameters back

**Signature**

```ts
declare const flipWith: { <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>; <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5120)

Since v2.0.0
Effect-fn.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.fn

The `Effect.fn` function allows you to create traced functions that return an
effect. It provides two key features:

- **Stack traces with location details** if an error occurs.
- **Automatic span creation** for tracing when a span name is provided.

If a span name is passed as the first argument, the function's execution is
tracked using that name. If no name is provided, stack tracing still works,
but spans are not created.

A function can be defined using either:

- A generator function, allowing the use of `yield*` for effect composition.
- A regular function that returns an `Effect`.

**Example** (Creating a Traced Function with a Span Name)

```ts
import { Effect } from "effect"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n) // Attach metadata to the span
  console.log(`got: ${n}`)
  yield* Effect.fail(new Error("Boom!")) // Simulate failure
})

Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))
// Output:
// got: 100
// timestamp=... level=ERROR fiber=#0 cause="Error: Boom!
//     at <anonymous> (/.../index.ts:6:22) <= Raise location
//     at myspan (/.../index.ts:3:23)  <= Definition location
//     at myspan (/.../index.ts:9:16)" <= Call location
```

`Effect.fn` automatically creates spans. The spans capture information about
the function execution, including metadata and error details.

**Example** (Exporting Spans to the Console)

```ts
import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n)
  console.log(`got: ${n}`)
  yield* Effect.fail(new Error("Boom!"))
})

const program = myfunc(100)

const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  // Export span data to the console
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

Effect.runFork(program.pipe(Effect.provide(NodeSdkLive)))
// Output:
// got: 100
// {
//   resource: {
//     attributes: {
//       'service.name': 'example',
//       'telemetry.sdk.language': 'nodejs',
//       'telemetry.sdk.name': '@effect/opentelemetry',
//       'telemetry.sdk.version': '1.30.1'
//     }
//   },
//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },
//   traceId: '22801570119e57a6e2aacda3dec9665b',
//   parentId: undefined,
//   traceState: undefined,
//   name: 'myspan',
//   id: '7af530c1e01bc0cb',
//   kind: 0,
//   timestamp: 1741182277518402.2,
//   duration: 4300.416,
//   attributes: {
//     n: 100,
//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\n' +
//       'at <anonymous> (/.../index.ts:14:17)'
//   },
//   status: { code: 2, message: 'Boom!' },
//   events: [
//     {
//       name: 'exception',
//       attributes: {
//         'exception.type': 'Error',
//         'exception.message': 'Boom!',
//         'exception.stacktrace': 'Error: Boom!\n' +
//           '    at <anonymous> (/.../index.ts:11:22)\n' +
//           '    at myspan (/.../index.ts:8:23)\n' +
//           '    at myspan (/.../index.ts:14:17)'
//       },
//       time: [ 1741182277, 522702583 ],
//       droppedAttributesCount: 0
//     }
//   ],
//   links: []
// }
```

`Effect.fn` also acts as a pipe function, allowing you to create a pipeline
after the function definition using the effect returned by the generator
function as the starting value of the pipeline.

**Example** (Creating a Traced Function with a Delay)

```ts
import { Effect } from "effect"

const myfunc = Effect.fn(
  function* (n: number) {
    console.log(`got: ${n}`)
    yield* Effect.fail(new Error("Boom!"))
  },
  // You can access both the created effect and the original arguments
  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)
)

Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))
// Output:
// got: 100
// timestamp=... level=ERROR fiber=#0 cause="Error: Boom! (<= after 1 second)
```

**See**

- `fnUntraced` for a version of this function that doesn't add a span.

**Signature**

```ts
declare const fn: fn.Gen & fn.NonGen & ((name: string, options?: Tracer.SpanOptions) => fn.Gen & fn.NonGen)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L14591)

Since v3.11.0
Effect-fnUntraced.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.fnUntraced

Same as `fn`, but allows you to create a function that is not traced, for when performance is critical.

**See**

- `fn` for a version that includes tracing.

**Signature**

```ts
declare const fnUntraced: fn.Untraced
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L14726)

Since v3.12.0
Effect-forEach.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.forEach

Executes an effectful operation for each element in an `Iterable`.

**Details**

This function applies a provided operation to each element in the iterable,
producing a new effect that returns an array of results.

If any effect fails, the iteration stops immediately (short-circuiting), and
the error is propagated.

**Concurrency**

The `concurrency` option controls how many operations are performed
concurrently. By default, the operations are performed sequentially.

**Discarding Results**

If the `discard` option is set to `true`, the intermediate results are not
collected, and the final result of the operation is `void`.

**Example** (Applying Effects to Iterable Elements)

```ts
import { Effect, Console } from "effect"

const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>
  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// [ 2, 4, 6, 8, 10 ]
```

**Example** (Discarding Results)

```ts
import { Effect, Console } from "effect"

// Apply effects but discard the results
const result = Effect.forEach(
  [1, 2, 3, 4, 5],
  (n, index) =>
    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
  { discard: true }
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// undefined
```

**See**

- `all` for combining multiple effects into one.

**Signature**

```ts
declare const forEach: { <B, E, R, S extends Iterable<any>>(f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (self: S) => Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (self: Iterable<A>) => Effect<void, E, R>; <B, E, R, S extends Iterable<any>>(self: S, f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1605)

Since v2.0.0
Effect-forever.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.forever

Repeats an effect indefinitely until an error occurs.

**Details**

This function executes an effect repeatedly in an infinite loop. Each
iteration is executed sequentially, and the loop continues until the first
error occurs. If the effect succeeds, it starts over from the beginning. If
the effect fails, the error is propagated, and the loop stops.

Be cautious when using this function, as it will run indefinitely unless an
error interrupts it. This makes it suitable for long-running processes or
continuous polling tasks, but you should ensure proper error handling or
combine it with other operators like `timeout` or `schedule` to prevent
unintentional infinite loops.

**Signature**

```ts
declare const forever: <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9881)

Since v2.0.0
Effect-fork.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.fork

Creates a new fiber to run an effect concurrently.

**Details**

This function takes an effect and forks it into a separate fiber, allowing it
to run concurrently without blocking the original effect. The new fiber
starts execution immediately after being created, and the fiber object is
returned immediately without waiting for the effect to begin. This is useful
when you want to run tasks concurrently while continuing other tasks in the
parent fiber.

The forked fiber is attached to the parent fiber's scope. This means that
when the parent fiber terminates, the child fiber will also be terminated
automatically. This feature, known as "auto supervision," ensures that no
fibers are left running unintentionally. If you prefer not to have this auto
supervision behavior, you can use `forkDaemon` or `forkIn`.

**When to Use**

Use this function when you need to run an effect concurrently without
blocking the current execution flow. For example, you might use it to launch
background tasks or concurrent computations. However, working with fibers can
be complex, so before using this function directly, you might want to explore
higher-level functions like `raceWith`, `zip`, or others that can
manage concurrency for you.

**Example**

```ts
import { Effect } from "effect"

const fib = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

//       Effect<RuntimeFiber<number, never>, never, never>
//      
const fib10Fiber = Effect.fork(fib(10))
```

**See**

- `forkWithErrorHandler` for a version that allows you to handle errors.

**Signature**

```ts
declare const fork: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6290)

Since v2.0.0
Effect-forkAll.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.forkAll

Returns an effect that forks all of the specified values, and returns a
composite fiber that produces a list of their results, in order.

**Signature**

```ts
declare const forkAll: { (options?: { readonly discard?: false | undefined; } | undefined): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; (options: { readonly discard: true; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options?: { readonly discard?: false | undefined; } | undefined): Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true; }): Effect<void, never, Effect.Context<Eff>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6351)

Since v2.0.0
Effect-forkDaemon.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.forkDaemon

Creates a long-running background fiber that is independent of its parent.

**Details**

This function creates a "daemon" fiber that runs in the background and is not
tied to the lifecycle of its parent fiber. Unlike normal fibers that stop
when the parent fiber terminates, a daemon fiber will continue running until
the global scope closes or the fiber completes naturally. This makes it
useful for tasks that need to run in the background independently, such as
periodic logging, monitoring, or background data processing.

**Example** (Creating a Daemon Fiber)

```ts
import { Effect, Console, Schedule } from "effect"

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(
  Console.log("daemon: still running!"),
  Schedule.fixed("1 second")
)

const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

Effect.runFork(parent)
// Output:
// parent: started!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// parent: finished!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// ...etc...
```

**Signature**

```ts
declare const forkDaemon: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6341)

Since v2.0.0
Effect-forkIn.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.forkIn

Forks an effect in a specific scope, allowing finer control over its
execution.

**Details**

There are some cases where we need more fine-grained control, so we want to
fork a fiber in a specific scope. We can use the `Effect.forkIn` operator
which takes the target scope as an argument.

The fiber will be interrupted when the scope is closed.

**Example** (Forking a Fiber in a Specific Scope)

In this example, the child fiber is forked into the outerScope,
allowing it to outlive the inner scope but still be terminated
when the outerScope is closed.

```ts
import { Console, Effect, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

const program = Effect.scoped(
  Effect.gen(function* () {
    yield* Effect.addFinalizer(() =>
      Console.log("The outer scope is about to be closed!")
    )

    // Capture the outer scope
    const outerScope = yield* Effect.scope

    // Create an inner scope
    yield* Effect.scoped(
      Effect.gen(function* () {
        yield* Effect.addFinalizer(() =>
          Console.log("The inner scope is about to be closed!")
        )
        // Fork the child fiber in the outer scope
        yield* Effect.forkIn(child, outerScope)
        yield* Effect.sleep("3 seconds")
      })
    )

    yield* Effect.sleep("5 seconds")
  })
)

Effect.runFork(program)
// Output:
// child: still running!
// child: still running!
// child: still running!
// The inner scope is about to be closed!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// The outer scope is about to be closed!
```

**Signature**

```ts
declare const forkIn: { (scope: Scope.Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, scope: Scope.Scope): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6440)

Since v2.0.0
Effect-forkScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.forkScoped

Forks a fiber in a local scope, ensuring it outlives its parent.

**Details**

This function is used to create fibers that are tied to a local scope,
meaning they are not dependent on their parent fiber's lifecycle. Instead,
they will continue running until the scope they were created in is closed.
This is particularly useful when you need a fiber to run independently of the
parent fiber, but still want it to be terminated when the scope ends.

Fibers created with this function are isolated from the parent fibers
termination, so they can run for a longer period. This behavior is different
from fibers created with `fork`, which are terminated when the parent fiber
terminates. With `forkScoped`, the child fiber will keep running until the
local scope ends, regardless of the state of the parent fiber.

**Example** (Forking a Fiber in a Local Scope)

In this example, the child fiber continues to run beyond the lifetime of the parent fiber.
The child fiber is tied to the local scope and will be terminated only when the scope ends.

```ts
import { Effect, Console, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

//       Effect<void, never, Scope>
//      
const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Child fiber attached to local scope
  yield* Effect.forkScoped(child)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

// Program runs within a local scope
const program = Effect.scoped(
  Effect.gen(function* () {
    console.log("Local scope started!")
    yield* Effect.fork(parent)
    // Scope lasts for 5 seconds
    yield* Effect.sleep("5 seconds")
    console.log("Leaving the local scope!")
  })
)

Effect.runFork(program)
// Output:
// Local scope started!
// parent: started!
// child: still running!
// child: still running!
// child: still running!
// parent: finished!
// child: still running!
// child: still running!
// Leaving the local scope!
```

**Signature**

```ts
declare const forkScoped: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6513)

Since v2.0.0
Effect-forkWithErrorHandler.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.forkWithErrorHandler

Like `fork` but handles an error with the provided handler.

**Signature**

```ts
declare const forkWithErrorHandler: { <E, X>(handler: (e: E) => Effect<X>): <A, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X>): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6522)

Since v2.0.0
Effect-fromFiber.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.fromFiber

Creates an `Effect` value that represents the exit value of the specified
fiber.

**See**

- `fromFiberEffect` for creating an effect from a fiber obtained from an effect.

**Signature**

```ts
declare const fromFiber: <A, E>(fiber: Fiber.Fiber<A, E>) => Effect<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6541)

Since v2.0.0
Effect-fromFiberEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.fromFiberEffect

Creates an `Effect` value that represents the exit value of a fiber obtained
from an effect.

**See**

- `fromFiber` for creating an effect from a fiber.

**Signature**

```ts
declare const fromFiberEffect: <A, E, R>(fiber: Effect<Fiber.Fiber<A, E>, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6552)

Since v2.0.0
Effect-fromNullable.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.fromNullable

Safely handles nullable values by creating an effect that fails for `null` or
`undefined`.

**Details**

This function ensures that an input value is non-null and non-undefined
before processing it. If the value is valid, the effect succeeds with the
value. If the value is `null` or `undefined`, the effect fails with a
`NoSuchElementException`. This is particularly useful for avoiding
null-related errors by clearly separating valid values from invalid ones in
effectful computations.

The failure with `NoSuchElementException` allows you to explicitly handle
cases where a value is expected but not provided, leading to safer and more
predictable code.

**When to Use**

Use this function when working with values that may be `null` or `undefined`
and you want to ensure that only non-null values are processed. It helps
enforce null-safety and makes error handling more explicit.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, NoSuchElementException, never>
//      
const maybe1 = Effect.fromNullable(1)

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// { _id: 'Exit', _tag: 'Success', value: 1 }

//       Effect<number, NoSuchElementException, never>
//      
const maybe2 = Effect.fromNullable(null as number | null)

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'NoSuchElementException' }
//   }
// }
```

**Signature**

```ts
declare const fromNullable: <A>(value: A) => Effect<NonNullable<A>, Cause.NoSuchElementException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13221)

Since v2.0.0
Effect-functionWithSpan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.functionWithSpan

Wraps a function that returns an effect with a new span for tracing.

**Example**

```ts
import { Effect } from "effect"

const getTodo = Effect.functionWithSpan({
  body: (id: number) => Effect.succeed(`Got todo ${id}!`),
  options: (id) => ({
    name: `getTodo-${id}`,
    attributes: { id }
  })
})
```

**Signature**

```ts
declare const functionWithSpan: <Args extends Array<any>, Ret extends Effect<any, any, any>>(options: { readonly body: (...args: Args) => Ret; readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions); readonly captureStackTrace?: boolean | undefined; }) => (...args: Args) => Unify.Unify<Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13126)

Since v3.2.0
Effect-gen.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.gen

Provides a way to write effectful code using generator functions, simplifying
control flow and error handling.

**When to Use**

`Effect.gen` allows you to write code that looks and behaves like synchronous
code, but it can handle asynchronous tasks, errors, and complex control flow
(like loops and conditions). It helps make asynchronous code more readable
and easier to manage.

The generator functions work similarly to `async/await` but with more
explicit control over the execution of effects. You can `yield*` values from
effects and return the final result at the end.

**Example**

```ts
import { Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))

export const program = Effect.gen(function* () {
  const transactionAmount = yield* fetchTransactionAmount
  const discountRate = yield* fetchDiscountRate
  const discountedAmount = yield* applyDiscount(
    transactionAmount,
    discountRate
  )
  const finalAmount = addServiceCharge(discountedAmount)
  return `Final amount to charge: ${finalAmount}`
})
```

**Signature**

```ts
declare const gen: { <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(self: Self, f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2760)

Since v2.0.0
Effect-getFiberRefs.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.getFiberRefs

Returns a collection of all `FiberRef` values for the fiber running this
effect.

**Signature**

```ts
declare const getFiberRefs: Effect<FiberRefs.FiberRefs, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10422)

Since v2.0.0
Effect-getRuntimeFlags.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.getRuntimeFlags

Retrieves an effect that succeeds with the current runtime flags, which
govern behavior and features of the runtime system.

**Signature**

```ts
declare const getRuntimeFlags: Effect<RuntimeFlags.RuntimeFlags, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11617)

Since v2.0.0
Effect-head.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.head

Returns the first element of the iterable if the collection is non-empty, or
fails with the error `NoSuchElementException` if the collection is empty.

**When to Use**

This function is useful when you need to retrieve the first item from a
collection and want to handle the case where the collection might be empty
without causing an unhandled exception.

**Example**

```ts
import { Effect } from "effect"

// Simulate an async operation
const fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))

const program = Effect.gen(function*() {
  const firstElement = yield* Effect.head(fetchNumbers)
  console.log(firstElement)
})

Effect.runFork(program)
// Output: 1
```

**Signature**

```ts
declare const head: <A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1678)

Since v2.0.0
Effect-if.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.if

Executes one of two effects based on a condition evaluated by an effectful predicate.

Use `if` to run one of two effects depending on whether the predicate effect
evaluates to `true` or `false`. If the predicate is `true`, the `onTrue` effect
is executed. If it is `false`, the `onFalse` effect is executed instead.

**Example** (Simulating a Coin Flip)

```ts
import { Effect, Random, Console } from "effect"

const flipTheCoin = Effect.if(Random.nextBoolean, {
  onTrue: () => Console.log("Head"), // Runs if the predicate is true
  onFalse: () => Console.log("Tail") // Runs if the predicate is false
})

Effect.runFork(flipTheCoin)
```

**Signature**

```ts
declare const if: { <A1, E1, R1, A2, E2, R2>(options: { readonly onTrue: LazyArg<Effect<A1, E1, R1>>; readonly onFalse: LazyArg<Effect<A2, E2, R2>>; }): <E = never, R = never>(self: boolean | Effect<boolean, E, R>) => Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>; <A1, E1, R1, A2, E2, R2, E = never, R = never>(self: boolean | Effect<boolean, E, R>, options: { readonly onTrue: LazyArg<Effect<A1, E1, R1>>; readonly onFalse: LazyArg<Effect<A2, E2, R2>>; }): Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8332)

Since v2.0.0
Effect-ignore.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.ignore

Discards both the success and failure values of an effect.

**When to Use**

`ignore` allows you to run an effect without caring about its result, whether
it succeeds or fails. This is useful when you only care about the side
effects of the effect and do not need to handle or process its outcome.

**Example** (Using Effect.ignore to Discard Values)

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const task = Effect.fail("Uh oh!").pipe(Effect.as(5))

//       Effect<void, never, never>
//      
const program = Effect.ignore(task)
```

**See**

- `ignoreLogged` to log failures while ignoring them.

**Signature**

```ts
declare const ignore: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4124)

Since v2.0.0
Effect-ignoreLogged.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.ignoreLogged

Ignores the result of an effect but logs any failures.

**Details**

This function takes an effect and returns a new effect that ignores whether
the original effect succeeds or fails. However, if the effect fails, it will
log the failure at the Debug level, so you can keep track of any issues that
arise.

**When to Use**

This is useful in scenarios where you want to continue with your program
regardless of the result of the effect, but you still want to be aware of
potential failures that may need attention later.

**Signature**

```ts
declare const ignoreLogged: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4145)

Since v2.0.0
Effect-inheritFiberRefs.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.inheritFiberRefs

Inherits values from all `FiberRef` instances into current fiber.

**Signature**

```ts
declare const inheritFiberRefs: (childFiberRefs: FiberRefs.FiberRefs) => Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10430)

Since v2.0.0
Effect-Latch.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.Latch

A `Latch` is a synchronization primitive that allows you to control the
execution of fibers based on an open or closed state. It acts as a gate,
where fibers can wait for the latch to open before proceeding.

**Details**

A `Latch` can be in one of two states: open or closed. Fibers can:
- Wait for the latch to open using `await`.
- Proceed only when the latch is open using `whenOpen`.
- Open the latch to release all waiting fibers using `open`.
- Close the latch to block fibers using `close`.

Additionally, fibers can be released without changing the state of the latch
using `release`.

**Signature**

```ts
export interface Latch extends Effect<void> {
  /**
   * Opens the latch, releasing all fibers waiting on it.
   *
   * **Details**
   *
   * Once the latch is opened, it remains open. Any fibers waiting on `await`
   * will be released and can continue execution.
   */
  readonly open: Effect<void>

  /**
   * Opens the latch, releasing all fibers waiting on it.
   *
   * **Details**
   *
   * Once the latch is opened, it remains open. Any fibers waiting on `await`
   * will be released and can continue execution.
   */
  readonly unsafeOpen: () => void

  /**
   * Releases all fibers waiting on the latch without opening it.
   *
   * **Details**
   *
   * This function lets waiting fibers proceed without permanently changing the
   * state of the latch.
   */
  readonly release: Effect<void>

  /**
   * Waits for the latch to be opened.
   *
   * **Details**
   *
   * If the latch is already open, this effect completes immediately. Otherwise,
   * it suspends the fiber until the latch is opened.
   */
  readonly await: Effect<void>

  /**
   * Closes the latch, blocking fibers from proceeding.
   *
   * **Details**
   *
   * This operation puts the latch into a closed state, requiring it to be
   * reopened before waiting fibers can proceed.
   */
  readonly close: Effect<void>

  /**
   * Unsafely closes the latch, blocking fibers without effect guarantees.
   *
   * **Details**
   *
   * Use this operation cautiously, as it does not run within an effect context
   * and bypasses runtime guarantees.
   */
  readonly unsafeClose: () => void

  /**
   * Runs the given effect only when the latch is open.
   *
   * **Details**
   *
   * This function ensures that the provided effect executes only if the latch
   * is open. If the latch is closed, the fiber will wait until it opens.
   */
  readonly whenOpen: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: LatchUnify<this>
  readonly [Unify.ignoreSymbol]?: LatchUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11852)

Since v3.8.0
Effect-interrupt.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.interrupt

Represents an effect that interrupts the current fiber.

**Details**

This effect models the explicit interruption of the fiber in which it runs.
When executed, it causes the fiber to stop its operation immediately,
capturing the interruption details such as the fiber's ID and its start time.
The resulting interruption can be observed in the `Exit` type if the effect
is run with functions like `runPromiseExit`.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  console.log("start")
  yield* Effect.sleep("2 seconds")
  yield* Effect.interrupt
  console.log("done")
  return "some result"
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// start
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Interrupt',
//     fiberId: {
//       _id: 'FiberId',
//       _tag: 'Runtime',
//       id: 0,
//       startTimeMillis: ...
//     }
//   }
// }
```

**Signature**

```ts
declare const interrupt: Effect<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4888)

Since v2.0.0
Effect-interruptible.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.interruptible

Marks an effect as interruptible.

**Signature**

```ts
declare const interruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4902)

Since v2.0.0
Effect-interruptibleMask.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.interruptibleMask

This function behaves like `interruptible`, but it also provides a
`restore` function. This function can be used to restore the interruptibility
of any specific region of code.

**Signature**

```ts
declare const interruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4912)

Since v2.0.0
Effect-intoDeferred.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.intoDeferred

Converts an `Effect` into an operation that completes a `Deferred` with its result.

**Details**

The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`
is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is
completed with the success value. If the effect fails, the `Deferred` is completed with the
failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.

**Example**

```ts
import { Deferred, Effect } from "effect"

// Define an effect that succeeds
const successEffect = Effect.succeed(42)

const program = Effect.gen(function*() {
  // Create a deferred
  const deferred = yield* Deferred.make<number, string>()

  // Complete the deferred using the successEffect
  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)

  // Access the value of the deferred
  const value = yield* Deferred.await(deferred)
  console.log(value)

  return isCompleted
})

Effect.runPromise(program).then(console.log)
// Output:
// 42
// true
```

**Signature**

```ts
declare const intoDeferred: { <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>; <A, E, R>(self: Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect<boolean, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8293)

Since v2.0.0
Effect-isEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.isEffect

Checks if a given value is an `Effect` value.

**When to Use**

This function can be useful for checking the type of a value before
attempting to operate on it as an `Effect` value. For example, you could use
`Effect.isEffect` to check the type of a value before using it as an argument
to a function that expects an `Effect` value.

**Signature**

```ts
declare const isEffect: (u: unknown) => u is Effect<unknown, unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L282)

Since v2.0.0
Effect-isFailure.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.isFailure

Checks if an effect has failed.

**Details**

This function evaluates whether an effect has resulted in a failure. It
returns a boolean value wrapped in an effect, with `true` indicating the
effect failed and `false` otherwise.

The resulting effect cannot fail (`never` in the error channel) but retains
the context of the original effect.

**Example**

```ts
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

console.log(Effect.runSync(Effect.isFailure(failure)))
// Output: true

const defect = Effect.dieMessage("BOOM!")

Effect.runSync(Effect.isFailure(defect))
// throws: BOOM!
```

**Signature**

```ts
declare const isFailure: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10528)

Since v2.0.0
Effect-isSuccess.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.isSuccess

Checks if an effect has succeeded.

**Details**

This function evaluates whether an effect has resulted in a success. It
returns a boolean value wrapped in an effect, with `true` indicating the
effect succeeded and `false` otherwise.

The resulting effect cannot fail (`never` in the error channel) but retains
the context of the original effect.

**Signature**

```ts
declare const isSuccess: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10545)

Since v2.0.0
Effect-iterate.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.iterate

Repeatedly updates a state through an effectful operation until a condition
is no longer met.

**Details**

This function provides a way to implement effectful loops, similar to a
`while` loop in JavaScript.

```ts
let result = initial

while (options.while(result)) {
  result = options.body(result)
}

return result
```

It starts with an initial state, checks a
condition (`while`), and executes a body operation to update the state if the
condition evaluates to `true`. The process repeats until the condition
returns `false`.

The state is passed between iterations, allowing the body operation to modify
it dynamically. The final state after the loop ends is returned as the result
of the effect.

**When to Use**

This is particularly useful for scenarios where looping logic involves
asynchronous or side-effectful operations, such as polling or iterative
computations that depend on external factors.

**Example** (Effectful Iteration)

```ts
import { Effect } from "effect"

const result = Effect.iterate(
  // Initial result
  1,
  {
    // Condition to continue iterating
    while: (result) => result <= 5,
    // Operation to change the result
    body: (result) => Effect.succeed(result + 1)
  }
)

Effect.runPromise(result).then(console.log)
// Output: 6
```

**Signature**

```ts
declare const iterate: { <A, B extends A, R, E>(initial: A, options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R>; }): Effect<A, E, R>; <A, R, E>(initial: A, options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R>; }): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9940)

Since v2.0.0
Effect-labelMetrics.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.labelMetrics

Adds labels to metrics within an effect using `MetricLabel` objects.

**Details**

This function allows you to label metrics using `MetricLabel` objects. Labels
help add structured metadata to metrics for categorization and filtering in
monitoring systems. The provided labels will apply to all metrics within the
effect's execution.

**Signature**

```ts
declare const labelMetrics: { (labels: Iterable<MetricLabel.MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11676)

Since v2.0.0
Effect-labelMetricsScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.labelMetricsScoped

Adds labels to metrics within a scope using `MetricLabel` objects.

**Details**

This function allows you to apply labels to all metrics generated within a
specific scope using an array of `MetricLabel` objects. These labels provide
additional metadata to metrics, which can be used for categorization,
filtering, or monitoring purposes. The labels are scoped and will be removed
automatically once the scope is closed, ensuring they are only applied
temporarily within the defined context.

**Signature**

```ts
declare const labelMetricsScoped: (labels: ReadonlyArray<MetricLabel.MetricLabel>) => Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11712)

Since v2.0.0
Effect-let.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })

```

**See**

- `Do`
- `bind`
- `bindTo`

**Signature**

```ts
declare const let: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): <E, R>(self: Effect<A, E, R>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; <A extends object, N extends string, E, R, B>(self: Effect<A, E, R>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8056)

Since v2.0.0
Effect-liftPredicate.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.liftPredicate

Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`
or failing with specified error if the predicate fails

**Example**

```ts
import { Effect } from "effect"

const isPositive = (n: number): boolean => n > 0

// succeeds with `1`
Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)

// fails with `"0 is not positive"`
Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)
```

**Signature**

```ts
declare const liftPredicate: { <T extends A, E, B extends T = T, A = T>(predicate: Refinement<T, B> | Predicate<T>, orFailWith: (a: EqualsWith<T, B, A, Exclude<A, B>>) => E): (a: A) => Effect<EqualsWith<T, B, A, B>, E>; <A, E, B extends A = A>(self: A, predicate: Refinement<A, B> | Predicate<A>, orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E): Effect<B, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5007)

Since v3.4.0
Effect-linkSpanCurrent.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.linkSpanCurrent

Add span links to the current span.

**Signature**

```ts
declare const linkSpanCurrent: { (span: Tracer.AnySpan, attributes?: Readonly<Record<string, unknown>> | undefined): Effect<void>; (links: ReadonlyArray<Tracer.SpanLink>): Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13022)

Since v3.14.0
Effect-linkSpans.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.linkSpans

For all spans in this effect, add a link with the provided span.

**Signature**

```ts
declare const linkSpans: { (span: Tracer.AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13004)

Since v2.0.0
Effect-log.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.log

Logs one or more messages or error causes at the current log level.

**Details**

This function provides a simple way to log messages or error causes during
the execution of your effects. By default, logs are recorded at the `INFO`
level, but this can be adjusted using other logging utilities
(`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,
can be logged in a single call. When logging `Cause` instances, detailed
error information is included in the log output.

The log output includes useful metadata like the current timestamp, log
level, and fiber ID, making it suitable for debugging and tracking purposes.
This function does not interrupt or alter the effect's execution flow.

**Example**

```ts
import { Cause, Effect } from "effect"

const program = Effect.log(
  "message1",
  "message2",
  Cause.die("Oh no!"),
  Cause.die("Oh uh!")
)

Effect.runFork(program)
// Output:
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!
// Error: Oh uh!"
```

**Signature**

```ts
declare const log: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10861)

Since v2.0.0
Effect-logAnnotations.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logAnnotations

Retrieves the current log annotations for the current scope.

**Details**

This function provides access to the log annotations associated with the
current scope. Log annotations are key-value pairs that provide additional
context to log entries. They are often used to add metadata such as tags,
identifiers, or extra debugging information to logs.

By using this function, you can inspect or utilize the annotations applied to
the current scope, making it easier to trace and debug specific sections of
your application.

**See**

- `annotateLogs` to add custom annotations to log entries generated within an effect.
- `annotateLogsScoped` to add log annotations with a limited scope.

**Signature**

```ts
declare const logAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11155)

Since v2.0.0
Effect-logDebug.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logDebug

Logs messages at the DEBUG log level.

**Details**

This function logs messages at the DEBUG level, which is typically used for
diagnosing application behavior during development. DEBUG messages provide
less detailed information than TRACE logs but are still not shown by default.
To view these logs, adjust the log level using `Logger.withMinimumLogLevel`.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message1
```

**Signature**

```ts
declare const logDebug: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10948)

Since v2.0.0
Effect-logError.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logError

Logs messages at the ERROR log level.

**Details**

This function logs messages at the ERROR level, suitable for reporting
application errors or failures. These logs are typically used for unexpected
issues that need immediate attention.

**Signature**

```ts
declare const logError: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10991)

Since v2.0.0
Effect-logFatal.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logFatal

Logs messages at the FATAL log level.

**Details**

This function logs messages at the FATAL level, suitable for reporting
critical errors that cause the application to terminate or stop functioning.
These logs are typically used for unrecoverable errors that require immediate
attention.

**Signature**

```ts
declare const logFatal: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11006)

Since v2.0.0
Effect-logInfo.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logInfo

Logs messages at the INFO log level.

**Details**

This function logs messages at the INFO level, suitable for general
application events or operational messages. INFO logs are shown by default
and are commonly used for highlighting normal, non-error operations.

**Signature**

```ts
declare const logInfo: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10962)

Since v2.0.0
Effect-logTrace.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logTrace

Logs messages at the TRACE log level.

**Details**

This function logs the specified messages at the TRACE level. TRACE logs are
typically used for very detailed diagnostic information. These messages are
not displayed by default. To view them, you must adjust the logging
configuration by setting the minimum log level to `LogLevel.Trace` using
`Logger.withMinimumLogLevel`.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))

Effect.runFork(program)
// timestamp=... level=TRACE fiber=#0 message=message1
```

**Signature**

```ts
declare const logTrace: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10922)

Since v2.0.0
Effect-logWarning.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logWarning

Logs messages at the WARNING log level.

**Details**

This function logs messages at the WARNING level, suitable for highlighting
potential issues that are not errors but may require attention. These
messages indicate that something unexpected occurred or might lead to errors
in the future.

**Signature**

```ts
declare const logWarning: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10977)

Since v2.0.0
Effect-logWithLevel.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.logWithLevel

Logs messages or error causes at a specified log level.

**Details**

This function allows you to log one or more messages or error causes while
specifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides
flexibility in categorizing logs based on their importance or severity,
making it easier to filter logs during debugging or production monitoring.

**Example**

```ts
import { Cause, Effect, LogLevel } from "effect"

const program = Effect.logWithLevel(
  LogLevel.Error,
  "Critical error encountered",
  Cause.die("System failure!")
)

Effect.runFork(program)
// Output:
// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"
```

**Signature**

```ts
declare const logWithLevel: (level: LogLevel.LogLevel, ...message: ReadonlyArray<any>) => Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10892)

Since v2.0.0
Effect-loop.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.loop

Repeatedly executes a loop with a state, collecting results or discarding
them based on configuration.

**Details**

This function performs an effectful loop, starting with an initial state and
iterating as long as the `while` condition evaluates to `true`, similar to a
`while` loop in JavaScript.

```ts
let state = initial
const result = []

while (options.while(state)) {
  result.push(options.body(state)) // Perform the effectful operation
  state = options.step(state) // Update the state
}

return result
```

During each iteration, the `step` function updates the state, and the `body`
effect is executed.

The results of the body effect can be collected in an array or discarded
based on the `discard` option.

**Discarding Intermediate Results**

- If `discard` is `false` or not provided, the intermediate results are
  collected into an array and returned as the final result.
- If `discard` is `true`, the intermediate results are ignored, and the
  effect returns `void`.

**When to Use**

This is useful for implementing loops where you need to perform effectful
computations repeatedly, such as processing items in a list, generating
values, or performing iterative updates.

**Example** (Looping with Collected Results)

```ts
import { Effect } from "effect"

// A loop that runs 5 times, collecting each iteration's result
const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Effect.succeed(state)
  }
)

Effect.runPromise(result).then(console.log)
// Output: [1, 2, 3, 4, 5]
```

**Example** (Loop with Discarded Results)

```ts
import { Effect, Console } from "effect"

const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Console.log(`Currently at state ${state}`),
    // Discard intermediate results
    discard: true
  }
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at state 1
// Currently at state 2
// Currently at state 3
// Currently at state 4
// Currently at state 5
// undefined
```

**Signature**

```ts
declare const loop: { <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10054)

Since v2.0.0
Effect-makeLatch.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.makeLatch

Creates a new `Latch`, starting in the specified state.

**Details**

This function initializes a `Latch` safely, ensuring proper runtime
guarantees. By default, the latch starts in the closed state.

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.gen(function*() {
  // Create a latch, starting in the closed state
  const latch = yield* Effect.makeLatch(false)

  // Fork a fiber that logs "open sesame" when the latch is opened
  const fiber = yield* Console.log("open sesame").pipe(
    latch.whenOpen,
    Effect.fork
  )

  yield* Effect.sleep("1 second")

  // Open the latch
  yield* latch.open
  yield* fiber.await
})

Effect.runFork(program)
// Output: open sesame (after 1 second)
```

**Signature**

```ts
declare const makeLatch: (open?: boolean | undefined) => Effect<Latch, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11987)

Since v3.8.0
Effect-makeSemaphore.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.makeSemaphore

Creates a new semaphore with the specified number of permits.

**Details**

This function initializes a semaphore that controls concurrent access to a
shared resource. The number of permits determines how many tasks can access
the resource concurrently.

**Example**

```ts
import { Effect } from "effect"

// Create a semaphore with 3 permits
const mutex = Effect.makeSemaphore(3)
```

**Signature**

```ts
declare const makeSemaphore: (permits: number) => Effect<Semaphore>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11831)

Since v2.0.0
Effect-makeSpan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.makeSpan

Create a new span for tracing.

**Signature**

```ts
declare const makeSpan: (name: string, options?: Tracer.SpanOptions) => Effect<Tracer.Span>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13033)

Since v2.0.0
Effect-makeSpanScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.makeSpanScoped

Create a new span for tracing, and automatically close it when the Scope
finalizes.

The span is not added to the current span stack, so no child spans will be
created for it.

**Signature**

```ts
declare const makeSpanScoped: (name: string, options?: Tracer.SpanOptions | undefined) => Effect<Tracer.Span, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13048)

Since v2.0.0
Effect-map.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.map

Transforms the value inside an effect by applying a function to it.

**Syntax**

```ts
const mappedEffect = pipe(myEffect, Effect.map(transformation))
// or
const mappedEffect = Effect.map(myEffect, transformation)
// or
const mappedEffect = myEffect.pipe(Effect.map(transformation))
```

**Details**

`map` takes a function and applies it to the value contained within an
effect, creating a new effect with the transformed value.

It's important to note that effects are immutable, meaning that the original
effect is not modified. Instead, a new effect is returned with the updated
value.

**Example** (Adding a Service Charge)

```ts
import { pipe, Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.map(addServiceCharge)
)

Effect.runPromise(finalAmount).then(console.log)
// Output: 101
```

**See**

- `mapError` for a version that operates on the error channel.
- `mapBoth` for a version that operates on both channels.
- `flatMap` or `andThen` for a version that can return a new effect.

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5177)

Since v2.0.0
Effect-mapAccum.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.mapAccum

Applies a stateful transformation to each element of a collection, producing
new elements along with an updated state.

**When to Use**

Use `mapAccum` when you need to process each element of a collection while
keeping track of some state across iterations.

**Details**

`mapAccum` takes an initial state (`initial`) and a function (`f`) that is
applied to each element. This function returns a new state and a transformed
element. The final effect produces both the accumulated state and the
transformed collection.

If the input collection is a non-empty array, the return type will match the
input collection type.

**Example**

```ts
import { Effect } from "effect"

// Define an initial state and a transformation function
const initialState = 0

const transformation = (state: number, element: string) =>
  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])

// Apply mapAccum to transform an array of strings
const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)

Effect.runPromise(program).then(([finalState, transformedCollection]) => {
  console.log(finalState)
  console.log(transformedCollection)
})
// Output:
// 6
// [ 'A', 'BB', 'CCC' ]
```

**Signature**

```ts
declare const mapAccum: { <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): (elements: I) => Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(elements: I, initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5227)

Since v2.0.0
Effect-mapBoth.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.mapBoth

Applies transformations to both the success and error channels of an effect.

**Details**

This function takes two map functions as arguments: one for the error channel
and one for the success channel. You can use it when you want to modify both
the error and the success values without altering the overall success or
failure status of the effect.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//       Effect<boolean, Error, never>
//      
const modified = Effect.mapBoth(simulatedTask, {
  onFailure: (message) => new Error(message),
  onSuccess: (n) => n > 0
})
```

**See**

- `map` for a version that operates on the success channel.
- `mapError` for a version that operates on the error channel.

**Signature**

```ts
declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5272)

Since v2.0.0
Effect-mapError.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.mapError

Transforms or modifies the error produced by an effect without affecting its
success value.

**When to Use**

This function is helpful when you want to enhance the error with additional
information, change the error type, or apply custom error handling while
keeping the original behavior of the effect's success values intact. It only
operates on the error channel and leaves the success channel unchanged.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//       Effect<number, Error, never>
//      
const mapped = Effect.mapError(
  simulatedTask,
  (message) => new Error(message)
)
```

**See**

- `map` for a version that operates on the success channel.
- `mapBoth` for a version that operates on both channels.
- `orElseFail` if you want to replace the error with a new one.

**Signature**

```ts
declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5317)

Since v2.0.0
Effect-mapErrorCause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.mapErrorCause

Maps the cause of failure of an effect using a specified function.

**See**

- `sandbox` for a version that exposes the full cause of failures, defects, or interruptions.
- `catchAllCause` for a version that can recover from all types of defects.

**Signature**

```ts
declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5331)

Since v2.0.0
Effect-mapInputContext.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.mapInputContext

Provides part of the required context while leaving the rest unchanged.

**Details**

This function allows you to transform the context required by an effect,
providing part of the context and leaving the rest to be fulfilled later.

**Example**

```ts
import { Context, Effect } from "effect"

class Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}
class Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}

const program = Effect.gen(function*() {
  const service1 = yield* Service1
  console.log(service1.port)
  const service2 = yield* Service2
  console.log(service2.connection)
  return "some result"
})

//       Effect<string, never, Service2>
//      
const programWithService1 = Effect.mapInputContext(
  program,
  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })
)

const runnable = programWithService1.pipe(
  Effect.provideService(Service2, { connection: "localhost" }),
  Effect.provideService(Service1, { port: 3001 })
)

Effect.runPromise(runnable)
// Output:
// 3000
// localhost
```

**Signature**

```ts
declare const mapInputContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<R>): Effect<A, E, R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7489)

Since v2.0.0
Effect-match.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.match

Handles both success and failure cases of an effect without performing side
effects.

**Details**

`match` lets you define custom handlers for both success and failure
scenarios. You provide separate functions to handle each case, allowing you
to process the result if the effect succeeds, or handle the error if the
effect fails.

**When to Use**

This is useful for structuring your code to respond differently to success or
failure without triggering side effects.

**Example** (Handling Both Success and Failure Cases)

```ts
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)

const program1 = Effect.match(success, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the successful effect
Effect.runPromise(program1).then(console.log)
// Output: "success: 42"

const failure: Effect.Effect<number, Error> = Effect.fail(
  new Error("Uh oh!")
)

const program2 = Effect.match(failure, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the failed effect
Effect.runPromise(program2).then(console.log)
// Output: "failure: Uh oh!"
```

**See**

- `matchEffect` if you need to perform side effects in the handlers.

**Signature**

```ts
declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10598)

Since v2.0.0
Effect-matchCause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.matchCause

Handles failures by matching the cause of failure.

**Details**

The `matchCause` function allows you to handle failures with access to the
full cause of the failure within a fiber.

**When to Use**

This is useful for differentiating between different types of errors, such as
regular failures, defects, or interruptions. You can provide specific
handling logic for each failure type based on the cause.

**Example** (Handling Different Failure Causes)

```ts
import { Effect } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCause(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure
        return `Fail: ${cause.error.message}`
      case "Die":
        // Handle defects (unexpected errors)
        return `Die: ${cause.defect}`
      case "Interrupt":
        // Handle interruption
        return `${cause.fiberId} interrupted!`
    }
    // Fallback for other causes
    return "failed due to other causes"
  },
  onSuccess: (value) =>
    // task completes successfully
    `succeeded with ${value} value`
})

Effect.runPromise(program).then(console.log)
// Output: "Die: Uh oh!"
```

**See**

- `matchCauseEffect` if you need to perform side effects in the
handlers.
- `match` if you don't need to handle the cause of the failure.

**Signature**

```ts
declare const matchCause: { <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10667)

Since v2.0.0
Effect-matchCauseEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.matchCauseEffect

Handles failures with access to the cause and allows performing side effects.

**Details**

The `matchCauseEffect` function works similarly to `matchCause`, but it
also allows you to perform additional side effects based on the failure
cause. This function provides access to the complete cause of the failure,
making it possible to differentiate between various failure types, and allows
you to respond accordingly while performing side effects (like logging or
other operations).

**Example** (Handling Different Failure Causes with Side Effects)

```ts
import { Effect, Console } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCauseEffect(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure with a logged message
        return Console.log(`Fail: ${cause.error.message}`)
      case "Die":
        // Handle defects (unexpected errors) by logging the defect
        return Console.log(`Die: ${cause.defect}`)
      case "Interrupt":
        // Handle interruption and log the fiberId that was interrupted
        return Console.log(`${cause.fiberId} interrupted!`)
    }
    // Fallback for other causes
    return Console.log("failed due to other causes")
  },
  onSuccess: (value) =>
    // Log success if the task completes successfully
    Console.log(`succeeded with ${value} value`)
})

Effect.runPromise(program)
// Output: "Die: Uh oh!"
```

**See**

- `matchCause` if you don't need side effects and only want to handle the result or failure.
- `matchEffect` if you don't need to handle the cause of the failure.

**Signature**

```ts
declare const matchCauseEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10733)

Since v2.0.0
Effect-matchEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.matchEffect

Handles both success and failure cases of an effect, allowing for additional
side effects.

**Details**

The `matchEffect` function is similar to `match`, but it enables you to
perform side effects in the handlers for both success and failure outcomes.

**When to Use**

This is useful when you need to execute additional actions, like logging or
notifying users, based on whether an effect succeeds or fails.

**Example** (Handling Both Success and Failure Cases with Side Effects)

```ts
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)
const failure: Effect.Effect<number, Error> = Effect.fail(
  new Error("Uh oh!")
)

const program1 = Effect.matchEffect(success, {
  onFailure: (error) =>
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =>
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program1))
// Output:
// timestamp=... level=INFO fiber=#0 message="success: 42"
// success: 42

const program2 = Effect.matchEffect(failure, {
  onFailure: (error) =>
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =>
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program2))
// Output:
// timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"
// failure: Uh oh!
```

**See**

- `match` if you don't need side effects and only want to handle the
result or failure.

**Signature**

```ts
declare const matchEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10808)

Since v2.0.0
Effect-merge.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.merge

Combines both success and error channels of an effect into a single outcome.

**Details**

This function transforms an effect that may fail into one that always returns
a value, where both success and failure outcomes are handled as values in the
success channel.

**When to Use**

This can be useful when you want to continue execution regardless of the
error type and still capture both successful results and errors as part of
the outcome.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<number | string, never, never>
//      
const recovered = Effect.merge(program)
```

**Signature**

```ts
declare const merge: <A, E, R>(self: Effect<A, E, R>) => Effect<E | A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5368)

Since v2.0.0
Effect-mergeAll.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.mergeAll

Merges an `Iterable<Effect<A, E, R>>` to a single effect.

**Details**

This function takes an iterable of effects and combines them into a single
effect. It does this by iterating over each effect in the collection and
applying a function that accumulates results into a "zero" value, which
starts with an initial value and is updated with each effect's success.

The provided function `f` is called for each element in the iterable,
allowing you to specify how to combine the results.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Effect } from "effect"

const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]
const add = (sum: number, value: number, i: number) => sum + value
const zero = 0

const program = Effect.gen(function*() {
  const total = yield* Effect.mergeAll(numbers, zero, add)
  console.log(total)
})

Effect.runFork(program)
// Output: 6
```

**Signature**

```ts
declare const mergeAll: { <Z, Eff extends Effect<any, any, any>>(zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z>(elements: Iterable<Eff>, zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1722)

Since v2.0.0
Effect-metricLabels.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.metricLabels

Retrieves the metric labels associated with the current scope.

**Signature**

```ts
declare const metricLabels: Effect<ReadonlyArray<MetricLabel.MetricLabel>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11722)

Since v2.0.0
Effect-negate.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.negate

Returns a new effect with the boolean value of this effect negated.

**Signature**

```ts
declare const negate: <E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5376)

Since v2.0.0
Effect-never.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.never

An effect that that runs indefinitely and never produces any result. The
moral equivalent of `while(true) {}`, only without the wasted CPU cycles.

**When to Use**

It could be useful for long-running background tasks or to simulate waiting
behavior without actually consuming resources. This effect is ideal for cases
where you want to keep the program alive or in a certain state without
performing any active work.

**Signature**

```ts
declare const never: Effect<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3058)

Since v2.0.0
Effect-none.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.none

Ensures the `Option` is `None`, returning `void`. Otherwise, raises a
`NoSuchElementException`.

**Details**

This function checks if the provided `Option` is `None`. If it is, it returns
an effect that produces no result (i.e., `void`). If the `Option` is not
`None` (i.e., it contains a value), the function will raise a
`NoSuchElementException` error.

**When to Use**

This is useful when you want to ensure that a certain value is absent (i.e.,
`None`) before continuing execution, and to handle cases where the value is
unexpectedly present.

**Signature**

```ts
declare const none: <A, E, R>(self: Effect<Option.Option<A>, E, R>) => Effect<void, E | Cause.NoSuchElementException, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3079)

Since v2.0.0
Effect-onError.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.onError

Ensures a cleanup effect runs whenever the calling effect fails, providing
the failure cause to the cleanup effect.

**Details**

This function allows you to attach a cleanup effect that runs whenever the
calling effect fails. The cleanup effect receives the cause of the failure,
allowing you to perform actions such as logging, releasing resources, or
executing additional recovery logic based on the error. The cleanup effect
will execute even if the failure is due to interruption.

Importantly, the cleanup effect itself is uninterruptible, ensuring that it
completes regardless of external interruptions.

**Example** (Running Cleanup Only on Failure)

```ts
import { Console, Effect } from "effect"

// This handler logs the failure cause when the effect fails
const handler = Effect.onError((cause) =>
  Console.log(`Cleanup completed: ${cause}`)
)

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

// Define a failing effect
const defect = Console.log("Task failed with defect").pipe(
  Effect.andThen(Effect.die("Boom!")),
  handler
)

Effect.runFork(defect)
// Output:
// Task failed with defect
// Cleanup completed: Error: Boom!

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.
```

**See**

- `ensuring` for attaching a cleanup effect that runs on both success and failure.
- `onExit` for attaching a cleanup effect that runs on all possible exits.

**Signature**

```ts
declare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): Effect<A, E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5842)

Since v2.0.0
Effect-onExit.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.onExit

Guarantees that a cleanup function runs regardless of whether the effect
succeeds, fails, or is interrupted.

**Details**

This function ensures that a provided cleanup function is executed after the
effect completes, regardless of the outcome. The cleanup function is given
the `Exit` value of the effect, which provides detailed information about the
result:
- If the effect succeeds, the `Exit` contains the success value.
- If the effect fails, the `Exit` contains the error or failure cause.
- If the effect is interrupted, the `Exit` reflects the interruption.

The cleanup function is guaranteed to run uninterruptibly, ensuring reliable
resource management even in complex or high-concurrency scenarios.

**Example** (Running a Cleanup Function with the Effects Result)

```ts
import { Console, Effect, Exit } from "effect"

// Define a cleanup effect that logs the result
const handler = Effect.onExit((exit) =>
  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)
)

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed: some result

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.
```

**Signature**

```ts
declare const onExit: { <A, E, X, R2>(cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5916)

Since v2.0.0
Effect-onInterrupt.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.onInterrupt

Registers a cleanup effect to run when an effect is interrupted.

**Details**

This function allows you to specify an effect to run when the fiber is
interrupted. This effect will be executed when the fiber is interrupted,
allowing you to perform cleanup or other actions.

**Example** (Running a Cleanup Action on Interruption)

```ts
import { Console, Effect } from "effect"

// This handler is executed when the fiber is interrupted
const handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))

const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)

Effect.runFork(success)
// Output:
// Task completed

const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)

Effect.runFork(failure)
// Output:
// Task failed

const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed
```

**Signature**

```ts
declare const onInterrupt: { <X, R2>(cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4956)

Since v2.0.0
Effect-once.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.once

Returns an effect that executes only once, regardless of how many times it's
called.

**Details**

This function ensures that a specific effect is executed only a single time,
no matter how many times it is invoked. The result of the effect will be
cached, and subsequent calls to the effect will immediately return the cached
result without re-executing the original logic.

**When to Use**

Use this function when you need to perform a task only once, regardless of
how many times the effect is triggered. It's particularly useful when you
have initialization tasks, logging, or other one-time actions that should not
be repeated. This can help optimize performance and avoid redundant actions.

**Example**

```ts
import { Effect, Console } from "effect"

const program = Effect.gen(function* () {
  const task1 = Console.log("task1")
  yield* Effect.repeatN(task1, 2)
  const task2 = yield* Effect.once(Console.log("task2"))
  yield* Effect.repeatN(task2, 2)
})

Effect.runFork(program)
// Output:
// task1
// task1
// task1
// task2
```

**Signature**

```ts
declare const once: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L604)

Since v2.0.0
Effect-option.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.option

Encapsulates the result of an effect in an `Option`.

**Details**

This function wraps the outcome of an effect in an `Option` type. If the
original effect succeeds, the success value is wrapped in `Option.some`. If
the effect fails, the failure is converted to `Option.none`.

This is particularly useful for scenarios where you want to represent the
absence of a value explicitly, without causing the resulting effect to fail.
The resulting effect has an error type of `never`, meaning it cannot fail
directly. However, unrecoverable errors, also referred to as defects, are
not captured and will still result in failure.

**Example** (Using Effect.option to Handle Errors)

```ts
import { Effect } from "effect"

const maybe1 = Effect.option(Effect.succeed(1))

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'Some', value: 1 }
// }

const maybe2 = Effect.option(Effect.fail("Uh oh!"))

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'None' }
// }

const maybe3 = Effect.option(Effect.die("Boom!"))

Effect.runPromiseExit(maybe3).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
// }
```

**See**

- `either` for a version that uses `Either` instead.
- `exit` for a version that encapsulates both recoverable errors and defects in an `Exit`.

**Signature**

```ts
declare const option: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8116)

Since v2.0.0
Effect-Semaphore.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.Semaphore

A semaphore is a synchronization mechanism used to manage access to a shared
resource. In Effect, semaphores help control resource access or coordinate
tasks within asynchronous, concurrent operations.

A semaphore acts as a generalized mutex, allowing a set number of permits to
be held and released concurrently. Permits act like tickets, giving tasks or
fibers controlled access to a shared resource. When no permits are available,
tasks trying to acquire one will wait until a permit is released.

**Signature**

```ts
export interface Semaphore {
  /**
   * Runs an effect with the given number of permits and releases the permits
   * when the effect completes.
   *
   * **Details**
   *
   * This function acquires the specified number of permits before executing
   * the provided effect. Once the effect finishes, the permits are released.
   * If insufficient permits are available, the function will wait until they
   * are released by other tasks.
   */
  withPermits(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

  /**
   * Runs an effect only if the specified number of permits are immediately
   * available.
   *
   * **Details**
   *
   * This function attempts to acquire the specified number of permits. If they
   * are available, it runs the effect and releases the permits after the effect
   * completes. If permits are not available, the effect does not execute, and
   * the result is `Option.none`.
   */
  withPermitsIfAvailable(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>

  /**
   * Acquires the specified number of permits and returns the resulting
   * available permits, suspending the task if they are not yet available.
   * Concurrent pending `take` calls are processed in a first-in, first-out manner.
   */
  take(permits: number): Effect<number>

  /**
   * Releases the specified number of permits and returns the resulting
   * available permits.
   */
  release(permits: number): Effect<number>

  /**
   * Releases all permits held by this semaphore and returns the resulting available permits.
   */
  releaseAll: Effect<number>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11756)

Since v2.0.0
Effect-Service.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.Service

Simplifies the creation and management of services in Effect by defining both
a `Tag` and a `Layer`.

**Details**

This function allows you to streamline the creation of services by combining
the definition of a `Context.Tag` and a `Layer` in a single step. It supports
various ways of providing the service implementation:
- Using an `effect` to define the service dynamically.
- Using `sync` or `succeed` to define the service statically.
- Using `scoped` to create services with lifecycle management.

It also allows you to specify dependencies for the service, which will be
provided automatically when the service is used. Accessors can be optionally
generated for the service, making it more convenient to use.

**Example**

```ts
import { Effect } from 'effect';

class Prefix extends Effect.Service<Prefix>()("Prefix", {
 sync: () => ({ prefix: "PRE" })
}) {}

class Logger extends Effect.Service<Logger>()("Logger", {
 accessors: true,
 effect: Effect.gen(function* () {
   const { prefix } = yield* Prefix
   return {
     info: (message: string) =>
       Effect.sync(() => {
         console.log(`[${prefix}][${message}]`)
       })
   }
 }),
 dependencies: [Prefix.Default]
}) {}
```

**Signature**

```ts
declare const Service: <Self = never>() => [Self] extends [never] ? MissingSelfGeneric : { <const Key extends string, const Make extends { readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly effect: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; }>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly effect: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13551)

Since v3.9.0
Effect-optionFromOptional.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.optionFromOptional

Converts an effect that may fail with a `NoSuchElementException` into an
effect that succeeds with an `Option`.

**Details**

This function transforms an effect that might fail with
`Cause.NoSuchElementException` into an effect that succeeds with an `Option`
type. If the original effect succeeds, its value is wrapped in `Option.some`.
If it fails specifically due to a `NoSuchElementException`, the failure is
mapped to `Option.none`. Other types of failures remain unchanged and are
passed through as they are.

This is useful when working with effects where you want to gracefully handle
the absence of a value while preserving other potential failures.

**When to Use**

Use this function when you need to handle missing values as `Option.none`
rather than throwing or propagating errors like `NoSuchElementException`.
Its ideal for scenarios where you want to explicitly represent optionality
in a type-safe way while retaining other failure information.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, NoSuchElementException, never>
//      
const maybe1 = Effect.fromNullable(1)

//       Effect<Option<number>, never, never>
//      
const option1 = Effect.optionFromOptional(maybe1)

Effect.runPromise(option1).then(console.log)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

//       Effect<number, NoSuchElementException, never>
//      
const maybe2 = Effect.fromNullable(null as number | null)

//       Effect<Option<number>, never, never>
//      
const option2 = Effect.optionFromOptional(maybe2)

Effect.runPromise(option2).then(console.log)
// Output: { _tag: 'None' }
```

**Signature**

```ts
declare const optionFromOptional: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13277)

Since v2.0.0
Effect-orDie.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.orDie

Converts an effect's failure into a fiber termination, removing the error
from the effect's type.

**Details**

The `orDie` function is used when you encounter errors that you do not want
to handle or recover from. It removes the error type from the effect and
ensures that any failure will terminate the fiber. This is useful for
propagating failures as defects, signaling that they should not be handled
within the effect.

**When to Use*

Use `orDie` when failures should be treated as unrecoverable defects and no
error handling is required.

**Example** (Propagating an Error as a Defect)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = Effect.orDie(divide(1, 0))

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...
```

**See**

- `orDieWith` if you need to customize the error.

**Signature**

```ts
declare const orDie: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11276)

Since v2.0.0
Effect-orDieWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.orDieWith

Converts an effect's failure into a fiber termination with a custom error.

**Details**

The `orDieWith` function behaves like `orDie`, but it allows you to provide a mapping
function to transform the error before terminating the fiber. This is useful for cases where
you want to include a more detailed or user-friendly error when the failure is propagated
as a defect.

**When to Use**

Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize
the error for clarity or debugging purposes.

**Example** (Customizing Defect)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = Effect.orDieWith(
  divide(1, 0),
  (error) => new Error(`defect: ${error.message}`)
)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: defect: Cannot divide by zero
//   ...stack trace...
```

**See**

- `orDie` if you don't need to customize the error.

**Signature**

```ts
declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>; <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11321)

Since v2.0.0
Effect-orElse.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.orElse

Attempts one effect, and if it fails, falls back to another effect.

**Details**

This function allows you to try executing an effect, and if it fails
(produces an error), a fallback effect is executed instead. The fallback
effect is defined as a lazy argument, meaning it will only be evaluated if
the first effect fails. This provides a way to recover from errors by
specifying an alternative path of execution.

The error type of the resulting effect will be that of the fallback effect,
as the first effect's error is replaced when the fallback is executed.

**Example**

```ts
import { Effect } from "effect"

const success = Effect.succeed("success")
const failure = Effect.fail("failure")
const fallback = Effect.succeed("fallback")

// Try the success effect first, fallback is not used
const program1 = Effect.orElse(success, () => fallback)
console.log(Effect.runSync(program1))
// Output: "success"

// Try the failure effect first, fallback is used
const program2 = Effect.orElse(failure, () => fallback)
console.log(Effect.runSync(program2))
// Output: "fallback"
```

**See**

- `catchAll` if you need to access the error in the fallback effect.

**Signature**

```ts
declare const orElse: { <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A2 | A, E2, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11365)

Since v2.0.0
Effect-orElseFail.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.orElseFail

Replaces the failure of an effect with a custom failure value.

**Details**

This function allows you to handle the failure of an effect by replacing it
with a predefined failure value. If the effect fails, the new failure value
provided by the `evaluate` function will be returned instead of the original
failure. If the effect succeeds, the original success value is returned
unchanged.

**When to Use**

This is particularly useful when you want to standardize error handling or
provide a consistent failure value for specific operations. It simplifies
error management by ensuring that all failures are replaced with a controlled
alternative.

**Example**

```ts
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseFail(validate(-1), () => "invalid age")

console.log(Effect.runSyncExit(program))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
// }
```

**See**

- `mapError` if you need to access the error to transform it.

**Signature**

```ts
declare const orElseFail: { <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11419)

Since v2.0.0
Effect-orElseSucceed.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.orElseSucceed

Ensures the effect always succeeds by replacing failures with a default
success value.

**Details**

This function transforms an effect that may fail into one that cannot fail by
replacing any failure with a provided success value. If the original effect
fails, the failure is "swallowed," and the specified success value is
returned instead. If the original effect succeeds, its value remains
unchanged.

**When to Use**

This is especially useful for providing default values in case of failure,
ensuring that an effect always completes successfully. By using this
function, you can avoid the need for complex error handling and guarantee a
fallback result.

**Example**

```ts
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseSucceed(validate(-1), () => 18)

console.log(Effect.runSyncExit(program))
// Output:
// { _id: 'Exit', _tag: 'Success', value: 18 }
```

**Signature**

```ts
declare const orElseSucceed: { <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11468)

Since v2.0.0
Effect-parallelErrors.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.parallelErrors

Combines all errors from concurrent operations into a single error.

**Details**

This function is used when you have multiple operations running at the same
time, and you want to capture all the errors that occur across those
operations. Instead of handling each error separately, it combines all the
errors into one unified error.

**When to Use**

When using this function, any errors that occur in the concurrently running
operations will be grouped together into a single error. This helps simplify
error handling in cases where you don't need to differentiate between each
failure, but simply want to know that multiple failures occurred.

**Example**

```ts
import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }
```

**Signature**

```ts
declare const parallelErrors: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Array<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4190)

Since v2.0.0
Effect-parallelFinalizers.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.parallelFinalizers

Ensures that finalizers are run concurrently when the scope of an effect is
closed.

**Details**

This function modifies the behavior of finalizers within a scoped workflow to
allow them to run concurrently when the scope is closed.

By default, finalizers are executed sequentially in reverse order of their
addition, but this function changes that behavior to execute all finalizers
concurrently.

**When to Use**

Running finalizers concurrently can improve performance when multiple
independent cleanup tasks need to be performed. However, it requires that
these tasks do not depend on the order of execution or introduce race
conditions.

**Example**

```ts
import { Console, Effect } from "effect"

// Define a program that adds multiple finalizers
const program = Effect.gen(function*() {
  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))
  return "some result"
})

// Modify the program to ensure finalizers run in parallel
const modified = program.pipe(Effect.parallelFinalizers)

const runnable = Effect.scoped(modified)

Effect.runFork(runnable)
// Output:
// Finalizer 2 executed
// Finalizer 3 executed
// Finalizer 1 executed
```

**See**

- `sequentialFinalizers` for a version that ensures finalizers are run sequentially.

**Signature**

```ts
declare const parallelFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5976)

Since v2.0.0
Effect-partition.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.partition

Processes an iterable and applies an effectful function to each element,
categorizing the results into successes and failures.

**Details**

This function processes each element in the provided iterable by applying an
effectful function to it. The results are then categorized into two separate
lists: one for failures and another for successes. This separation allows you
to handle the two categories differently. Failures are collected in a list
without interrupting the processing of the remaining elements, so the
operation continues even if some elements fail. This is particularly useful
when you need to handle both successful and failed results separately,
without stopping the entire process on encountering a failure.

**When to Use**

Use this function when you want to process a collection of items and handle
errors or failures without interrupting the processing of other items. It's
useful when you need to distinguish between successful and failed results and
process them separately, for example, when logging errors while continuing to
work with valid data. The function ensures that failures are captured, while
successes are processed normally.

**Example**

```ts
import { Effect } from "effect"

//       Effect<[string[], number[]], never, never>
//      
const program = Effect.partition([0, 1, 2, 3, 4], (n) => {
  if (n % 2 === 0) {
    return Effect.succeed(n)
  } else {
    return Effect.fail(`${n} is not even`)
  }
})

Effect.runPromise(program).then(console.log, console.error)
// Output:
// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]
```

**See**

- `validateAll` for a function that either collects all failures or all successes.
- `validateFirst` for a function that stops at the first success.

**Signature**

```ts
declare const partition: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1798)

Since v2.0.0
Effect-patchFiberRefs.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.patchFiberRefs

Applies the specified changes to the `FiberRef` values for the fiber
running this workflow.

**Signature**

```ts
declare const patchFiberRefs: (patch: FiberRefsPatch.FiberRefsPatch) => Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10475)

Since v2.0.0
Effect-promise.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.promise

Creates an `Effect` that represents an asynchronous computation guaranteed to
succeed.

**Details**

The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error
will be treated as a "defect".

This defect is not a standard error but indicates a flaw in the logic that
was expected to be error-free. You can think of it similar to an unexpected
crash in the program, which can be further managed or logged using tools like
`catchAllDefect`.

**Interruptions**

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

**When to Use**

Use this function when you are sure the operation will not reject.

**Example** (Delayed Message)

```ts
import { Effect } from "effect"

const delay = (message: string) =>
  Effect.promise<string>(
    () =>
      new Promise((resolve) => {
        setTimeout(() => {
          resolve(message)
        }, 2000)
      })
  )

//       Effect<string, never, never>
//      
const program = delay("Async operation completed successfully!")
```

**See**

- `tryPromise` for a version that can handle failures.

**Signature**

```ts
declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3131)

Since v2.0.0
Effect-provide.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.provide

Provides necessary dependencies to an effect, removing its environmental
requirements.

**Details**

This function allows you to supply the required environment for an effect.
The environment can be provided in the form of one or more `Layer`s, a
`Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is
provided, the effect can run without requiring external dependencies.

You can compose layers to create a modular and reusable way of setting up the
environment for effects. For example, layers can be used to configure
databases, logging services, or any other required dependencies.

**Example**

```ts
import { Context, Effect, Layer } from "effect"

class Database extends Context.Tag("Database")<
  Database,
  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }
>() {}

const DatabaseLive = Layer.succeed(
  Database,
  {
    // Simulate a database query
    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))
  }
)

//       Effect<unknown[], never, Database>
//      
const program = Effect.gen(function*() {
  const database = yield* Database
  const result = yield* database.query("SELECT * FROM users")
  return result
})

//       Effect<unknown[], never, never>
//      
const runnable = Effect.provide(program, DatabaseLive)

Effect.runPromise(runnable).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"
// []
```

**See**

- `provideService` for providing a service to an effect.

**Signature**

```ts
declare const provide: { <const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <ROut, E2, RIn>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>; <R2>(context: Context.Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <R2>(runtime: Runtime.Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <E2, R2>(managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, R2>>; <A, E, R, const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>; <A, E, R, R2>(self: Effect<A, E, R>, context: Context.Context<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime.Runtime<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime.ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7550)

Since v2.0.0
Effect-provideService.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.provideService

Provides an implementation for a service in the context of an effect.

**Details**

This function allows you to supply a specific implementation for a service
required by an effect. Services are typically defined using `Context.Tag`,
which acts as a unique identifier for the service. By using this function,
you link the service to its concrete implementation, enabling the effect to
execute successfully without additional requirements.

For example, you can use this function to provide a random number generator,
a logger, or any other service your effect depends on. Once the service is
provided, all parts of the effect that rely on the service will automatically
use the implementation you supplied.

**Example**

```ts
import { Effect, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

// Using the service
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
//
//       Effect<void, never, never>
//      
const runnable = Effect.provideService(program, Random, {
  next: Effect.sync(() => Math.random())
})

// Run successfully
Effect.runPromise(runnable)
// Example Output:
// random number: 0.8241872233134417
```

**See**

- `provide` for providing multiple layers to an effect.

**Signature**

```ts
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7643)

Since v2.0.0
Effect-provideServiceEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.provideServiceEffect

Dynamically provides an implementation for a service using an effect.

**Details**

This function allows you to provide an implementation for a service
dynamically by using another effect. The provided effect is executed to
produce the service implementation, which is then made available to the
consuming effect. This is particularly useful when the service implementation
itself requires asynchronous or resource-intensive initialization.

For example, you can use this function to lazily initialize a database
connection or fetch configuration values from an external source before
making the service available to your effect.

**Signature**

```ts
declare const provideServiceEffect: { <I, S, E1, R1>(tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): Effect<A, E | E1, R1 | Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7666)

Since v2.0.0
Effect-race.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.race

Races two effects and returns the result of the first successful one.

**Details**

This function takes two effects and runs them concurrently. The first effect
that successfully completes will determine the result of the race, and the
other effect will be interrupted.

If neither effect succeeds, the function will fail with a `Cause`
containing all the errors.

**When to Use**

This is useful when you want to run two effects concurrently, but only care
about the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effect.

**Handling Success or Failure with Either**

If you want to handle the result of whichever task completes first, whether
it succeeds or fails, you can use the `Effect.either` function. This function
wraps the result in an `Either` type, allowing you to see if the result
was a success (`Right`) or a failure (`Left`).

**Example** (Both Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
// Output:
// task1 done
// task2 interrupted
```

**Example** (One Task Fails, One Succeeds)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
// Output:
// task2 done
```

**Example** (Both Tasks Fail)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Parallel',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
//   }
// }
```

**Example** (Handling Success or Failure with Either)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Effect.race(Effect.either(task1), Effect.either(task2))

Effect.runPromise(program).then(console.log)
// Output:
// task2 interrupted
// { _id: 'Either', _tag: 'Left', left: 'task1' }
```

**See**

- `raceAll` for a version that handles multiple effects.
- `raceFirst` for a version that returns the result of the first effect to complete.

**Signature**

```ts
declare const race: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9108)

Since v2.0.0
Effect-raceAll.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.raceAll

Races multiple effects and returns the first successful result.

**Details**

This function runs multiple effects concurrently and returns the result of
the first one to succeed. If one effect succeeds, the others will be
interrupted.

If none of the effects succeed, the function will fail with the last error
encountered.

**When to Use**

This is useful when you want to race multiple effects, but only care about
the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effects.

**Example** (All Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)
// Output:
// task1 done
// task2 interrupted
// task3 interrupted
```

**Example** (One Task Fails, Two Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)
// Output:
// task3 done
// task2 interrupted
```

**Example** (All Tasks Fail)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.fail("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
// }
```

**See**

- `race` for a version that handles only two effects.

**Signature**

```ts
declare const raceAll: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9231)

Since v2.0.0
Effect-raceFirst.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.raceFirst

Races two effects and returns the result of the first one to complete.

**Details**

This function takes two effects and runs them concurrently, returning the
result of the first one that completes, regardless of whether it succeeds or
fails.

**When to Use**

This function is useful when you want to race two operations, and you want to
proceed with whichever one finishes first, regardless of whether it succeeds
or fails.

**Disconnecting Effects**

The `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.

If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:

```ts
Effect.raceFirst(task1, task2)
```

You can use:

```ts
Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))
```

This allows both effects to complete independently while still terminating the losing effect in the background.

**Example** (Both Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// task2 interrupted
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
```

**Example** (One Task Fails, One Succeeds)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task2 interrupted
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }
// }
```

**Example** (Using Effect.disconnect for Quicker Return)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

// Race the two tasks with disconnect to allow quicker return
const program = Effect.raceFirst(
  Effect.disconnect(task1),
  Effect.disconnect(task2)
).pipe(Effect.tap(Console.log("more work...")))

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
// task2 interrupted
```

**Signature**

```ts
declare const raceFirst: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9371)

Since v2.0.0
Effect-raceWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.raceWith

Races two effects and calls a finisher when the first one completes.

**Details**

This function runs two effects concurrently and calls a specified finisher
function once one of the effects completes, regardless of whether it succeeds
or fails.

The finisher functions for each effect allow you to handle the results of
each effect as soon as they complete.

The function takes two finisher callbacks, one for each effect, and allows
you to specify how to handle the result of the race.

**When to Use**

This function is useful when you need to react to the completion of either
effect without waiting for both to finish. It can be used whenever you want
to take action based on the first available result.

**Example** (Handling Results of Concurrent Tasks)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceWith(task1, task2, {
  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),
  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)
})

Effect.runFork(program)
// Output:
// task1 done
// task1 exited with {
//   "_id": "Exit",
//   "_tag": "Success",
//   "value": "task1"
// }
// task2 interrupted
```

**Signature**

```ts
declare const raceWith: { <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>; <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9436)

Since v2.0.0
Effect-random.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.random

Retrieves the `Random` service from the context.

**Signature**

```ts
declare const random: Effect<Random.Random, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11562)

Since v2.0.0
Effect-randomWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.randomWith

Retrieves the `Random` service from the context and uses it to run the
specified effect.

**Signature**

```ts
declare const randomWith: <A, E, R>(f: (random: Random.Random) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11571)

Since v2.0.0
Effect-reduce.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.reduce

Reduces an `Iterable<A>` using an effectual function `f`, working
sequentially from left to right.

**Details**

This function takes an iterable and applies a function `f` to each element in
the iterable. The function works sequentially, starting with an initial value
`zero` and then combining it with each element in the collection. The
provided function `f` is called for each element in the iterable, allowing
you to accumulate a result based on the current value and the element being
processed.

**When to Use**

The function is often used for operations like summing a collection of
numbers or combining results from multiple tasks. It ensures that operations
are performed one after the other, maintaining the order of the elements.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduce(
  [1, 2, 3, 4],
  0,
  (acc, id, i) =>
    processOrder(id)
      .pipe(Effect.map((order) => acc + order.price))
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000
```

**See**

- `reduceWhile` for a similar function that stops the process based on a predicate.
- `reduceRight` for a similar function that works from right to left.

**Signature**

```ts
declare const reduce: { <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1873)

Since v2.0.0
Effect-reduceEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.reduceEffect

Reduces an `Iterable<Effect<A, E, R>>` to a single effect.

**Details**

This function processes a collection of effects and combines them into one
single effect. It starts with an initial effect (`zero`) and applies a
function `f` to each element in the collection.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceEffect(
  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],
  Effect.succeed(0),
  (acc, order, i) => acc + order.price
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000
```

**Signature**

```ts
declare const reduceEffect: { <Z, E, R, Eff extends Effect<any, any, any>>(zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z, E, R>(elements: Iterable<Eff>, zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2039)

Since v2.0.0
Effect-reduceRight.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.reduceRight

Reduces an `Iterable<A>` using an effectual function `f`, working
sequentially from right to left.

**Details**

This function takes an iterable and applies a function `f` to each element in
the iterable. The function works sequentially, starting with an initial value
`zero` and then combining it with each element in the collection. The
provided function `f` is called for each element in the iterable, allowing
you to accumulate a result based on the current value and the element being
processed.

**When to Use**

The function is often used for operations like summing a collection of
numbers or combining results from multiple tasks. It ensures that operations
are performed one after the other, maintaining the order of the elements.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceRight(
  [1, 2, 3, 4],
  0,
  (id, acc, i) =>
    processOrder(id)
      .pipe(Effect.map((order) => acc + order.price))
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 4 processed
// Order 3 processed
// Order 2 processed
// Order 1 processed
// 1000
```

**See**

- `reduce` for a similar function that works from left to right.

**Signature**

```ts
declare const reduceRight: { <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1991)

Since v2.0.0
Effect-reduceWhile.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.reduceWhile

Reduces an `Iterable<A>` using an effectual function `body`, working
sequentially from left to right, stopping the process early when the
predicate `while` is not satisfied.

**Details**

This function processes a collection of elements, applying a function `body`
to reduce them to a single value, starting from the first element. It checks
the value of the accumulator against a predicate (`while`). If at any point
the predicate returns `false`, the reduction stops, and the accumulated
result is returned.

**When to Use**

Use this function when you need to reduce a collection of elements, but only
continue the process as long as a certain condition holds true. For example,
if you want to sum values in a list but stop as soon as the sum exceeds a
certain threshold, you can use this function.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceWhile(
  [1, 2, 3, 4],
  0,
  {
    body: (acc, id, i) =>
      processOrder(id)
        .pipe(Effect.map((order) => acc + order.price)),
    while: (acc) => acc < 500
  }
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// 600
```

**Signature**

```ts
declare const reduceWhile: { <Z, A, E, R>(zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): Effect<Z, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1929)

Since v2.0.0
Effect-repeat.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.repeat

Repeats an effect based on a specified schedule or until the first failure.

**Details**

This function executes an effect repeatedly according to the given schedule.
Each repetition occurs after the initial execution of the effect, meaning
that the schedule determines the number of additional repetitions. For
example, using `Schedule.once` will result in the effect being executed twice
(once initially and once as part of the repetition).

If the effect succeeds, it is repeated according to the schedule. If it
fails, the repetition stops immediately, and the failure is returned.

The schedule can also specify delays between repetitions, making it useful
for tasks like retrying operations with backoff, periodic execution, or
performing a series of dependent actions.

You can combine schedules for more advanced repetition logic, such as adding
delays, limiting recursions, or dynamically adjusting based on the outcome of
each execution.

**Example** (Success Example)

```ts
import { Effect, Schedule, Console } from "effect"

const action = Console.log("success")
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

**Example** (Failure Example)

```ts
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

Effect.runPromiseExit(program).then(console.log)
```

**Signature**

```ts
declare const repeat: { <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Repeat.Return<R, E, A, O>; <B, A, R1>(schedule: Schedule.Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R1>): Effect<B, E, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10189)

Since v2.0.0
Effect-repeatN.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.repeatN

Repeats an effect a specified number of times or until the first failure.

**Details**

This function executes an effect initially and then repeats it the specified
number of times, as long as it succeeds. For example, calling
`repeatN(action, 2)` will execute `action` once initially and then repeat it
two additional times if there are no failures.

If the effect fails during any repetition, the failure is returned, and no
further repetitions are attempted.

**When to Use**

This function is useful for tasks that need to be retried a fixed number of
times or for performing repeated actions without requiring a schedule.

**Example**

```ts
import { Effect, Console } from "effect"

const action = Console.log("success")
const program = Effect.repeatN(action, 2)

Effect.runPromise(program)
```

**Signature**

```ts
declare const repeatN: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10237)

Since v2.0.0
Effect-repeatOrElse.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.repeatOrElse

Repeats an effect with a schedule, handling failures using a custom handler.

**Details**

This function allows you to execute an effect repeatedly based on a specified
schedule. If the effect fails at any point, a custom failure handler is
invoked. The handler is provided with both the failure value and the output
of the schedule at the time of failure. This enables advanced error recovery
or alternative fallback logic while maintaining flexibility in how
repetitions are handled.

For example, using a schedule with `recurs(2)` will allow for two additional
repetitions after the initial execution, provided the effect succeeds. If a
failure occurs during any iteration, the failure handler is invoked to handle
the situation.

**Example**

```ts
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(
  Schedule.recurs(2), // Repeat for a maximum of 2 times
  () => "100 millis" // Add a delay of 100 milliseconds between repetitions
)

const program = Effect.repeatOrElse(action, policy, () =>
  Effect.sync(() => {
    console.log("orElse")
    return count - 1
  })
)

Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

**Signature**

```ts
declare const repeatOrElse: { <R2, A, B, E, E2, R3>(schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10296)

Since v2.0.0
Effect-replicate.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.replicate

Replicates the given effect `n` times.

**Details**

This function takes an effect and replicates it a specified number of times
(`n`). The result is an array of `n` effects, each of which is identical to
the original effect.

**Example**

```ts
import { Console, Effect } from "effect"

const task = Effect.succeed("Hello, World!").pipe(
  Effect.tap(Console.log)
)

const program = Effect.gen(function*() {
  // Replicate the task 3 times
  const tasks = Effect.replicate(task, 3)
  for (const t of tasks) {
    // Run each task
    yield* t
  }
})

Effect.runFork(program)
// Output:
// Hello, World!
// Hello, World!
// Hello, World!
```

**Signature**

```ts
declare const replicate: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>; <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2101)

Since v2.0.0
Effect-replicateEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.replicateEffect

Performs this effect the specified number of times and collects the results.

**Details**

This function repeats an effect multiple times and collects the results into
an array. You specify how many times to execute the effect, and it runs that
many times, either in sequence or concurrently depending on the provided
options.

**Options**

If the `discard` option is set to `true`, the intermediate results are not
collected, and the final result of the operation is `void`.

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Console, Effect } from "effect"

let counter = 0

const task = Effect.sync(() => ++counter).pipe(
  Effect.tap(() => Console.log(`Task completed`))
)

const program = Effect.gen(function*() {
  // Replicate the task 3 times and collect the results
  const results = yield* Effect.replicateEffect(task, 3)
  yield* Console.log(`Results: ${results.join(", ")}`)
})

Effect.runFork(program)
// Output:
// Task completed
// Task completed
// Task completed
// Results: 1, 2, 3
```

**Signature**

```ts
declare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<Array<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2154)

Since v2.0.0
Effect-retry.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.retry

Retries a failing effect based on a defined retry policy.

**Details**

The `Effect.retry` function takes an effect and a `Schedule` policy,
and will automatically retry the effect if it fails, following the rules of
the policy.

If the effect ultimately succeeds, the result will be returned.

If the maximum retries are exhausted and the effect still fails, the failure
is propagated.

**When to Use**

This can be useful when dealing with intermittent failures, such as network
issues or temporary resource unavailability. By defining a retry policy, you
can control the number of retries, the delay between them, and when to stop
retrying.

**Example** (Retrying with a Fixed Delay)

```ts
import { Effect, Schedule } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Define a repetition policy using a fixed delay between retries
const policy = Schedule.fixed("100 millis")

const repeated = Effect.retry(task, policy)

Effect.runPromise(repeated).then(console.log)
// Output:
// failure
// failure
// failure
// success
// yay!
```

**Example** (Retrying a Task up to 5 times)

```ts
import { Effect } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task up to 5 times
Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)
// Output:
// failure
// failure
// failure
// success
```

**Example** (Retrying Until a Specific Condition is Met)

```ts
import { Effect } from "effect"

let count = 0

// Define an effect that simulates varying error on each invocation
const action = Effect.failSync(() => {
  console.log(`Action called ${++count} time(s)`)
  return `Error ${count}`
})

// Retry the action until a specific condition is met
const program = Effect.retry(action, {
  until: (err) => err === "Error 3"
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// Action called 1 time(s)
// Action called 2 time(s)
// Action called 3 time(s)
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }
// }
```

**See**

- `retryOrElse` for a version that allows you to run a fallback.
- `repeat` if your retry condition is based on successful outcomes rather than errors.

**Signature**

```ts
declare const retry: { <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>; <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule.Schedule<B, NoInfer<E>, R1>): Effect<A, E, R1 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4407)

Since v2.0.0
Effect-retryOrElse.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.retryOrElse

Retries a failing effect and runs a fallback effect if retries are exhausted.

**Details**

The `Effect.retryOrElse` function attempts to retry a failing effect multiple
times according to a defined `Schedule` policy.

If the retries are exhausted and the effect still fails, it runs a fallback
effect instead.

**When to Use**

This function is useful when you want to handle failures gracefully by
specifying an alternative action after repeated failures.

**Example** (Retrying with Fallback)

```ts
import { Effect, Schedule, Console } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task with a delay between retries and a maximum of 2 retries
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")

// If all retries fail, run the fallback effect
const repeated = Effect.retryOrElse(
  task,
  policy,
  // fallback
  () => Console.log("orElse").pipe(Effect.as("default value"))
)

Effect.runPromise(repeated).then(console.log)
// Output:
// failure
// failure
// failure
// orElse
// default value
```

**See**

- `retry` for a version that does not run a fallback effect.

**Signature**

```ts
declare const retryOrElse: { <A1, E, R1, A2, E2, R2>(policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4497)

Since v2.0.0
Effect-runCallback.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.runCallback

Executes an effect asynchronously and handles the result using a callback.

**Details**

This function runs an effect asynchronously and passes the result (`Exit`) to
a specified callback. The callback is invoked with the outcome of the effect:
- On success, the callback receives the successful result.
- On failure, the callback receives the failure information.

**When to Use**

This function is effectful and should only be invoked at the edges of your
program.

**Signature**

```ts
declare const runCallback: <A, E>(effect: Effect<A, E>, options?: Runtime.RunCallbackOptions<A, E> | undefined) => Runtime.Cancel<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12066)

Since v2.0.0
Effect-runFork.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.runFork

Runs an effect in the background, returning a fiber that can be observed or
interrupted.

Unless you specifically need a `Promise` or synchronous operation, `runFork`
is a good default choice.

**Details**

This function is the foundational way to execute an effect in the background.
It creates a "fiber," a lightweight, cooperative thread of execution that can
be observed (to access its result), interrupted, or joined. Fibers are useful
for concurrent programming and allow effects to run independently of the main
program flow.

Once the effect is running in a fiber, you can monitor its progress, cancel
it if necessary, or retrieve its result when it completes. If the effect
fails, the fiber will propagate the failure, which you can observe and
handle.

**When to Use**

Use this function when you need to run an effect in the background,
especially if the effect is long-running or performs periodic tasks. It's
suitable for tasks that need to run independently but might still need
observation or management, like logging, monitoring, or scheduled tasks.

This function is ideal if you don't need the result immediately or if the
effect is part of a larger concurrent workflow.

**Example** (Running an Effect in the Background)

```ts
import { Effect, Console, Schedule, Fiber } from "effect"

//       Effect<number, never, never>
//      
const program = Effect.repeat(
  Console.log("running..."),
  Schedule.spaced("200 millis")
)

//       RuntimeFiber<number, never>
//      
const fiber = Effect.runFork(program)

setTimeout(() => {
  Effect.runFork(Fiber.interrupt(fiber))
}, 500)
```

**Signature**

```ts
declare const runFork: <A, E>(effect: Effect<A, E>, options?: Runtime.RunForkOptions) => Fiber.RuntimeFiber<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12043)

Since v2.0.0
Effect-runPromise.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.runPromise

Executes an effect and returns the result as a `Promise`.

**Details**

This function runs an effect and converts its result into a `Promise`. If the
effect succeeds, the `Promise` will resolve with the successful result. If
the effect fails, the `Promise` will reject with an error, which includes the
failure details of the effect.

The optional `options` parameter allows you to pass an `AbortSignal` for
cancellation, enabling more fine-grained control over asynchronous tasks.

**When to Use**

Use this function when you need to execute an effect and work with its result
in a promise-based system, such as when integrating with third-party
libraries that expect `Promise` results.

**Example** (Running a Successful Effect as a Promise)

```ts
import { Effect } from "effect"

Effect.runPromise(Effect.succeed(1)).then(console.log)
// Output: 1
```

**Example** (Handling a Failing Effect as a Rejected Promise)

```ts
import { Effect } from "effect"

Effect.runPromise(Effect.fail("my error")).catch(console.error)
// Output:
// (FiberFailure) Error: my error
```

**See**

- `runPromiseExit` for a version that returns an `Exit` type instead
of rejecting.

**Signature**

```ts
declare const runPromise: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12115)

Since v2.0.0
Effect-runPromiseExit.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.runPromiseExit

Runs an effect and returns a `Promise` that resolves to an `Exit`,
representing the outcome.

**Details**

This function executes an effect and resolves to an `Exit` object. The `Exit`
type provides detailed information about the result of the effect:
- If the effect succeeds, the `Exit` will be of type `Success` and include
  the value produced by the effect.
- If the effect fails, the `Exit` will be of type `Failure` and contain a
  `Cause` object, detailing the failure.

Using this function allows you to examine both successful results and failure
cases in a unified way, while still leveraging `Promise` for handling the
asynchronous behavior of the effect.

**When to Use**

Use this function when you need to understand the outcome of an effect,
whether it succeeded or failed, and want to work with this result using
`Promise` syntax. This is particularly useful when integrating with systems
that rely on promises but need more detailed error handling than a simple
rejection.

**Example** (Handling Results as Exit)

```ts
import { Effect } from "effect"

// Execute a successful effect and get the Exit result as a Promise
Effect.runPromiseExit(Effect.succeed(1)).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

// Execute a failing effect and get the Exit result as a Promise
Effect.runPromiseExit(Effect.fail("my error")).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }
```

**Signature**

```ts
declare const runPromiseExit: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12176)

Since v2.0.0
Effect-runSync.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.runSync

Executes an effect synchronously, running it immediately and returning the
result.

**Details**

This function evaluates the provided effect synchronously, returning its
result directly. It is ideal for effects that do not fail or include
asynchronous operations. If the effect does fail or involves async tasks, it
will throw an error. Execution stops at the point of failure or asynchronous
operation, making it unsuitable for effects that require asynchronous
handling.

**Important**: Attempting to run effects that involve asynchronous operations
or failures will result in exceptions being thrown, so use this function with
care for purely synchronous and error-free effects.

**When to Use**

Use this function when:
- You are sure that the effect will not fail or involve asynchronous
  operations.
- You need a direct, synchronous result from the effect.
- You are working within a context where asynchronous effects are not
  allowed.

Avoid using this function for effects that can fail or require asynchronous
handling. For such cases, consider using `runPromise` or
`runSyncExit`.

**Example** (Synchronous Logging)

```ts
import { Effect } from "effect"

const program = Effect.sync(() => {
  console.log("Hello, World!")
  return 1
})

const result = Effect.runSync(program)
// Output: Hello, World!

console.log(result)
// Output: 1
```

**Example** (Incorrect Usage with Failing or Async Effects)

```ts
import { Effect } from "effect"

try {
  // Attempt to run an effect that fails
  Effect.runSync(Effect.fail("my error"))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) Error: my error

try {
  // Attempt to run an effect that involves async work
  Effect.runSync(Effect.promise(() => Promise.resolve(1)))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work
```

**See**

- `runSyncExit` for a version that returns an `Exit` type instead of
throwing an error.

**Signature**

```ts
declare const runSync: <A, E>(effect: Effect<A, E>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12258)

Since v2.0.0
Effect-runSyncExit.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.runSyncExit

Runs an effect synchronously and returns the result as an `Exit` type.

**Details**

This function executes the provided effect synchronously and returns an `Exit`
type that encapsulates the outcome of the effect:
- If the effect succeeds, the result is wrapped in a `Success`.
- If the effect fails, it returns a `Failure` containing a `Cause` that explains
  the failure.

If the effect involves asynchronous operations, this function will return a `Failure`
with a `Die` cause, indicating that it cannot resolve the effect synchronously.
This makes the function suitable for use only with effects that are synchronous
in nature.

**When to Use**

Use this function when:
- You want to handle both success and failure outcomes in a structured way using the `Exit` type.
- You are working with effects that are purely synchronous and do not involve asynchronous operations.
- You need to debug or inspect failures, including their causes, in a detailed manner.

Avoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.

**Example** (Handling Results as Exit)

```ts
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.succeed(1)))
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

console.log(Effect.runSyncExit(Effect.fail("my error")))
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }
```

**Example** (Asynchronous Operation Resulting in Die)

```ts
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
//       fiber: [FiberRuntime],
//       _tag: 'AsyncFiberException',
//       name: 'AsyncFiberException'
//     }
//   }
// }
```

**Signature**

```ts
declare const runSyncExit: <A, E>(effect: Effect<A, E>) => Exit.Exit<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12336)

Since v2.0.0
Effect-runtime.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.runtime

Returns an effect that accesses the runtime, which can be used to (unsafely)
execute tasks.

**When to Use**

This is useful for integration with legacy code that must call back into
Effect code.

**Signature**

```ts
declare const runtime: <R = never>() => Effect<Runtime.Runtime<R>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11608)

Since v2.0.0
Effect-sandbox.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.sandbox

Transforms an effect to expose detailed error causes.

**Details**

This function enhances an effect by providing detailed information about any
error, defect, or interruption that may occur during its execution. It
modifies the error channel of the effect so that it includes a full cause of
the failure, wrapped in a `Cause<E>` type.

After applying this function, you can use operators like `catchAll` and
`catchTags` to handle specific types of errors.

If you no longer need the detailed cause information, you can revert the
changes using `unsandbox` to return to the original error-handling
behavior.

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<string, Error, never>
//      
const task = Effect.fail(new Error("Oh uh!")).pipe(
  Effect.as("primary result")
)

//       Effect<string, Cause<Error>, never>
//      
const sandboxed = Effect.sandbox(task)

const program = Effect.catchTags(sandboxed, {
  Die: (cause) =>
    Console.log(`Caught a defect: ${cause.defect}`).pipe(
      Effect.as("fallback result on defect")
    ),
  Interrupt: (cause) =>
    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(
      Effect.as("fallback result on fiber interruption")
    ),
  Fail: (cause) =>
    Console.log(`Caught a defect: ${cause.error}`).pipe(
      Effect.as("fallback result on failure")
    )
})

// Restore the original error handling with unsandbox
const main = Effect.unsandbox(program)

Effect.runPromise(main).then(console.log)
// Output:
// Caught a defect: Oh uh!
// fallback result on failure
```

**See**

- `unsandbox` to restore the original error handling.

**Signature**

```ts
declare const sandbox: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause.Cause<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4253)

Since v2.0.0
Effect-schedule.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.schedule

Repeats an effect based on a specified schedule.

**Details**

This function allows you to execute an effect repeatedly according to a given
schedule. The schedule determines the timing and number of repetitions. Each
repetition can also depend on the decision of the schedule, providing
flexibility for complex workflows. This function does not modify the effect's
success or failure; it only controls its repetition.

For example, you can use a schedule that recurs a specific number of times,
adds delays between repetitions, or customizes repetition behavior based on
external inputs. The effect runs initially and is repeated according to the
schedule.

**See**

- `scheduleFrom` for a variant that allows the schedule's decision
to depend on the result of this effect.

**Signature**

```ts
declare const schedule: { <A, R2, Out>(schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>; <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, A | undefined, R2>): Effect<Out, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10330)

Since v2.0.0
Effect-scheduleForked.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.scheduleForked

Runs an effect repeatedly on a new fiber according to a given schedule.

**Details**

This function starts the provided effect on a new fiber and runs it
repeatedly based on the specified schedule. The repetitions are managed by
the schedule's rules, which define the timing and number of iterations. The
fiber is attached to the current scope, meaning it is automatically managed
and cleaned up when the scope is closed.

The function returns a `RuntimeFiber` that allows you to monitor or interact
with the running fiber.

**When to Use**

This is particularly useful for concurrent execution of scheduled tasks or
when you want to continue processing without waiting for the repetitions to
complete.

**Signature**

```ts
declare const scheduleForked: { <Out, R2>(schedule: Schedule.Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R2 | R>; <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, unknown, R2>): Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10363)

Since v2.0.0
Effect-scheduleFrom.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.scheduleFrom

Runs an effect repeatedly according to a schedule, starting from a specified
input value.

**Details**

This function allows you to repeatedly execute an effect based on a schedule.
The schedule starts with the given `initial` input value, which is passed to
the first execution. Subsequent executions of the effect are controlled by
the schedule's rules, using the output of the previous iteration as the input
for the next one.

The returned effect will complete when the schedule ends or the effect fails,
propagating the error.

**Signature**

```ts
declare const scheduleFrom: { <R2, In, Out>(initial: In, schedule: Schedule.Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>; <In, E, R, R2, Out>(self: Effect<In, E, R>, initial: In, schedule: Schedule.Schedule<Out, In, R2>): Effect<Out, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10391)

Since v2.0.0
Effect-scope.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.scope

Provides access to the current scope in a scoped workflow.

**Signature**

```ts
declare const scope: Effect<Scope.Scope, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6025)

Since v2.0.0
Effect-scopeWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.scopeWith

Accesses the current scope and uses it to perform the specified effect.

**Signature**

```ts
declare const scopeWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R | Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6033)

Since v2.0.0
Effect-scoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.scoped

Scopes all resources used in an effect to the lifetime of the effect.

**Details**

This function ensures that all resources used within an effect are tied to
its lifetime. Finalizers for these resources are executed automatically when
the effect completes, whether through success, failure, or interruption. This
guarantees proper resource cleanup without requiring explicit management.

**Signature**

```ts
declare const scoped: <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6060)

Since v2.0.0
Effect-scopedWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.scopedWith

Creates a `Scope`, passes it to the specified effectful function, and closes
the scope when the effect completes (whether through success, failure, or
interruption).

**Signature**

```ts
declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6044)

Since v3.11.0
Effect-sequentialFinalizers.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.sequentialFinalizers

Ensures that finalizers are run sequentially in reverse order of their
addition.

**Details**

This function modifies the behavior of finalizers within a scoped workflow to
ensure they are run sequentially in reverse order when the scope is closed.

By default, finalizers are executed sequentially, so this only changes the
behavior if the scope is configured to run finalizers concurrently.

**See**

- `parallelFinalizers` for a version that ensures finalizers are run concurrently.

**Signature**

```ts
declare const sequentialFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5995)

Since v2.0.0
Effect-serviceFunction.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.serviceFunction

Creates a function that uses a service from the context to produce a value.

**See**

- `serviceFunctionEffect` for a version that returns an effect.

**Signature**

```ts
declare const serviceFunction: <T extends Effect<any, any, any>, Args extends Array<any>, A>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => A) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7686)

Since v2.0.0
Effect-Tag.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.Tag

Creates a unique tag for a dependency, embedding the service's methods as
static properties.

**Details**

This function allows you to define a `Tag` for a service or dependency in
your application. The `Tag` not only acts as an identifier but also provides
direct access to the service's methods via static properties. This makes it
easier to access and use the service in your code without manually managing
contexts.

In the example below, the fields of the service (in this case, the `notify`
method) are turned into static properties of the Notifications class, making
it easier to access them.

**Example**

```ts
import { Effect } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {}

// Create an effect that depends on the Notifications service
const action = Notifications.notify("Hello, world!")
```

**Signature**

```ts
declare const Tag: <const Id extends string>(id: Id) => <Self, Type extends Tag.AllowedType>() => Context.TagClass<Self, Id, Type> & (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {}) & { use: <X>(body: (_: Type) => X) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, R | Self> : [X] extends [PromiseLike<infer A>] ? Effect<A, Cause.UnknownException, Self> : Effect<X, never, Self>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13471)

Since v2.0.0
Effect-serviceFunctionEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.serviceFunctionEffect

Creates a function that uses a service from the context to produce an effect.

**See**

- `serviceFunction` for a version that returns a value.

**Signature**

```ts
declare const serviceFunctionEffect: <T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7699)

Since v2.0.0
Effect-serviceOption.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.serviceOption

Retrieves an optional service from the context as an `Option`.

**Details**

This function retrieves a service from the context and wraps it in an
`Option`. If the service is available, it returns a `Some` containing the
service. If the service is not found, it returns a `None`. This approach is
useful when you want to handle the absence of a service gracefully without
causing an error.

**When to Use**

Use this function when:
- You need to access a service that may or may not be present in the context.
- You want to handle the absence of a service using the `Option` type instead
  of throwing an error.

**See**

- `serviceOptional` for a version that throws an error if the service is missing.

**Signature**

```ts
declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Effect<Option.Option<S>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7768)

Since v2.0.0
Effect-serviceOptional.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.serviceOptional

Retrieves a service from the context, throwing an error if it is missing.

**Details**

This function retrieves a required service from the context. If the service
is available, it returns the service. If the service is missing, it throws a
`NoSuchElementException`, which can be handled using Effect's error-handling
mechanisms. This is useful for services that are critical to the execution of
your effect.

**See**

- `serviceOption` for a version that returns an `Option` instead of throwing an error.

**Signature**

```ts
declare const serviceOptional: <I, S>(tag: Context.Tag<I, S>) => Effect<S, Cause.NoSuchElementException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7786)

Since v2.0.0
Effect-setFiberRefs.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.setFiberRefs

Sets the `FiberRef` values for the fiber running this effect to the values
in the specified collection of `FiberRef` values.

**Signature**

```ts
declare const setFiberRefs: (fiberRefs: FiberRefs.FiberRefs) => Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10484)

Since v2.0.0
Effect-sleep.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.sleep

Suspends the execution of an effect for a specified `Duration`.

**Details**

This function pauses the execution of an effect for a given duration. It is
asynchronous, meaning that it does not block the fiber executing the effect.
Instead, the fiber is suspended during the delay period and can resume once
the specified time has passed.

The duration can be specified using various formats supported by the
`Duration` module, such as a string (`"2 seconds"`) or numeric value
representing milliseconds.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  console.log("Starting task...")
  yield* Effect.sleep("3 seconds") // Waits for 3 seconds
  console.log("Task completed!")
})

Effect.runFork(program)
// Output:
// Starting task...
// Task completed!
```

**Signature**

```ts
declare const sleep: (duration: Duration.DurationInput) => Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6910)

Since v2.0.0
Effect-succeed.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.succeed

Creates an `Effect` that always succeeds with a given value.

**When to Use**

Use this function when you need an effect that completes successfully with a
specific value without any errors or external dependencies.

**Example** (Creating a Successful Effect)

```ts
import { Effect } from "effect"

// Creating an effect that represents a successful scenario
//
//       Effect<number, never, never>
//      
const success = Effect.succeed(42)
```

**See**

- `fail` to create an effect that represents a failure.

**Signature**

```ts
declare const succeed: <A>(value: A) => Effect<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3160)

Since v2.0.0
Effect-succeedNone.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.succeedNone

Returns an effect which succeeds with `None`.

**When to Use**

Use this function when you need to represent the absence of a value in your
code, especially when working with optional data. This can be helpful when
you want to indicate that no result is available without throwing an error or
performing additional logic.

**See**

- `succeedSome` to create an effect that succeeds with a `Some` value.

**Signature**

```ts
declare const succeedNone: Effect<Option.Option<never>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3177)

Since v2.0.0
Effect-succeedSome.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.succeedSome

Returns an effect which succeeds with the value wrapped in a `Some`.

**See**

- `succeedNone` for a similar function that returns `None` when the value is absent.

**Signature**

```ts
declare const succeedSome: <A>(value: A) => Effect<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3187)

Since v2.0.0
Effect-summarized.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.summarized

Summarizes a effect by computing some value before and after execution, and
then combining the values to produce a summary, together with the result of
execution.

**Signature**

```ts
declare const summarized: { <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Effect<A, E, R>, summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): Effect<[C, A], E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9462)

Since v2.0.0
Effect-supervised.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.supervised

Supervises child fibers by reporting them to a specified supervisor.

**Details**

This function takes a supervisor as an argument and returns an effect where
all child fibers forked within it are supervised by the provided supervisor.
This enables you to capture detailed information about these child fibers,
such as their status, through the supervisor.

**Example** (Monitoring Fiber Count)

```ts
import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"

// Main program that monitors fibers while calculating a Fibonacci number
const program = Effect.gen(function* () {
  // Create a supervisor to track child fibers
  const supervisor = yield* Supervisor.track

  // Start a Fibonacci calculation, supervised by the supervisor
  const fibFiber = yield* fib(20).pipe(
    Effect.supervised(supervisor),
    // Fork the Fibonacci effect into a fiber
    Effect.fork
  )

  // Define a schedule to periodically monitor the fiber count every 500ms
  const policy = Schedule.spaced("500 millis").pipe(
    Schedule.whileInputEffect((_) =>
      Fiber.status(fibFiber).pipe(
        // Continue while the Fibonacci fiber is not done
        Effect.andThen((status) => status !== FiberStatus.done)
      )
    )
  )

  // Start monitoring the fibers, using the supervisor to track the count
  const monitorFiber = yield* monitorFibers(supervisor).pipe(
    // Repeat the monitoring according to the schedule
    Effect.repeat(policy),
    // Fork the monitoring into its own fiber
    Effect.fork
  )

  // Join the monitor and Fibonacci fibers to ensure they complete
  yield* Fiber.join(monitorFiber)
  const result = yield* Fiber.join(fibFiber)

  console.log(`fibonacci result: ${result}`)
})

// Function to monitor and log the number of active fibers
const monitorFibers = (
  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>
): Effect.Effect<void> =>
  Effect.gen(function* () {
    const fibers = yield* supervisor.value // Get the current set of fibers
    console.log(`number of fibers: ${fibers.length}`)
  })

// Recursive Fibonacci calculation, spawning fibers for each recursive step
const fib = (n: number): Effect.Effect<number> =>
  Effect.gen(function* () {
    if (n <= 1) {
      return 1
    }
    yield* Effect.sleep("500 millis") // Simulate work by delaying

    // Fork two fibers for the recursive Fibonacci calls
    const fiber1 = yield* Effect.fork(fib(n - 2))
    const fiber2 = yield* Effect.fork(fib(n - 1))

    // Join the fibers to retrieve their results
    const v1 = yield* Fiber.join(fiber1)
    const v2 = yield* Fiber.join(fiber2)

    return v1 + v2 // Combine the results
  })

Effect.runPromise(program)
// Output:
// number of fibers: 0
// number of fibers: 2
// number of fibers: 6
// number of fibers: 14
// number of fibers: 30
// number of fibers: 62
// number of fibers: 126
// number of fibers: 254
// number of fibers: 510
// number of fibers: 1022
// number of fibers: 2034
// number of fibers: 3795
// number of fibers: 5810
// number of fibers: 6474
// number of fibers: 4942
// number of fibers: 2515
// number of fibers: 832
// number of fibers: 170
// number of fibers: 18
// number of fibers: 0
// fibonacci result: 10946
```

**Signature**

```ts
declare const supervised: { <X>(supervisor: Supervisor.Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6663)

Since v2.0.0
Effect-suspend.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.suspend

Delays the creation of an `Effect` until it is actually needed.

**Details**

The `Effect.suspend` function takes a thunk that represents the effect and
wraps it in a suspended effect. This means the effect will not be created
until it is explicitly needed, which is helpful in various scenarios:
- **Lazy Evaluation**: Helps optimize performance by deferring computations,
  especially when the effect might not be needed, or when its computation is
  expensive. This also ensures that any side effects or scoped captures are
  re-executed on each invocation.
- **Handling Circular Dependencies**: Useful in managing circular
  dependencies, such as recursive functions that need to avoid eager
  evaluation to prevent stack overflow.
- **Unifying Return Types**: Can help TypeScript unify return types in
  situations where multiple branches of logic return different effects,
  simplifying type inference.

**When to Use**

Use this function when you need to defer the evaluation of an effect until it
is required. This is particularly useful for optimizing expensive
computations, managing circular dependencies, or resolving type inference
issues.

**Example** (Lazy Evaluation with Side Effects)

```ts
import { Effect } from "effect"

let i = 0

const bad = Effect.succeed(i++)

const good = Effect.suspend(() => Effect.succeed(i++))

console.log(Effect.runSync(bad)) // Output: 0
console.log(Effect.runSync(bad)) // Output: 0

console.log(Effect.runSync(good)) // Output: 1
console.log(Effect.runSync(good)) // Output: 2
```

**Example** (Recursive Fibonacci)

```ts
import { Effect } from "effect"

const blowsUp = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(1)
    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)

console.log(Effect.runSync(blowsUp(32)))
// crash: JavaScript heap out of memory

const allGood = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(1)
    : Effect.zipWith(
        Effect.suspend(() => allGood(n - 1)),
        Effect.suspend(() => allGood(n - 2)),
        (a, b) => a + b
      )

console.log(Effect.runSync(allGood(32)))
// Output: 3524578
```

**Example** (Using Effect.suspend to Help TypeScript Infer Types)

```ts
import { Effect } from "effect"

//   Without suspend, TypeScript may struggle with type inference.
//   Inferred type:
//     (a: number, b: number) =>
//       Effect<never, Error, never> | Effect<number, never, never>
const withoutSuspend = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//   Using suspend to unify return types.
//   Inferred type:
//     (a: number, b: number) => Effect<number, Error, never>
const withSuspend = (a: number, b: number) =>
  Effect.suspend(() =>
    b === 0
      ? Effect.fail(new Error("Cannot divide by zero"))
      : Effect.succeed(a / b)
  )
```

**Signature**

```ts
declare const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3287)

Since v2.0.0
Effect-sync.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.sync

Creates an `Effect` that represents a synchronous side-effectful computation.

**Details**

The provided function (`thunk`) must not throw errors; if it does, the error
will be treated as a "defect".

This defect is not a standard error but indicates a flaw in the logic that
was expected to be error-free. You can think of it similar to an unexpected
crash in the program, which can be further managed or logged using tools like
`catchAllDefect`.

**When to Use**

Use this function when you are sure the operation will not fail.

**Example** (Logging a Message)

```ts
import { Effect } from "effect"

const log = (message: string) =>
  Effect.sync(() => {
    console.log(message) // side effect
  })

//       Effect<void, never, never>
//      
const program = log("Hello, World!")
```

**See**

- `| try` for a version that can handle failures.

**Signature**

```ts
declare const sync: <A>(thunk: LazyArg<A>) => Effect<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3326)

Since v2.0.0
Effect-tagMetrics.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tagMetrics

Tags each metric in an effect with specific key-value pairs.

**Details**

This function allows you to tag all metrics in an effect with a set of
key-value pairs or a single key-value pair. Tags help you add metadata to
metrics, making it easier to filter and categorize them in monitoring
systems. The provided tags will apply to all metrics generated within the
effect's scope.

**Signature**

```ts
declare const tagMetrics: { (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11656)

Since v2.0.0
Effect-tagMetricsScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tagMetricsScoped

Tags metrics within a scope with a specific key-value pair.

**Details**

This function tags all metrics within a scope with the provided key-value
pair. Once the scope is closed, the tag is automatically removed. This is
useful for applying temporary context-specific tags to metrics during scoped
operations.

**Signature**

```ts
declare const tagMetricsScoped: (key: string, value: string) => Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11694)

Since v2.0.0
Effect-takeUntil.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.takeUntil

Takes elements from a collection until the effectful predicate returns
`true`.

**Details**

This function processes a collection of elements and uses an effectful
predicate to decide when to stop taking elements. The elements are taken from
the beginning of the collection until the predicate returns `true`.

The predicate is a function that takes an element and its index in the
collection, and returns an effect that resolves to a boolean.

Once the predicate returns `true`, the remaining elements of the collection
are discarded, and the function stops taking more elements.

**Note**: The first element for which the predicate returns `true` is also
included in the result.

**When to Use**

Use this function when you want to conditionally take elements from a
collection based on a dynamic condition. For example, you may want to collect
numbers from a list until a certain threshold is reached, or gather items
until a specific condition is met.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.takeUntil(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [ 1, 2, 3, 4 ]
```

**See**

- `takeWhile` for a similar function that takes elements while the
predicate returns `true`.

**Signature**

```ts
declare const takeUntil: { <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1197)

Since v2.0.0
Effect-takeWhile.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.takeWhile

Takes elements as long as the predicate returns `true`.

**Details**

This function processes a collection of elements and uses a predicate to
decide whether to take an element.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

As long as the predicate returns `true`, elements will continue to be taken
from the collection.

Once the predicate returns `false`, the remaining elements are discarded.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.takeWhile(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [1, 2, 3]
```

**See**

- `takeUntil` for a similar function that takes elements until the predicate returns `true`.

**Signature**

```ts
declare const takeWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1245)

Since v2.0.0
Effect-tap.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tap

Runs a side effect with the result of an effect without changing the original
value.

**Details**

This function works similarly to `flatMap`, but it ignores the result of the
function passed to it. The value from the previous effect remains available
for the next part of the chain. Note that if the side effect fails, the
entire chain will fail too.

**When to Use**

Use this function when you want to perform a side effect, like logging or
tracking, without modifying the main value. This is useful when you need to
observe or record an action but want the original value to be passed to the
next step.

**Example** (Logging a step in a pipeline)

```ts
import { Console, Effect, pipe } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  // Log the fetched transaction amount
  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),
  // `amount` is still available!
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
// Output:
// Apply a discount to: 100
// 95
```

**See**

- `flatMap` for a version that allows you to change the value.

**Signature**

```ts
declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9528)

Since v2.0.0
Effect-tapBoth.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tapBoth

Allows you to inspect both success and failure outcomes of an effect and
perform side effects for each.

**Details**

This function enables you to handle both success and failure cases
separately, without modifying the main effect's result. It is particularly
useful for scenarios where you need to log, monitor, or perform additional
actions depending on whether the effect succeeded or failed.

When the effect succeeds, the `onSuccess` handler is executed with the
success value. When the effect fails, the `onFailure` handler is executed
with the failure value. Both handlers can include side effects such as
logging or analytics, and neither modifies the original effect's output.

If either the success or failure handler fails, the overall effect will also
fail.

**Example**

```ts
import { Effect, Random, Console } from "effect"

// Simulate a task that might fail
const task = Effect.filterOrFail(
  Random.nextRange(-1, 1),
  (n) => n >= 0,
  () => "random number is negative"
)

// Use tapBoth to log both success and failure outcomes
const tapping = Effect.tapBoth(task, {
  onFailure: (error) => Console.log(`failure: ${error}`),
  onSuccess: (randomNumber) =>
    Console.log(`random number: ${randomNumber}`)
})

Effect.runFork(tapping)
// Example Output:
// failure: random number is negative
```

**Signature**

```ts
declare const tapBoth: { <E, X, E2, R2, A, X1, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X, E2, R2, X1, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3>; }): Effect<A, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9625)

Since v2.0.0
Effect-tapDefect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tapDefect

Inspect severe errors or defects (non-recoverable failures) in an effect.

**Details**

This function is specifically designed to handle and inspect defects, which
are critical failures in your program, such as unexpected runtime exceptions
or system-level errors. Unlike normal recoverable errors, defects typically
indicate serious issues that cannot be addressed through standard error
handling.

When a defect occurs in an effect, the function you provide to this function
will be executed, allowing you to log, monitor, or handle the defect in some
way. Importantly, this does not alter the main result of the effect. If no
defect occurs, the effect behaves as if this function was not used.

**Example**

```ts
import { Effect, Console } from "effect"

// Simulate a task that fails with a recoverable error
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

// tapDefect won't log anything because NetworkError is not a defect
const tapping1 = Effect.tapDefect(task1, (cause) =>
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping1)
// No Output

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage(
  "Something went wrong"
)

// Log the defect using tapDefect
const tapping2 = Effect.tapDefect(task2, (cause) =>
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping2)
// Output:
// defect: RuntimeException: Something went wrong
//   ... stack trace ...
```

**Signature**

```ts
declare const tapDefect: { <X, E2, R2>(f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9692)

Since v2.0.0
Effect-tapError.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tapError

Execute a side effect on failure without modifying the original effect.

**Details**

This function allows you to inspect and react to the failure of an effect by
executing an additional effect. The failure value is passed to the provided
function, enabling you to log it, track it, or perform any other operation.
Importantly, the original failure remains intact and is re-propagated, so the
effect's behavior is unchanged.

The side effect you provide is only executed when the effect fails. If the
effect succeeds, the function is ignored, and the success value is propagated
as usual.

**Example**

```ts
import { Effect, Console } from "effect"

// Simulate a task that fails with an error
const task: Effect.Effect<number, string> = Effect.fail("NetworkError")

// Use tapError to log the error message when the task fails
const tapping = Effect.tapError(task, (error) =>
  Console.log(`expected error: ${error}`)
)

Effect.runFork(tapping)
// Output:
// expected error: NetworkError
```

**Signature**

```ts
declare const tapError: { <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9738)

Since v2.0.0
Effect-tapErrorCause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tapErrorCause

Inspect the complete cause of an error, including failures and defects.

**Details**

This function provides access to the full cause of an error, including both
recoverable failures and irrecoverable defects. It allows you to handle, log,
or monitor specific error causes without modifying the result of the effect.
The full `Cause` object encapsulates the error and its contextual
information, making it useful for debugging and understanding failure
scenarios in complex workflows.

The effect itself is not modified, and any errors or defects remain in the
error channel of the original effect.

**Example**

```ts
import { Effect, Console } from "effect"

// Create a task that fails with a NetworkError
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

const tapping1 = Effect.tapErrorCause(task1, (cause) =>
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping1)
// Output:
// error cause: Error: NetworkError

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage(
  "Something went wrong"
)

const tapping2 = Effect.tapErrorCause(task2, (cause) =>
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping2)
// Output:
// error cause: RuntimeException: Something went wrong
//   ... stack trace ...
```

**Signature**

```ts
declare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9852)

Since v2.0.0
Effect-tapErrorTag.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tapErrorTag

Inspect errors matching a specific tag without altering the original effect.

**Details**

This function allows you to inspect and handle specific error types based on
their `_tag` property. It is particularly useful in applications where errors
are modeled with tagged types (e.g., union types with discriminating tags).
By targeting errors with a specific `_tag`, you can log or perform actions on
them while leaving the error channel and overall effect unchanged.

If the error doesn't match the specified tag, this function does nothing, and
the effect proceeds as usual.

**Example**

```ts
import { Effect, Console } from "effect"

class NetworkError {
  readonly _tag = "NetworkError"
  constructor(readonly statusCode: number) {}
}

class ValidationError {
  readonly _tag = "ValidationError"
  constructor(readonly field: string) {}
}

// Create a task that fails with a NetworkError
const task: Effect.Effect<number, NetworkError | ValidationError> =
  Effect.fail(new NetworkError(504))

// Use tapErrorTag to inspect only NetworkError types and log the status code
const tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>
  Console.log(`expected error: ${error.statusCode}`)
)

Effect.runFork(tapping)
// Output:
// expected error: 504
```

**Signature**

```ts
declare const tapErrorTag: { <K extends E extends { _tag: string; } ? E["_tag"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, A1, E1, R1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9791)

Since v2.0.0
Effect-timed.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.timed

Executes an effect and measures the time it takes to complete.

**Details**

This function wraps the provided effect and returns a new effect that, when
executed, performs the original effect and calculates its execution duration.

The result of the new effect includes both the execution time (as a
`Duration`) and the original effect's result. This is useful for monitoring
performance or gaining insights into the time taken by specific operations.

The original effect's behavior (success, failure, or interruption) remains
unchanged, and the timing information is provided alongside the result in a
tuple.

**Example**

```ts
import { Duration, Effect } from "effect"

const task = Effect.gen(function*() {
  yield* Effect.sleep("2 seconds") // Simulates some work
  return "some result"
})

const timedTask = task.pipe(Effect.timed)

const program = Effect.gen(function*() {
  const [duration, result] = yield* timedTask
  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)
})

Effect.runFork(program)
// Output: Task completed in 2003.749125 ms with result: some result
```

**Signature**

```ts
declare const timed: <A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration.Duration, result: A], E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6952)

Since v2.0.0
Effect-timedWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.timedWith

Executes an effect and measures its execution time using a custom clock.

**Details**

This function extends the functionality of `timed` by allowing you to
specify a custom clock for measuring the execution duration. The provided
effect (`nanoseconds`) represents the clock and should return the current
time in nanoseconds. The timing information is computed using this custom
clock instead of the default system clock.

**Signature**

```ts
declare const timedWith: { <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration.Duration, A], E1 | E, R1 | R>; <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration.Duration, A], E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6969)

Since v2.0.0
Effect-timeout.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.timeout

Adds a time limit to an effect, triggering a timeout if the effect exceeds
the duration.

**Details**

This function allows you to enforce a time limit on the execution of an
effect. If the effect does not complete within the given duration, it fails
with a `TimeoutException`. This is useful for preventing tasks from hanging
indefinitely, especially in scenarios where responsiveness or resource limits
are critical.

The returned effect will either:
- Succeed with the original effect's result if it completes within the
  specified duration.
- Fail with a `TimeoutException` if the time limit is exceeded.

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
```

**See**

- `timeoutFail` for a version that raises a custom error.
- `timeoutFailCause` for a version that raises a custom defect.
- `timeoutTo` for a version that allows specifying both success and
timeout handlers.

**Signature**

```ts
declare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutException, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, Cause.TimeoutException | E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7034)

Since v2.0.0
Effect-timeoutFail.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.timeoutFail

Specifies a custom error to be produced when a timeout occurs.

**Details**

This function allows you to handle timeouts in a customized way by defining a
specific error to be raised when an effect exceeds the given duration. Unlike
default timeout behaviors that use generic exceptions, this function gives
you the flexibility to specify a meaningful error type that aligns with your
application's needs.

When you apply this function, you provide:
- A `duration`: The time limit for the effect.
- An `onTimeout` function: A lazy evaluation function that generates the
  custom error if the timeout occurs.

If the effect completes within the time limit, its result is returned
normally. Otherwise, the `onTimeout` function is triggered, and its output is
used as the error for the effect.

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError {
  readonly _tag = "MyTimeoutError"
}

const program = task.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError() // Custom timeout error
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }
//   }
// }
```

**See**

- `timeout` for a version that raises a `TimeoutException`.
- `timeoutFailCause` for a version that raises a custom defect.
- `timeoutTo` for a version that allows specifying both success and
timeout handlers.

**Signature**

```ts
declare const timeoutFail: { <E1>(options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7165)

Since v2.0.0
Effect-timeoutFailCause.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.timeoutFailCause

Specifies a custom defect to be thrown when a timeout occurs.

**Details**

This function allows you to handle timeouts as exceptional cases by
generating a custom defect when an effect exceeds the specified duration. You
provide:
- A `duration`: The time limit for the effect.
- An `onTimeout` function: A lazy evaluation function that generates the
  custom defect (typically created using `Cause.die`).

If the effect completes within the time limit, its result is returned
normally. Otherwise, the custom defect is triggered, and the effect fails
with that defect.

**When to Use**

This is especially useful when you need to treat timeouts as critical
failures in your application and wish to include meaningful information in
the defect.

**Example**

```ts
import { Effect, Cause } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
// }
```

**See**

- `timeout` for a version that raises a `TimeoutException`.
- `timeoutFail` for a version that raises a custom error.
- `timeoutTo` for a version that allows specifying both success and
timeout handlers.

**Signature**

```ts
declare const timeoutFailCause: { <E1>(options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7234)

Since v2.0.0
Effect-timeoutOption.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.timeoutOption

Gracefully handles timeouts by returning an `Option` that represents either
the result or a timeout.

**Details**

This function wraps the outcome of an effect in an `Option` type. If the
effect completes within the specified duration, it returns a `Some`
containing the result. If the effect times out, it returns a `None`. Unlike
other timeout methods, this approach does not raise errors or exceptions;
instead, it allows you to treat timeouts as a regular outcome, simplifying
the logic for handling delays.

**When to Use**

This is useful when you want to handle timeouts without causing the program
to fail, making it easier to manage situations where you expect tasks might
take too long but want to continue executing other tasks.

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const timedOutEffect = Effect.all([
  task.pipe(Effect.timeoutOption("3 seconds")),
  task.pipe(Effect.timeoutOption("1 second"))
])

Effect.runPromise(timedOutEffect).then(console.log)
// Output:
// Start processing...
// Processing complete.
// Start processing...
// [
//   { _id: 'Option', _tag: 'Some', value: 'Result' },
//   { _id: 'Option', _tag: 'None' }
// ]
```

**See**

- `timeout` for a version that raises a `TimeoutException`.
- `timeoutFail` for a version that raises a custom error.
- `timeoutFailCause` for a version that raises a custom defect.
- `timeoutTo` for a version that allows specifying both success and
timeout handlers.

**Signature**

```ts
declare const timeoutOption: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7095)

Since v3.1.0
Effect-timeoutTo.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.timeoutTo

Provides custom behavior for successful and timed-out operations.

**Details**

This function allows you to define distinct outcomes for an effect depending
on whether it completes within a specified time frame or exceeds the timeout
duration. You can provide:
- `onSuccess`: A handler for processing the result of the effect if it
  completes successfully within the time limit.
- `onTimeout`: A handler for generating a result when the effect times out.
- `duration`: The maximum allowed time for the effect to complete.

**When to Use**

Unlike `timeout`, which raises an exception for timeouts, this function
gives you full control over the behavior for both success and timeout
scenarios. It is particularly useful when you want to encapsulate timeouts
and successes into a specific data structure, like an `Either` type, to
represent these outcomes in a meaningful way.

**Example**

```ts
import { Effect, Either } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutTo({
    duration: "1 second",
    onSuccess: (result): Either.Either<string, string> =>
      Either.right(result),
    onTimeout: (): Either.Either<string, string> =>
      Either.left("Timed out!")
  })
)

Effect.runPromise(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: "Either",
//   _tag: "Left",
//   left: "Timed out!"
// }
```

**See**

- `timeout` for a version that raises a `TimeoutException`.
- `timeoutFail` for a version that raises a custom error.
- `timeoutFailCause` for a version that raises a custom defect.

**Signature**

```ts
declare const timeoutTo: { <A, B, B1>(options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>; <A, E, R, B1, B>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): Effect<B1 | B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7304)

Since v2.0.0
Effect-transplant.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.transplant

Transplants specified effects so that when those effects fork other
effects, the forked effects will be governed by the scope of the fiber that
executes this effect.

This can be used to "graft" deep grandchildren onto a higher-level scope,
effectively extending their lifespans into the parent scope.

**Signature**

```ts
declare const transplant: <A, E, R>(f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6679)

Since v2.0.0
Effect-transposeMapOption.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.transposeMapOption

Applies an `Effect` on an `Option` and transposes the result.

**Details**

If the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.
If the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.

**Example**

```ts
import { Effect, Option, pipe } from "effect"

//           Effect<Option<number>, never, never>>
//          
const noneResult = pipe(
  Option.none(),
  Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed
)
console.log(Effect.runSync(noneResult))
// Output: { _id: 'Option', _tag: 'None' }

//           Effect<Option<number>, never, never>>
//          
const someSuccessResult = pipe(
  Option.some(42),
  Effect.transposeMapOption((value) => Effect.succeed(value * 2))
)
console.log(Effect.runSync(someSuccessResult))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }
```

**Signature**

```ts
declare const transposeMapOption: (<A, B, E = never, R = never>(f: (self: A) => Effect<B, E, R>) => (self: Option.Option<A>) => Effect<Option.Option<B>, E, R>) & (<A, B, E = never, R = never>(self: Option.Option<A>, f: (self: A) => Effect<B, E, R>) => Effect<Option.Option<B>, E, R>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13351)

Since v3.14.0
Effect-transposeOption.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.transposeOption

Converts an `Option` of an `Effect` into an `Effect` of an `Option`.

**Details**

This function transforms an `Option<Effect<A, E, R>>` into an
`Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`
will immediately succeed with a `None` value. If the `Option` is `Some`, the
inner `Effect` will be executed, and its result wrapped in a `Some`.

**Example**

```ts
import { Effect, Option } from "effect"

//       Option<Effect<number, never, never>>
//      
const maybe = Option.some(Effect.succeed(42))

//       Effect<Option<number>, never, never>
//      
const result = Effect.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }
```

**Signature**

```ts
declare const transposeOption: <A = never, E = never, R = never>(self: Option.Option<Effect<A, E, R>>) => Effect<Option.Option<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13311)

Since v3.13.0
Effect-try.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.try

Creates an `Effect` that represents a synchronous computation that might
fail.

**When to Use**

In situations where you need to perform synchronous operations that might
fail, such as parsing JSON, you can use the `try` constructor. This
constructor is designed to handle operations that could throw exceptions by
capturing those exceptions and transforming them into manageable errors.

**Error Handling**

There are two ways to handle errors with `try`:

1. If you don't provide a `catch` function, the error is caught and the
   effect fails with an `UnknownException`.
2. If you provide a `catch` function, the error is caught and the `catch`
   function maps it to an error of type `E`.

**Example** (Safe JSON Parsing)

```ts
import { Effect } from "effect"

const parse = (input: string) =>
  // This might throw an error if input is not valid JSON
  Effect.try(() => JSON.parse(input))

//       Effect<any, UnknownException, never>
//      
const program = parse("")

```

**Example** (Custom Error Handling)

```ts
import { Effect } from "effect"

const parse = (input: string) =>
  Effect.try({
    // JSON.parse may throw for bad input
    try: () => JSON.parse(input),
    // remap the error
    catch: (unknown) => new Error(`something went wrong ${unknown}`)
  })

//       Effect<any, Error, never>
//      
const program = parse("")
```

**See**

- `sync` if the effectful computation is synchronous and does not
throw errors.

**Signature**

```ts
declare const try: { <A, E>(options: { readonly try: LazyArg<A>; readonly catch: (error: unknown) => E; }): Effect<A, E>; <A>(thunk: LazyArg<A>): Effect<A, Cause.UnknownException>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4574)

Since v2.0.0
Effect-tryMap.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tryMap

Returns an effect that maps its success using the specified side-effecting
`try` function, converting any errors into typed failed effects using the
`catch` function.

**See**

- `tryPromise` for a version that works with asynchronous computations.

**Signature**

```ts
declare const tryMap: { <A, B, E1>(options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4587)

Since v2.0.0
Effect-tryMapPromise.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tryMapPromise

Returns an effect that maps its success using the specified side-effecting
`try` function, converting any promise rejections into typed failed effects
using the `catch` function.

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

**See**

- `tryMap` for a version that works with synchronous computations.

**Signature**

```ts
declare const tryMapPromise: { <A, B, E1>(options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4610)

Since v2.0.0
Effect-tryPromise.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.tryPromise

Creates an `Effect` that represents an asynchronous computation that might
fail.

**When to Use**

In situations where you need to perform asynchronous operations that might
fail, such as fetching data from an API, you can use the `tryPromise`
constructor. This constructor is designed to handle operations that could
throw exceptions by capturing those exceptions and transforming them into
manageable errors.

**Error Handling**

There are two ways to handle errors with `tryPromise`:

1. If you don't provide a `catch` function, the error is caught and the
   effect fails with an `UnknownException`.
2. If you provide a `catch` function, the error is caught and the `catch`
   function maps it to an error of type `E`.

**Interruptions**

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

**Example** (Fetching a TODO Item)

```ts
import { Effect } from "effect"

const getTodo = (id: number) =>
  // Will catch any errors and propagate them as UnknownException
  Effect.tryPromise(() =>
    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
  )

//       Effect<Response, UnknownException, never>
//      
const program = getTodo(1)
```

**Example** (Custom Error Handling)

```ts
import { Effect } from "effect"

const getTodo = (id: number) =>
  Effect.tryPromise({
    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),
    // remap the error
    catch: (unknown) => new Error(`something went wrong ${unknown}`)
  })

//       Effect<Response, Error, never>
//      
const program = getTodo(1)
```

**See**

- `promise` if the effectful computation is asynchronous and does not throw errors.

**Signature**

```ts
declare const tryPromise: { <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }): Effect<A, E>; <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, Cause.UnknownException>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4684)

Since v2.0.0
Effect-uninterruptible.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.uninterruptible

Marks an effect as uninterruptible.

**Signature**

```ts
declare const uninterruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4972)

Since v2.0.0
Effect-uninterruptibleMask.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.uninterruptibleMask

This function behaves like `uninterruptible`, but it also provides a
`restore` function. This function can be used to restore the interruptibility
of any specific region of code.

**Signature**

```ts
declare const uninterruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4982)

Since v2.0.0
Effect-unless.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.unless

Executes an effect only if the condition is `false`.

**See**

- `unlessEffect` for a version that allows the condition to be an effect.
- `when` for a version that executes the effect when the condition is `true`.

**Signature**

```ts
declare const unless: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8623)

Since v2.0.0
Effect-unlessEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.unlessEffect

Conditionally execute an effect based on the result of another effect.

**See**

- `unless` for a version that allows the condition to be a boolean.
- `whenEffect` for a version that executes the effect when the condition is `true`.

**Signature**

```ts
declare const unlessEffect: { <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option.Option<A>, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8637)

Since v2.0.0
Effect-unsafeMakeSemaphore.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.unsafeMakeSemaphore

Unsafely creates a new Semaphore.

**Signature**

```ts
declare const unsafeMakeSemaphore: (permits: number) => Semaphore
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11808)

Since v2.0.0
Effect-unsandbox.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.unsandbox

The `unsandbox` function is used to revert an effect that has been
sandboxed by `sandbox`. When you apply `unsandbox`, the
effect's error channel is restored to its original state, without the
detailed `Cause<E>` information. This means that any underlying causes of
errors, defects, or fiber interruptions are no longer exposed in the error
channel.

This function is useful when you want to remove the detailed error tracking
provided by `sandbox` and return to the standard error handling for
your effect. Once unsandboxed, the effect behaves as if `sandbox` was
never applied.

**See**

- `sandbox` to expose the full cause of failures, defects, or interruptions.

**Signature**

```ts
declare const unsandbox: <A, E, R>(self: Effect<A, Cause.Cause<E>, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4712)

Since v2.0.0
Effect-updateFiberRefs.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.updateFiberRefs

Updates the `FiberRef` values for the fiber running this effect using the
specified function.

**Signature**

```ts
declare const updateFiberRefs: (f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs) => Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10493)

Since v2.0.0
Effect-updateService.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.updateService

Updates a service in the context with a new implementation.

**Details**

This function modifies the existing implementation of a service in the
context. It retrieves the current service, applies the provided
transformation function `f`, and replaces the old service with the
transformed one.

**When to Use**

This is useful for adapting or extending a service's behavior during the
execution of an effect.

**Signature**

```ts
declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R | I>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Effect<A, E, R | I>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7807)

Since v2.0.0
Effect-useSpan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.useSpan

Create a new span for tracing, and automatically close it when the effect
completes.

The span is not added to the current span stack, so no child spans will be
created for it.

**Signature**

```ts
declare const useSpan: { <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; <A, E, R>(name: string, options: Tracer.SpanOptions, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13063)

Since v2.0.0
Effect-using.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.using

Scopes all resources acquired by one effect to the lifetime of another
effect.

**Details**

This function allows you to scope the resources acquired by one effect
(`self`) to the lifetime of another effect (`use`). This ensures that the
resources are cleaned up as soon as the `use` effect completes, regardless of
how the `use` effect ends (success, failure, or interruption).

**Example**

```ts
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const use = (resource: number) => Console.log(`Using resource: ${resource}`)

const program = acquire.pipe(Effect.using(use))

Effect.runFork(program)
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource
```

**See**

- `scopedWith` Manage scoped operations with a temporary scope.

**Signature**

```ts
declare const using: { <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope.Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6099)

Since v2.0.0
Effect-validate.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.validate

Combines multiple effects and accumulates both successes and failures.

**Details**

This function allows you to combine multiple effects, continuing through all
effects even if some of them fail. Unlike other functions that stop execution
upon encountering an error, this function collects all errors into a `Cause`.
The final result includes all successes and the accumulated failures.

By default, effects are executed sequentially, but you can control
concurrency and batching behavior using the `options` parameter. This
provides flexibility in scenarios where you want to maximize performance or
ensure specific ordering.

**Example**

```ts
import { Effect, Console } from "effect"

const task1 = Console.log("task1").pipe(Effect.as(1))
const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
const task3 = Console.log("task2").pipe(Effect.as(3))
const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))

const program = task1.pipe(
  Effect.validate(task2),
  Effect.validate(task3),
  Effect.validate(task4)
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1
// task2
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Sequential',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
//   }
// }
```

**See**

- `zip` for a version that stops at the first error.

**Signature**

```ts
declare const validate: { <B, E1, R1>(that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, B], E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12390)

Since v2.0.0
Effect-validateAll.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.validateAll

Applies an effectful operation to each element in a collection while
collecting both successes and failures.

**Details**

This function allows you to apply an effectful operation to every item in a
collection.

Unlike `forEach`, which would stop at the first error, this function
continues processing all elements, accumulating both successes and failures.

**When to Use**

Use this function when you want to process every item in a collection, even
if some items fail. This is particularly useful when you need to perform
operations on all elements without halting due to an error.

Keep in mind that if there are any failures, **all successes will be lost**,
so this function is not suitable when you need to keep the successful results
in case of errors.

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number[], [string, ...string[]], never>
//      
const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  } else {
    return Effect.fail(`${n} is not less that 4`)
  }
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// item 1
// item 2
// item 3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [ '4 is not less that 4', '5 is not less that 4' ]
//   }
// }
```

**See**

- `forEach` for a similar function that stops at the first error.
- `partition` when you need to separate successes and failures
instead of losing successes with errors.

**Signature**

```ts
declare const validateAll: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (elements: Iterable<A>) => Effect<void, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, RA.NonEmptyArray<E>, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2255)

Since v2.0.0
Effect-validateFirst.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.validateFirst

This function is similar to `validateAll` but with a key difference: it
returns the first successful result or all errors if none of the operations
succeed.

**Details**

This function processes a collection of elements and applies an effectful
operation to each. Unlike `validateAll`, which accumulates both
successes and failures, `Effect.validateFirst` stops and returns the first
success it encounters. If no success occurs, it returns all accumulated
errors. This can be useful when you are interested in the first successful
result and want to avoid processing further once a valid result is found.

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number, string[], never>
//      
const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Effect.fail(`${n} is not less that 4`)
  } else {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  }
})

Effect.runPromise(program).then(console.log, console.error)
// Output:
// item 4
// 4
```

**See**

- `validateAll` for a similar function that accumulates all results.
- `firstSuccessOf` for a similar function that processes multiple
effects and returns the first successful one or the last error.

**Signature**

```ts
declare const validateFirst: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<B, Array<E>, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2338)

Since v2.0.0
Effect-validateWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.validateWith

Sequentially combines two effects using a specified combiner function while
accumulating errors.

**Details**

This function combines two effects, `self` and `that`, into a single effect
by applying the provided combiner function to their results. If both effects
succeed, the combiner function is applied to their results to produce the
final value. If either effect fails, the failures are accumulated into a
combined `Cause`.

By default, effects are executed sequentially. However, the execution mode
can be controlled using the `options` parameter to enable concurrency,
batching, or customized finalizer behavior.

**Signature**

```ts
declare const validateWith: { <B, E1, R1, A, C>(that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>; <A, E, R, B, E1, R1, C>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<C, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12431)

Since v2.0.0
Effect-void.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.void

Represents an effect that does nothing and produces no value.

**When to Use**

Use this effect when you need to represent an effect that does nothing.
This is useful in scenarios where you need to satisfy an effect-based
interface or control program flow without performing any operations. For
example, it can be used in situations where you want to return an effect
from a function but do not need to compute or return any result.

**Signature**

```ts
declare const void: Effect<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3345)

Since v2.0.0
Effect-when.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.when

Conditionally executes an effect based on a boolean condition.

**Details**

This function allows you to run an effect only if a given condition evaluates
to `true`. If the condition is `true`, the effect is executed, and its result
is wrapped in an `Option.some`. If the condition is `false`, the effect is
skipped, and the result is `Option.none`.

**When to Use**

This function is useful for scenarios where you need to dynamically decide
whether to execute an effect based on runtime logic, while also representing
the skipped case explicitly.

**Example** (Conditional Effect Execution)

```ts
import { Effect, Option } from "effect"

const validateWeightOption = (
  weight: number
): Effect.Effect<Option.Option<number>> =>
  // Conditionally execute the effect if the weight is non-negative
  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))

// Run with a valid weight
Effect.runPromise(validateWeightOption(100)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "Some",
//   value: 100
// }

// Run with an invalid weight
Effect.runPromise(validateWeightOption(-5)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "None"
// }
```

**See**

- `whenEffect` for a version that allows the condition to be an effect.
- `unless` for a version that executes the effect when the condition is `false`.

**Signature**

```ts
declare const when: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8695)

Since v2.0.0
Effect-whenEffect.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.whenEffect

Conditionally executes an effect based on the result of another effect.

**Details**

This function allows you to run an effect only if a conditional effect
evaluating to a boolean resolves to `true`. If the conditional effect
evaluates to `true`, the specified effect is executed, and its result is
wrapped in `Option.some`. If the conditional effect evaluates to `false`, the
effect is skipped, and the result is `Option.none`.

**When to Use**

This function is particularly useful when the decision to execute an effect
depends on the result of another effect, such as a random value, a
user-provided input, or a network request result.

**Example** (Using an Effect as a Condition)

```ts
import { Effect, Random } from "effect"

const randomIntOption = Random.nextInt.pipe(
  Effect.whenEffect(Random.nextBoolean)
)

console.log(Effect.runSync(randomIntOption))
// Example Output:
// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }
```

**See**

- `when` for a version that allows the condition to be a boolean.
- `unlessEffect` for a version that executes the effect when the condition is `false`.

**Signature**

```ts
declare const whenEffect: { <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option.Option<A>, E | E2, R | R2>; <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option.Option<A>, E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8737)

Since v2.0.0
Effect-whenFiberRef.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.whenFiberRef

Executes an effect conditionally based on the value of a `FiberRef` that
satisfies a predicate.

**Details**

This function enables you to execute an effect only when the value of a
specified `FiberRef` meets a certain condition defined by a predicate. If the
value satisfies the predicate, the effect is executed, and the result is
wrapped in an `Option.some`. If the predicate is not satisfied, the effect is
skipped, and the result is `Option.none`. In both cases, the current value of
the `FiberRef` is included in the result.

**Signature**

```ts
declare const whenFiberRef: { <S>(fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8760)

Since v2.0.0
Effect-whenLogLevel.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.whenLogLevel

Conditionally executes an effect based on the specified log level and currently enabled log level.

**Details**

This function runs the provided effect only if the specified log level is
enabled. If the log level is enabled, the effect is executed and its result
is wrapped in `Some`. If the log level is not enabled, the effect is not
executed and `None` is returned.

This function is useful for conditionally executing logging-related effects
or other operations that depend on the current log level configuration.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`
  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`
}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));

Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message2
```

**See**

- `FiberRef.currentMinimumLogLevel` to retrieve the current minimum log level.

**Signature**

```ts
declare const whenLogLevel: { (level: LogLevel.LogLevel | LogLevel.Literal): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel | LogLevel.Literal): Effect<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11229)

Since v3.13.0
Effect-whenRef.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.whenRef

Executes an effect conditionally based on the value of a `Ref` that satisfies
a predicate.

**Details**

This function allows you to execute an effect only when the value of a
specified `Ref` meets a condition defined by a predicate. If the value
satisfies the predicate, the effect is executed, and the result is wrapped in
an `Option.some`. If the predicate is not satisfied, the effect is skipped,
and the result is `Option.none`. In both cases, the current value of the
`Ref` is included in the result.

**Signature**

```ts
declare const whenRef: { <S>(ref: Ref.Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8788)

Since v2.0.0
Effect-withClock.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withClock

Executes the specified workflow with the specified implementation of the
`Clock` service.

**Signature**

```ts
declare const withClock: { <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6792)

Since v2.0.0
Effect-withClockScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withClockScoped

Sets the implementation of the `Clock` service to the specified value and
restores it to its original value when the scope is closed.

**Signature**

```ts
declare const withClockScoped: <C extends Clock.Clock>(clock: C) => Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6782)

Since v2.0.0
Effect-withConfigProvider.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withConfigProvider

Executes an effect using a specific configuration provider.

**Details**

This function lets you run an effect with a specified configuration provider.
The custom provider will override the default configuration provider for the
duration of the effect's execution.

**When to Use**

This is particularly useful when you need to use a different set of
configuration values or sources for specific parts of your application.

**Example**

```ts
import { Config, ConfigProvider, Effect } from "effect"

const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(
  new Map([["custom-key", "custom-value"]])
)

const program = Effect.withConfigProvider(customProvider)(
  Effect.gen(function*() {
    const value = yield* Config.string("custom-key")
    console.log(`Config value: ${value}`)
  })
)

Effect.runPromise(program)
// Output:
// Config value: custom-value
```

**Signature**

```ts
declare const withConfigProvider: { (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7376)

Since v2.0.0
Effect-withConfigProviderScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withConfigProviderScoped

Sets a configuration provider within a scope.

**Details**

This function sets the configuration provider to a specified value and
ensures that it is restored to its original value when the scope is closed.

**Signature**

```ts
declare const withConfigProviderScoped: (provider: ConfigProvider) => Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7392)

Since v2.0.0
Effect-withConsole.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withConsole

Executes the specified workflow with the specified implementation of the
console service.

**Signature**

```ts
declare const withConsole: { <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6831)

Since v2.0.0
Effect-withConsoleScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withConsoleScoped

Sets the implementation of the console service to the specified value and
restores it to its original value when the scope is closed.

**Signature**

```ts
declare const withConsoleScoped: <A extends Console>(console: A) => Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6821)

Since v2.0.0
Effect-withEarlyRelease.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withEarlyRelease

Returns the result of the effect and a finalizer to close its scope.

**Details**

This function allows you to retrieve both the result of an effect and a
finalizer that can be used to manually close its scope. This is useful for
workflows where you need early access to the result while retaining control
over the resource cleanup process.

**Example**

```ts
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const program = Effect.gen(function*() {
  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)
  console.log(`Using resource: ${resource}`)
  yield* Effect.sleep("1 second")
  yield* finalizer
})

Effect.runFork(program.pipe(Effect.scoped))
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource
```

**Signature**

```ts
declare const withEarlyRelease: <A, E, R>(self: Effect<A, E, R>) => Effect<[finalizer: Effect<void>, result: A], E, R | Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6145)

Since v2.0.0
Effect-withExecutionPlan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withExecutionPlan

Apply an `ExecutionPlan` to the effect, which allows you to fallback to
different resources in case of failure.

**Signature**

```ts
declare const withExecutionPlan: { <Input, Provides, PlanE, PlanR>(plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): <A, E extends Input, R>(effect: Effect<A, E, R>) => Effect<A, E | PlanE, Exclude<R, Provides> | PlanR>; <A, E extends Input, R, Provides, Input, PlanE, PlanR>(effect: Effect<A, E, R>, plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): Effect<A, E | PlanE, Exclude<R, Provides> | PlanR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4427)

Since v3.16.0
Effect-withLogSpan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withLogSpan

Adds a log span to an effect for tracking and logging its execution duration.

**Details**

This function wraps an effect with a log span, providing performance
monitoring and debugging capabilities. The log span tracks the duration of
the wrapped effect and logs it with the specified label. This is particularly
useful when analyzing time-sensitive operations or understanding the
execution time of specific tasks in your application.

The logged output will include the label and the total time taken for the
operation. The span information is included in the log metadata, making it
easy to trace performance metrics in logs.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.sleep("1 second")
  yield* Effect.log("The job is finished!")
}).pipe(Effect.withLogSpan("myspan"))

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms
```

**Signature**

```ts
declare const withLogSpan: { (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11040)

Since v2.0.0
Effect-withMaxOpsBeforeYield.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withMaxOpsBeforeYield

Sets the maximum number of operations before yield by the default schedulers

**Signature**

```ts
declare const withMaxOpsBeforeYield: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6720)

Since v2.0.0
Effect-withMetric.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withMetric

Associates a metric with the current effect, updating it as the effect progresses.

**Signature**

```ts
declare const withMetric: { <Type, In, Out>(metric: Metric.Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric.Metric<Type, In, Out>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11730)

Since v2.0.0
Effect-withParentSpan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withParentSpan

Adds the provided span to the current span stack.

**Signature**

```ts
declare const withParentSpan: { (span: Tracer.AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13160)

Since v2.0.0
Effect-withRandom.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withRandom

Executes the specified effect with the specified implementation of the
`Random` service.

**Signature**

```ts
declare const withRandom: { <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11581)

Since v2.0.0
Effect-withRandomScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withRandomScoped

Sets the implementation of the `Random` service to the specified value and
restores it to its original value when the scope is closed.

**Signature**

```ts
declare const withRandomScoped: <A extends Random.Random>(value: A) => Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11593)

Since v2.0.0
Effect-withScheduler.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withScheduler

Sets the provided scheduler for usage in the wrapped effect

**Signature**

```ts
declare const withScheduler: { (scheduler: Scheduler.Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler.Scheduler): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6698)

Since v2.0.0
Effect-withSchedulingPriority.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withSchedulingPriority

Sets the scheduling priority used when yielding

**Signature**

```ts
declare const withSchedulingPriority: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6709)

Since v2.0.0
Effect-withSpan.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withSpan

Wraps the effect with a new span for tracing.

**Signature**

```ts
declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13078)

Since v2.0.0
Effect-withSpanScoped.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withSpanScoped

Wraps the effect with a new span for tracing.

The span is ended when the Scope is finalized.

**Signature**

```ts
declare const withSpanScoped: { (name: string, options?: Tracer.SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions): Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13142)

Since v2.0.0
Effect-withTracerEnabled.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withTracerEnabled

Disable the tracer for the given Effect.

**Example**

```ts
import { Effect } from "effect"

Effect.succeed(42).pipe(
  Effect.withSpan("my-span"),
  // the span will not be registered with the tracer
  Effect.withTracerEnabled(false)
)
```

**Signature**

```ts
declare const withTracerEnabled: { (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12913)

Since v2.0.0
Effect-withUnhandledErrorLogLevel.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.withUnhandledErrorLogLevel

Configures whether child fibers will log unhandled errors and at what log
level.

**Details**

This function allows you to control whether unhandled errors from child
fibers are logged and to specify the log level for these errors. By default,
unhandled errors are reported via the logger. However, using this function,
you can choose to suppress these logs by passing `Option.none` or adjust the
log level to a specific severity, such as `Error`, `Warning`, or `Info`.

This configuration is scoped to the effect it is applied to, meaning the
changes only apply to the child fibers created within that effect's context.
It is especially useful when you want to reduce noise in logs or prioritize
certain types of errors.

**Example**

```ts
import { Effect, Fiber, LogLevel, Option } from "effect"

const program = Effect.gen(function*() {
  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))
  yield* Fiber.join(fiber)
})

Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))
// Output:
// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"
```

**Signature**

```ts
declare const withUnhandledErrorLogLevel: { (level: Option.Option<LogLevel.LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11192)

Since v2.0.0
Effect-zip.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.zip

Combines two effects into a single effect, producing a tuple of their
results.

**Details**

This function combines two effects, `self` and `that`, into one. It executes
the first effect (`self`) and then the second effect (`that`), collecting
their results into a tuple. Both effects must succeed for the resulting
effect to succeed. If either effect fails, the entire operation fails.

By default, the effects are executed sequentially. If the `concurrent` option
is set to `true`, the effects will run concurrently, potentially improving
performance for independent operations.

**Example** (Combining Two Effects Sequentially)

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Combine the two effects together
//
//       Effect<[number, string], never, never>
//      
const program = Effect.zip(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// [ 1, 'hello' ]
```

**Example** (Combining Two Effects Concurrently)

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Run both effects concurrently using the concurrent option
const program = Effect.zip(task1, task2, { concurrent: true })

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task2 done"
// timestamp=... level=INFO fiber=#0 message="task1 done"
// [ 1, 'hello' ]
```

**See**

- `zipWith` for a version that combines the results with a custom
function.
- `validate` for a version that accumulates errors.

**Signature**

```ts
declare const zip: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, A2], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12530)

Since v2.0.0
Effect-zipLeft.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.zipLeft

Executes two effects sequentially, returning the result of the first effect
and ignoring the result of the second.

**Details**

This function allows you to run two effects in sequence, where the result of
the first effect is preserved, and the result of the second effect is
discarded. By default, the two effects are executed sequentially. If you need
them to run concurrently, you can pass the `{ concurrent: true }` option.

The second effect will always be executed, even though its result is ignored.
This makes it useful for cases where you want to execute an effect for its
side effects while keeping the result of another effect.

**When to Use**

Use this function when you are only interested in the result of the first
effect but still need to run the second effect for its side effects, such as
logging or performing a cleanup action.

**Example**

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = Effect.zipLeft(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// 1
```

**See**

- `zipRight` for a version that returns the result of the second
effect.

**Signature**

```ts
declare const zipLeft: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12604)

Since v2.0.0
Effect-zipRight.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.zipRight

Executes two effects sequentially, returning the result of the second effect
while ignoring the result of the first.

**Details**

This function allows you to run two effects in sequence, keeping the result
of the second effect and discarding the result of the first. By default, the
two effects are executed sequentially. If you need them to run concurrently,
you can pass the `{ concurrent: true }` option.

The first effect will always be executed, even though its result is ignored.
This makes it useful for scenarios where the first effect is needed for its
side effects, but only the result of the second effect is important.

**When to Use**

Use this function when you are only interested in the result of the second
effect but still need to run the first effect for its side effects, such as
initialization or setup tasks.

**Example**

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = Effect.zipRight(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// hello
```

**See**

- `zipLeft` for a version that returns the result of the first
effect.

**Signature**

```ts
declare const zipRight: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<A2, E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12678)

Since v2.0.0
Effect-zipWith.md
Package: `effect`<br />
Module: `Effect`<br />

## Effect.zipWith

Combines two effects sequentially and applies a function to their results to
produce a single value.

**Details**

This function runs two effects in sequence (or concurrently, if the `{
concurrent: true }` option is provided) and combines their results using a
provided function. Unlike `zip`, which returns a tuple of the results,
this function processes the results with a custom function to produce a
single output.

**Example** (Combining Effects with a Custom Function)

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const task3 = Effect.zipWith(
  task1,
  task2,
  // Combines results into a single value
  (number, string) => number + string.length
)

Effect.runPromise(task3).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task1 done"
// timestamp=... level=INFO fiber=#2 message="task2 done"
// 6
```

**Signature**

```ts
declare const zipWith: { <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<B, E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12741)

Since v2.0.0
Effectify-Effectify.md
Package: `@effect/platform`<br />
Module: `Effectify`<br />

## Effectify.Effectify

Converts a callback-based function to a function that returns an `Effect`.

**Signature**

```ts
type Effectify<T, E> = T extends {
  (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
  (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
  (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
  (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
  (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
  (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
  (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
  (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8
  (...args: ArgsWithCallback<infer Args9, infer _E9, infer A9>): infer _R9
  (...args: ArgsWithCallback<infer Args10, infer _E10, infer A10>): infer _R10
} ? {
    (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
    (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
    (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
    (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
    (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
    (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
    (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
    (...args: Args8): Effect.Effect<WithoutNull<A8>, E>
    (...args: Args9): Effect.Effect<WithoutNull<A9>, E>
    (...args: Args10): Effect.Effect<WithoutNull<A10>, E>
  }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
    (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
    (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8
    (...args: ArgsWithCallback<infer Args9, infer _E9, infer A9>): infer _R9
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
      (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
      (...args: Args8): Effect.Effect<WithoutNull<A8>, E>
      (...args: Args9): Effect.Effect<WithoutNull<A9>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
    (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
    (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
      (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
      (...args: Args8): Effect.Effect<WithoutNull<A8>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
    (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
      (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
    }
  : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Effectify.ts#L20)

Since v1.0.0
Either-Do.md
Package: `effect`<br />
Module: `Either`<br />

## Either.Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

**See**

- `bind`
- `bindTo`
- `let`

**Signature**

```ts
declare const Do: Either<{}, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L835)

Since v2.0.0
Either-all.md
Package: `effect`<br />
Module: `Either`<br />

## Either.all

Takes a structure of `Either`s and returns an `Either` of values with the same structure.

- If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.
- If a struct is supplied, then the returned `Either` will contain a struct with the same keys.
- If an iterable is supplied, then the returned `Either` will contain an array.

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))
assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right("hello") }), Either.right({ right: 1, b: "hello" }))
assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left("error") }), Either.left("error"))
```

**Signature**

```ts
declare const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(input: I) => [I] extends [ReadonlyArray<Either<any, any>>] ? Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[number] extends never ? never : [I[number]] extends [Either<any, infer L>] ? L : never> : [I] extends [Iterable<Either<infer R, infer L>>] ? Either<Array<R>, L> : Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer L>] ? L : never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L734)

Since v2.0.0
Either-andThen.md
Package: `effect`<br />
Module: `Either`<br />

## Either.andThen

Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.

**Signature**

```ts
declare const andThen: { <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>; <R2, L2>(f: Either<R2, L2>): <L, R1>(self: Either<R1, L>) => Either<R2, L | L2>; <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R2>(right: NotFunction<R2>): <R1, L>(self: Either<R1, L>) => Either<R2, L>; <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>; <R, L, R2, L2>(self: Either<R, L>, f: Either<R2, L2>): Either<R2, L | L2>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: NotFunction<R2>): Either<R2, L>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L662)

Since v2.0.0
Either-bind.md
Package: `effect`<br />
Module: `Either`<br />

## Either.bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bindTo`
- `let`

**Signature**

```ts
declare const bind: { <N extends string, A extends object, B, L2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): <L1>(self: Either<A, L1>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; <A extends object, L1, N extends string, B, L2>(self: Either<A, L1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L868)

Since v2.0.0
Either-bindTo.md
Package: `effect`<br />
Module: `Either`<br />

## Either.bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bind`
- `let`

**Signature**

```ts
declare const bindTo: { <N extends string>(name: N): <R, L>(self: Either<R, L>) => Either<{ [K in N]: R; }, L>; <R, L, N extends string>(self: Either<R, L>, name: N): Either<{ [K in N]: R; }, L>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L911)

Since v2.0.0
Either-filterOrLeft.md
Package: `effect`<br />
Module: `Either`<br />

## Either.filterOrLeft

Filter the right value with the provided function.
If the predicate fails, set the left value with the result of the provided function.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0

assert.deepStrictEqual(
  pipe(
    Either.right(1),
    Either.filterOrLeft(isPositive, n => `${n} is not positive`)
  ),
  Either.right(1)
)
assert.deepStrictEqual(
  pipe(
    Either.right(0),
    Either.filterOrLeft(isPositive, n => `${n} is not positive`)
  ),
  Either.left("0 is not positive")
)
```

**Signature**

```ts
declare const filterOrLeft: { <R, B extends R, L2>(refinement: Refinement<NoInfer<R>, B>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<B, L2 | L>; <R, L2>(predicate: Predicate<NoInfer<R>>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<R, L2 | L>; <R, L, B extends R, L2>(self: Either<R, L>, refinement: Refinement<R, B>, orLeftWith: (right: R) => L2): Either<B, L | L2>; <R, L, E2>(self: Either<R, L>, predicate: Predicate<R>, orLeftWith: (right: R) => E2): Either<R, L | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L491)

Since v2.0.0
Either-flip.md
Package: `effect`<br />
Module: `Either`<br />

## Either.flip

Returns an `Either` that swaps the error/success cases. This allows you to
use all methods on the error channel, possibly before flipping back.

**Signature**

```ts
declare const flip: <R, L>(self: Either<R, L>) => Either<L, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L776)

Since v2.0.0
Either-fromNullable.md
Package: `effect`<br />
Module: `Either`<br />

## Either.fromNullable

Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use
the provided default as a `Left`.

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))
assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))
```

**Signature**

```ts
declare const fromNullable: { <R, L>(onNullable: (right: R) => L): (self: R) => Either<NonNullable<R>, L>; <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L156)

Since v2.0.0
Either-getLeft.md
Package: `effect`<br />
Module: `Either`<br />

## Either.getLeft

Converts a `Either` to an `Option` discarding the value.

**Example**

```ts
import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())
assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))
```

**Signature**

```ts
declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L307)

Since v2.0.0
Either-getOrElse.md
Package: `effect`<br />
Module: `Either`<br />

## Either.getOrElse

Returns the wrapped value if it's a `Right` or a default value if is a `Left`.

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + "!"), 1)
assert.deepStrictEqual(Either.getOrElse(Either.left("not a number"), (error) => error + "!"), "not a number!")
```

**Signature**

```ts
declare const getOrElse: { <L, R2>(onLeft: (left: L) => R2): <R>(self: Either<R, L>) => R2 | R; <R, L, R2>(self: Either<R, L>, onLeft: (left: L) => R2): R | R2; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L536)

Since v2.0.0
Either-getOrThrow.md
Package: `effect`<br />
Module: `Either`<br />

## Either.getOrThrow

Extracts the value of an `Either` or throws if the `Either` is `Left`.

The thrown error is a default error. To configure the error thrown, see  `getOrThrowWith`.

**Throws**

`Error("getOrThrow called on a Left")`

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)
assert.throws(() => Either.getOrThrow(Either.left("error")))
```

**Signature**

```ts
declare const getOrThrow: <R, L>(self: Either<R, L>) => R
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L624)

Since v2.0.0
Either-getOrThrowWith.md
Package: `effect`<br />
Module: `Either`<br />

## Either.getOrThrowWith

Extracts the value of an `Either` or throws if the `Either` is `Left`.

If a default error is sufficient for your use case and you don't need to configure the thrown error, see `getOrThrow`.

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(
  Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
  1
)
assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))
```

**Signature**

```ts
declare const getOrThrowWith: { <L>(onLeft: (left: L) => unknown): <A>(self: Either<A, L>) => A; <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L594)

Since v2.0.0
Either-getRight.md
Package: `effect`<br />
Module: `Either`<br />

## Either.getRight

Converts a `Either` to an `Option` discarding the `Left`.

**Example**

```ts
import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))
assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())
```

**Signature**

```ts
declare const getRight: <R, L>(self: Either<R, L>) => Option<R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L290)

Since v2.0.0
Either-isEither.md
Package: `effect`<br />
Module: `Either`<br />

## Either.isEither

Tests if a value is a `Either`.

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isEither(Either.right(1)), true)
assert.deepStrictEqual(Either.isEither(Either.left("a")), true)
assert.deepStrictEqual(Either.isEither({ right: 1 }), false)
```

**Signature**

```ts
declare const isEither: (input: unknown) => input is Either<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L239)

Since v2.0.0
Either-isLeft.md
Package: `effect`<br />
Module: `Either`<br />

## Either.isLeft

Determine if a `Either` is a `Left`.

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)
```

**Signature**

```ts
declare const isLeft: <R, L>(self: Either<R, L>) => self is Left<L, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L256)

Since v2.0.0
Either-isRight.md
Package: `effect`<br />
Module: `Either`<br />

## Either.isRight

Determine if a `Either` is a `Right`.

**Example**

```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
assert.deepStrictEqual(Either.isRight(Either.left("a")), false)
```

**Signature**

```ts
declare const isRight: <R, L>(self: Either<R, L>) => self is Right<L, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L273)

Since v2.0.0
Either-left.md
Package: `effect`<br />
Module: `Either`<br />

## Either.left

Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
structure.

**Signature**

```ts
declare const left: <L>(left: L) => Either<never, L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L138)

Since v2.0.0
Either-let.md
Package: `effect`<br />
Module: `Either`<br />

## Either.let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bindTo`
- `bind`

**Signature**

```ts
declare const let: { <N extends string, R extends object, B>(name: Exclude<N, keyof R>, f: (r: NoInfer<R>) => B): <L>(self: Either<R, L>) => Either<{ [K in N | keyof R]: K extends keyof R ? R[K] : B; }, L>; <R extends object, L, N extends string, B>(self: Either<R, L>, name: Exclude<N, keyof R>, f: (r: NoInfer<R>) => B): Either<{ [K in N | keyof R]: K extends keyof R ? R[K] : B; }, L>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L960)

Since v2.0.0
Either-liftPredicate.md
Package: `effect`<br />
Module: `Either`<br />

## Either.liftPredicate

Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`
or `Left` of the result of the provided function if the predicate returns false

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0
const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)

assert.deepStrictEqual(
  isPositiveEither(1),
  Either.right(1)
)
assert.deepStrictEqual(
  isPositiveEither(0),
  Either.left("0 is not positive")
)
```

**Signature**

```ts
declare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<A, B>, orLeftWith: (a: A) => E): (a: A) => Either<B, E>; <B extends A, E, A = B>(predicate: Predicate<A>, orLeftWith: (a: A) => E): (a: B) => Either<B, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>; <B extends A, E, A = B>(self: B, predicate: Predicate<A>, orLeftWith: (a: A) => E): Either<B, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L439)

Since v3.4.0
Either-map.md
Package: `effect`<br />
Module: `Either`<br />

## Either.map

Maps the `Right` side of an `Either` value to a new `Either` value.

**Signature**

```ts
declare const map: { <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L365)

Since v2.0.0
Either-mapLeft.md
Package: `effect`<br />
Module: `Either`<br />

## Either.mapLeft

Maps the `Left` side of an `Either` value to a new `Either` value.

**Signature**

```ts
declare const mapLeft: { <L, L2>(f: (left: L) => L2): <R>(self: Either<R, L>) => Either<R, L2>; <R, L, L2>(self: Either<R, L>, f: (left: L) => L2): Either<R, L2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L350)

Since v2.0.0
Either-match.md
Package: `effect`<br />
Module: `Either`<br />

## Either.match

Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,
if the value is a `Right` the inner value is applied to the `onRight` function.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`

const onRight = (value: number): string => `Ok: ${value}`

assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')
assert.deepStrictEqual(
  pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),
  'strings: string 1, string 2'
)
```

**Signature**

```ts
declare const match: { <L, B, R, C = B>(options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): (self: Either<R, L>) => B | C; <R, L, B, C = B>(self: Either<R, L>, options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): B | C; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L397)

Since v2.0.0
Either-orElse.md
Package: `effect`<br />
Module: `Either`<br />

## Either.orElse

Returns `self` if it is a `Right` or `that` otherwise.

**Signature**

```ts
declare const orElse: { <L, R2, L2>(that: (left: L) => Either<R2, L2>): <R>(self: Either<R, L>) => Either<R | R2, L2>; <R, L, R2, L2>(self: Either<R, L>, that: (left: L) => Either<R2, L2>): Either<R | R2, L2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L634)

Since v2.0.0
Either-right.md
Package: `effect`<br />
Module: `Either`<br />

## Either.right

Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
of this structure.

**Signature**

```ts
declare const right: <R>(right: R) => Either<R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L120)

Since v2.0.0
Either-transposeMapOption.md
Package: `effect`<br />
Module: `Either`<br />

## Either.transposeMapOption

Applies an `Either` on an `Option` and transposes the result.

**Details**

If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.
If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.

**Example**

```ts
import { Either, Option, pipe } from "effect"

//           Either<Option<number>, never>>
//          
const noneResult = pipe(
  Option.none(),
  Either.transposeMapOption(() => Either.right(42)) // will not be executed
)
console.log(noneResult)
// Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }

//           Either<Option<number>, never>>
//          
const someRightResult = pipe(
  Option.some(42),
  Either.transposeMapOption((value) => Either.right(value * 2))
)
console.log(someRightResult)
// Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }
```

**Signature**

```ts
declare const transposeMapOption: (<A, B, E = never>(f: (self: A) => Either<B, E>) => (self: Option<A>) => Either<Option<B>, E>) & (<A, B, E = never>(self: Option<A>, f: (self: A) => Either<B, E>) => Either<Option<B>, E>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L1032)

Since v3.15.0
Either-transposeOption.md
Package: `effect`<br />
Module: `Either`<br />

## Either.transposeOption

Converts an `Option` of an `Either` into an `Either` of an `Option`.

**Details**

This function transforms an `Option<Either<A, E>>` into an
`Either<Option<A>, E>`. If the `Option` is `None`, the resulting `Either`
will be a `Right` with a `None` value. If the `Option` is `Some`, the
inner `Either` will be executed, and its result wrapped in a `Some`.

**Example**

```ts
import { Effect, Either, Option } from "effect"

//       Option<Either<number, never>>
//      
const maybe = Option.some(Either.right(42))

//       Either<Option<number>, never, never>
//      
const result = Either.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }
```

**Signature**

```ts
declare const transposeOption: <A = never, E = never>(self: Option<Either<A, E>>) => Either<Option<A>, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L992)

Since v3.14.0
Either-try.md
Package: `effect`<br />
Module: `Either`<br />

## Either.try

Imports a synchronous side-effect into a pure `Either` value, translating any
thrown exceptions into typed failed eithers creating with `Either.left`.

**Signature**

```ts
declare const try: { <R, L>(options: { readonly try: LazyArg<R>; readonly catch: (error: unknown) => L; }): Either<R, L>; <R>(evaluate: LazyArg<R>): Either<R, unknown>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L220)

Since v2.0.0
Encoding-DecodeException.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.DecodeException

Represents a checked exception which occurs when decoding fails.

**Signature**

```ts
export interface DecodeException {
  readonly _tag: "DecodeException"
  readonly [DecodeExceptionTypeId]: DecodeExceptionTypeId
  readonly input: string
  readonly message?: string
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L133)

Since v2.0.0
Encoding-EncodeException.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.EncodeException

Represents a checked exception which occurs when encoding fails.

**Signature**

```ts
export interface EncodeException {
  readonly _tag: "EncodeException"
  readonly [EncodeExceptionTypeId]: EncodeExceptionTypeId
  readonly input: string
  readonly message?: string
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L174)

Since v3.12.0
Encoding-decodeBase64.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.decodeBase64

Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.

**Signature**

```ts
declare const decodeBase64: (str: string) => Either.Either<Uint8Array, DecodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L31)

Since v2.0.0
Encoding-decodeBase64String.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.decodeBase64String

Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.

**Signature**

```ts
declare const decodeBase64String: (str: string) => Either.Either<string, DecodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L39)

Since v2.0.0
Encoding-decodeBase64Url.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.decodeBase64Url

Decodes a base64 (URL) encoded `string` into a `Uint8Array`.

**Signature**

```ts
declare const decodeBase64Url: (str: string) => Either.Either<Uint8Array, DecodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L56)

Since v2.0.0
Encoding-decodeBase64UrlString.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.decodeBase64UrlString

Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.

**Signature**

```ts
declare const decodeBase64UrlString: (str: string) => Either.Either<string, DecodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L64)

Since v2.0.0
Encoding-decodeHex.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.decodeHex

Decodes a hex encoded `string` into a `Uint8Array`.

**Signature**

```ts
declare const decodeHex: (str: string) => Either.Either<Uint8Array, DecodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L81)

Since v2.0.0
Encoding-decodeHexString.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.decodeHexString

Decodes a hex encoded `string` into a UTF-8 `string`.

**Signature**

```ts
declare const decodeHexString: (str: string) => Either.Either<string, DecodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L89)

Since v2.0.0
Encoding-decodeUriComponent.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.decodeUriComponent

Decodes a URI component `string` into a UTF-8 `string`.

**Signature**

```ts
declare const decodeUriComponent: (str: string) => Either.Either<string, DecodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L109)

Since v3.12.0
Encoding-encodeBase64.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.encodeBase64

Encodes the given value into a base64 (RFC4648) `string`.

**Signature**

```ts
declare const encodeBase64: (input: Uint8Array | string) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L22)

Since v2.0.0
Encoding-encodeBase64Url.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.encodeBase64Url

Encodes the given value into a base64 (URL) `string`.

**Signature**

```ts
declare const encodeBase64Url: (input: Uint8Array | string) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L47)

Since v2.0.0
Encoding-encodeHex.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.encodeHex

Encodes the given value into a hex `string`.

**Signature**

```ts
declare const encodeHex: (input: Uint8Array | string) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L72)

Since v2.0.0
Encoding-encodeUriComponent.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.encodeUriComponent

Encodes a UTF-8 `string` into a URI component `string`.

**Signature**

```ts
declare const encodeUriComponent: (str: string) => Either.Either<string, EncodeException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L97)

Since v3.12.0
Encoding-isDecodeException.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.isDecodeException

Returns `true` if the specified value is an `DecodeException`, `false` otherwise.

**Signature**

```ts
declare const isDecodeException: (u: unknown) => u is DecodeException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L154)

Since v2.0.0
Encoding-isEncodeException.md
Package: `effect`<br />
Module: `Encoding`<br />

## Encoding.isEncodeException

Returns `true` if the specified value is an `EncodeException`, `false` otherwise.

**Signature**

```ts
declare const isEncodeException: (u: unknown) => u is EncodeException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L195)

Since v3.12.0
Entity-CurrentAddress.md
Package: `@effect/cluster`<br />
Module: `Entity`<br />

## Entity.CurrentAddress

A Context.Tag to access the current entity address.

**Signature**

```ts
declare class CurrentAddress
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Entity.ts#L402)

Since v1.0.0
Entity-CurrentRunnerAddress.md
Package: `@effect/cluster`<br />
Module: `Entity`<br />

## Entity.CurrentRunnerAddress

A Context.Tag to access the current Runner address.

**Signature**

```ts
declare class CurrentRunnerAddress
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Entity.ts#L413)

Since v1.0.0
Entity-fromRpcGroup.md
Package: `@effect/cluster`<br />
Module: `Entity`<br />

## Entity.fromRpcGroup

Creates a new `Entity` of the specified `type` which will accept messages
that adhere to the provided `RpcGroup`.

**Signature**

```ts
declare const fromRpcGroup: <Rpcs extends Rpc.Any>(type: string, protocol: RpcGroup.RpcGroup<Rpcs>) => Entity<Rpcs>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Entity.ts#L359)

Since v1.0.0
Entity-make.md
Package: `@effect/cluster`<br />
Module: `Entity`<br />

## Entity.make

Creates a new `Entity` of the specified `type` which will accept messages
that adhere to the provided schemas.

**Signature**

```ts
declare const make: <Rpcs extends ReadonlyArray<Rpc.Any>>(type: string, protocol: Rpcs) => Entity<Rpcs[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Entity.ts#L384)

Since v1.0.0
EntityAddress-EntityAddress.md
Package: `@effect/cluster`<br />
Module: `EntityAddress`<br />

## EntityAddress.EntityAddress

Represents the unique address of an entity within the cluster.

**Signature**

```ts
declare class EntityAddress
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/EntityAddress.ts#L31)

Since v1.0.0
EntityAddress-EntityAddressFromSelf.md
Package: `@effect/cluster`<br />
Module: `EntityAddress`<br />

## EntityAddress.EntityAddressFromSelf

Represents the unique address of an entity within the cluster.

**Signature**

```ts
declare const EntityAddressFromSelf: Schema.Schema<EntityAddress, EntityAddress, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/EntityAddress.ts#L63)

Since v1.0.0
EntityProxy-toHttpApiGroup.md
Package: `@effect/cluster`<br />
Module: `EntityProxy`<br />

## EntityProxy.toHttpApiGroup

Derives an `HttpApiGroup` from an `Entity`.

```ts
import { ClusterSchema, Entity, EntityProxy, EntityProxyServer } from "@effect/cluster"
import { HttpApi, HttpApiBuilder } from "@effect/platform"
import { Rpc } from "@effect/rpc"
import { Layer, Schema } from "effect"

export const Counter = Entity.make("Counter", [
  Rpc.make("Increment", {
    payload: { id: Schema.String, amount: Schema.Number },
    primaryKey: ({ id }) => id,
    success: Schema.Number
  })
]).annotateRpcs(ClusterSchema.Persisted, true)

// Use EntityProxy.toHttpApiGroup to create a `HttpApiGroup` from the
// Counter entity
export class MyApi extends HttpApi.make("api")
  .add(
    EntityProxy.toHttpApiGroup("counter", Counter)
      .prefix("/counter")
  )
{}

// Use EntityProxyServer.layerHttpApi to create a layer that implements
// the handlers for the HttpApiGroup
const ApiLayer = HttpApiBuilder.api(MyApi).pipe(
  Layer.provide(EntityProxyServer.layerHttpApi(MyApi, "counter", Counter))
)
```

**Signature**

```ts
declare const toHttpApiGroup: <const Name extends string, Rpcs extends Rpc.Any>(name: Name, entity: Entity.Entity<Rpcs>) => HttpApiGroup.HttpApiGroup<Name, ConvertHttpApi<Rpcs>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/EntityProxy.ts#L147)

Since v1.0.0
EntityProxy-toRpcGroup.md
Package: `@effect/cluster`<br />
Module: `EntityProxy`<br />

## EntityProxy.toRpcGroup

Derives an `RpcGroup` from an `Entity`.

```ts
import { ClusterSchema, Entity, EntityProxy, EntityProxyServer } from "@effect/cluster"
import { Rpc, RpcServer } from "@effect/rpc"
import { Layer, Schema } from "effect"

export const Counter = Entity.make("Counter", [
  Rpc.make("Increment", {
    payload: { id: Schema.String, amount: Schema.Number },
    primaryKey: ({ id }) => id,
    success: Schema.Number
  })
]).annotateRpcs(ClusterSchema.Persisted, true)

// Use EntityProxy.toRpcGroup to create a `RpcGroup` from the Counter entity
export class MyRpcs extends EntityProxy.toRpcGroup(Counter) {}

// Use EntityProxyServer.layerRpcHandlers to create a layer that implements
// the rpc handlers
const RpcServerLayer = RpcServer.layer(MyRpcs).pipe(
  Layer.provide(EntityProxyServer.layerRpcHandlers(Counter))
)
```

**Signature**

```ts
declare const toRpcGroup: <Rpcs extends Rpc.Any, const Prefix extends string = "">(entity: Entity.Entity<Rpcs>, options?: { readonly prefix?: Prefix | undefined; }) => RpcGroup.RpcGroup<ConvertRpcs<Rpcs, Prefix>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/EntityProxy.ts#L48)

Since v1.0.0
Equivalence-array.md
Package: `effect`<br />
Module: `Equivalence`<br />

## Equivalence.array

Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.

**Signature**

```ts
declare const array: <A>(item: Equivalence<A>) => Equivalence<ReadonlyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L200)

Since v2.0.0
Equivalence-strict.md
Package: `effect`<br />
Module: `Equivalence`<br />

## Equivalence.strict

Return an `Equivalence` that uses strict equality (===) to compare values.

**Signature**

```ts
declare const strict: <A>() => Equivalence<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L42)

Since v2.0.0
Equivalence-struct.md
Package: `effect`<br />
Module: `Equivalence`<br />

## Equivalence.struct

Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
by applying each `Equivalence` to the corresponding property of the struct.

**Signature**

```ts
declare const struct: <R extends Record<string, Equivalence<any>>>(fields: R) => Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L223)

Since v2.0.0
Equivalence-tuple.md
Package: `effect`<br />
Module: `Equivalence`<br />

## Equivalence.tuple

Similar to `Promise.all` but operates on `Equivalence`s.

```ts
[Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>
```

Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
by applying each `Equivalence` to the corresponding element of the tuple.

**Signature**

```ts
declare const tuple: <T extends ReadonlyArray<Equivalence<any>>>(...elements: T) => Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence<infer A>] ? A : never; }>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L190)

Since v2.0.0
Event-Event.md
Package: `@effect/experimental`<br />
Module: `Event`<br />

## Event.Event

Represents an event in an EventLog.

**Signature**

```ts
export interface Event<
  out Tag extends string,
  in out Payload extends Schema.Schema.Any = typeof Schema.Void,
  in out Success extends Schema.Schema.Any = typeof Schema.Void,
  in out Error extends Schema.Schema.All = typeof Schema.Never
> {
  readonly [TypeId]: TypeId
  readonly tag: Tag
  readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string
  readonly payload: Payload
  readonly payloadMsgPack: MsgPack.schema<Payload>
  readonly success: Success
  readonly error: Error
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/Event.ts#L33)

Since v1.0.0
EventGroup-EventGroup.md
Package: `@effect/experimental`<br />
Module: `EventGroup`<br />

## EventGroup.EventGroup

An `EventGroup` is a collection of `Event`s. You can use an `EventGroup` to
represent a portion of your domain.

The events can be implemented later using the `EventLogBuilder.group` api.

**Signature**

```ts
export interface EventGroup<
  out Events extends Event.Any = never
> extends Pipeable {
  new(_: never): {}

  readonly [TypeId]: TypeId
  readonly events: Record.ReadonlyRecord<string, Events>

  /**
   * Add an `Event` to the `EventGroup`.
   */
  add<
    Tag extends string,
    Payload extends Schema.Schema.Any = typeof Schema.Void,
    Success extends Schema.Schema.Any = typeof Schema.Void,
    Error extends Schema.Schema.All = typeof Schema.Never
  >(options: {
    readonly tag: Tag
    readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string
    readonly payload?: Payload
    readonly success?: Success
    readonly error?: Error
  }): EventGroup<Events | Event<Tag, Payload, Success, Error>>

  /**
   * Add an error schema to all the events in the `EventGroup`.
   */
  addError<Error extends Schema.Schema.Any>(error: Error): EventGroup<Event.AddError<Events, Error>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/EventGroup.ts#L39)

Since v1.0.0
EventGroup-empty.md
Package: `@effect/experimental`<br />
Module: `EventGroup`<br />

## EventGroup.empty

An `EventGroup` is a collection of `Event`s. You can use an `EventGroup` to
represent a portion of your domain.

The events can be implemented later using the `EventLog.group` api.

**Signature**

```ts
declare const empty: EventGroup<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/EventGroup.ts#L158)

Since v1.0.0
EventLog-Handlers.md
Package: `@effect/experimental`<br />
Module: `EventLog`<br />

## EventLog.Handlers

Represents a handled `EventGroup`.

**Signature**

```ts
export interface Handlers<
  R,
  Events extends Event.Any = never
> extends Pipeable {
  readonly [HandlersTypeId]: {
    _Endpoints: Covariant<Events>
  }
  readonly group: EventGroup.AnyWithProps
  readonly handlers: Record.ReadonlyRecord<string, Handlers.Item<R>>
  readonly context: Context.Context<any>

  /**
   * Add the implementation for an `Event` to a `Handlers` group.
   */
  handle<Tag extends Events["tag"], R1>(
    name: Tag,
    handler: (
      options: {
        readonly payload: Event.PayloadWithTag<Events, Tag>
        readonly entry: Entry
        readonly conflicts: Array<{
          readonly entry: Entry
          readonly payload: Event.PayloadWithTag<Events, Tag>
        }>
      }
    ) => Effect.Effect<Event.SuccessWithTag<Events, Tag>, Event.ErrorWithTag<Events, Tag>, R1>
  ): Handlers<
    R | R1,
    Event.ExcludeTag<Events, Tag>
  >
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/EventLog.ts#L85)

Since v1.0.0
ExecutionPlan-ExecutionPlan.md
Package: `effect`<br />
Module: `ExecutionPlan`<br />

## ExecutionPlan.ExecutionPlan

A `ExecutionPlan` can be used with `Effect.withExecutionPlan` or `Stream.withExecutionPlan`, allowing you to provide different resources for each step of execution until the effect succeeds or the plan is exhausted.

```ts
import { type AiLanguageModel } from "@effect/ai"
import type { Layer } from "effect"
import { Effect, ExecutionPlan, Schedule } from "effect"

declare const layerBad: Layer.Layer<AiLanguageModel.AiLanguageModel>
declare const layerGood: Layer.Layer<AiLanguageModel.AiLanguageModel>

const ThePlan = ExecutionPlan.make(
  {
    // First try with the bad layer 2 times with a 3 second delay between attempts
    provide: layerBad,
    attempts: 2,
    schedule: Schedule.spaced(3000)
  },
  // Then try with the bad layer 3 times with a 1 second delay between attempts
  {
    provide: layerBad,
    attempts: 3,
    schedule: Schedule.spaced(1000)
  },
  // Finally try with the good layer.
  //
  // If `attempts` is omitted, the plan will only attempt once, unless a schedule is provided.
  {
    provide: layerGood
  }
)

declare const effect: Effect.Effect<
  void,
  never,
  AiLanguageModel.AiLanguageModel
>
const withPlan: Effect.Effect<void> = Effect.withExecutionPlan(effect, ThePlan)
```

**Signature**

```ts
export interface ExecutionPlan<
  Types extends {
    provides: any
    input: any
    error: any
    requirements: any
  }
> extends Pipeable {
  readonly [TypeId]: TypeId
  readonly steps: NonEmptyReadonlyArray<{
    readonly provide:
      | Context.Context<Types["provides"]>
      | Layer.Layer<Types["provides"], Types["error"], Types["requirements"]>
    readonly attempts?: number | undefined
    readonly while?:
      | ((input: Types["input"]) => Effect.Effect<boolean, Types["error"], Types["requirements"]>)
      | undefined
    readonly schedule?: Schedule.Schedule<any, Types["input"], Types["requirements"]> | undefined
  }>

  /**
   * Returns an equivalent `ExecutionPlan` with the requirements satisfied,
   * using the current context.
   */
  readonly withRequirements: Effect.Effect<
    ExecutionPlan<{
      provides: Types["provides"]
      input: Types["input"]
      error: Types["error"]
      requirements: never
    }>,
    never,
    Types["requirements"]
  >
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionPlan.ts#L79)

Since v3.16.0
ExecutionPlan-make.md
Package: `effect`<br />
Module: `ExecutionPlan`<br />

## ExecutionPlan.make

Create an `ExecutionPlan`, which can be used with `Effect.withExecutionPlan` or `Stream.withExecutionPlan`, allowing you to provide different resources for each step of execution until the effect succeeds or the plan is exhausted.

```ts
import { type AiLanguageModel } from "@effect/ai"
import type { Layer } from "effect"
import { Effect, ExecutionPlan, Schedule } from "effect"

declare const layerBad: Layer.Layer<AiLanguageModel.AiLanguageModel>
declare const layerGood: Layer.Layer<AiLanguageModel.AiLanguageModel>

const ThePlan = ExecutionPlan.make(
  {
    // First try with the bad layer 2 times with a 3 second delay between attempts
    provide: layerBad,
    attempts: 2,
    schedule: Schedule.spaced(3000)
  },
  // Then try with the bad layer 3 times with a 1 second delay between attempts
  {
    provide: layerBad,
    attempts: 3,
    schedule: Schedule.spaced(1000)
  },
  // Finally try with the good layer.
  //
  // If `attempts` is omitted, the plan will only attempt once, unless a schedule is provided.
  {
    provide: layerGood
  }
)

declare const effect: Effect.Effect<
  void,
  never,
  AiLanguageModel.AiLanguageModel
>
const withPlan: Effect.Effect<void> = Effect.withExecutionPlan(effect, ThePlan)
```

**Signature**

```ts
declare const make: <const Steps extends NonEmptyReadonlyArray<make.Step>>(...steps: Steps & { [K in keyof Steps]: make.Step; }) => ExecutionPlan<{ provides: make.StepProvides<Steps>; input: make.StepInput<Steps>; error: (Steps[number]["provide"] extends Context.Context<infer _P> | Layer.Layer<infer _P, infer E, infer _R> ? E : never) | (Steps[number]["while"] extends (input: infer _I) => Effect.Effect<infer _A, infer _E, infer _R> ? _E : never); requirements: (Steps[number]["provide"] extends Layer.Layer<infer _A, infer _E, infer R> ? R : never) | (Steps[number]["while"] extends (input: infer _I) => Effect.Effect<infer _A, infer _E, infer R> ? R : never) | (Steps[number]["schedule"] extends Schedule.Schedule<infer _O, infer _I, infer R> ? R : never); }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionPlan.ts#L170)

Since v3.16.0
ExecutionStrategy-ExecutionStrategy.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.ExecutionStrategy

Describes a strategy for evaluating multiple effects, potentially in
parallel.

There are 3 possible execution strategies: `Sequential`, `Parallel`,
`ParallelN`.

**Signature**

```ts
type ExecutionStrategy = Sequential | Parallel | ParallelN
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L17)

Since v2.0.0
ExecutionStrategy-Parallel.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.Parallel

Execute effects in parallel.

**Signature**

```ts
export interface Parallel {
  readonly _tag: "Parallel"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L35)

Since v2.0.0
ExecutionStrategy-isParallel.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.isParallel

Returns `true` if the specified `ExecutionStrategy` is an instance of
`Sequential`, `false` otherwise.

**Signature**

```ts
declare const isParallel: (self: ExecutionStrategy) => self is Parallel
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L90)

Since v2.0.0
ExecutionStrategy-isParallelN.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.isParallelN

Returns `true` if the specified `ExecutionStrategy` is an instance of
`Sequential`, `false` otherwise.

**Signature**

```ts
declare const isParallelN: (self: ExecutionStrategy) => self is ParallelN
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L99)

Since v2.0.0
ExecutionStrategy-isSequential.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.isSequential

Returns `true` if the specified `ExecutionStrategy` is an instance of
`Sequential`, `false` otherwise.

**Signature**

```ts
declare const isSequential: (self: ExecutionStrategy) => self is Sequential
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L81)

Since v2.0.0
ExecutionStrategy-match.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.match

Folds over the specified `ExecutionStrategy` using the provided case
functions.

**Signature**

```ts
declare const match: { <A>(options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): (self: ExecutionStrategy) => A; <A>(self: ExecutionStrategy, options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L108)

Since v2.0.0
ExecutionStrategy-parallel.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.parallel

Execute effects in parallel.

**Signature**

```ts
declare const parallel: ExecutionStrategy
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L64)

Since v2.0.0
ExecutionStrategy-parallelN.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.parallelN

Execute effects in parallel, up to the specified number of concurrent fibers.

**Signature**

```ts
declare const parallelN: (parallelism: number) => ExecutionStrategy
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L72)

Since v2.0.0
ExecutionStrategy-ParallelN.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.ParallelN

Execute effects in parallel, up to the specified number of concurrent fibers.

**Signature**

```ts
export interface ParallelN {
  readonly _tag: "ParallelN"
  readonly parallelism: number
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L45)

Since v2.0.0
ExecutionStrategy-Sequential.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.Sequential

Execute effects sequentially.

**Signature**

```ts
export interface Sequential {
  readonly _tag: "Sequential"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L25)

Since v2.0.0
ExecutionStrategy-sequential.md
Package: `effect`<br />
Module: `ExecutionStrategy`<br />

## ExecutionStrategy.sequential

Execute effects sequentially.

**Signature**

```ts
declare const sequential: ExecutionStrategy
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L56)

Since v2.0.0
Exit-Exit.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.Exit

An `Exit<A, E = never>` describes the result of a executing an `Effect` workflow.

There are two possible values for an `Exit<A, E>`:
  - `Exit.Success` contain a success value of type `A`
  - `Exit.Failure` contains a failure `Cause` of type `E`

**Signature**

```ts
type Exit<A, E> = Success<A, E> | Failure<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L26)

Since v2.0.0
Exit-Failure.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.Failure

Represents a failed `Effect` workflow containing the `Cause` of the failure
of type `E`.

**Signature**

```ts
export interface Failure<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {
  readonly _tag: "Failure"
  readonly _op: "Failure"
  readonly cause: Cause.Cause<E>
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: ExitUnify<this>
  [Unify.ignoreSymbol]?: ExitUnifyIgnore
  /** @internal */
  readonly effect_instruction_i0: Cause.Cause<E>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L35)

Since v2.0.0
Exit-Success.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.Success

Represents a successful `Effect` workflow and containing the returned value
of type `A`.

**Signature**

```ts
export interface Success<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {
  readonly _tag: "Success"
  readonly _op: "Success"
  readonly value: A
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: ExitUnify<this>
  [Unify.ignoreSymbol]?: ExitUnifyIgnore
  /** @internal */
  readonly effect_instruction_i0: A
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L69)

Since v2.0.0
Exit-all.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.all

Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If
the provided iterable contains no elements, `None` will be returned.

**Signature**

```ts
declare const all: <A, E>(exits: Iterable<Exit<A, E>>, options?: { readonly parallel?: boolean | undefined; } | undefined) => Option.Option<Exit<Array<A>, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L149)

Since v2.0.0
Exit-as.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.as

Maps the `Success` value of the specified exit to the provided constant
value.

**Signature**

```ts
declare const as: { <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>; <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L120)

Since v2.0.0
Exit-asVoid.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.asVoid

Maps the `Success` value of the specified exit to a void.

**Signature**

```ts
declare const asVoid: <A, E>(self: Exit<A, E>) => Exit<void, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L131)

Since v2.0.0
Exit-causeOption.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.causeOption

Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`
otherwise.

**Signature**

```ts
declare const causeOption: <A, E>(self: Exit<A, E>) => Option.Option<Cause.Cause<E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L140)

Since v2.0.0
Exit-die.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.die

Constructs a new `Exit.Failure` from the specified unrecoverable defect.

**Signature**

```ts
declare const die: (defect: unknown) => Exit<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L160)

Since v2.0.0
Exit-exists.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.exists

Executes the predicate on the value of the specified exit if it is a
`Success`, otherwise returns `false`.

**Signature**

```ts
declare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B>; <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean; <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B>; <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L169)

Since v2.0.0
Exit-fail.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.fail

Constructs a new `Exit.Failure` from the specified recoverable error of type
`E`.

**Signature**

```ts
declare const fail: <E>(error: E) => Exit<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L183)

Since v2.0.0
Exit-failCause.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.failCause

Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Exit<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L191)

Since v2.0.0
Exit-fromEither.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.fromEither

Converts an `Either<R, L>` into an `Exit<R, L>`.

**Signature**

```ts
declare const fromEither: <R, L>(either: Either.Either<R, L>) => Exit<R, L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L234)

Since v2.0.0
Exit-fromOption.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.fromOption

Converts an `Option<A>` into an `Exit<void, A>`.

**Signature**

```ts
declare const fromOption: <A>(option: Option.Option<A>) => Exit<A, void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L242)

Since v2.0.0
Exit-getOrElse.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.getOrElse

Returns the `A` if specified exit is a `Success`, otherwise returns the
alternate `A` value computed from the specified function which receives the
`Cause<E>` of the exit `Failure`.

**Signature**

```ts
declare const getOrElse: { <E, A2>(orElse: (cause: Cause.Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A; <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2): A | A2; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L252)

Since v2.0.0
Exit-interrupt.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.interrupt

Constructs a new `Exit.Failure` from the specified `FiberId` indicating that
the `Fiber` running an `Effect` workflow was terminated due to interruption.

**Signature**

```ts
declare const interrupt: (fiberId: FiberId.FiberId) => Exit<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L264)

Since v2.0.0
Exit-isExit.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.isExit

Returns `true` if the specified value is an `Exit`, `false` otherwise.

**Signature**

```ts
declare const isExit: (u: unknown) => u is Exit<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L86)

Since v2.0.0
Exit-isFailure.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.isFailure

Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.

**Signature**

```ts
declare const isFailure: <A, E>(self: Exit<A, E>) => self is Failure<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L94)

Since v2.0.0
Exit-isInterrupted.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.isInterrupted

Returns `true` if the specified exit is a `Failure` **and** the `Cause` of
the failure was due to interruption, `false` otherwise.

**Signature**

```ts
declare const isInterrupted: <A, E>(self: Exit<A, E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L111)

Since v2.0.0
Exit-isSuccess.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.isSuccess

Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.

**Signature**

```ts
declare const isSuccess: <A, E>(self: Exit<A, E>) => self is Success<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L102)

Since v2.0.0
Exit-map.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.map

Maps over the `Success` value of the specified exit using the provided
function.

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>; <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L273)

Since v2.0.0
Exit-mapBoth.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.mapBoth

Maps over the `Success` and `Failure` cases of the specified exit using the
provided functions.

**Signature**

```ts
declare const mapBoth: { <E, A, E2, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): (self: Exit<A, E>) => Exit<A2, E2>; <A, E, E2, A2>(self: Exit<A, E>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Exit<A2, E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L285)

Since v2.0.0
Exit-mapError.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.mapError

Maps over the error contained in the `Failure` of the specified exit using
the provided function.

**Signature**

```ts
declare const mapError: { <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>; <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L302)

Since v2.0.0
Exit-mapErrorCause.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.mapErrorCause

Maps over the `Cause` contained in the `Failure` of the specified exit using
the provided function.

**Signature**

```ts
declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>; <E, A, E2>(self: Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Exit<A, E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L314)

Since v2.0.0
Exit-succeed.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.succeed

Constructs a new `Exit.Success` containing the specified value of type `A`.

**Signature**

```ts
declare const succeed: <A>(value: A) => Exit<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L359)

Since v2.0.0
Exit-void.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.void

Represents an `Exit` which succeeds with `undefined`.

**Signature**

```ts
declare const void: Exit<void, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L369)

Since v2.0.0
Exit-zip.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.zip

Sequentially zips the this result with the specified result or else returns
the failed `Cause<E | E2>`.

**Signature**

```ts
declare const zip: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L379)

Since v2.0.0
Exit-zipLeft.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.zipLeft

Sequentially zips the this result with the specified result discarding the
second element of the tuple or else returns the failed `Cause<E | E2>`.

**Signature**

```ts
declare const zipLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L391)

Since v2.0.0
Exit-zipPar.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.zipPar

Parallelly zips the this result with the specified result or else returns
the failed `Cause<E | E2>`.

**Signature**

```ts
declare const zipPar: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L415)

Since v2.0.0
Exit-zipParLeft.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.zipParLeft

Parallelly zips the this result with the specified result discarding the
second element of the tuple or else returns the failed `Cause<E | E2>`.

**Signature**

```ts
declare const zipParLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L427)

Since v2.0.0
Exit-zipParRight.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.zipParRight

Parallelly zips the this result with the specified result discarding the
first element of the tuple or else returns the failed `Cause<E | E2>`.

**Signature**

```ts
declare const zipParRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L439)

Since v2.0.0
Exit-zipRight.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.zipRight

Sequentially zips the this result with the specified result discarding the
first element of the tuple or else returns the failed `Cause<E | E2>`.

**Signature**

```ts
declare const zipRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L403)

Since v2.0.0
Exit-zipWith.md
Package: `effect`<br />
Module: `Exit`<br />

## Exit.zipWith

Zips this exit together with that exit using the specified combination
functions.

**Signature**

```ts
declare const zipWith: { <B, E2, A, C, E>(that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<any>; }): (self: Exit<A, E>) => Exit<C, any>; <A, E, B, E2, C>(self: Exit<A, E>, that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>; }): Exit<C, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L451)

Since v2.0.0
Fiber-Fiber.Descriptor.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.Fiber.Descriptor

A record containing information about a `Fiber`.

**Signature**

```ts
export interface Descriptor {
    /**
     * The fiber's unique identifier.
     */
    readonly id: FiberId.FiberId
    /**
     * The status of the fiber.
     */
    readonly status: FiberStatus.FiberStatus
    /**
     * The set of fibers attempting to interrupt the fiber or its ancestors.
     */
    readonly interruptors: HashSet.HashSet<FiberId.FiberId>
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L288)

Since v2.0.0
Fiber-Fiber.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.Fiber

A fiber is a lightweight thread of execution that never consumes more than a
whole thread (but may consume much less, depending on contention and
asynchronicity). Fibers are spawned by forking effects, which run
concurrently with the parent effect.

Fibers can be joined, yielding their result to other fibers, or interrupted,
which terminates the fiber, safely releasing all resources.

**Signature**

```ts
export interface Fiber<out A, out E = never> extends Effect.Effect<A, E>, Fiber.Variance<A, E> {
  /**
   * The identity of the fiber.
   */
  id(): FiberId.FiberId

  /**
   * Awaits the fiber, which suspends the awaiting fiber until the result of the
   * fiber has been determined.
   */
  readonly await: Effect.Effect<Exit.Exit<A, E>>

  /**
   * Retrieves the immediate children of the fiber.
   */
  readonly children: Effect.Effect<Array<Fiber.Runtime<any, any>>>

  /**
   * Inherits values from all `FiberRef` instances into current fiber. This
   * will resume immediately.
   */
  readonly inheritAll: Effect.Effect<void>

  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  readonly poll: Effect.Effect<Option.Option<Exit.Exit<A, E>>>

  /**
   * In the background, interrupts the fiber as if interrupted from the
   * specified fiber. If the fiber has already exited, the returned effect will
   * resume immediately. Otherwise, the effect will resume when the fiber exits.
   */
  interruptAsFork(fiberId: FiberId.FiberId): Effect.Effect<void>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: FiberUnify<this>
  readonly [Unify.ignoreSymbol]?: FiberUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L65)

Since v2.0.0
Fiber-all.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.all

Collects all fibers into a single fiber producing an in-order list of the
results.

**Signature**

```ts
declare const all: <A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<ReadonlyArray<A>, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L378)

Since v2.0.0
Fiber-await.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.await

Awaits the fiber, which suspends the awaiting fiber until the result of the
fiber has been determined.

**Signature**

```ts
declare const await: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L345)

Since v2.0.0
Fiber-awaitAll.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.awaitAll

Awaits on all fibers to be completed, successfully or not.

**Signature**

```ts
declare const awaitAll: <const T extends Iterable<Fiber<any, any>>>(fibers: T) => Effect.Effect<[T] extends [ReadonlyArray<infer U>] ? number extends T["length"] ? Array<U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never> : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never; } : Array<T extends Iterable<infer U> ? U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never : never>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L354)

Since v2.0.0
Fiber-children.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.children

Retrieves the immediate children of the fiber.

**Signature**

```ts
declare const children: <A, E>(self: Fiber<A, E>) => Effect.Effect<Array<RuntimeFiber<any, any>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L369)

Since v2.0.0
Fiber-done.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.done

A fiber that is done with the specified `Exit` value.

**Signature**

```ts
declare const done: <A, E>(exit: Exit.Exit<A, E>) => Fiber<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L386)

Since v2.0.0
Fiber-fail.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.fail

A fiber that has already failed with the specified value.

**Signature**

```ts
declare const fail: <E>(error: E) => Fiber<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L408)

Since v2.0.0
Fiber-failCause.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.failCause

Creates a `Fiber` that has already failed with the specified cause.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Fiber<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L416)

Since v2.0.0
Fiber-fromEffect.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.fromEffect

Lifts an `Effect` into a `Fiber`.

**Signature**

```ts
declare const fromEffect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<Fiber<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L424)

Since v2.0.0
Fiber-getCurrentFiber.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.getCurrentFiber

Gets the current fiber if one is running.

**Signature**

```ts
declare const getCurrentFiber: () => Option.Option<RuntimeFiber<any, any>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L432)

Since v2.0.0
Fiber-id.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.id

The identity of the fiber.

**Signature**

```ts
declare const id: <A, E>(self: Fiber<A, E>) => FiberId.FiberId
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L333)

Since v2.0.0
Fiber-inheritAll.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.inheritAll

Inherits values from all `FiberRef` instances into current fiber. This
will resume immediately.

**Signature**

```ts
declare const inheritAll: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L441)

Since v2.0.0
Fiber-interrupt.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.interrupt

Interrupts the fiber from whichever fiber is calling this method. If the
fiber has already exited, the returned effect will resume immediately.
Otherwise, the effect will resume when the fiber exits.

**Signature**

```ts
declare const interrupt: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L451)

Since v2.0.0
Fiber-RuntimeFiber.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.RuntimeFiber

A runtime fiber that is executing an effect. Runtime fibers have an
identity and a trace.

**Signature**

```ts
export interface RuntimeFiber<out A, out E = never> extends Fiber<A, E>, Fiber.RuntimeVariance<A, E> {
  /**
   * Reads the current number of ops that have occurred since the last yield
   */
  get currentOpCount(): number

  /**
   * Reads the current value of a fiber ref
   */
  getFiberRef<X>(fiberRef: FiberRef<X>): X

  /**
   * The identity of the fiber.
   */
  id(): FiberId.Runtime

  /**
   * The status of the fiber.
   */
  readonly status: Effect.Effect<FiberStatus.FiberStatus>

  /**
   * Returns the current `RuntimeFlags` the fiber is running with.
   */
  readonly runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags>

  /**
   * Adds an observer to the list of observers.
   */
  addObserver(observer: (exit: Exit.Exit<A, E>) => void): void

  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   */
  removeObserver(observer: (exit: Exit.Exit<A, E>) => void): void

  /**
   * Retrieves all fiber refs of the fiber.
   */
  getFiberRefs(): FiberRefs.FiberRefs

  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll(): Exit.Exit<A, E> | null

  /**
   * In the background, interrupts the fiber as if interrupted from the
   * specified fiber. If the fiber has already exited, the returned effect will
   * resume immediately. Otherwise, the effect will resume when the fiber exits.
   */
  unsafeInterruptAsFork(fiberId: FiberId.FiberId): void

  /**
   * Gets the current context
   */
  get currentContext(): Context<never>

  /**
   * Gets the current context
   */
  get currentDefaultServices(): Context<DefaultServices>

  /**
   * Gets the current scheduler
   */
  get currentScheduler(): Scheduler

  /**
   * Gets the current tracer
   */
  get currentTracer(): Tracer

  /**
   * Gets the current span
   */
  get currentSpan(): AnySpan | undefined

  /**
   * Gets the current supervisor
   */
  get currentSupervisor(): Supervisor<unknown>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: RuntimeFiberUnify<this>
  readonly [Unify.ignoreSymbol]?: RuntimeFiberUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L129)

Since v2.0.0
Fiber-interruptAll.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.interruptAll

Interrupts all fibers, awaiting their interruption.

**Signature**

```ts
declare const interruptAll: (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L493)

Since v2.0.0
Fiber-interruptAllAs.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.interruptAllAs

Interrupts all fibers as by the specified fiber, awaiting their
interruption.

**Signature**

```ts
declare const interruptAllAs: { (fiberId: FiberId.FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>; (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId.FiberId): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L502)

Since v2.0.0
Fiber-interruptAs.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.interruptAs

Interrupts the fiber as if interrupted from the specified fiber. If the
fiber has already exited, the returned effect will resume immediately.
Otherwise, the effect will resume when the fiber exits.

**Signature**

```ts
declare const interruptAs: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<Exit.Exit<A, E>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L469)

Since v2.0.0
Fiber-interruptAsFork.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.interruptAsFork

Interrupts the fiber as if interrupted from the specified fiber. If the
fiber has already exited, the returned effect will resume immediately.
Otherwise, the effect will resume when the fiber exits.

**Signature**

```ts
declare const interruptAsFork: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<void>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L482)

Since v2.0.0
Fiber-interruptFork.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.interruptFork

Interrupts the fiber from whichever fiber is calling this method. The
interruption will happen in a separate daemon fiber, and the returned
effect will always resume immediately without waiting.

**Signature**

```ts
declare const interruptFork: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L515)

Since v2.0.0
Fiber-interrupted.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.interrupted

Constructrs a `Fiber` that is already interrupted.

**Signature**

```ts
declare const interrupted: (fiberId: FiberId.FiberId) => Fiber<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L459)

Since v2.0.0
Fiber-isFiber.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.isFiber

Returns `true` if the specified value is a `Fiber`, `false` otherwise.

**Signature**

```ts
declare const isFiber: (u: unknown) => u is Fiber<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L316)

Since v2.0.0
Fiber-isRuntimeFiber.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.isRuntimeFiber

Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`
otherwise.

**Signature**

```ts
declare const isRuntimeFiber: <A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L325)

Since v2.0.0
Fiber-join.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.join

Joins the fiber, which suspends the joining fiber until the result of the
fiber has been determined. Attempting to join a fiber that has erred will
result in a catchable error. Joining an interrupted fiber will result in an
"inner interruption" of this fiber, unlike interruption triggered by
another fiber, "inner interruption" can be caught and recovered.

**Signature**

```ts
declare const join: <A, E>(self: Fiber<A, E>) => Effect.Effect<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L527)

Since v2.0.0
Fiber-joinAll.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.joinAll

Joins all fibers, awaiting their _successful_ completion. Attempting to
join a fiber that has erred will result in a catchable error, _if_ that
error does not result from interruption.

**Signature**

```ts
declare const joinAll: <A, E>(fibers: Iterable<Fiber<A, E>>) => Effect.Effect<Array<A>, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L537)

Since v2.0.0
Fiber-map.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.map

Maps over the value the Fiber computes.

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>; <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L545)

Since v2.0.0
Fiber-mapEffect.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.mapEffect

Effectually maps over the value the fiber computes.

**Signature**

```ts
declare const mapEffect: { <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>): Fiber<A2, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L556)

Since v2.0.0
Fiber-mapFiber.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.mapFiber

Passes the success of this fiber to the specified callback, and continues
with the fiber that it returns.

**Signature**

```ts
declare const mapFiber: { <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect.Effect<Fiber<B, E | E2>>; <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect.Effect<Fiber<B, E | E2>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L568)

Since v2.0.0
Fiber-match.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.match

Folds over the `Fiber` or `RuntimeFiber`.

**Signature**

```ts
declare const match: { <A, E, Z>(options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): (self: Fiber<A, E>) => Z; <A, E, Z>(self: Fiber<A, E>, options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L579)

Since v2.0.0
Fiber-never.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.never

A fiber that never fails or succeeds.

**Signature**

```ts
declare const never: Fiber<never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L601)

Since v2.0.0
Fiber-orElse.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.orElse

Returns a fiber that prefers `this` fiber, but falls back to the `that` one
when `this` one fails. Interrupting the returned fiber will interrupt both
fibers, sequentially, from left to right.

**Signature**

```ts
declare const orElse: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L611)

Since v2.0.0
Fiber-orElseEither.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.orElseEither

Returns a fiber that prefers `this` fiber, but falls back to the `that` one
when `this` one fails. Interrupting the returned fiber will interrupt both
fibers, sequentially, from left to right.

**Signature**

```ts
declare const orElseEither: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either.Either<A2, A>, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either.Either<A2, A>, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L624)

Since v2.0.0
Fiber-poll.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.poll

Tentatively observes the fiber, but returns immediately if it is not
already done.

**Signature**

```ts
declare const poll: <A, E>(self: Fiber<A, E>) => Effect.Effect<Option.Option<Exit.Exit<A, E>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L636)

Since v2.0.0
Fiber-pretty.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.pretty

Pretty-prints a `RuntimeFiber`.

**Signature**

```ts
declare const pretty: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L644)

Since v2.0.0
Fiber-roots.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.roots

Returns a chunk containing all root fibers.

**Signature**

```ts
declare const roots: Effect.Effect<Array<RuntimeFiber<any, any>>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L652)

Since v2.0.0
Fiber-scoped.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.scoped

Converts this fiber into a scoped effect. The fiber is interrupted when the
scope is closed.

**Signature**

```ts
declare const scoped: <A, E>(self: Fiber<A, E>) => Effect.Effect<Fiber<A, E>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L669)

Since v2.0.0
Fiber-status.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.status

Returns the `FiberStatus` of a `RuntimeFiber`.

**Signature**

```ts
declare const status: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<FiberStatus.FiberStatus>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L678)

Since v2.0.0
Fiber-succeed.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.succeed

Returns a fiber that has already succeeded with the specified value.

**Signature**

```ts
declare const succeed: <A>(value: A) => Fiber<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L686)

Since v2.0.0
Fiber-unsafeRoots.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.unsafeRoots

Returns a chunk containing all root fibers.

**Signature**

```ts
declare const unsafeRoots: (_: void) => Array<RuntimeFiber<any, any>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L660)

Since v2.0.0
Fiber-void.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.void

A fiber that has already succeeded with unit.

**Signature**

```ts
declare const void: Fiber<void, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L696)

Since v2.0.0
Fiber-zip.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.zip

Zips this fiber and the specified fiber together, producing a tuple of
their output.

**Signature**

```ts
declare const zip: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L706)

Since v2.0.0
Fiber-zipLeft.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.zipLeft

Same as `zip` but discards the output of that `Fiber`.

**Signature**

```ts
declare const zipLeft: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L717)

Since v2.0.0
Fiber-zipRight.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.zipRight

Same as `zip` but discards the output of this `Fiber`.

**Signature**

```ts
declare const zipRight: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L728)

Since v2.0.0
Fiber-zipWith.md
Package: `effect`<br />
Module: `Fiber`<br />

## Fiber.zipWith

Zips this fiber with the specified fiber, combining their results using the
specified combiner function. Both joins and interruptions are performed in
sequential order from left to right.

**Signature**

```ts
declare const zipWith: { <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>; <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L741)

Since v2.0.0
FiberHandle-awaitEmpty.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.awaitEmpty

Wait for the fiber in the FiberHandle to complete.

**Signature**

```ts
declare const awaitEmpty: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L530)

Since v3.13.0
FiberHandle-get.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.get

Retrieve the fiber from the FiberHandle.

**Signature**

```ts
declare const get: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L303)

Since v2.0.0
FiberHandle-join.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.join

If any of the Fiber's in the handle terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

**Example**

```ts
import { Effect, FiberHandle } from "effect";

Effect.gen(function* (_) {
  const handle = yield* _(FiberHandle.make());
  yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberHandle.join(handle));
});
```

**Signature**

```ts
declare const join: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L521)

Since v2.0.0
FiberHandle-make.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.make

A FiberHandle can be used to store a single fiber.
When the associated Scope is closed, the contained fiber will be interrupted.

You can add a fiber to the handle using `FiberHandle.run`, and the fiber will
be automatically removed from the FiberHandle when it completes.

**Example**

```ts
import { Effect, FiberHandle } from "effect"

Effect.gen(function*() {
  const handle = yield* FiberHandle.make()

  // run some effects
  yield* FiberHandle.run(handle, Effect.never)
  // this will interrupt the previous fiber
  yield* FiberHandle.run(handle, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)
```

**Signature**

```ts
declare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberHandle<A, E>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L110)

Since v2.0.0
FiberHandle-makeRuntime.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.makeRuntime

Create an Effect run function that is backed by a FiberHandle.

**Signature**

```ts
declare const makeRuntime: <R, E = unknown, A = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L133)

Since v2.0.0
FiberHandle-makeRuntimePromise.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.makeRuntimePromise

Create an Effect run function that is backed by a FiberHandle.

**Signature**

```ts
declare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Promise<XA>), never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L156)

Since v3.13.0
FiberHandle-run.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.run

Run an Effect and add the forked fiber to the FiberHandle.
When the fiber completes, it will be removed from the FiberHandle.

**Signature**

```ts
declare const run: { <A, E>(self: FiberHandle<A, E>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberHandle<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L344)

Since v2.0.0
FiberHandle-runtime.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.runtime

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.

**Example**

```ts
import { Context, Effect, FiberHandle } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const handle = yield* FiberHandle.make()
  const run = yield* FiberHandle.runtime(handle)<Users>()

  // run an effect and set the fiber in the handle
  run(Effect.andThen(Users, _ => _.getAll))

  // this will interrupt the previous fiber
  run(Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)
```

**Signature**

```ts
declare const runtime: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L422)

Since v2.0.0
FiberHandle-runtimePromise.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.runtimePromise

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.

The returned run function will return Promise's that will resolve when the
fiber completes.

**Signature**

```ts
declare const runtimePromise: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L471)

Since v3.13.0
FiberHandle-set.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.set

Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.
If a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.

**Signature**

```ts
declare const set: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): (self: FiberHandle<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberHandle<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L253)

Since v2.0.0
FiberHandle-unsafeGet.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.unsafeGet

Retrieve the fiber from the FiberHandle.

**Signature**

```ts
declare const unsafeGet: <A, E>(self: FiberHandle<A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L294)

Since v2.0.0
FiberHandle-unsafeSet.md
Package: `effect`<br />
Module: `FiberHandle`<br />

## FiberHandle.unsafeSet

Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.
If a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.

**Signature**

```ts
declare const unsafeSet: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): (self: FiberHandle<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberHandle<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L187)

Since v2.0.0
FiberId-combine.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.combine

Combine two `FiberId`s.

**Signature**

```ts
declare const combine: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L124)

Since v2.0.0
FiberId-combineAll.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.combineAll

Combines a set of `FiberId`s into a single `FiberId`.

**Signature**

```ts
declare const combineAll: (fiberIds: HashSet.HashSet<FiberId>) => FiberId
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L135)

Since v2.0.0
FiberId-getOrElse.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.getOrElse

Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.

**Signature**

```ts
declare const getOrElse: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L143)

Since v2.0.0
FiberId-ids.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.ids

Get the set of identifiers for this `FiberId`.

**Signature**

```ts
declare const ids: (self: FiberId) => HashSet.HashSet<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L154)

Since v2.0.0
FiberId-isComposite.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.isComposite

Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.

**Signature**

```ts
declare const isComposite: (self: FiberId) => self is Composite
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L116)

Since v2.0.0
FiberId-isFiberId.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.isFiberId

Returns `true` if the specified unknown value is a `FiberId`, `false`
otherwise.

**Signature**

```ts
declare const isFiberId: (self: unknown) => self is FiberId
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L92)

Since v2.0.0
FiberId-isNone.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.isNone

Returns `true` if the `FiberId` is a `None`, `false` otherwise.

**Signature**

```ts
declare const isNone: (self: FiberId) => self is None
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L100)

Since v2.0.0
FiberId-isRuntime.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.isRuntime

Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.

**Signature**

```ts
declare const isRuntime: (self: FiberId) => self is Runtime
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L108)

Since v2.0.0
FiberId-make.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.make

Creates a new `FiberId`.

**Signature**

```ts
declare const make: (id: number, startTimeSeconds: number) => FiberId
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L162)

Since v2.0.0
FiberId-threadName.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.threadName

Creates a string representing the name of the current thread of execution
represented by the specified `FiberId`.

**Signature**

```ts
declare const threadName: (self: FiberId) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L171)

Since v2.0.0
FiberId-toOption.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.toOption

Convert a `FiberId` into an `Option<FiberId>`.

**Signature**

```ts
declare const toOption: (self: FiberId) => Option.Option<FiberId>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L179)

Since v2.0.0
FiberId-toSet.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.toSet

Convert a `FiberId` into a `HashSet<FiberId>`.

**Signature**

```ts
declare const toSet: (self: FiberId) => HashSet.HashSet<Runtime>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L187)

Since v2.0.0
FiberId-unsafeMake.md
Package: `effect`<br />
Module: `FiberId`<br />

## FiberId.unsafeMake

Unsafely creates a new `FiberId`.

**Signature**

```ts
declare const unsafeMake: (_: void) => Runtime
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L195)

Since v2.0.0
FiberMap-awaitEmpty.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.awaitEmpty

Wait for the FiberMap to be empty.

**Signature**

```ts
declare const awaitEmpty: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L647)

Since v3.13.0
FiberMap-get.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.get

Retrieve a fiber from the FiberMap.

**Signature**

```ts
declare const get: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L344)

Since v2.0.0
FiberMap-has.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.has

Check if a key exists in the FiberMap.

**Signature**

```ts
declare const has: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<boolean>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L378)

Since v2.0.0
FiberMap-join.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.join

Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

**Example**

```ts
import { Effect, FiberMap } from "effect";

Effect.gen(function* (_) {
  const map = yield* _(FiberMap.make());
  yield* _(FiberMap.set(map, "a", Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberMap.join(map));
});
```

**Signature**

```ts
declare const join: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L638)

Since v2.0.0
FiberMap-make.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.make

A FiberMap can be used to store a collection of fibers, indexed by some key.
When the associated Scope is closed, all fibers in the map will be interrupted.

You can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will
be automatically removed from the FiberMap when they complete.

**Example**

```ts
import { Effect, FiberMap } from "effect"

Effect.gen(function*() {
  const map = yield* FiberMap.make<string>()

  // run some effects and add the fibers to the map
  yield* FiberMap.run(map, "fiber a", Effect.never)
  yield* FiberMap.run(map, "fiber b", Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
declare const make: <K, A = unknown, E = unknown>() => Effect.Effect<FiberMap<K, A, E>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L120)

Since v2.0.0
FiberMap-makeRuntime.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.makeRuntime

Create an Effect run function that is backed by a FiberMap.

**Signature**

```ts
declare const makeRuntime: <R, K, E = unknown, A = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L147)

Since v2.0.0
FiberMap-makeRuntimePromise.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.makeRuntimePromise

Create an Effect run function that is backed by a FiberMap.

**Signature**

```ts
declare const makeRuntimePromise: <R, K, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Promise<XA>), never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L171)

Since v3.13.0
FiberMap-remove.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.remove

Remove a fiber from the FiberMap, interrupting it if it exists.

**Signature**

```ts
declare const remove: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L392)

Since v2.0.0
FiberMap-run.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.run

Run an Effect and add the forked fiber to the FiberMap.
When the fiber completes, it will be removed from the FiberMap.

**Signature**

```ts
declare const run: { <K, A, E>(self: FiberMap<K, A, E>, key: K, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <K, A, E, R, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L448)

Since v2.0.0
FiberMap-runtime.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.runtime

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.

**Example**

```ts
import { Context, Effect, FiberMap } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const map = yield* FiberMap.make<string>()
  const run = yield* FiberMap.runtime(map)<Users>()

  // run some effects and add the fibers to the map
  run("effect-a", Effect.andThen(Users, _ => _.getAll))
  run("effect-b", Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
declare const runtime: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L528)

Since v2.0.0
FiberMap-runtimePromise.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.runtimePromise

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.

**Signature**

```ts
declare const runtimePromise: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L576)

Since v3.13.0
FiberMap-set.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.set

Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.
If the key already exists in the FiberMap, the previous fiber will be interrupted.

**Signature**

```ts
declare const set: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L282)

Since v2.0.0
FiberMap-unsafeGet.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.unsafeGet

Retrieve a fiber from the FiberMap.

**Signature**

```ts
declare const unsafeGet: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Option.Option<Fiber.RuntimeFiber<A, E>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L325)

Since v2.0.0
FiberMap-unsafeHas.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.unsafeHas

Check if a key exists in the FiberMap.

**Signature**

```ts
declare const unsafeHas: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => boolean; <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L363)

Since v2.0.0
FiberMap-unsafeSet.md
Package: `effect`<br />
Module: `FiberMap`<br />

## FiberMap.unsafeSet

Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.
If the key already exists in the FiberMap, the previous fiber will be interrupted.

**Signature**

```ts
declare const unsafeSet: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => void; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L207)

Since v2.0.0
FiberRefs-FiberRefs.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.FiberRefs

`FiberRefs` is a data type that represents a collection of `FiberRef` values.

This allows safely propagating `FiberRef` values across fiber boundaries, for
example between an asynchronous producer and consumer.

**Signature**

```ts
export interface FiberRefs extends Pipeable {
  readonly [FiberRefsSym]: FiberRefsSym
  readonly locals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L34)

Since v2.0.0
FiberRefs-delete.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.delete

Deletes the specified `FiberRef` from the `FibterRefs`.

**Signature**

```ts
declare const delete: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => FiberRefs; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): FiberRefs; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L51)

Since v2.0.0
FiberRefs-empty.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.empty

The empty collection of `FiberRef` values.

**Signature**

```ts
declare const empty: () => FiberRefs
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L204)

Since v2.0.0
FiberRefs-fiberRefs.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.fiberRefs

Returns a set of each `FiberRef` in this collection.

**Signature**

```ts
declare const fiberRefs: (self: FiberRefs) => HashSet.HashSet<FiberRef.FiberRef<any>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L60)

Since v2.0.0
FiberRefs-forkAs.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.forkAs

Forks this collection of fiber refs as the specified child fiber id. This
will potentially modify the value of the fiber refs, as determined by the
individual fiber refs that make up the collection.

**Signature**

```ts
declare const forkAs: { (childId: FiberId.Single): (self: FiberRefs) => FiberRefs; (self: FiberRefs, childId: FiberId.Single): FiberRefs; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L70)

Since v2.0.0
FiberRefs-get.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.get

Gets the value of the specified `FiberRef` in this collection of `FiberRef`
values if it exists or `None` otherwise.

**Signature**

```ts
declare const get: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => Option.Option<A>; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): Option.Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L82)

Since v2.0.0
FiberRefs-getOrDefault.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.getOrDefault

Gets the value of the specified `FiberRef` in this collection of `FiberRef`
values if it exists or the `initial` value of the `FiberRef` otherwise.

**Signature**

```ts
declare const getOrDefault: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => A; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L94)

Since v2.0.0
FiberRefs-joinAs.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.joinAs

Joins this collection of fiber refs to the specified collection, as the
specified fiber id. This will perform diffing and merging to ensure
preservation of maximum information from both child and parent refs.

**Signature**

```ts
declare const joinAs: { (fiberId: FiberId.Single, that: FiberRefs): (self: FiberRefs) => FiberRefs; (self: FiberRefs, fiberId: FiberId.Single, that: FiberRefs): FiberRefs; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L107)

Since v2.0.0
FiberRefs-setAll.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.setAll

Set each ref to either its value or its default.

**Signature**

```ts
declare const setAll: (self: FiberRefs) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L118)

Since v2.0.0
FiberRefs-unsafeMake.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.unsafeMake

Note: it will not copy the provided Map, make sure to provide a fresh one.

**Signature**

```ts
declare const unsafeMake: (fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>) => FiberRefs
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L194)

Since v2.0.0
FiberRefs-updateAs.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.updateAs

Updates the value of the specified `FiberRef` using the provided `FiberId`

**Signature**

```ts
declare const updateAs: { <A>(options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): (self: FiberRefs) => FiberRefs; <A>(self: FiberRefs, options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): FiberRefs; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L126)

Since v2.0.0
FiberRefs-updateManyAs.md
Package: `effect`<br />
Module: `FiberRefs`<br />

## FiberRefs.updateManyAs

Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`

**Signature**

```ts
declare const updateManyAs: { (options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): (self: FiberRefs) => FiberRefs; (self: FiberRefs, options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): FiberRefs; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L150)

Since v2.0.0
FiberRefsPatch-FiberRefsPatch.md
Package: `effect`<br />
Module: `FiberRefsPatch`<br />

## FiberRefsPatch.FiberRefsPatch

A `FiberRefsPatch` captures the changes in `FiberRef` values made by a single
fiber as a value. This allows fibers to apply the changes made by a workflow
without inheriting all the `FiberRef` values of the fiber that executed the
workflow.

**Signature**

```ts
type FiberRefsPatch = Empty | Add | Remove | Update | AndThen
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L18)

Since v2.0.0
FiberRefsPatch-combine.md
Package: `effect`<br />
Module: `FiberRefsPatch`<br />

## FiberRefsPatch.combine

Combines this patch and the specified patch to create a new patch that
describes applying the changes from this patch and the specified patch
sequentially.

**Signature**

```ts
declare const combine: { (that: FiberRefsPatch): (self: FiberRefsPatch) => FiberRefsPatch; (self: FiberRefsPatch, that: FiberRefsPatch): FiberRefsPatch; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L90)

Since v2.0.0
FiberRefsPatch-diff.md
Package: `effect`<br />
Module: `FiberRefsPatch`<br />

## FiberRefsPatch.diff

Constructs a patch that describes the changes between the specified
collections of `FiberRef`

**Signature**

```ts
declare const diff: (oldValue: FiberRefs.FiberRefs, newValue: FiberRefs.FiberRefs) => FiberRefsPatch
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L80)

Since v2.0.0
FiberRefsPatch-patch.md
Package: `effect`<br />
Module: `FiberRefsPatch`<br />

## FiberRefsPatch.patch

Applies the changes described by this patch to the specified collection
of `FiberRef` values.

**Signature**

```ts
declare const patch: { (fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): (self: FiberRefsPatch) => FiberRefs.FiberRefs; (self: FiberRefsPatch, fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): FiberRefs.FiberRefs; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L102)

Since v2.0.0
FiberSet-add.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.add

Add a fiber to the FiberSet. When the fiber completes, it will be removed.

**Signature**

```ts
declare const add: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L242)

Since v2.0.0
FiberSet-awaitEmpty.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.awaitEmpty

Wait until the fiber set is empty.

**Signature**

```ts
declare const awaitEmpty: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L486)

Since v3.13.0
FiberSet-join.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.join

Join all fibers in the FiberSet. If any of the Fiber's in the set terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

**Example**

```ts
import { Effect, FiberSet } from "effect";

Effect.gen(function* (_) {
  const set = yield* _(FiberSet.make());
  yield* _(FiberSet.add(set, Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberSet.join(set));
});
```

**Signature**

```ts
declare const join: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L477)

Since v2.0.0
FiberSet-make.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.make

A FiberSet can be used to store a collection of fibers.
When the associated Scope is closed, all fibers in the set will be interrupted.

You can add fibers to the set using `FiberSet.add` or `FiberSet.run`, and the fibers will
be automatically removed from the FiberSet when they complete.

**Example**

```ts
import { Effect, FiberSet } from "effect"

Effect.gen(function*() {
  const set = yield* FiberSet.make()

  // run some effects and add the fibers to the set
  yield* FiberSet.run(set, Effect.never)
  yield* FiberSet.run(set, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
declare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberSet<A, E>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L117)

Since v2.0.0
FiberSet-makeRuntime.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.makeRuntime

Create an Effect run function that is backed by a FiberSet.

**Signature**

```ts
declare const makeRuntime: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L138)

Since v2.0.0
FiberSet-makeRuntimePromise.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.makeRuntimePromise

Create an Effect run function that is backed by a FiberSet.

**Signature**

```ts
declare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Promise<XA>), never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L157)

Since v3.13.0
FiberSet-run.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.run

Fork an Effect and add the forked fiber to the FiberSet.
When the fiber completes, it will be removed from the FiberSet.

**Signature**

```ts
declare const run: { <A, E>(self: FiberSet<A, E>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberSet<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L306)

Since v2.0.0
FiberSet-runtime.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.runtime

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.

**Example**

```ts
import { Context, Effect, FiberSet } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const set = yield* FiberSet.make()
  const run = yield* FiberSet.runtime(set)<Users>()

  // run some effects and add the fibers to the set
  run(Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
declare const runtime: <A, E>(self: FiberSet<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L380)

Since v2.0.0
FiberSet-runtimePromise.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.runtimePromise

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.

The returned run function will return Promise's.

**Signature**

```ts
declare const runtimePromise: <A, E>(self: FiberSet<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L420)

Since v3.13.0
FiberSet-unsafeAdd.md
Package: `effect`<br />
Module: `FiberSet`<br />

## FiberSet.unsafeAdd

Add a fiber to the FiberSet. When the fiber completes, it will be removed.

**Signature**

```ts
declare const unsafeAdd: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L187)

Since v2.0.0
FiberStatus-isDone.md
Package: `effect`<br />
Module: `FiberStatus`<br />

## FiberStatus.isDone

Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.

**Signature**

```ts
declare const isDone: (self: FiberStatus) => self is Done
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L90)

Since v2.0.0
FiberStatus-isFiberStatus.md
Package: `effect`<br />
Module: `FiberStatus`<br />

## FiberStatus.isFiberStatus

Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.

**Signature**

```ts
declare const isFiberStatus: (u: unknown) => u is FiberStatus
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L82)

Since v2.0.0
FiberStatus-isRunning.md
Package: `effect`<br />
Module: `FiberStatus`<br />

## FiberStatus.isRunning

Returns `true` if the specified `FiberStatus` is `Running`, `false`
otherwise.

**Signature**

```ts
declare const isRunning: (self: FiberStatus) => self is Running
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L99)

Since v2.0.0
FiberStatus-isSuspended.md
Package: `effect`<br />
Module: `FiberStatus`<br />

## FiberStatus.isSuspended

Returns `true` if the specified `FiberStatus` is `Suspended`, `false`
otherwise.

**Signature**

```ts
declare const isSuspended: (self: FiberStatus) => self is Suspended
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L108)

Since v2.0.0
FileSystem-Size.md
Package: `@effect/platform`<br />
Module: `FileSystem`<br />

## FileSystem.Size

Represents a size in bytes.

**Signature**

```ts
type Size = Brand.Branded<bigint, "Size">
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/FileSystem.ts#L260)

Since v1.0.0
FileSystem-SizeInput.md
Package: `@effect/platform`<br />
Module: `FileSystem`<br />

## FileSystem.SizeInput

Represents a size in bytes.

**Signature**

```ts
type SizeInput = bigint | number | Size
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/FileSystem.ts#L268)

Since v1.0.0
FileSystem-layerNoop.md
Package: `@effect/platform`<br />
Module: `FileSystem`<br />

## FileSystem.layerNoop

Create a no-op file system that can be used for testing.

**Signature**

```ts
declare const layerNoop: (fileSystem: Partial<FileSystem>) => Layer<FileSystem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/FileSystem.ts#L463)

Since v1.0.0
FileSystem-makeNoop.md
Package: `@effect/platform`<br />
Module: `FileSystem`<br />

## FileSystem.makeNoop

Create a no-op file system that can be used for testing.

**Signature**

```ts
declare const makeNoop: (fileSystem: Partial<FileSystem>) => FileSystem
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/FileSystem.ts#L455)

Since v1.0.0
Filterable-filterMapComposition.md
Package: `@effect/typeclass`<br />
Module: `Filterable`<br />

## Filterable.filterMapComposition

Returns a default binary `filterMap` composition.

**Signature**

```ts
declare const filterMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Option.Option<B>) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Filterable.ts#L60)

Since v0.24.0
Filterable-partitionMapComposition.md
Package: `@effect/typeclass`<br />
Module: `Filterable`<br />

## Filterable.partitionMapComposition

Returns a default binary `partitionMap` composition.

**Signature**

```ts
declare const partitionMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B, C>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Either.Either<C, B>) => [Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>, Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, C>>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Filterable.ts#L40)

Since v0.24.0
FlatMap-zipRight.md
Package: `@effect/typeclass`<br />
Module: `FlatMap`<br />

## FlatMap.zipRight

A variant of `flatMap` that ignores the value produced by this effect.

**Signature**

```ts
declare const zipRight: <F extends TypeLambda>(F: FlatMap<F>) => { <R2, O2, E2, B>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1, _>(self: Kind<F, R1, O1, E1, _>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, B>; <R1, O1, E1, _, R2, O2, E2, B>(self: Kind<F, R1, O1, E1, _>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/FlatMap.ts#L36)

Since v0.24.0
Flatten-AlreadyFlat.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.AlreadyFlat

Represents a `FlattenResult` where the input was already flat.

**Signature**

```ts
export interface AlreadyFlat<A> extends Flatten.Variance<A> {
  readonly _tag: "AlreadyFlat"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L79)

Since v1.0.0
Flatten-Flatten.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.Flatten

Because certain documents do not change after removal of newlines, etc, there
is no point in creating a `Union` of the flattened and unflattened versions.
All this leads to is the introduction of two possible branches for a layout
algorithm to take, resulting in potentially exponential behavior on deeply
nested examples.

**Signature**

```ts
type Flatten<A> = Flattened<A> | AlreadyFlat<A> | NeverFlat<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L32)

Since v1.0.0
Flatten-Flattened.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.Flattened

Represents a `FlattenResult` where `A` is likely flatter than the input.

**Signature**

```ts
export interface Flattened<A> extends Flatten.Variance<A> {
  readonly _tag: "Flattened"
  readonly value: A
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L68)

Since v1.0.0
Flatten-NeverFlat.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.NeverFlat

Represents a `FlattenResult` where the input cannot be flattened.

**Signature**

```ts
export interface NeverFlat<A> extends Flatten.Variance<A> {
  readonly _tag: "NeverFlat"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L89)

Since v1.0.0
Flatten-isAlreadyFlat.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.isAlreadyFlat

Returns `true` if the specified `Flatten` is an `AlreadyFlat`, `false` otherwise.

**Signature**

```ts
declare const isAlreadyFlat: <A>(a: Flatten<A>) => a is AlreadyFlat<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L119)

Since v1.0.0
Flatten-isFlatten.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.isFlatten

Returns `true` if the specified value is a `Flatten`, `false` otherwise.

**Signature**

```ts
declare const isFlatten: (u: unknown) => u is Flatten<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L103)

Since v1.0.0
Flatten-isFlattened.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.isFlattened

Returns `true` if the specified `Flatten` is a `Flattened`, `false` otherwise.

**Signature**

```ts
declare const isFlattened: <A>(a: Flatten<A>) => a is Flattened<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L111)

Since v1.0.0
Flatten-isNeverFlat.md
Package: `@effect/printer`<br />
Module: `Flatten`<br />

## Flatten.isNeverFlat

Returns `true` if the specified `Flatten` is a `NeverFlat`, `false` otherwise.

**Signature**

```ts
declare const isNeverFlat: <A>(a: Flatten<A>) => a is NeverFlat<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Flatten.ts#L127)

Since v1.0.0
Foldable-reduceComposition.md
Package: `@effect/typeclass`<br />
Module: `Foldable`<br />

## Foldable.reduceComposition

Returns a default ternary `reduce` composition.

**Signature**

```ts
declare const reduceComposition: <F extends TypeLambda, G extends TypeLambda>(F: Foldable<F>, G: Foldable<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, b: B, f: (b: B, a: A) => B) => B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Foldable.ts#L27)

Since v0.24.0
Function-LazyArg.md
Package: `effect`<br />
Module: `Function`<br />

## Function.LazyArg

A lazy argument.

**Example**

```ts
import * as assert from "node:assert"
import { LazyArg, constant } from "effect/Function"

const constNull: LazyArg<null> = constant(null)
```

**Signature**

```ts
export interface LazyArg<A> {
  (): A
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L202)

Since v2.0.0
Function-SK.md
Package: `effect`<br />
Module: `Function`<br />

## Function.SK

The SK combinator, also known as the "S-K combinator" or "S-combinator", is a fundamental combinator in the
lambda calculus and the SKI combinator calculus.

This function is useful for discarding the first argument passed to it and returning the second argument.

**Example**

```ts
import * as assert from "node:assert"
import { SK } from "effect/Function";

assert.deepStrictEqual(SK(0, "hello"), "hello")
```

**Signature**

```ts
declare const SK: <A, B>(_: A, b: B) => B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L1222)

Since v2.0.0
Function-absurd.md
Package: `effect`<br />
Module: `Function`<br />

## Function.absurd

The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,
meaning that it should be impossible for this code to be executed.

This function is particularly useful when it's necessary to specify that certain cases are impossible.

**Signature**

```ts
declare const absurd: <A>(_: never) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L420)

Since v2.0.0
Function-apply.md
Package: `effect`<br />
Module: `Function`<br />

## Function.apply

Apply a function to given values.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, apply } from "effect/Function"
import { length } from "effect/String"

assert.deepStrictEqual(pipe(length, apply("hello")), 5)
```

**Signature**

```ts
declare const apply: <A extends ReadonlyArray<unknown>>(...a: A) => <B>(self: (...a: A) => B) => B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L187)

Since v2.0.0
Function-compose.md
Package: `effect`<br />
Module: `Function`<br />

## Function.compose

Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.

**Example**

```ts
import * as assert from "node:assert"
import { compose } from "effect/Function"

const increment = (n: number) => n + 1;
const square = (n: number) => n * n;

assert.strictEqual(compose(increment, square)(2), 9);
```

**Signature**

```ts
declare const compose: { <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C; <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L407)

Since v2.0.0
Function-constFalse.md
Package: `effect`<br />
Module: `Function`<br />

## Function.constFalse

A thunk that returns always `false`.

**Example**

```ts
import * as assert from "node:assert"
import { constFalse } from "effect/Function"

assert.deepStrictEqual(constFalse(), false)
```

**Signature**

```ts
declare const constFalse: LazyArg<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L322)

Since v2.0.0
Function-constNull.md
Package: `effect`<br />
Module: `Function`<br />

## Function.constNull

A thunk that returns always `null`.

**Example**

```ts
import * as assert from "node:assert"
import { constNull } from "effect/Function"

assert.deepStrictEqual(constNull(), null)
```

**Signature**

```ts
declare const constNull: LazyArg<null>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L337)

Since v2.0.0
Function-constTrue.md
Package: `effect`<br />
Module: `Function`<br />

## Function.constTrue

A thunk that returns always `true`.

**Example**

```ts
import * as assert from "node:assert"
import { constTrue } from "effect/Function"

assert.deepStrictEqual(constTrue(), true)
```

**Signature**

```ts
declare const constTrue: LazyArg<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L307)

Since v2.0.0
Function-constUndefined.md
Package: `effect`<br />
Module: `Function`<br />

## Function.constUndefined

A thunk that returns always `undefined`.

**Example**

```ts
import * as assert from "node:assert"
import { constUndefined } from "effect/Function"

assert.deepStrictEqual(constUndefined(), undefined)
```

**Signature**

```ts
declare const constUndefined: LazyArg<undefined>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L352)

Since v2.0.0
Function-constVoid.md
Package: `effect`<br />
Module: `Function`<br />

## Function.constVoid

A thunk that returns always `void`.

**Example**

```ts
import * as assert from "node:assert"
import { constVoid } from "effect/Function"

assert.deepStrictEqual(constVoid(), undefined)
```

**Signature**

```ts
declare const constVoid: LazyArg<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L367)

Since v2.0.0
Function-constant.md
Package: `effect`<br />
Module: `Function`<br />

## Function.constant

Creates a constant value that never changes.

This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)
and want that inner function to always use the same value, no matter how many times it is called.

**Example**

```ts
import * as assert from "node:assert"
import { constant } from "effect/Function"

const constNull = constant(null)

assert.deepStrictEqual(constNull(), null)
assert.deepStrictEqual(constNull(), null)
```

**Signature**

```ts
declare const constant: <A>(value: A) => LazyArg<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L292)

Since v2.0.0
Function-dual.md
Package: `effect`<br />
Module: `Function`<br />

## Function.dual

Creates a function that can be used in a data-last (aka `pipe`able) or
data-first style.

The first parameter to `dual` is either the arity of the uncurried function
or a predicate that determines if the function is being used in a data-first
or data-last style.

Using the arity is the most common use case, but there are some cases where
you may want to use a predicate. For example, if you have a function that
takes an optional argument, you can use a predicate to determine if the
function is being used in a data-first or data-last style.

You can pass either the arity of the uncurried function or a predicate
which determines if the function is being used in a data-first or
data-last style.

**Example** (Using arity to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(2, (self, that) => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using call signatures to define the overloads)

```ts
import { dual, pipe } from "effect/Function"

const sum: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(2, (self: number, that: number): number => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using a predicate to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(
  (args) => args.length === 2,
  (self, that) => self + that
)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Signature**

```ts
declare const dual: { <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>["length"], body: DataFirst): DataLast & DataFirst; <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L95)

Since v2.0.0
Function-flip.md
Package: `effect`<br />
Module: `Function`<br />

## Function.flip

Reverses the order of arguments for a curried function.

**Example**

```ts
import * as assert from "node:assert"
import { flip } from "effect/Function"

const f = (a: number) => (b: string) => a - b.length

assert.deepStrictEqual(flip(f)('aaa')(2), -1)
```

**Signature**

```ts
declare const flip: <A extends Array<unknown>, B extends Array<unknown>, C>(f: (...a: A) => (...b: B) => C) => (...b: B) => (...a: A) => C
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L384)

Since v2.0.0
Function-flow.md
Package: `effect`<br />
Module: `Function`<br />

## Function.flow

Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.

See also [`pipe`](#pipe).

**Example**

```ts
import * as assert from "node:assert"
import { flow } from "effect/Function"

const len = (s: string): number => s.length
const double = (n: number): number => n * 2

const f = flow(len, double)

assert.strictEqual(f('aaa'), 6)
```

**Signature**

```ts
declare const flow: { <A extends ReadonlyArray<unknown>, B = never>(ab: (...a: A) => B): (...a: A) => B; <A extends ReadonlyArray<unknown>, B = never, C = never>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): (...a: A) => E; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): (...a: A) => F; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): (...a: A) => G; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): (...a: A) => H; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): (...a: A) => I; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): (...a: A) => J; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L1149)

Since v2.0.0
Function-hole.md
Package: `effect`<br />
Module: `Function`<br />

## Function.hole

Type hole simulation.

**Signature**

```ts
declare const hole: <T>() => T
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L1204)

Since v2.0.0
Function-identity.md
Package: `effect`<br />
Module: `Function`<br />

## Function.identity

The identity function, i.e. A function that returns its input argument.

**Example**

```ts
import * as assert from "node:assert"
import { identity } from "effect/Function"

assert.deepStrictEqual(identity(5), 5)
```

**Signature**

```ts
declare const identity: <A>(a: A) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L234)

Since v2.0.0
Function-isFunction.md
Package: `effect`<br />
Module: `Function`<br />

## Function.isFunction

Tests if a value is a `function`.

**Example**

```ts
import * as assert from "node:assert"
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)
assert.deepStrictEqual(isFunction("function"), false)
```

**Signature**

```ts
declare const isFunction: (input: unknown) => input is Function
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L29)

Since v2.0.0
Function-pipe.md
Package: `effect`<br />
Module: `Function`<br />

## Function.pipe

Pipes the value of an expression into a pipeline of functions.

**Details**

The `pipe` function is a utility that allows us to compose functions in a
readable and sequential manner. It takes the output of one function and
passes it as the input to the next function in the pipeline. This enables us
to build complex transformations by chaining multiple functions together.

```ts
import { pipe } from "effect"

const result = pipe(input, func1, func2, ..., funcN)
```

In this syntax, `input` is the initial value, and `func1`, `func2`, ...,
`funcN` are the functions to be applied in sequence. The result of each
function becomes the input for the next function, and the final result is
returned.

Here's an illustration of how `pipe` works:

```
                    
 input  func1  func2   ...   funcN  result 
                    
```

It's important to note that functions passed to `pipe` must have a **single
argument** because they are only called with a single argument.

**When to Use**

This is useful in combination with data-last functions as a simulation of
methods:

```ts
as.map(f).filter(g)
```

becomes:

```ts
import { pipe, Array } from "effect"

pipe(as, Array.map(f), Array.filter(g))
```

**Example** (Chaining Arithmetic Operations)

```ts
import { pipe } from "effect"

// Define simple arithmetic operations
const increment = (x: number) => x + 1
const double = (x: number) => x * 2
const subtractTen = (x: number) => x - 10

// Sequentially apply these operations using `pipe`
const result = pipe(5, increment, double, subtractTen)

console.log(result)
// Output: 2
```

**Signature**

```ts
declare const pipe: { <A>(a: A): A; <A, B = never>(a: A, ab: (a: A) => B): B; <A, B = never, C = never>(a: A, ab: (a: A) => B, bc: (b: B) => C): C; <A, B = never, C = never, D = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D; <A, B = never, C = never, D = never, E = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): E; <A, B = never, C = never, D = never, E = never, F = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): F; <A, B = never, C = never, D = never, E = never, F = never, G = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): G; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): H; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): I; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): J; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K): K; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L): L; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M): M; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N): N; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O): O; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P): P; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q): Q; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R): R; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S): S; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never, T = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S, st: (s: S) => T): T; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L974)

Since v2.0.0
Function-satisfies.md
Package: `effect`<br />
Module: `Function`<br />

## Function.satisfies

A function that ensures that the type of an expression matches some type,
without changing the resulting type of that expression.

**Example**

```ts
import * as assert from "node:assert"
import { satisfies } from "effect/Function"

const test1 = satisfies<number>()(5 as const)
    //^? const test: 5
    // @ts-expect-error
const test2 = satisfies<string>()(5)
    //^? Argument of type 'number' is not assignable to parameter of type 'string'

assert.deepStrictEqual(satisfies<number>()(5), 5)
```

**Signature**

```ts
declare const satisfies: <A>() => <B extends A>(b: B) => B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L256)

Since v2.0.0
Function-tupled.md
Package: `effect`<br />
Module: `Function`<br />

## Function.tupled

Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.

**Example**

```ts
import * as assert from "node:assert"
import { tupled } from "effect/Function"

const sumTupled = tupled((x: number, y: number): number => x + y)

assert.deepStrictEqual(sumTupled([1, 2]), 3)
```

**Signature**

```ts
declare const tupled: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (a: A) => B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L439)

Since v2.0.0
Function-unsafeCoerce.md
Package: `effect`<br />
Module: `Function`<br />

## Function.unsafeCoerce

Casts the result to the specified type.

**Example**

```ts
import * as assert from "node:assert"
import { unsafeCoerce, identity } from "effect/Function"

assert.deepStrictEqual(unsafeCoerce, identity)
```

**Signature**

```ts
declare const unsafeCoerce: <A, B>(a: A) => B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L271)

Since v2.0.0
Function-untupled.md
Package: `effect`<br />
Module: `Function`<br />

## Function.untupled

Inverse function of `tupled`

**Example**

```ts
import * as assert from "node:assert"
import { untupled } from "effect/Function"

const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])

assert.deepStrictEqual(getFirst(1, 2), 1)
```

**Signature**

```ts
declare const untupled: <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B) => (...a: A) => B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L456)

Since v2.0.0
GlobalValue-globalValue.md
Package: `effect`<br />
Module: `GlobalValue`<br />

## GlobalValue.globalValue

Retrieves or computes a global value associated with the given `id`. If the value for this `id`
has already been computed, it will be returned from the global store. If it does not exist yet,
the provided `compute` function will be executed to compute the value, store it, and then return it.

This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments
like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused
thereafter.

**Example**

```ts
import { globalValue } from "effect/GlobalValue"

// This cache will persist as long as the module is running,
// even if reloaded or imported elsewhere
const myCache = globalValue(
  Symbol.for("myCache"),
  () => new WeakMap<object, number>()
)
```

**Signature**

```ts
declare const globalValue: <A>(id: unknown, compute: () => A) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GlobalValue.ts#L44)

Since v2.0.0
GroupBy-GroupBy.md
Package: `effect`<br />
Module: `GroupBy`<br />

## GroupBy.GroupBy

Representation of a grouped stream. This allows to filter which groups will
be processed. Once this is applied all groups will be processed in parallel
and the results will be merged in arbitrary order.

**Signature**

```ts
export interface GroupBy<out K, out V, out E = never, out R = never> extends GroupBy.Variance<K, V, E, R>, Pipeable {
  readonly grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L32)

Since v2.0.0
GroupBy-evaluate.md
Package: `effect`<br />
Module: `GroupBy`<br />

## GroupBy.evaluate

Run the function across all groups, collecting the results in an
arbitrary order.

**Signature**

```ts
declare const evaluate: { <K, V, E, A, E2, R2>(f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <R>(self: GroupBy<K, V, E, R>) => Stream.Stream<A, E | E2, R2 | R>; <K, V, E, R, A, E2, R2>(self: GroupBy<K, V, E, R>, f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Stream.Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L61)

Since v2.0.0
GroupBy-filter.md
Package: `effect`<br />
Module: `GroupBy`<br />

## GroupBy.filter

Filter the groups to be processed.

**Signature**

```ts
declare const filter: { <K>(predicate: Predicate<NoInfer<K>>): <V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, predicate: Predicate<K>): GroupBy<K, V, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L79)

Since v2.0.0
GroupBy-first.md
Package: `effect`<br />
Module: `GroupBy`<br />

## GroupBy.first

Only consider the first `n` groups found in the `Stream`.

**Signature**

```ts
declare const first: { (n: number): <K, V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, n: number): GroupBy<K, V, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L90)

Since v2.0.0
GroupBy-make.md
Package: `effect`<br />
Module: `GroupBy`<br />

## GroupBy.make

Constructs a `GroupBy` from a `Stream`.

**Signature**

```ts
declare const make: <K, V, E, R>(grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>) => GroupBy<K, V, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L101)

Since v2.0.0
HashMap-beginMutation.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.beginMutation

Marks the `HashMap` as mutable.

**Signature**

```ts
declare const beginMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L290)

Since v2.0.0
HashMap-compact.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.compact

Filters out `None` values from a `HashMap` of `Options`s.

**Signature**

```ts
declare const compact: <K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L447)

Since v2.0.0
HashMap-empty.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.empty

Creates a new `HashMap`.

**Signature**

```ts
declare const empty: <K = never, V = never>() => HashMap<K, V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L108)

Since v2.0.0
HashMap-endMutation.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.endMutation

Marks the `HashMap` as immutable.

**Signature**

```ts
declare const endMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L297)

Since v2.0.0
HashMap-entries.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.entries

Returns an `IterableIterator` of the entries within the `HashMap`.

**Signature**

```ts
declare const entries: <K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L267)

Since v2.0.0
HashMap-every.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.every

Checks if all entries in a hashmap meets a specific condition.

**Signature**

```ts
declare const every: { <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L495)

Since v3.14.0
HashMap-HashMap.Entry.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.HashMap.Entry

This type-level utility extracts the entry type `[K, V]` from a `HashMap<K, V>` type.

**Example**

```ts
import { HashMap } from "effect"

declare const hm: HashMap.HashMap<string, number>

// $ExpectType [string, number]
type V = HashMap.HashMap.Entry<typeof hm>

```

**Signature**

```ts
type Entry<T> = [Key<T>, Value<T>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L90)

Since v3.9.0
HashMap-HashMap.Key.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.HashMap.Key

This type-level utility extracts the key type `K` from a `HashMap<K, V>` type.

**Example**

```ts
import { HashMap } from "effect"

declare const hm: HashMap.HashMap<string, number>

// $ExpectType string
type K = HashMap.HashMap.Key<typeof hm>

```

**Signature**

```ts
type Key<T> = [T] extends [HashMap<infer _K, infer _V>] ? _K : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L55)

Since v2.0.0
HashMap-HashMap.Value.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.HashMap.Value

This type-level utility extracts the value type `V` from a `HashMap<K, V>` type.

**Example**

```ts
import { HashMap } from "effect"

declare const hm: HashMap.HashMap<string, number>

// $ExpectType number
type V = HashMap.HashMap.Value<typeof hm>

```

**Signature**

```ts
type Value<T> = [T] extends [HashMap<infer _K, infer _V>] ? _V : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L72)

Since v2.0.0
HashMap-filter.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.filter

Filters entries out of a `HashMap` using the specified predicate.

**Signature**

```ts
declare const filter: { <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => HashMap<K, B>; <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => HashMap<K, A>; <K, A, B extends A>(self: HashMap<K, A>, f: (a: A, k: K) => a is B): HashMap<K, B>; <K, A>(self: HashMap<K, A>, f: (a: A, k: K) => boolean): HashMap<K, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L434)

Since v2.0.0
HashMap-filterMap.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.filterMap

Maps over the entries of the `HashMap` using the specified partial function
and filters out `None` values.

**Signature**

```ts
declare const filterMap: { <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L456)

Since v2.0.0
HashMap-findFirst.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

**Signature**

```ts
declare const findFirst: { <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>; <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>; <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L468)

Since v2.0.0
HashMap-flatMap.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.flatMap

Chains over the entries of the `HashMap` using the specified function.

**NOTE**: the hash and equal of both maps have to be the same.

**Signature**

```ts
declare const flatMap: { <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L401)

Since v2.0.0
HashMap-forEach.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.forEach

Applies the specified function to the entries of the `HashMap`.

**Signature**

```ts
declare const forEach: { <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void; <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L412)

Since v2.0.0
HashMap-fromIterable.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.fromIterable

Creates a new `HashMap` from an iterable collection of key/value pairs.

**Signature**

```ts
declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L129)

Since v2.0.0
HashMap-get.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.get

Safely lookup the value for the specified key in the `HashMap` using the
internal hashing function.

**Signature**

```ts
declare const get: { <K1 extends K, K>(key: K1): <V>(self: HashMap<K, V>) => Option<V>; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): Option<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L146)

Since v2.0.0
HashMap-getHash.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.getHash

Lookup the value for the specified key in the `HashMap` using a custom hash.

**Signature**

```ts
declare const getHash: { <K1 extends K, K>(key: K1, hash: number): <V>(self: HashMap<K, V>) => Option<V>; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1, hash: number): Option<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L157)

Since v2.0.0
HashMap-has.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.has

Checks if the specified key has an entry in the `HashMap`.

**Signature**

```ts
declare const has: { <K1 extends K, K>(key: K1): <K, V>(self: HashMap<K, V>) => boolean; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L180)

Since v2.0.0
HashMap-hasBy.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.hasBy

Checks if an element matching the given predicate exists in the given `HashMap`.

**Example**

```ts
import { HashMap } from "effect"

const hm = HashMap.make([1, 'a'])
HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true
HashMap.hasBy(hm, (value) => value === 'b'); // -> false

```

**Signature**

```ts
declare const hasBy: { <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: HashMap<K, V>) => boolean; <K, V>(self: HashMap<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L213)

Since v3.16.0
HashMap-hasHash.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.hasHash

Checks if the specified key has an entry in the `HashMap` using a custom
hash.

**Signature**

```ts
declare const hasHash: { <K1 extends K, K>(key: K1, hash: number): <V>(self: HashMap<K, V>) => boolean; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1, hash: number): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L192)

Since v2.0.0
HashMap-isEmpty.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.isEmpty

Checks if the `HashMap` contains any entries.

**Signature**

```ts
declare const isEmpty: <K, V>(self: HashMap<K, V>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L137)

Since v2.0.0
HashMap-keySet.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.keySet

Returns a `HashSet` of keys within the `HashMap`.

**Signature**

```ts
declare const keySet: <K, V>(self: HashMap<K, V>) => HashSet<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L243)

Since v2.0.0
HashMap-keys.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.keys

Returns an `IterableIterator` of the keys within the `HashMap`.

**Signature**

```ts
declare const keys: <K, V>(self: HashMap<K, V>) => IterableIterator<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L235)

Since v2.0.0
HashMap-make.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.make

Constructs a new `HashMap` from an array of key/value pairs.

**Signature**

```ts
declare const make: <Entries extends ReadonlyArray<readonly [any, any]>>(...entries: Entries) => HashMap<Entries[number] extends readonly [infer K, any] ? K : never, Entries[number] extends readonly [any, infer V] ? V : never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L116)

Since v2.0.0
HashMap-map.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.map

Maps over the entries of the `HashMap` using the specified function.

**Signature**

```ts
declare const map: { <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>; <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L388)

Since v2.0.0
HashMap-modify.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.modify

Updates the value of the specified key within the `HashMap` if it exists.

**Signature**

```ts
declare const modify: { <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L346)

Since v2.0.0
HashMap-modifyAt.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.modifyAt

Set or remove the specified key in the `HashMap` using the specified
update function. The value of the specified key will be computed using the
provided hash.

The update function will be invoked with the current value of the key if it
exists, or `None` if no such value exists.

**Signature**

```ts
declare const modifyAt: { <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L319)

Since v2.0.0
HashMap-modifyHash.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.modifyHash

Alter the value of the specified key in the `HashMap` using the specified
update function. The value of the specified key will be computed using the
provided hash.

The update function will be invoked with the current value of the key if it
exists, or `None` if no such value exists.

This function will always either update or insert a value into the `HashMap`.

**Signature**

```ts
declare const modifyHash: { <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L336)

Since v2.0.0
HashMap-mutate.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.mutate

Mutates the `HashMap` within the context of the provided function.

**Signature**

```ts
declare const mutate: { <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L304)

Since v2.0.0
HashMap-reduce.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.reduce

Reduces the specified state over the entries of the `HashMap`.

**Signature**

```ts
declare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z; <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L423)

Since v2.0.0
HashMap-remove.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.remove

Remove the entry for the specified key in the `HashMap` using the internal
hashing function.

**Signature**

```ts
declare const remove: { <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L367)

Since v2.0.0
HashMap-removeMany.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.removeMany

Removes all entries in the `HashMap` which have the specified keys.

**Signature**

```ts
declare const removeMany: { <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L377)

Since v2.0.0
HashMap-set.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.set

Sets the specified key to the specified value using the internal hashing
function.

**Signature**

```ts
declare const set: { <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L224)

Since v2.0.0
HashMap-size.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.size

Returns the number of entries within the `HashMap`.

**Signature**

```ts
declare const size: <K, V>(self: HashMap<K, V>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L283)

Since v2.0.0
HashMap-some.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.some

Checks if any entry in a hashmap meets a specific condition.

**Signature**

```ts
declare const some: { <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L481)

Since v3.13.0
HashMap-toEntries.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.toEntries

Returns an `Array<[K, V]>` of the entries within the `HashMap`.

**Signature**

```ts
declare const toEntries: <K, V>(self: HashMap<K, V>) => Array<[K, V]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L275)

Since v2.0.0
HashMap-toValues.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.toValues

Returns an `Array` of the values within the `HashMap`.

**Signature**

```ts
declare const toValues: <K, V>(self: HashMap<K, V>) => Array<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L259)

Since v3.13.0
HashMap-union.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.union

Performs a union of this `HashMap` and that `HashMap`.

**Signature**

```ts
declare const union: { <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>; <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L356)

Since v2.0.0
HashMap-unsafeGet.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.unsafeGet

Unsafely lookup the value for the specified key in the `HashMap` using the
internal hashing function.

**Signature**

```ts
declare const unsafeGet: { <K1 extends K, K>(key: K1): <V>(self: HashMap<K, V>) => V; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): V; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L169)

Since v2.0.0
HashMap-values.md
Package: `effect`<br />
Module: `HashMap`<br />

## HashMap.values

Returns an `IterableIterator` of the values within the `HashMap`.

**Signature**

```ts
declare const values: <K, V>(self: HashMap<K, V>) => IterableIterator<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L251)

Since v2.0.0
HashSet-add.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.add

Adds a value to the `HashSet`.

Time complexity: **`O(1)`** average

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))

// or piped with the pipe function
HashSet.empty().pipe(HashSet.add(0))

// or with data-first API
HashSet.add(HashSet.empty(), 0)
```

**See**

- Other `HashSet` mutations are `module:HashSet.remove` `module:HashSet.toggle` `module:HashSet.beginMutation` `module:HashSet.endMutation` `module:HashSet.mutate`

**Signature**

```ts
declare const add: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1261)

Since v2.0.0
HashSet-beginMutation.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.beginMutation

Creates a new mutable version of the `HashSet`

When a `HashSet` is mutable, operations like `add` and `remove`
modify the data structure in place instead of creating a new one, which is
more efficient when performing multiple operations.

**Example**

```ts
import { HashSet } from "effect"
import assert from "node:assert/strict"

const UPPER_BOUND = 10_000

const immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))

// Create a mutable version of the immutableSet
const mutableSet = HashSet.beginMutation(immutableSet)

for (let i = 1; i < UPPER_BOUND; i++) {
  // Operations now modify the set in place instead of creating new instances
  // This is more efficient when making multiple changes
  const pointerToMutableSet = HashSet.add(mutableSet, i)

  // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance
  assert(Object.is(mutableSet, pointerToMutableSet))
  assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet
  assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet
}

const next = UPPER_BOUND + 1
// When done, mark the set as immutable again
HashSet.endMutation(mutableSet).pipe(
  HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet
)
assert.equal(HashSet.has(mutableSet, next), false)

console.log(HashSet.toValues(immutableSet)) // [0]
console.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]
```

**See**

- Other `HashSet` mutations are `module:HashSet.add` `module:HashSet.remove` `module:HashSet.toggle` `module:HashSet.endMutation` `module:HashSet.mutate`

**Signature**

```ts
declare const beginMutation: <A>(self: HashSet<A>) => HashSet<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1068)

Since v2.0.0
HashSet-difference.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.difference

Computes the set difference `(A - B)` between this `HashSet` and the
specified `Iterable<A>`.

Time complexity: **`O(n)`** where n is the number of elements in the set

**NOTE**: the hash and equal of the values in both the set and the iterable
must be the same; meaning we cannot compute a difference between a `HashSet
of bananas` and a `HashSet of elephants` as they are not the same type and
won't implement the Equal trait in the same way.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))

// or with data-first API
HashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))
```

**See**

- Other `HashSet` operations are `module:HashSet.intersection` `module:HashSet.union`

**Signature**

```ts
declare const difference: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1401)

Since v2.0.0
HashSet-empty.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.empty

Creates an empty `HashSet`.

Time complexity: **`O(1)`**

**Example**

```ts
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    // Provide a type argument to create a HashSet of a specific type
    HashSet.empty<number>(),
    HashSet.add(1),
    HashSet.add(1), // Notice the duplicate
    HashSet.add(2),
    HashSet.toValues
  )
) // Output: [1, 2]
```

**See**

- Other `HashSet` constructors are `module:HashSet.make` `module:HashSet.fromIterable`

**Signature**

```ts
declare const empty: <A = never>() => HashSet<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L375)

Since v2.0.0
HashSet-endMutation.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.endMutation

Makes the `HashSet` immutable again.

After calling `endMutation`, operations like `add` and `remove`
will create new instances of the `HashSet` instead of modifying the existing
one.

**Example**

```ts
import { HashSet } from "effect"
import assert from "node:assert/strict"

// Create a mutable set
const mutableSet = HashSet.beginMutation(HashSet.empty<number>())

// Add some elements to the mutable set
HashSet.add(mutableSet, 1)
HashSet.add(mutableSet, 2)

// Before endMutation, operations modify the set in place
const sameSet = HashSet.add(mutableSet, 3)
assert(Object.is(mutableSet, sameSet)) // true - same object reference
assert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])

// Make the set immutable again
const immutableSet = HashSet.endMutation(mutableSet)

// endMutation returns the same set instance, now made immutable
assert(Object.is(mutableSet, immutableSet)) // true - same object reference

// After endMutation, operations create new instances
const newSet = HashSet.add(immutableSet, 4)
assert(!Object.is(immutableSet, newSet)) // false - different object references

// The original set remains unchanged
assert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])

// The new set contains the added element
assert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])
```

**See**

- Other `HashSet` mutations are `module:HashSet.add` `module:HashSet.remove` `module:HashSet.toggle` `module:HashSet.beginMutation` `module:HashSet.mutate`

**Signature**

```ts
declare const endMutation: <A>(self: HashSet<A>) => HashSet<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1116)

Since v2.0.0
HashSet-every.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.every

Check if a predicate holds true for every `HashSet` element.

Time complexity is **`O(n)`** as it needs to traverse the whole HashSet
collection

**Example**

```ts
// Syntax with Refinement
import { HashSet, pipe, Predicate } from "effect"

const numberOrString = HashSet.make(1, "1", "one", "uno")

// with `data-last`, a.k.a. `pipeable` API and `Refinement`
pipe(
  numberOrString, // HashSet.HashSet<number | string>
  HashSet.every(Predicate.isString)
) // HashSet.HashSet<string>

// or piped with the pipe function and  `Refinement`
numberOrString // HashSet.HashSet<number | string>
  .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>

// or with `data-first` API and `Refinement`
HashSet.every(
  numberOrString, // HashSet.HashSet<number | string>
  Predicate.isString
) // HashSet.HashSet<string>
```

**Example**

```ts
// Syntax with Predicate
import { HashSet, pipe } from "effect"

const set = HashSet.make(1, 2, 3)

// with `data-last`, a.k.a. `pipeable` API
pipe(
  set,
  HashSet.every((n) => n >= 0)
) // true

// or piped with the pipe function
set.pipe(HashSet.every((n) => n >= 0)) // true

// or with `data-first` API
HashSet.every(set, (n) => n >= 0) // true
```

**See**

- Other `HashSet` elements are `module:HashSet.has` `module:HashSet.some` `module:HashSet.isSubset`

**Signature**

```ts
declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => self is HashSet<B>; <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): self is HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L770)

Since v2.0.0
HashSet-filter.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.filter

Filters values out of a `HashSet` using the specified predicate.

The time complexity is of **`O(n)`**.

**Example**

```ts
// Syntax with  Predicate
import { HashSet, type Predicate, pipe } from "effect"

const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(-2, -1, 0, 1, 2),
  HashSet.filter(filterPositiveNumbers)
)

// or with the pipe method
HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))

// or with `data-first` API
HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)
```

**Example**

```ts
/// Syntax with Refinement
import { HashSet, pipe } from "effect"

const stringRefinement = (value: unknown): value is string =>
  typeof value === "string"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // // HashSet.HashSet<number | string>
  HashSet.filter(stringRefinement)
) // HashSet.HashSet<string>

// or with the pipe method
HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier") // HashSet.HashSet<number | string>
  .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>

// or with `data-first` API
HashSet.filter(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // HashSet.HashSet<number | string>
  stringRefinement
) // HashSet.HashSet<string>
```

**Signature**

```ts
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => HashSet<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L2076)

Since v2.0.0
HashSet-flatMap.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.flatMap

Chains over the values of the `HashSet` using the specified function.

The time complexity is of **`O(n)`**.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(0, 1, 2), // HashSet.HashSet<number>
  HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>
)

// or piped with the pipe method
HashSet.make(0, 1, 2) // HashSet.HashSet<number>
  .pipe(
    HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>
  )

// or with `data-first` API
HashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))
```

**Signature**

```ts
declare const flatMap: { <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1854)

Since v2.0.0
HashSet-forEach.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.forEach

Applies the specified function to the values of the `HashSet`.

The time complexity is of **`O(n)`**.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2

// or piped with the pipe method
HashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2

// or with `data-first` API
HashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2
```

**Signature**

```ts
declare const forEach: { <A>(f: (value: A) => void): (self: HashSet<A>) => void; <A>(self: HashSet<A>, f: (value: A) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1915)

Since v2.0.0
HashSet-fromIterable.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.fromIterable

Creates a new `HashSet` from an iterable collection of values.

Time complexity: **`O(n)`** where n is the number of elements in the iterable

**Example**

```ts
// Creating a HashSet from an Array
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.
    HashSet.fromIterable,
    HashSet.toValues
  )
) // Output: [1, 2, 3, 4, 5]
```

**Example**

```ts
// Creating a HashSet from a Set
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    new Set(["apple", "banana", "orange", "apple"]), // Set<string> is an Iterable<string>
    HashSet.fromIterable,
    HashSet.toValues
  )
) // Output: ["apple", "banana", "orange"]
```

**Example**

```ts
// Creating a HashSet from a Generator
import { HashSet } from "effect"

// Generator functions return iterables
function* fibonacci(n: number): Generator<number, void, unknown> {
  let [a, b] = [0, 1]
  for (let i = 0; i < n; i++) {
    yield a
    ;[a, b] = [b, a + b]
  }
}

// Create a HashSet from the first 10 Fibonacci numbers
const fibonacciSet = HashSet.fromIterable(fibonacci(10))

console.log(HashSet.toValues(fibonacciSet))
// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order
```

**Example**

```ts
//  Creating a HashSet from another HashSet
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    // since HashSet implements the Iterable interface, we can use it to create a new HashSet
    HashSet.make(1, 2, 3, 4),
    HashSet.fromIterable,
    HashSet.toValues // turns the HashSet back into an array
  )
) // Output: [1, 2, 3, 4]
```

**Example**

```ts
// Creating a HashSet from other Effect's data structures like Chunk
import { Chunk, HashSet, pipe } from "effect"

console.log(
  pipe(
    Chunk.make(1, 2, 3, 4), // Iterable<number>
    HashSet.fromIterable,
    HashSet.toValues // turns the HashSet back into an array
  )
) // Outputs: [1, 2, 3, 4]
```

**See**

- Other `HashSet` constructors are `module:HashSet.empty` `module:HashSet.make`

**Signature**

```ts
declare const fromIterable: <A>(elements: Iterable<A>) => HashSet<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L470)

Since v2.0.0
HashSet-has.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.has

Checks if the specified value exists in the `HashSet`.

Time complexity: **`O(1)`** average

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false

// or piped with the pipe function
HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false

// or with `data-first` API
HashSet.has(HashSet.make(0, 1, 2), 3) // false
```

**See**

- Other `HashSet` elements are `module:HashSet.some` `module:HashSet.every` `module:HashSet.isSubset`

**Signature**

```ts
declare const has: { <A>(value: A): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, value: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L588)

Since v2.0.0
HashSet-intersection.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.intersection

Returns a `HashSet` of values which are present in both this set and that
`Iterable<A>`. Computes set intersection (A  B)

Time complexity: **`O(n)`** where n is the number of elements in the smaller
set

**NOTE**: the hash and equal of the values in both the set and the iterable
must be the same.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))

// or with data-first API
HashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))
```

**See**

- Other `HashSet` operations are `module:HashSet.difference` `module:HashSet.union`

**Signature**

```ts
declare const intersection: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1497)

Since v2.0.0
HashSet-isSubset.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.isSubset

Returns `true` if and only if every element in the this `HashSet` is an
element of the second set,

**NOTE**: the hash and equal of both sets must be the same.

Time complexity analysis is of **`O(n)`**

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

const set1 = HashSet.make(0, 1)
const set2 = HashSet.make(1, 2)
const set3 = HashSet.make(0, 1, 2)

// with `data-last`, a.k.a. `pipeable` API
pipe(set1, HashSet.isSubset(set2)) // false
pipe(set1, HashSet.isSubset(set3)) // true

// or piped with the pipe function
set1.pipe(HashSet.isSubset(set2)) // false
set1.pipe(HashSet.isSubset(set3)) // true

// or with `data-first` API
HashSet.isSubset(set1, set2) // false
HashSet.isSubset(set1, set3) // true)
```

**See**

- Other `HashSet` elements are `module:HashSet.has` `module:HashSet.some` `module:HashSet.every`

**Signature**

```ts
declare const isSubset: { <A>(that: HashSet<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, that: HashSet<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L900)

Since v2.0.0
HashSet-make.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.make

Construct a new `HashSet` from a variable number of values.

Time complexity: **`O(n)`** where n is the number of elements

**Example**

```ts
import { Equal, Hash, HashSet, pipe } from "effect"
import assert from "node:assert/strict"

class Character implements Equal.Equal {
  readonly name: string
  readonly trait: string

  constructor(name: string, trait: string) {
    this.name = name
    this.trait = trait
  }

  // Define equality based on name, and trait
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Character) {
      return (
        Equal.equals(this.name, that.name) &&
        Equal.equals(this.trait, that.trait)
      )
    }
    return false
  }

  // Generate a hash code based on the sum of the character's name and trait
  [Hash.symbol](): number {
    return Hash.hash(this.name + this.trait)
  }

  static readonly of = (name: string, trait: string): Character => {
    return new Character(name, trait)
  }
}

assert.strictEqual(
  Equal.equals(
    HashSet.make(
      Character.of("Alice", "Curious"),
      Character.of("Alice", "Curious"),
      Character.of("White Rabbit", "Always late"),
      Character.of("Mad Hatter", "Tea enthusiast")
    ),
    // Is the same as adding each character to an empty set
    pipe(
      HashSet.empty(),
      HashSet.add(Character.of("Alice", "Curious")),
      HashSet.add(Character.of("Alice", "Curious")), // Alice tried to attend twice!
      HashSet.add(Character.of("White Rabbit", "Always late")),
      HashSet.add(Character.of("Mad Hatter", "Tea enthusiast"))
    )
  ),
  true,
  "`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal"
)

assert.strictEqual(
  Equal.equals(
    HashSet.make(
      Character.of("Alice", "Curious"),
      Character.of("Alice", "Curious"),
      Character.of("White Rabbit", "Always late"),
      Character.of("Mad Hatter", "Tea enthusiast")
    ),
    HashSet.fromIterable([
      Character.of("Alice", "Curious"),
      Character.of("Alice", "Curious"),
      Character.of("White Rabbit", "Always late"),
      Character.of("Mad Hatter", "Tea enthusiast")
    ])
  ),
  true,
  "`HashSet.make` and `HashSet.fromIterable` should be equal"
)
```

**See**

- Other `HashSet` constructors are `module:HashSet.fromIterable` `module:HashSet.empty`

**Signature**

```ts
declare const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L559)

Since v2.0.0
HashSet-map.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.map

Maps over the values of the `HashSet` using the specified function.

The time complexity is of **`O(n)`**.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(0, 1, 2), // HashSet.HashSet<number>
  HashSet.map(String) // HashSet.HashSet<string>
)

// or piped with the pipe method
HashSet.make(0, 1, 2).pipe(HashSet.map(String))

// or with `data-first` API
HashSet.map(HashSet.make(0, 1, 2), String)
```

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1786)

Since v2.0.0
HashSet-mutate.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.mutate

Mutates the `HashSet` within the context of the provided function.

You can consider it a functional abstraction on top of the lower-level
mutation primitives of `module:HashSet.beginMutation` `->` `mutable
context` `->` `HashSet.endMutation`.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(
  HashSet.make(1, 2, 3),
  HashSet.mutate((set) => {
    HashSet.add(set, 4)
    HashSet.remove(set, 1)
  })
)

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(
  HashSet.mutate((set) => {
    HashSet.add(set, 4)
    HashSet.remove(set, 1)
  })
)

// or with data-first API
HashSet.mutate(HashSet.make(1, 2, 3), (set) => {
  HashSet.add(set, 4)
  HashSet.remove(set, 1)
})
```

**See**

- Other `HashSet` mutations are `module:HashSet.add` `module:HashSet.remove` `module:HashSet.toggle` `module:HashSet.beginMutation` `module:HashSet.endMutation`

**Signature**

```ts
declare const mutate: { <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1159)

Since v2.0.0
HashSet-partition.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.partition

Partition the values of a `HashSet` using the specified predicate.

If a value matches the predicate, it will be placed into the `HashSet` on the
right side of the resulting `Tuple`, otherwise the value will be placed into
the left side.

Time complexity is of **`O(n)`**.

**Example**

```ts
// Syntax with Predicate
import { HashSet, pipe, Predicate } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(0, 1, 2, 3, 4, 5),
  HashSet.partition((n) => n % 2 === 0)
)

// or with the pipe method
HashSet.make(0, 1, 2, 3, 4, 5).pipe(
  HashSet.partition((n) => n % 2 === 0)
)

// or with `data-first` API
HashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)
```

**Example**

```ts
// Syntax with Refinement
import { HashSet, pipe, Predicate } from "effect"

const stringRefinement: Predicate.Refinement<string | number, string> = (
  value
) => typeof value === "string"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
  HashSet.partition(stringRefinement)
)

// or with the pipe method
HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier").pipe(
  HashSet.partition(stringRefinement)
)

// or with `data-first` API
HashSet.partition(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
  stringRefinement
)
```

**Signature**

```ts
declare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(self: HashSet<A>, predicate: Predicate<A>): [excluded: HashSet<A>, satisfying: HashSet<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L2234)

Since v2.0.0
HashSet-reduce.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.reduce

Reduces the specified state over the values of the `HashSet`.

The time complexity is of **`O(n)`**.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

const sum = (a: number, b: number): number => a + b

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))

// or with the pipe method
HashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))

// or with `data-first` API
HashSet.reduce(HashSet.make(0, 1, 2), 0, sum)
```

**Signature**

```ts
declare const reduce: { <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z; <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1982)

Since v2.0.0
HashSet-remove.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.remove

Removes a value from the `HashSet`.

Time complexity: **`O(1)`** average

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.remove(0))

// or piped with the pipe function
HashSet.make(0, 1, 2).pipe(HashSet.remove(0))

// or with `data-first` API
HashSet.remove(HashSet.make(0, 1, 2), 0)
```

**See**

- Other `HashSet` mutations are `module:HashSet.add` `module:HashSet.toggle` `module:HashSet.beginMutation` `module:HashSet.endMutation` `module:HashSet.mutate`

**Signature**

```ts
declare const remove: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1330)

Since v2.0.0
HashSet-size.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.size

Calculates the number of values in the `HashSet`.

Time complexity: **`O(1)`**

**Example**

```ts
import { HashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)

assert.deepStrictEqual(
  pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),
  4
)
```

**See**

- Other `HashSet` getters are `module:HashSet.values` `module:HashSet.toValues`

**Signature**

```ts
declare const size: <A>(self: HashSet<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1020)

Since v2.0.0
HashSet-some.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.some

Check if a predicate holds true for some `HashSet` element.

Time complexity: **`O(n)`** where n is the number of elements in the set

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)

// with `data-last`, a.k.a. `pipeable` API
pipe(
  set,
  HashSet.some((n) => n > 0)
) // true

// or piped with the pipe function
set.pipe(HashSet.some((n) => n > 0)) // true

// or with `data-first` API
HashSet.some(set, (n) => n > 0) // true
```

**See**

- Other `HashSet` elements are `module:HashSet.has` `module:HashSet.every` `module:HashSet.isSubset`

**Signature**

```ts
declare const some: { <A>(f: Predicate<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, f: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L657)

Since v2.0.0
HashSet-toValues.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.toValues

Returns an `Array` of the values within the `HashSet`.

Time complexity: **`O(n)`** where n is the number of elements in the set

**Example**

```ts
import { HashSet, pipe } from "effect"
import { deepStrictEqual } from "node:assert/strict"

deepStrictEqual(
  pipe(
    HashSet.make(0, 1, 1, 2), // HashSet<number>
    HashSet.toValues // takes an HashSet<A> and returns an Array<A>
  ),
  Array.of(0, 1, 2)
)
```

**See**

- Other `HashSet` getters are `module:HashSet.values` `module:HashSet.size`

**Signature**

```ts
declare const toValues: <A>(self: HashSet<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L994)

Since v3.13.0
HashSet-toggle.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.toggle

Checks if a value is present in the `HashSet`. If it is present, the value
will be removed from the `HashSet`, otherwise the value will be added to the
`HashSet`.

Time complexity: **`O(1)`** average

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.toggle(0))

// or piped with the pipe function
HashSet.make(0, 1, 2).pipe(HashSet.toggle(0))

// or with `data-first` API
HashSet.toggle(HashSet.make(0, 1, 2), 0)
```

**See**

- Other `HashSet` mutations are `module:HashSet.add` `module:HashSet.remove` `module:HashSet.beginMutation` `module:HashSet.endMutation` `module:HashSet.mutate`

**Signature**

```ts
declare const toggle: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1699)

Since v2.0.0
HashSet-union.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.union

Computes the set union `( self  that )` between this `HashSet` and the
specified `Iterable<A>`.

Time complexity: **`O(n)`** where n is the number of elements in the set

**NOTE**: the hash and equal of the values in both the set and the iterable
must be the same.

**Example**

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))

// or with data-first API
HashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))
```

**See**

- Other `HashSet` operations are `module:HashSet.difference` `module:HashSet.intersection`

**Signature**

```ts
declare const union: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1592)

Since v2.0.0
HashSet-values.md
Package: `effect`<br />
Module: `HashSet`<br />

## HashSet.values

Returns an `IterableIterator` of the values in the `HashSet`.

Time complexity: **`O(1)`**

**Example**

```ts
import { HashSet, pipe } from "effect"

const numberIterable = pipe(
  HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>
  HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>
)

for (const number of numberIterable) {
  console.log(number) // it will logs: 0, 1, 2
}
```

**See**

- Other `HashSet` getters are `module:HashSet.toValues` `module:HashSet.size`

**Signature**

```ts
declare const values: <A>(self: HashSet<A>) => IterableIterator<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L967)

Since v2.0.0
HelpDoc-HelpDoc.md
Package: `@effect/cli`<br />
Module: `HelpDoc`<br />

## HelpDoc.HelpDoc

A `HelpDoc` models the full documentation for a command-line application.

`HelpDoc` is composed of optional header and footers, and in-between, a
list of HelpDoc-level content items.

HelpDoc-level content items, in turn, can be headers, paragraphs, description
lists, and enumerations.

A `HelpDoc` can be converted into plaintext, JSON, and HTML.

**Signature**

```ts
type HelpDoc = Empty | Header | Paragraph | DescriptionList | Enumeration | Sequence
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/HelpDoc.ts#L23)

Since v1.0.0
HttpApi-AdditionalSchemas.md
Package: `@effect/platform`<br />
Module: `HttpApi`<br />

## HttpApi.AdditionalSchemas

Adds additional schemas to components/schemas.
The provided schemas must have a `identifier` annotation.

**Signature**

```ts
declare class AdditionalSchemas
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApi.ts#L450)

Since v1.0.0
HttpApi-HttpApi.md
Package: `@effect/platform`<br />
Module: `HttpApi`<br />

## HttpApi.HttpApi

An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.make` api.

**Signature**

```ts
export interface HttpApi<
  out Id extends string,
  out Groups extends HttpApiGroup.HttpApiGroup.Any = never,
  in out E = never,
  out R = never
> extends Pipeable {
  new(_: never): {}
  readonly [TypeId]: TypeId
  readonly identifier: Id
  readonly groups: Record.ReadonlyRecord<string, Groups>
  readonly annotations: Context.Context<never>
  readonly errorSchema: Schema.Schema<E, unknown, R>
  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>

  /**
   * Add a `HttpApiGroup` to the `HttpApi`.
   */
  add<A extends HttpApiGroup.HttpApiGroup.Any>(group: A): HttpApi<Id, Groups | A, E, R>
  /**
   * Add another `HttpApi` to the `HttpApi`.
   */
  addHttpApi<Id2 extends string, Groups2 extends HttpApiGroup.HttpApiGroup.Any, E2, R2>(
    api: HttpApi<Id2, Groups2, E2, R2>
  ): HttpApi<
    Id,
    Groups | HttpApiGroup.HttpApiGroup.AddContext<Groups2, R2>,
    E | E2,
    R
  >
  /**
   * Add an global error to the `HttpApi`.
   */
  addError<A, I, RX>(
    schema: Schema.Schema<A, I, RX>,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApi<Id, Groups, E | A, R | RX>
  /**
   * Prefix all endpoints in the `HttpApi`.
   */
  prefix(prefix: HttpApiEndpoint.PathSegment): HttpApi<Id, Groups, E, R>
  /**
   * Add a middleware to a `HttpApi`. It will be applied to all endpoints in the
   * `HttpApi`.
   */
  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(
    middleware: Context.Tag<I, S>
  ): HttpApi<
    Id,
    Groups,
    E | HttpApiMiddleware.HttpApiMiddleware.Error<I>,
    R | I | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>
  >
  /**
   * Annotate the `HttpApi`.
   */
  annotate<I, S>(tag: Context.Tag<I, S>, value: S): HttpApi<Id, Groups, E, R>
  /**
   * Annotate the `HttpApi` with a Context.
   */
  annotateContext<I>(context: Context.Context<I>): HttpApi<Id, Groups, E, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApi.ts#L46)

Since v1.0.0
HttpApi-make.md
Package: `@effect/platform`<br />
Module: `HttpApi`<br />

## HttpApi.make

An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.make` api.

**Signature**

```ts
declare const make: <const Id extends string>(identifier: Id) => HttpApi<Id, never, HttpApiDecodeError>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApi.ts#L261)

Since v1.0.0
HttpApi-reflect.md
Package: `@effect/platform`<br />
Module: `HttpApi`<br />

## HttpApi.reflect

Extract metadata from an `HttpApi`, which can be used to generate documentation
or other tooling.

See the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.

**Signature**

```ts
declare const reflect: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, R>(self: HttpApi<Id, Groups, Error, R>, options: { readonly predicate?: Predicate.Predicate<{ readonly endpoint: HttpApiEndpoint.HttpApiEndpoint.AnyWithProps; readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps; }>; readonly onGroup: (options: { readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps; readonly mergedAnnotations: Context.Context<never>; }) => void; readonly onEndpoint: (options: { readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps; readonly endpoint: HttpApiEndpoint.HttpApiEndpoint<string, HttpMethod>; readonly mergedAnnotations: Context.Context<never>; readonly middleware: ReadonlySet<HttpApiMiddleware.TagClassAny>; readonly payloads: ReadonlyMap<string, { readonly encoding: HttpApiSchema.Encoding; readonly ast: AST.AST; }>; readonly successes: ReadonlyMap<number, { readonly ast: Option.Option<AST.AST>; readonly description: Option.Option<string>; }>; readonly errors: ReadonlyMap<number, { readonly ast: Option.Option<AST.AST>; readonly description: Option.Option<string>; }>; }) => void; }) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApi.ts#L279)

Since v1.0.0
HttpApiBuilder-Handlers.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.Handlers

Represents a handled `HttpApi`.

**Signature**

```ts
export interface Handlers<
  E,
  Provides,
  R,
  Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any = never
> extends Pipeable {
  readonly [HandlersTypeId]: {
    _Endpoints: Covariant<Endpoints>
  }
  readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps
  readonly handlers: Chunk.Chunk<Handlers.Item<E, R>>

  /**
   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.
   */
  handle<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(
    name: Name,
    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<Endpoints, Name, E, R1>,
    options?: { readonly uninterruptible?: boolean | undefined } | undefined
  ): Handlers<
    E,
    Provides,
    | R
    | Exclude<
      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<
        Endpoints,
        Name,
        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>
      >,
      Provides
    >,
    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>
  >

  /**
   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.
   * This version of the api allows you to return the full response object.
   */
  handleRaw<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(
    name: Name,
    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerResponseWithName<Endpoints, Name, E, R1>,
    options?: { readonly uninterruptible?: boolean | undefined } | undefined
  ): Handlers<
    E,
    Provides,
    | R
    | Exclude<
      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<
        Endpoints,
        Name,
        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>
      >,
      Provides
    >,
    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>
  >
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L205)

Since v1.0.0
HttpApiBuilder-Router.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.Router

The router that the API endpoints are attached to.

**Signature**

```ts
declare class Router
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L50)

Since v1.0.0
HttpApiBuilder-api.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.api

Create a top-level `HttpApi` layer.

**Signature**

```ts
declare const api: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(api: HttpApi.HttpApi<Id, Groups, E, R>) => Layer.Layer<HttpApi.Api, never, HttpApiGroup.HttpApiGroup.ToService<Id, Groups> | R | HttpApiGroup.HttpApiGroup.ErrorContext<Groups>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L58)

Since v1.0.0
HttpApiBuilder-group.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.group

Create a `Layer` that will implement all the endpoints in an `HttpApi`.

An unimplemented `Handlers` instance is passed to the `build` function, which
you can use to add handlers to the group.

You can implement endpoints using the `handlers.handle` api.

**Signature**

```ts
declare const group: <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const Name extends HttpApiGroup.HttpApiGroup.Name<Groups>, Return>(api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>, groupName: Name, build: (handlers: Handlers.FromGroup<ApiError, ApiR, HttpApiGroup.HttpApiGroup.WithName<Groups, Name>>) => Handlers.ValidateReturn<Return>) => Layer.Layer<HttpApiGroup.ApiGroup<ApiId, Name>, Handlers.Error<Return>, Exclude<Handlers.Context<Return> | HttpApiGroup.HttpApiGroup.MiddlewareWithName<Groups, Name>, Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L440)

Since v1.0.0
HttpApiBuilder-handler.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.handler

Create a `Handler` for a single endpoint.

**Signature**

```ts
declare const handler: <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const GroupName extends Groups["identifier"], const Name extends HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>["name"], R>(_api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>, _groupName: GroupName, _name: Name, f: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>, Name, ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>, R>) => HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>, Name, ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L497)

Since v1.0.0
HttpApiBuilder-httpApp.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.httpApp

Construct an `HttpApp` from an `HttpApi` instance.

**Signature**

```ts
declare const httpApp: Effect.Effect<HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>, never, HttpApi.Api | Router | Middleware>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L102)

Since v1.0.0
HttpApiBuilder-middleware.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.middleware

Create an `HttpApi` level middleware `Layer`.

**Signature**

```ts
declare const middleware: { <EX = never, RX = never>(middleware: MiddlewareFn<never> | Effect.Effect<MiddlewareFn<never>, EX, RX>, options?: { readonly withContext?: false | undefined; }): Layer.Layer<never, EX, Exclude<RX, Scope>>; <R, EX = never, RX = never>(middleware: MiddlewareFn<never, R> | Effect.Effect<MiddlewareFn<never, R>, EX, RX>, options: { readonly withContext: true; }): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>; <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, EX = never, RX = never>(api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>, middleware: MiddlewareFn<NoInfer<Error>> | Effect.Effect<MiddlewareFn<NoInfer<Error>>, EX, RX>, options?: { readonly withContext?: false | undefined; }): Layer.Layer<never, EX, Exclude<RX, Scope>>; <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, R, EX = never, RX = never>(api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>, middleware: MiddlewareFn<NoInfer<Error>, R> | Effect.Effect<MiddlewareFn<NoInfer<Error>, R>, EX, RX>, options: { readonly withContext: true; }): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L876)

Since v1.0.0
HttpApiBuilder-middlewareCors.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.middlewareCors

A CORS middleware layer that can be provided to the `HttpApiBuilder.serve` layer.

**Signature**

```ts
declare const middlewareCors: (options?: { readonly allowedOrigins?: ReadonlyArray<string> | undefined; readonly allowedMethods?: ReadonlyArray<string> | undefined; readonly allowedHeaders?: ReadonlyArray<string> | undefined; readonly exposedHeaders?: ReadonlyArray<string> | undefined; readonly maxAge?: number | undefined; readonly credentials?: boolean | undefined; } | undefined) => Layer.Layer<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L932)

Since v1.0.0
HttpApiBuilder-middlewareOpenApi.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.middlewareOpenApi

A middleware that adds an openapi.json endpoint to the API.

**Signature**

```ts
declare const middlewareOpenApi: (options?: { readonly path?: HttpApiEndpoint.PathSegment | undefined; readonly additionalPropertiesStrategy?: OpenApi.AdditionalPropertiesStrategy | undefined; } | undefined) => Layer.Layer<never, never, HttpApi.Api>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L949)

Since v1.0.0
HttpApiBuilder-securitySetCookie.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.securitySetCookie

Set a cookie from an `HttpApiSecurity.HttpApiKey` instance.

You can use this api before returning a response from an endpoint handler.

```ts
handlers.handle(
  "authenticate",
  (_) => HttpApiBuilder.securitySetCookie(security, "secret123")
)
```

**Signature**

```ts
declare const securitySetCookie: (self: HttpApiSecurity.ApiKey, value: string | Redacted.Redacted, options?: Cookie["options"]) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L1046)

Since v1.0.0
HttpApiBuilder-serve.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.serve

Build an `HttpApp` from an `HttpApi` instance, and serve it using an
`HttpServer`.

Optionally, you can provide a middleware function that will be applied to
the `HttpApp` before serving.

**Signature**

```ts
declare const serve: <R = never>(middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, R>) => Layer.Layer<never, never, HttpServer.HttpServer | HttpRouter.HttpRouter.DefaultServices | Exclude<R, Scope | HttpServerRequest.HttpServerRequest> | HttpApi.Api>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L80)

Since v1.0.0
HttpApiBuilder-toWebHandler.md
Package: `@effect/platform`<br />
Module: `HttpApiBuilder`<br />

## HttpApiBuilder.toWebHandler

Construct an http web handler from an `HttpApi` instance.

**Example**

```ts
import { HttpApi, HttpApiBuilder, HttpServer } from "@effect/platform"
import { Layer } from "effect"

class MyApi extends HttpApi.make("api") {}

const MyApiLive = HttpApiBuilder.api(MyApi)

const { dispose, handler } = HttpApiBuilder.toWebHandler(
  Layer.mergeAll(
    MyApiLive,
    // you could also use NodeHttpServer.layerContext, depending on your
    // server's platform
    HttpServer.layerContext
  )
)
```

**Signature**

```ts
declare const toWebHandler: <LA, LE>(layer: Layer.Layer<LA | HttpApi.Api | HttpRouter.HttpRouter.DefaultServices, LE>, options?: { readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpApi.Api | Router | HttpRouter.HttpRouter.DefaultServices>; readonly memoMap?: Layer.MemoMap; }) => { readonly handler: (request: Request, context?: Context.Context<never> | undefined) => Promise<Response>; readonly dispose: () => Promise<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiBuilder.ts#L151)

Since v1.0.0
HttpApiEndpoint-HttpApiEndpoint.md
Package: `@effect/platform`<br />
Module: `HttpApiEndpoint`<br />

## HttpApiEndpoint.HttpApiEndpoint

Represents an API endpoint. An API endpoint is mapped to a single route on
the underlying `HttpRouter`.

**Signature**

```ts
export interface HttpApiEndpoint<
  out Name extends string,
  out Method extends HttpMethod,
  in out Path = never,
  in out UrlParams = never,
  in out Payload = never,
  in out Headers = never,
  in out Success = void,
  in out Error = never,
  out R = never,
  out RE = never
> extends Pipeable {
  readonly [TypeId]: TypeId
  readonly name: Name
  readonly path: PathSegment
  readonly method: Method
  readonly pathSchema: Option.Option<Schema.Schema<Path, unknown, R>>
  readonly urlParamsSchema: Option.Option<Schema.Schema<UrlParams, unknown, R>>
  readonly payloadSchema: Option.Option<Schema.Schema<Payload, unknown, R>>
  readonly headersSchema: Option.Option<Schema.Schema<Headers, unknown, R>>
  readonly successSchema: Schema.Schema<Success, unknown, R>
  readonly errorSchema: Schema.Schema<Error, unknown, RE>
  readonly annotations: Context.Context<never>
  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>

  /**
   * Add a schema for the success response of the endpoint. The status code
   * will be inferred from the schema, otherwise it will default to 200.
   */
  addSuccess<S extends Schema.Schema.Any>(
    schema: S,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApiEndpoint<
    Name,
    Method,
    Path,
    UrlParams,
    Payload,
    Headers,
    Exclude<Success, void> | Schema.Schema.Type<S>,
    Error,
    R | Schema.Schema.Context<S>,
    RE
  >

  /**
   * Add an error response schema to the endpoint. The status code
   * will be inferred from the schema, otherwise it will default to 500.
   */
  addError<E extends Schema.Schema.Any>(
    schema: E,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApiEndpoint<
    Name,
    Method,
    Path,
    UrlParams,
    Payload,
    Headers,
    Success,
    Error | Schema.Schema.Type<E>,
    R,
    RE | Schema.Schema.Context<E>
  >

  /**
   * Set the schema for the request body of the endpoint. The schema will be
   * used to validate the request body before the handler is called.
   *
   * For endpoints with no request body, the payload will use the url search
   * parameters.
   *
   * You can set a multipart schema to handle file uploads by using the
   * `HttpApiSchema.Multipart` combinator.
   */
  setPayload<P extends Schema.Schema.Any>(
    schema: P & HttpApiEndpoint.ValidatePayload<Method, P>
  ): HttpApiEndpoint<
    Name,
    Method,
    Path,
    UrlParams,
    Schema.Schema.Type<P>,
    Headers,
    Success,
    Error,
    R | Schema.Schema.Context<P>,
    RE
  >

  /**
   * Set the schema for the path parameters of the endpoint. The schema will be
   * used to validate the path parameters before the handler is called.
   */
  setPath<Path extends Schema.Schema.Any>(
    schema: Path & HttpApiEndpoint.ValidatePath<Path>
  ): HttpApiEndpoint<
    Name,
    Method,
    Schema.Schema.Type<Path>,
    UrlParams,
    Payload,
    Headers,
    Success,
    Error,
    R | Schema.Schema.Context<Path>,
    RE
  >

  /**
   * Set the schema for the url search parameters of the endpoint.
   */
  setUrlParams<UrlParams extends Schema.Schema.Any>(
    schema: UrlParams & HttpApiEndpoint.ValidateUrlParams<UrlParams>
  ): HttpApiEndpoint<
    Name,
    Method,
    Path,
    Schema.Schema.Type<UrlParams>,
    Payload,
    Headers,
    Success,
    Error,
    R | Schema.Schema.Context<Path>,
    RE
  >

  /**
   * Set the schema for the headers of the endpoint. The schema will be
   * used to validate the headers before the handler is called.
   */
  setHeaders<H extends Schema.Schema.Any>(
    schema: H & HttpApiEndpoint.ValidateHeaders<H>
  ): HttpApiEndpoint<
    Name,
    Method,
    Path,
    UrlParams,
    Payload,
    Schema.Schema.Type<H>,
    Success,
    Error,
    R | Schema.Schema.Context<H>,
    RE
  >

  /**
   * Add a prefix to the path of the endpoint.
   */
  prefix(
    prefix: PathSegment
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>

  /**
   * Add an `HttpApiMiddleware` to the endpoint.
   */
  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(middleware: Context.Tag<I, S>): HttpApiEndpoint<
    Name,
    Method,
    Path,
    UrlParams,
    Payload,
    Headers,
    Success,
    Error | HttpApiMiddleware.HttpApiMiddleware.Error<I>,
    R | I,
    RE | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>
  >

  /**
   * Add an annotation on the endpoint.
   */
  annotate<I, S>(
    tag: Context.Tag<I, S>,
    value: S
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>

  /**
   * Merge the annotations of the endpoint with the provided context.
   */
  annotateContext<I>(
    context: Context.Context<I>
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiEndpoint.ts#L52)

Since v1.0.0
HttpApiEndpoint-PathSegment.md
Package: `@effect/platform`<br />
Module: `HttpApiEndpoint`<br />

## HttpApiEndpoint.PathSegment

Represents a path segment. A path segment is a string that represents a
segment of a URL path.

**Signature**

```ts
type PathSegment = `/${string}`
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiEndpoint.ts#L43)

Since v1.0.0
HttpApiGroup-HttpApiGroup.md
Package: `@effect/platform`<br />
Module: `HttpApiGroup`<br />

## HttpApiGroup.HttpApiGroup

An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.group` api.

**Signature**

```ts
export interface HttpApiGroup<
  out Id extends string,
  out Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any = never,
  in out Error = HttpApiDecodeError,
  out R = never,
  out TopLevel extends (true | false) = false
> extends Pipeable {
  new(_: never): {}
  readonly [TypeId]: TypeId
  readonly identifier: Id
  readonly topLevel: TopLevel
  readonly endpoints: Record.ReadonlyRecord<string, Endpoints>
  readonly errorSchema: Schema.Schema<Error, unknown, R>
  readonly annotations: Context.Context<never>
  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>

  /**
   * Add an `HttpApiEndpoint` to an `HttpApiGroup`.
   */
  add<A extends HttpApiEndpoint.HttpApiEndpoint.Any>(
    endpoint: A
  ): HttpApiGroup<Id, Endpoints | A, Error, R, TopLevel>

  /**
   * Add an error schema to an `HttpApiGroup`, which is shared by all endpoints in the
   * group.
   */
  addError<A, I, RX>(
    schema: Schema.Schema<A, I, RX>,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApiGroup<Id, Endpoints, Error | A, R | RX, TopLevel>

  /**
   * Add a path prefix to all endpoints in an `HttpApiGroup`. Note that this will only
   * add the prefix to the endpoints before this api is called.
   */
  prefix(prefix: HttpApiEndpoint.PathSegment): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  /**
   * Add an `HttpApiMiddleware` to the `HttpApiGroup`.
   *
   * It will be applied to all endpoints in the group.
   */
  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(middleware: Context.Tag<I, S>): HttpApiGroup<
    Id,
    Endpoints,
    Error | HttpApiMiddleware.HttpApiMiddleware.Error<I>,
    R | I | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>,
    TopLevel
  >

  /**
   * Add an `HttpApiMiddleware` to each endpoint in the `HttpApiGroup`.
   *
   * Endpoints added after this api is called will not have the middleware
   * applied.
   */
  middlewareEndpoints<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(
    middleware: Context.Tag<I, S>
  ): HttpApiGroup<
    Id,
    HttpApiEndpoint.HttpApiEndpoint.AddContext<Endpoints, I>,
    Error,
    R,
    TopLevel
  >

  /**
   * Merge the annotations of an `HttpApiGroup` with a new context.
   */
  annotateContext<I>(context: Context.Context<I>): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  /**
   * Add an annotation to an `HttpApiGroup`.
   */
  annotate<I, S>(tag: Context.Tag<I, S>, value: S): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  /**
   * For each endpoint in an `HttpApiGroup`, update the annotations with a new
   * context.
   *
   * Note that this will only update the annotations before this api is called.
   */
  annotateEndpointsContext<I>(context: Context.Context<I>): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  /**
   * For each endpoint in an `HttpApiGroup`, add an annotation.
   *
   * Note that this will only add the annotation to the endpoints before this api
   * is called.
   */
  annotateEndpoints<I, S>(tag: Context.Tag<I, S>, value: S): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiGroup.ts#L41)

Since v1.0.0
HttpApiGroup-make.md
Package: `@effect/platform`<br />
Module: `HttpApiGroup`<br />

## HttpApiGroup.make

An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.group` api.

**Signature**

```ts
declare const make: <const Id extends string, const TopLevel extends (true | false) = false>(identifier: Id, options?: { readonly topLevel?: TopLevel | undefined; }) => HttpApiGroup<Id, never, never, never, TopLevel>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiGroup.ts#L420)

Since v1.0.0
HttpApiSecurity-apiKey.md
Package: `@effect/platform`<br />
Module: `HttpApiSecurity`<br />

## HttpApiSecurity.apiKey

Create an API key security scheme.

You can implement some api middleware for this security scheme using
`HttpApiBuilder.middlewareSecurity`.

To set the correct cookie in a handler, you can use
`HttpApiBuilder.securitySetCookie`.

The default value for `in` is "header".

**Signature**

```ts
declare const apiKey: (options: { readonly key: string; readonly in?: "header" | "query" | "cookie" | undefined; }) => ApiKey
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiSecurity.ts#L121)

Since v1.0.0
HttpApiSecurity-bearer.md
Package: `@effect/platform`<br />
Module: `HttpApiSecurity`<br />

## HttpApiSecurity.bearer

Create an Bearer token security scheme.

You can implement some api middleware for this security scheme using
`HttpApiBuilder.middlewareSecurity`.

**Signature**

```ts
declare const bearer: Bearer
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiSecurity.ts#L102)

Since v1.0.0
HttpApiSwagger-layer.md
Package: `@effect/platform`<br />
Module: `HttpApiSwagger`<br />

## HttpApiSwagger.layer

Exported layer mounting Swagger/OpenAPI documentation UI.

**Signature**

```ts
declare const layer: (options?: { readonly path?: `/${string}` | undefined; }) => Layer<never, never, Api>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpApiSwagger.ts#L21)

Since v1.0.0
HttpClient-filterOrElse.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.filterOrElse

Filters the result of a response, or runs an alternative effect if the predicate fails.

**Signature**

```ts
declare const filterOrElse: { <E2, R2>(predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpClient.With<E, R>, predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): HttpClient.With<E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L295)

Since v1.0.0
HttpClient-filterOrFail.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.filterOrFail

Filters the result of a response, or throws an error if the predicate fails.

**Signature**

```ts
declare const filterOrFail: { <E2>(predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orFailWith: (response: ClientResponse.HttpClientResponse) => E2): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R>; <E, R, E2>(self: HttpClient.With<E, R>, predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orFailWith: (response: ClientResponse.HttpClientResponse) => E2): HttpClient.With<E2 | E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L313)

Since v1.0.0
HttpClient-filterStatus.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.filterStatus

Filters responses by HTTP status code.

**Signature**

```ts
declare const filterStatus: { (f: (status: number) => boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>; <E, R>(self: HttpClient.With<E, R>, f: (status: number) => boolean): HttpClient.With<E | Error.ResponseError, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L331)

Since v1.0.0
HttpClient-filterStatusOk.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.filterStatusOk

Filters responses that return a 2xx status code.

**Signature**

```ts
declare const filterStatusOk: <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L342)

Since v1.0.0
HttpClient-followRedirects.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.followRedirects

Follows HTTP redirects up to a specified number of times.

**Signature**

```ts
declare const followRedirects: { (maxRedirects?: number | undefined): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, maxRedirects?: number | undefined): HttpClient.With<E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L608)

Since v1.0.0
HttpClient-mapRequest.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.mapRequest

Appends a transformation of the request object before sending it.

**Signature**

```ts
declare const mapRequest: { (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): HttpClient.With<E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L413)

Since v1.0.0
HttpClient-mapRequestEffect.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.mapRequestEffect

Appends an effectful transformation of the request object before sending it.

**Signature**

```ts
declare const mapRequestEffect: { <E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L429)

Since v1.0.0
HttpClient-mapRequestInput.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.mapRequestInput

Prepends a transformation of the request object before sending it.

**Signature**

```ts
declare const mapRequestInput: { (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): HttpClient.With<E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L445)

Since v1.0.0
HttpClient-mapRequestInputEffect.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.mapRequestInputEffect

Prepends an effectful transformation of the request object before sending it.

**Signature**

```ts
declare const mapRequestInputEffect: { <E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L461)

Since v1.0.0
HttpClient-retry.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.retry

Retries the request based on a provided schedule or policy.

**Signature**

```ts
declare const retry: { <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(options: O): <R>(self: HttpClient.With<E, R>) => Retry.Return<R, E, O>; <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>; <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(self: HttpClient.With<E, R>, options: O): Retry.Return<R, E, O>; <E, R, B, R1>(self: HttpClient.With<E, R>, policy: Schedule.Schedule<B, E, R1>): HttpClient.With<E, R1 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L499)

Since v1.0.0
HttpClient-retryTransient.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.retryTransient

Retries common transient errors, such as rate limiting, timeouts or network issues.

Specifying a `while` predicate allows you to consider other errors as
transient.

**Signature**

```ts
declare const retryTransient: { <B, E, R1 = never>(options: { readonly while?: Predicate.Predicate<NoInfer<E>>; readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>; readonly times?: number; } | Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>; <E, R, B, R1 = never>(self: HttpClient.With<E, R>, options: { readonly while?: Predicate.Predicate<NoInfer<E>>; readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>; readonly times?: number; } | Schedule.Schedule<B, NoInfer<E>, R1>): HttpClient.With<E, R1 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L525)

Since v1.0.0
HttpClient-tap.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.tap

Performs an additional effect after a successful request.

**Signature**

```ts
declare const tap: { <_, E2, R2>(f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L549)

Since v1.0.0
HttpClient-tapError.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.tapError

Performs an additional effect after an unsuccessful request.

**Signature**

```ts
declare const tapError: { <_, E, E2, R2>(f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L565)

Since v1.0.0
HttpClient-tapRequest.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.tapRequest

Performs an additional effect on the request before sending it.

**Signature**

```ts
declare const tapRequest: { <_, E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L581)

Since v1.0.0
HttpClient-withCookiesRef.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.withCookiesRef

Associates a `Ref` of cookies with the client for handling cookies across requests.

**Signature**

```ts
declare const withCookiesRef: { (ref: Ref<Cookies>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, ref: Ref<Cookies>): HttpClient.With<E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L597)

Since v1.0.0
HttpClient-withScope.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.withScope

Ties the lifetime of the `HttpClientRequest` to a `Scope`.

**Signature**

```ts
declare const withScope: <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R | Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L713)

Since v1.0.0
HttpClient-withSpanNameGenerator.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.withSpanNameGenerator

Customizes the span names for tracing.

```ts
import { FetchHttpClient, HttpClient } from "@effect/platform"
import { NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

Effect.gen(function* () {
  const client = (yield* HttpClient.HttpClient).pipe(
    // Customize the span names for this HttpClient
    HttpClient.withSpanNameGenerator(
      (request) => `http.client ${request.method} ${request.url}`
    )
  )

  yield* client.get("https://jsonplaceholder.typicode.com/posts/1")
}).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)
```

**Signature**

```ts
declare const withSpanNameGenerator: { (f: (request: ClientRequest.HttpClientRequest) => string): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, f: (request: ClientRequest.HttpClientRequest) => string): HttpClient.With<E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L700)

Since v1.0.0
HttpClient-withTracerDisabledWhen.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.withTracerDisabledWhen

Disables tracing for specific requests based on a provided predicate.

**Signature**

```ts
declare const withTracerDisabledWhen: { (predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): HttpClient.With<E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L626)

Since v1.0.0
HttpClient-withTracerPropagation.md
Package: `@effect/platform`<br />
Module: `HttpClient`<br />

## HttpClient.withTracerPropagation

Enables or disables tracing propagation for the request.

**Signature**

```ts
declare const withTracerPropagation: { (enabled: boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, enabled: boolean): HttpClient.With<E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpClient.ts#L648)

Since v1.0.0
HttpMethod-isHttpMethod.md
Package: `@effect/platform`<br />
Module: `HttpMethod`<br />

## HttpMethod.isHttpMethod

Tests if a value is a `HttpMethod`.

**Example**

```ts
import { HttpMethod } from "@effect/platform"

console.log(HttpMethod.isHttpMethod("GET"))
// true
console.log(HttpMethod.isHttpMethod("get"))
// false
console.log(HttpMethod.isHttpMethod(1))
// false
```

**Signature**

```ts
declare const isHttpMethod: (u: unknown) => u is HttpMethod
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpMethod.ts#L61)

Since v1.0.0
HttpMiddleware-withSpanNameGenerator.md
Package: `@effect/platform`<br />
Module: `HttpMiddleware`<br />

## HttpMiddleware.withSpanNameGenerator

Customizes the span name for the http app.

```ts
import {
  HttpMiddleware,
  HttpRouter,
  HttpServer,
  HttpServerResponse
} from "@effect/platform"
import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { Layer } from "effect"
import { createServer } from "http"

HttpRouter.empty.pipe(
  HttpRouter.get("/", HttpServerResponse.empty()),
  HttpServer.serve(),
  // Customize the span names for this HttpApp
  HttpMiddleware.withSpanNameGenerator((request) => `GET ${request.url}`),
  Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),
  Layer.launch,
  NodeRuntime.runMain
)
```

**Signature**

```ts
declare const withSpanNameGenerator: { (f: (request: ServerRequest.HttpServerRequest) => string): <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>; <A, E, R>(layer: Layer.Layer<A, E, R>, f: (request: ServerRequest.HttpServerRequest) => string): Layer.Layer<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpMiddleware.ts#L179)

Since v1.0.0
HttpRunner-layer.md
Package: `@effect/cluster`<br />
Module: `HttpRunner`<br />

## HttpRunner.layer

A HTTP layer for the `Runners` services, that adds a route to the provided
`HttpRouter.Tag`.

By default, it uses the `HttpRouter.Default` tag.

**Signature**

```ts
declare const layer: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly logAddress?: boolean | undefined; }) => Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | HttpServer.HttpServer | MessageStorage | ShardStorage>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpRunner.ts#L81)

Since v1.0.0
HttpServer-layerContext.md
Package: `@effect/platform`<br />
Module: `HttpServer`<br />

## HttpServer.layerContext

A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`
services.

The `FileSystem` service is a no-op implementation, so this layer is only
useful for platforms that have no file system.

**Signature**

```ts
declare const layerContext: Layer.Layer<FileSystem | Path | HttpPlatform | Generator, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpServer.ts#L221)

Since v1.0.0
HttpServer-layerTestClient.md
Package: `@effect/platform`<br />
Module: `HttpServer`<br />

## HttpServer.layerTestClient

Layer producing an `HttpClient` with prepended url of the running http server.

**Signature**

```ts
declare const layerTestClient: Layer.Layer<Client.HttpClient, never, HttpServer | Client.HttpClient>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpServer.ts#L208)

Since v1.0.0
HttpShardManager-layerHttp.md
Package: `@effect/cluster`<br />
Module: `HttpShardManager`<br />

## HttpShardManager.layerHttp

A HTTP layer for the `ShardManager` server, that adds a route to the provided
`HttpRouter.Tag`.

By default, it uses the `HttpRouter.Default` tag.

**Signature**

```ts
declare const layerHttp: Layer.Layer<ShardManager.ShardManager, never, ShardStorage | ShardingConfig | RpcSerialization.RpcSerialization | RunnerHealth.RunnerHealth | ShardManager.Config | HttpClient.HttpClient | HttpServer.HttpServer>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpShardManager.ts#L222)

Since v1.0.0
HttpShardManager-layerHttpOptions.md
Package: `@effect/cluster`<br />
Module: `HttpShardManager`<br />

## HttpShardManager.layerHttpOptions

A HTTP layer for the `ShardManager` server, that adds a route to the provided
`HttpRouter.Tag`.

By default, it uses the `HttpRouter.Default` tag.

**Signature**

```ts
declare const layerHttpOptions: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; readonly logAddress?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | HttpServer.HttpServer | ShardManager.Config | ShardingConfig>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpShardManager.ts#L138)

Since v1.0.0
HttpShardManager-layerNoServerHttp.md
Package: `@effect/cluster`<br />
Module: `HttpShardManager`<br />

## HttpShardManager.layerNoServerHttp

A layer for the `ShardManager` service, that does not run a server.

It only provides the `Runners` rpc client.

You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
to run a complete `ShardManager` server.

**Signature**

```ts
declare const layerNoServerHttp: (options: { readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | ShardManager.Config | ShardingConfig>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpShardManager.ts#L64)

Since v1.0.0
HttpShardManager-layerNoServerWebsocket.md
Package: `@effect/cluster`<br />
Module: `HttpShardManager`<br />

## HttpShardManager.layerNoServerWebsocket

A layer for the `ShardManager` service, that does not run a server.

It only provides the `Runners` rpc client.

You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
to run a complete `ShardManager` server.

**Signature**

```ts
declare const layerNoServerWebsocket: (options: { readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpShardManager.ts#L102)

Since v1.0.0
HttpShardManager-layerWebsocket.md
Package: `@effect/cluster`<br />
Module: `HttpShardManager`<br />

## HttpShardManager.layerWebsocket

A Websocket layer for the `ShardManager` server, that adds a route to the provided
`HttpRouter.Tag`.

By default, it uses the `HttpRouter.Default` tag.

**Signature**

```ts
declare const layerWebsocket: Layer.Layer<ShardManager.ShardManager, never, ShardStorage | ShardingConfig | RpcSerialization.RpcSerialization | RunnerHealth.RunnerHealth | ShardManager.Config | Socket.WebSocketConstructor | HttpServer.HttpServer>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpShardManager.ts#L243)

Since v1.0.0
HttpShardManager-layerWebsocketOptions.md
Package: `@effect/cluster`<br />
Module: `HttpShardManager`<br />

## HttpShardManager.layerWebsocketOptions

A WebSocket layer for the `ShardManager` server, that adds a route to the provided
`HttpRouter.Tag`.

By default, it uses the `HttpRouter.Default` tag.

**Signature**

```ts
declare const layerWebsocketOptions: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; readonly logAddress?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpServer.HttpServer | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/HttpShardManager.ts#L175)

Since v1.0.0
index-Activity.md
Package: `@effect/workflow`<br />
Module: `index`<br />

## index.Activity

Re-exports all named exports from the "./Activity.js" module as `Activity`.

**Signature**

```ts
export * as Activity from "./Activity.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L4)

Since v1.0.0
index-AiChat.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiChat

Re-exports all named exports from the "./AiChat.js" module as `AiChat`.

**Signature**

```ts
export * as AiChat from "./AiChat.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L4)

Since v1.0.0
index-AiEmbeddingModel.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiEmbeddingModel

Re-exports all named exports from the "./AiEmbeddingModel.js" module as `AiEmbeddingModel`.

**Signature**

```ts
export * as AiEmbeddingModel from "./AiEmbeddingModel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L9)

Since v1.0.0
index-AiError.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiError

Re-exports all named exports from the "./AiError.js" module as `AiError`.

**Signature**

```ts
export * as AiError from "./AiError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L14)

Since v1.0.0
index-AiInput.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiInput

Re-exports all named exports from the "./AiInput.js" module as `AiInput`.

**Signature**

```ts
export * as AiInput from "./AiInput.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L19)

Since v1.0.0
index-AiLanguageModel.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiLanguageModel

Re-exports all named exports from the "./AiLanguageModel.js" module as `AiLanguageModel`.

**Signature**

```ts
export * as AiLanguageModel from "./AiLanguageModel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L24)

Since v1.0.0
index-AiModel.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiModel

Re-exports all named exports from the "./AiModel.js" module as `AiModel`.

**Signature**

```ts
export * as AiModel from "./AiModel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L29)

Since v1.0.0
index-AiResponse.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiResponse

Re-exports all named exports from the "./AiResponse.js" module as `AiResponse`.

**Signature**

```ts
export * as AiResponse from "./AiResponse.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L34)

Since v1.0.0
index-AiTelemetry.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiTelemetry

Re-exports all named exports from the "./AiTelemetry.js" module as `AiTelemetry`.

**Signature**

```ts
export * as AiTelemetry from "./AiTelemetry.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L39)

Since v1.0.0
index-AiTool.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiTool

Re-exports all named exports from the "./AiTool.js" module as `AiTool`.

**Signature**

```ts
export * as AiTool from "./AiTool.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L44)

Since v1.0.0
index-AiToolkit.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.AiToolkit

Re-exports all named exports from the "./AiToolkit.js" module as `AiToolkit`.

**Signature**

```ts
export * as AiToolkit from "./AiToolkit.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L49)

Since v1.0.0
index-Alternative.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Alternative

Re-exports all named exports from the "./Alternative.js" module as `Alternative`.

**Signature**

```ts
export * as Alternative from "./Alternative.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L4)

Since v0.24.0
index-Ansi.md
Package: `@effect/printer-ansi`<br />
Module: `index`<br />

## index.Ansi

Re-exports all named exports from the "./Ansi.js" module as `Ansi`.

**Signature**

```ts
export * as Ansi from "./Ansi.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/index.ts#L4)

Since v1.0.0
index-AnsiDoc.md
Package: `@effect/printer-ansi`<br />
Module: `index`<br />

## index.AnsiDoc

Re-exports all named exports from the "./AnsiDoc.js" module as `AnsiDoc`.

**Signature**

```ts
export * as AnsiDoc from "./AnsiDoc.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/index.ts#L9)

Since v1.0.0
index-AnthropicClient.md
Package: `@effect/ai-anthropic`<br />
Module: `index`<br />

## index.AnthropicClient

Re-exports all named exports from the "./AnthropicClient.js" module as `AnthropicClient`.

**Signature**

```ts
export * as AnthropicClient from "./AnthropicClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/anthropic/src/index.ts#L4)

Since v1.0.0
index-AnthropicConfig.md
Package: `@effect/ai-anthropic`<br />
Module: `index`<br />

## index.AnthropicConfig

Re-exports all named exports from the "./AnthropicConfig.js" module as `AnthropicConfig`.

**Signature**

```ts
export * as AnthropicConfig from "./AnthropicConfig.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/anthropic/src/index.ts#L9)

Since v1.0.0
index-AnthropicLanguageModel.md
Package: `@effect/ai-anthropic`<br />
Module: `index`<br />

## index.AnthropicLanguageModel

Re-exports all named exports from the "./AnthropicLanguageModel.js" module as `AnthropicLanguageModel`.

**Signature**

```ts
export * as AnthropicLanguageModel from "./AnthropicLanguageModel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/anthropic/src/index.ts#L14)

Since v1.0.0
index-AnthropicTokenizer.md
Package: `@effect/ai-anthropic`<br />
Module: `index`<br />

## index.AnthropicTokenizer

Re-exports all named exports from the "./AnthropicTokenizer.js" module as `AnthropicTokenizer`.

**Signature**

```ts
export * as AnthropicTokenizer from "./AnthropicTokenizer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/anthropic/src/index.ts#L19)

Since v1.0.0
index-Applicative.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Applicative

Re-exports all named exports from the "./Applicative.js" module as `Applicative`.

**Signature**

```ts
export * as Applicative from "./Applicative.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L9)

Since v0.24.0
index-Arbitrary.md
Package: `effect`<br />
Module: `index`<br />

## index.Arbitrary

Re-exports all named exports from the "./Arbitrary.js" module as `Arbitrary`.

**Signature**

```ts
export * as Arbitrary from "./Arbitrary.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L35)

Since v3.10.0
index-Args.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.Args

Re-exports all named exports from the "./Args.js" module as `Args`.

**Signature**

```ts
export * as Args from "./Args.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L4)

Since v1.0.0
index-Array.md
Package: `effect`<br />
Module: `index`<br />

## index.Array

Re-exports all named exports from the "./Array.js" module as `Array`.

**Signature**

```ts
export * as Array from "./Array.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L42)

Since v2.0.0
index-AutoCorrect.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.AutoCorrect

Re-exports all named exports from the "./AutoCorrect.js" module as `AutoCorrect`.

**Signature**

```ts
export * as AutoCorrect from "./AutoCorrect.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L9)

Since v1.0.0
index-Bicovariant.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Bicovariant

Re-exports all named exports from the "./Bicovariant.js" module as `Bicovariant`.

**Signature**

```ts
export * as Bicovariant from "./Bicovariant.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L14)

Since v0.24.0
index-BigDecimal.md
Package: `effect`<br />
Module: `index`<br />

## index.BigDecimal

Re-exports all named exports from the "./BigDecimal.js" module as `BigDecimal`.

**See**

- `module:BigInt` for more similar operations on `bigint` types
- `module:Number` for more similar operations on `number` types

**Signature**

```ts
export * as BigDecimal from "./BigDecimal.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L62)

Since v2.0.0
index-BigInt.md
Package: `effect`<br />
Module: `index`<br />

## index.BigInt

Re-exports all named exports from the "./BigInt.js" module as `BigInt`.

**See**

- `module:BigDecimal` for more similar operations on `BigDecimal` types
- `module:Number` for more similar operations on `number` types

**Signature**

```ts
export * as BigInt from "./BigInt.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L74)

Since v2.0.0
index-Boolean.md
Package: `effect`<br />
Module: `index`<br />

## index.Boolean

Re-exports all named exports from the "./Boolean.js" module as `Boolean`.

**Signature**

```ts
export * as Boolean from "./Boolean.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L83)

Since v2.0.0
index-Bounded.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Bounded

Re-exports all named exports from the "./Bounded.js" module as `Bounded`.

**Signature**

```ts
export * as Bounded from "./Bounded.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L19)

Since v0.24.0
index-Brand.md
Package: `effect`<br />
Module: `index`<br />

## index.Brand

Re-exports all named exports from the "./Brand.js" module as `Brand`.

**Signature**

```ts
export * as Brand from "./Brand.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L103)

Since v2.0.0
index-BrowserHttpClient.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.BrowserHttpClient

Re-exports all named exports from the "./BrowserHttpClient.js" module as `BrowserHttpClient`.

**Signature**

```ts
export * as BrowserHttpClient from "./BrowserHttpClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L4)

Since v1.0.0
index-BrowserKeyValueStore.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.BrowserKeyValueStore

Re-exports all named exports from the "./BrowserKeyValueStore.js" module as `BrowserKeyValueStore`.

**Signature**

```ts
export * as BrowserKeyValueStore from "./BrowserKeyValueStore.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L9)

Since v1.0.0
index-BrowserRuntime.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.BrowserRuntime

Re-exports all named exports from the "./BrowserRuntime.js" module as `BrowserRuntime`.

**Signature**

```ts
export * as BrowserRuntime from "./BrowserRuntime.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L14)

Since v1.0.0
index-BrowserSocket.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.BrowserSocket

Re-exports all named exports from the "./BrowserSocket.js" module as `BrowserSocket`.

**Signature**

```ts
export * as BrowserSocket from "./BrowserSocket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L19)

Since v1.0.0
index-BrowserStream.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.BrowserStream

Re-exports all named exports from the "./BrowserStream.js" module as `BrowserStream`.

**Signature**

```ts
export * as BrowserStream from "./BrowserStream.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L24)

Since v1.0.0
index-BrowserWorker.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.BrowserWorker

Re-exports all named exports from the "./BrowserWorker.js" module as `BrowserWorker`.

**Signature**

```ts
export * as BrowserWorker from "./BrowserWorker.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L29)

Since v1.0.0
index-BrowserWorkerRunner.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.BrowserWorkerRunner

Re-exports all named exports from the "./BrowserWorkerRunner.js" module as `BrowserWorkerRunner`.

**Signature**

```ts
export * as BrowserWorkerRunner from "./BrowserWorkerRunner.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L34)

Since v1.0.0
index-BuiltInOptions.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.BuiltInOptions

Re-exports all named exports from the "./BuiltInOptions.js" module as `BuiltInOptions`.

**Signature**

```ts
export * as BuiltInOptions from "./BuiltInOptions.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L14)

Since v1.0.0
index-BunClusterRunnerHttp.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunClusterRunnerHttp

Re-exports all named exports from the "./BunClusterRunnerHttp.js" module as `BunClusterRunnerHttp`.

**Signature**

```ts
export * as BunClusterRunnerHttp from "./BunClusterRunnerHttp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L4)

Since v1.0.0
index-BunClusterRunnerSocket.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunClusterRunnerSocket

Re-exports all named exports from the "./BunClusterRunnerSocket.js" module as `BunClusterRunnerSocket`.

**Signature**

```ts
export * as BunClusterRunnerSocket from "./BunClusterRunnerSocket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L9)

Since v1.0.0
index-BunClusterShardManagerHttp.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunClusterShardManagerHttp

Re-exports all named exports from the "./BunClusterShardManagerHttp.js" module as `BunClusterShardManagerHttp`.

**Signature**

```ts
export * as BunClusterShardManagerHttp from "./BunClusterShardManagerHttp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L14)

Since v1.0.0
index-BunClusterShardManagerSocket.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunClusterShardManagerSocket

Re-exports all named exports from the "./BunClusterShardManagerSocket.js" module as `BunClusterShardManagerSocket`.

**Signature**

```ts
export * as BunClusterShardManagerSocket from "./BunClusterShardManagerSocket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L19)

Since v1.0.0
index-BunCommandExecutor.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunCommandExecutor

Re-exports all named exports from the "./BunCommandExecutor.js" module as `BunCommandExecutor`.

**Signature**

```ts
export * as BunCommandExecutor from "./BunCommandExecutor.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L24)

Since v1.0.0
index-BunContext.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunContext

Re-exports all named exports from the "./BunContext.js" module as `BunContext`.

**Signature**

```ts
export * as BunContext from "./BunContext.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L29)

Since v1.0.0
index-BunFileSystem.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunFileSystem

Re-exports all named exports from the "./BunFileSystem.js" module as `BunFileSystem`.

**Signature**

```ts
export * as BunFileSystem from "./BunFileSystem.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L34)

Since v1.0.0
index-BunHttpPlatform.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunHttpPlatform

Re-exports all named exports from the "./BunHttpPlatform.js" module as `BunHttpPlatform`.

**Signature**

```ts
export * as BunHttpPlatform from "./BunHttpPlatform.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L39)

Since v1.0.0
index-BunHttpServer.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunHttpServer

Re-exports all named exports from the "./BunHttpServer.js" module as `BunHttpServer`.

**Signature**

```ts
export * as BunHttpServer from "./BunHttpServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L44)

Since v1.0.0
index-BunHttpServerRequest.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunHttpServerRequest

Re-exports all named exports from the "./BunHttpServerRequest.js" module as `BunHttpServerRequest`.

**Signature**

```ts
export * as BunHttpServerRequest from "./BunHttpServerRequest.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L49)

Since v1.0.0
index-BunKeyValueStore.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunKeyValueStore

Re-exports all named exports from the "./BunKeyValueStore.js" module as `BunKeyValueStore`.

**Signature**

```ts
export * as BunKeyValueStore from "./BunKeyValueStore.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L54)

Since v1.0.0
index-BunMultipart.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunMultipart

Re-exports all named exports from the "./BunMultipart.js" module as `BunMultipart`.

**Signature**

```ts
export * as BunMultipart from "./BunMultipart.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L59)

Since v1.0.0
index-BunPath.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunPath

Re-exports all named exports from the "./BunPath.js" module as `BunPath`.

**Signature**

```ts
export * as BunPath from "./BunPath.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L64)

Since v1.0.0
index-BunRuntime.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunRuntime

Re-exports all named exports from the "./BunRuntime.js" module as `BunRuntime`.

**Signature**

```ts
export * as BunRuntime from "./BunRuntime.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L69)

Since v1.0.0
index-BunSink.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunSink

Re-exports all named exports from the "./BunSink.js" module as `BunSink`.

**Signature**

```ts
export * as BunSink from "./BunSink.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L74)

Since v1.0.0
index-BunSocket.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunSocket

Re-exports all named exports from the "./BunSocket.js" module as `BunSocket`.

**Signature**

```ts
export * as BunSocket from "./BunSocket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L79)

Since v1.0.0
index-BunSocketServer.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunSocketServer

Re-exports all named exports from the "./BunSocketServer.js" module as `BunSocketServer`.

**Signature**

```ts
export * as BunSocketServer from "./BunSocketServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L84)

Since v1.0.0
index-BunStream.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunStream

Re-exports all named exports from the "./BunStream.js" module as `BunStream`.

**Signature**

```ts
export * as BunStream from "./BunStream.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L89)

Since v1.0.0
index-BunTerminal.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunTerminal

Re-exports all named exports from the "./BunTerminal.js" module as `BunTerminal`.

**Signature**

```ts
export * as BunTerminal from "./BunTerminal.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L94)

Since v1.0.0
index-BunWorker.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunWorker

Re-exports all named exports from the "./BunWorker.js" module as `BunWorker`.

**Signature**

```ts
export * as BunWorker from "./BunWorker.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L99)

Since v1.0.0
index-BunWorkerRunner.md
Package: `@effect/platform-bun`<br />
Module: `index`<br />

## index.BunWorkerRunner

Re-exports all named exports from the "./BunWorkerRunner.js" module as `BunWorkerRunner`.

**Signature**

```ts
export * as BunWorkerRunner from "./BunWorkerRunner.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-bun/src/index.ts#L104)

Since v1.0.0
index-Cache.md
Package: `effect`<br />
Module: `index`<br />

## index.Cache

Re-exports all named exports from the "./Cache.js" module as `Cache`.

**Signature**

```ts
export * as Cache from "./Cache.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L108)

Since v2.0.0
index-Cause.md
Package: `effect`<br />
Module: `index`<br />

## index.Cause

Re-exports all named exports from the "./Cause.js" module as `Cause`.

**Signature**

```ts
export * as Cause from "./Cause.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L133)

Since v2.0.0
index-Chainable.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Chainable

Re-exports all named exports from the "./Chainable.js" module as `Chainable`.

**Signature**

```ts
export * as Chainable from "./Chainable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L24)

Since v0.24.0
index-Channel.md
Package: `effect`<br />
Module: `index`<br />

## index.Channel

Re-exports all named exports from the "./Channel.js" module as `Channel`.

**Signature**

```ts
export * as Channel from "./Channel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L138)

Since v2.0.0
index-ChannelSchema.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.ChannelSchema

Re-exports all named exports from the "./ChannelSchema.js" module as `ChannelSchema`.

**Signature**

```ts
export * as ChannelSchema from "./ChannelSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L4)

Since v1.0.0
index-ChildExecutorDecision.md
Package: `effect`<br />
Module: `index`<br />

## index.ChildExecutorDecision

Re-exports all named exports from the "./ChildExecutorDecision.js" module as `ChildExecutorDecision`.

**Signature**

```ts
export * as ChildExecutorDecision from "./ChildExecutorDecision.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L143)

Since v2.0.0
index-Chunk.md
Package: `effect`<br />
Module: `index`<br />

## index.Chunk

Re-exports all named exports from the "./Chunk.js" module as `Chunk`.

**Signature**

```ts
export * as Chunk from "./Chunk.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L148)

Since v2.0.0
index-CliApp.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.CliApp

Re-exports all named exports from the "./CliApp.js" module as `CliApp`.

**Signature**

```ts
export * as CliApp from "./CliApp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L19)

Since v1.0.0
index-CliConfig.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.CliConfig

Re-exports all named exports from the "./CliConfig.js" module as `CliConfig`.

**Signature**

```ts
export * as CliConfig from "./CliConfig.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L24)

Since v1.0.0
index-ClickhouseClient.md
Package: `@effect/sql-clickhouse`<br />
Module: `index`<br />

## index.ClickhouseClient

Re-exports all named exports from the "./ClickhouseClient.js" module as `ClickhouseClient`.

**Signature**

```ts
export * as ClickhouseClient from "./ClickhouseClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-clickhouse/src/index.ts#L4)

Since v1.0.0
index-ClickhouseMigrator.md
Package: `@effect/sql-clickhouse`<br />
Module: `index`<br />

## index.ClickhouseMigrator

Re-exports all named exports from the "./ClickhouseMigrator.js" module as `ClickhouseMigrator`.

**Signature**

```ts
export * as ClickhouseMigrator from "./ClickhouseMigrator.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-clickhouse/src/index.ts#L9)

Since v1.0.0
index-Clipboard.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.Clipboard

Re-exports all named exports from the "./Clipboard.js" module as `Clipboard`.

**Signature**

```ts
export * as Clipboard from "./Clipboard.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L39)

Since v1.0.0
index-Clock.md
Package: `effect`<br />
Module: `index`<br />

## index.Clock

Re-exports all named exports from the "./Clock.js" module as `Clock`.

**Signature**

```ts
export * as Clock from "./Clock.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L153)

Since v2.0.0
index-ClusterCron.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ClusterCron

Re-exports all named exports from the "./ClusterCron.js" module as `ClusterCron`.

**Signature**

```ts
export * as ClusterCron from "./ClusterCron.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L4)

Since v1.0.0
index-ClusterError.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ClusterError

Re-exports all named exports from the "./ClusterError.js" module as `ClusterError`.

**Signature**

```ts
export * as ClusterError from "./ClusterError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L9)

Since v1.0.0
index-ClusterMetrics.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ClusterMetrics

Re-exports all named exports from the "./ClusterMetrics.js" module as `ClusterMetrics`.

**Signature**

```ts
export * as ClusterMetrics from "./ClusterMetrics.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L14)

Since v1.0.0
index-ClusterSchema.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ClusterSchema

Re-exports all named exports from the "./ClusterSchema.js" module as `ClusterSchema`.

**Signature**

```ts
export * as ClusterSchema from "./ClusterSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L19)

Since v1.0.0
index-ClusterWorkflowEngine.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ClusterWorkflowEngine

Re-exports all named exports from the "./ClusterWorkflowEngine.js" module as `ClusterWorkflowEngine`.

**Signature**

```ts
export * as ClusterWorkflowEngine from "./ClusterWorkflowEngine.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L24)

Since v1.0.0
index-Color.md
Package: `@effect/printer-ansi`<br />
Module: `index`<br />

## index.Color

Re-exports all named exports from the "./Color.js" module as `Color`.

**Signature**

```ts
export * as Color from "./Color.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer-ansi/src/index.ts#L14)

Since v1.0.0
index-Command.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.Command

Re-exports all named exports from the "./Command.js" module as `Command`.

**Signature**

```ts
export * as Command from "./Command.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L29)

Since v1.0.0
index-CommandDescriptor.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.CommandDescriptor

Re-exports all named exports from the "./CommandDescriptor.js" module as `CommandDescriptor`.

**Signature**

```ts
export * as CommandDescriptor from "./CommandDescriptor.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L34)

Since v1.0.0
index-CommandDirective.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.CommandDirective

Re-exports all named exports from the "./CommandDirective.js" module as `CommandDirective`.

**Signature**

```ts
export * as CommandDirective from "./CommandDirective.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L39)

Since v1.0.0
index-CommandExecutor.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.CommandExecutor

Re-exports all named exports from the "./CommandExecutor.js" module as `CommandExecutor`.

**Signature**

```ts
export * as CommandExecutor from "./CommandExecutor.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L14)

Since v1.0.0
index-Config.md
Package: `effect`<br />
Module: `index`<br />

## index.Config

Re-exports all named exports from the "./Config.js" module as `Config`.

**Signature**

```ts
export * as Config from "./Config.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L158)

Since v2.0.0
index-ConfigError.md
Package: `effect`<br />
Module: `index`<br />

## index.ConfigError

Re-exports all named exports from the "./ConfigError.js" module as `ConfigError`.

**Signature**

```ts
export * as ConfigError from "./ConfigError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L163)

Since v2.0.0
index-ConfigFile.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.ConfigFile

Re-exports all named exports from the "./ConfigFile.js" module as `ConfigFile`.

**Signature**

```ts
export * as ConfigFile from "./ConfigFile.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L44)

Since v2.0.0
index-ConfigProvider.md
Package: `effect`<br />
Module: `index`<br />

## index.ConfigProvider

Re-exports all named exports from the "./ConfigProvider.js" module as `ConfigProvider`.

**Signature**

```ts
export * as ConfigProvider from "./ConfigProvider.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L168)

Since v2.0.0
index-ConfigProviderPathPatch.md
Package: `effect`<br />
Module: `index`<br />

## index.ConfigProviderPathPatch

Re-exports all named exports from the "./ConfigProviderPathPatch.js" module as `ConfigProviderPathPatch`.

**Signature**

```ts
export * as ConfigProviderPathPatch from "./ConfigProviderPathPatch.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L173)

Since v2.0.0
index-Console.md
Package: `effect`<br />
Module: `index`<br />

## index.Console

Re-exports all named exports from the "./Console.js" module as `Console`.

**Signature**

```ts
export * as Console from "./Console.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L178)

Since v2.0.0
index-Context.md
Package: `effect`<br />
Module: `index`<br />

## index.Context

Re-exports all named exports from the "./Context.js" module as `Context`.

**Signature**

```ts
export * as Context from "./Context.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L189)

Since v2.0.0
index-Contravariant.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Contravariant

Re-exports all named exports from the "./Contravariant.js" module as `Contravariant`.

**Signature**

```ts
export * as Contravariant from "./Contravariant.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L29)

Since v0.24.0
index-Cookies.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Cookies

Re-exports all named exports from the "./Cookies.js" module as `Cookies`.

**Signature**

```ts
export * as Cookies from "./Cookies.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L19)

Since v1.0.0
index-Coproduct.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Coproduct

Re-exports all named exports from the "./Coproduct.js" module as `Coproduct`.

**Signature**

```ts
export * as Coproduct from "./Coproduct.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L34)

Since v0.24.0
index-Covariant.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Covariant

Re-exports all named exports from the "./Covariant.js" module as `Covariant`.

**Signature**

```ts
export * as Covariant from "./Covariant.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L39)

Since v0.24.0
index-Cron.md
Package: `effect`<br />
Module: `index`<br />

## index.Cron

Re-exports all named exports from the "./Cron.js" module as `Cron`.

**Signature**

```ts
export * as Cron from "./Cron.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L194)

Since v2.0.0
index-D1Client.md
Package: `@effect/sql-d1`<br />
Module: `index`<br />

## index.D1Client

Re-exports all named exports from the "./D1Client.js" module as `D1Client`.

**Signature**

```ts
export * as D1Client from "./D1Client.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-d1/src/index.ts#L4)

Since v1.0.0
index-Data.md
Package: `effect`<br />
Module: `index`<br />

## index.Data

Re-exports all named exports from the "./Data.js" module as `Data`.

**Signature**

```ts
export * as Data from "./Data.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L199)

Since v2.0.0
index-DateTime.md
Package: `effect`<br />
Module: `index`<br />

## index.DateTime

Re-exports all named exports from the "./DateTime.js" module as `DateTime`.

**Signature**

```ts
export * as DateTime from "./DateTime.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L204)

Since v3.6.0
index-DefaultServices.md
Package: `effect`<br />
Module: `index`<br />

## index.DefaultServices

Re-exports all named exports from the "./DefaultServices.js" module as `DefaultServices`.

**Signature**

```ts
export * as DefaultServices from "./DefaultServices.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L209)

Since v2.0.0
index-Deferred.md
Package: `effect`<br />
Module: `index`<br />

## index.Deferred

Re-exports all named exports from the "./Deferred.js" module as `Deferred`.

**Signature**

```ts
export * as Deferred from "./Deferred.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L214)

Since v2.0.0
index-DeliverAt.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.DeliverAt

Re-exports all named exports from the "./DeliverAt.js" module as `DeliverAt`.

**Signature**

```ts
export * as DeliverAt from "./DeliverAt.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L29)

Since v1.0.0
index-DevTools.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.DevTools

Re-exports all named exports from the "./DevTools.js" module as `DevTools`.

**Signature**

```ts
export * as DevTools from "./DevTools.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L4)

Since v1.0.0
index-Differ.md
Package: `effect`<br />
Module: `index`<br />

## index.Differ

Re-exports all named exports from the "./Differ.js" module as `Differ`.

**Signature**

```ts
export * as Differ from "./Differ.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L219)

Since v2.0.0
index-Doc.md
Package: `@effect/printer`<br />
Module: `index`<br />

## index.Doc

Re-exports all named exports from the "./Doc.js" module as `Doc`.

**Signature**

```ts
export * as Doc from "./Doc.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/index.ts#L19)

Since v1.0.0
index-DocStream.md
Package: `@effect/printer`<br />
Module: `index`<br />

## index.DocStream

Re-exports all named exports from the "./DocStream.js" module as `DocStream`.

**Signature**

```ts
export * as DocStream from "./DocStream.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/index.ts#L24)

Since v1.0.0
index-DocTree.md
Package: `@effect/printer`<br />
Module: `index`<br />

## index.DocTree

Re-exports all named exports from the "./DocTree.js" module as `DocTree`.

**Signature**

```ts
export * as DocTree from "./DocTree.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/index.ts#L29)

Since v1.0.0
index-DurableClock.md
Package: `@effect/workflow`<br />
Module: `index`<br />

## index.DurableClock

Re-exports all named exports from the "./DurableClock.js" module as `DurableClock`.

**Signature**

```ts
export * as DurableClock from "./DurableClock.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L9)

Since v1.0.0
index-DurableDeferred.md
Package: `@effect/workflow`<br />
Module: `index`<br />

## index.DurableDeferred

Re-exports all named exports from the "./DurableDeferred.js" module as `DurableDeferred`.

**Signature**

```ts
export * as DurableDeferred from "./DurableDeferred.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L14)

Since v1.0.0
index-Duration.md
Package: `effect`<br />
Module: `index`<br />

## index.Duration

Re-exports all named exports from the "./Duration.js" module as `Duration`.

**Signature**

```ts
export * as Duration from "./Duration.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L224)

Since v2.0.0
index-Effect.md
Package: `effect`<br />
Module: `index`<br />

## index.Effect

Re-exports all named exports from the "./Effect.js" module as `Effect`.

**Signature**

```ts
export * as Effect from "./Effect.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L229)

Since v2.0.0
index-Effectable.md
Package: `effect`<br />
Module: `index`<br />

## index.Effectable

Re-exports all named exports from the "./Effectable.js" module as `Effectable`.

**Signature**

```ts
export * as Effectable from "./Effectable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L234)

Since v2.0.0
index-Effectify.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Effectify

Re-exports all named exports from the "./Effectify.js" module as `Effectify`.

**Signature**

```ts
export * as Effectify from "./Effectify.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L24)

Since v1.0.0
index-Either.md
Package: `effect`<br />
Module: `index`<br />

## index.Either

Re-exports all named exports from the "./Either.js" module as `Either`.

**Signature**

```ts
export * as Either from "./Either.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L239)

Since v2.0.0
index-Encoding.md
Package: `effect`<br />
Module: `index`<br />

## index.Encoding

Re-exports all named exports from the "./Encoding.js" module as `Encoding`.

**Signature**

```ts
export * as Encoding from "./Encoding.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L250)

Since v2.0.0
index-Entity.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Entity

Re-exports all named exports from the "./Entity.js" module as `Entity`.

**Signature**

```ts
export * as Entity from "./Entity.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L34)

Since v1.0.0
index-EntityAddress.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.EntityAddress

Re-exports all named exports from the "./EntityAddress.js" module as `EntityAddress`.

**Signature**

```ts
export * as EntityAddress from "./EntityAddress.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L39)

Since v1.0.0
index-EntityId.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.EntityId

Re-exports all named exports from the "./EntityId.js" module as `EntityId`.

**Signature**

```ts
export * as EntityId from "./EntityId.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L44)

Since v1.0.0
index-EntityProxy.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.EntityProxy

Re-exports all named exports from the "./EntityProxy.js" module as `EntityProxy`.

**Signature**

```ts
export * as EntityProxy from "./EntityProxy.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L49)

Since v1.0.0
index-EntityProxyServer.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.EntityProxyServer

Re-exports all named exports from the "./EntityProxyServer.js" module as `EntityProxyServer`.

**Signature**

```ts
export * as EntityProxyServer from "./EntityProxyServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L54)

Since v1.0.0
index-EntityType.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.EntityType

Re-exports all named exports from the "./EntityType.js" module as `EntityType`.

**Signature**

```ts
export * as EntityType from "./EntityType.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L59)

Since v1.0.0
index-Envelope.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Envelope

Re-exports all named exports from the "./Envelope.js" module as `Envelope`.

**Signature**

```ts
export * as Envelope from "./Envelope.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L64)

Since v1.0.0
index-Equal.md
Package: `effect`<br />
Module: `index`<br />

## index.Equal

Re-exports all named exports from the "./Equal.js" module as `Equal`.

**Signature**

```ts
export * as Equal from "./Equal.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L255)

Since v2.0.0
index-Equivalence.md
Package: `effect`<br />
Module: `index`<br />

## index.Equivalence

Re-exports all named exports from the "./Equivalence.js" module as `Equivalence`.

**Signature**

```ts
export * as Equivalence from "./Equivalence.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L264)

Since v2.0.0
index-Error.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Error

Re-exports all named exports from the "./Error.js" module as `Error`.

**Signature**

```ts
export * as Error from "./Error.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L29)

Since v1.0.0
index-Etag.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Etag

Re-exports all named exports from the "./Etag.js" module as `Etag`.

**Signature**

```ts
export * as Etag from "./Etag.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L34)

Since v1.0.0
index-Event.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.Event

Re-exports all named exports from the "./Event.js" module as `Event`.

**Signature**

```ts
export * as Event from "./Event.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L9)

Since v1.0.0
index-EventGroup.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.EventGroup

Re-exports all named exports from the "./EventGroup.js" module as `EventGroup`.

**Signature**

```ts
export * as EventGroup from "./EventGroup.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L14)

Since v1.0.0
index-EventJournal.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.EventJournal

Re-exports all named exports from the "./EventJournal.js" module as `EventJournal`.

**Signature**

```ts
export * as EventJournal from "./EventJournal.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L19)

Since v1.0.0
index-EventLog.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.EventLog

Re-exports all named exports from the "./EventLog.js" module as `EventLog`.

**Signature**

```ts
export * as EventLog from "./EventLog.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L24)

Since v1.0.0
index-EventLogEncryption.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.EventLogEncryption

Re-exports all named exports from the "./EventLogEncryption.js" module as `EventLogEncryption`.

**Signature**

```ts
export * as EventLogEncryption from "./EventLogEncryption.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L29)

Since v1.0.0
index-EventLogRemote.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.EventLogRemote

Re-exports all named exports from the "./EventLogRemote.js" module as `EventLogRemote`.

**Signature**

```ts
export * as EventLogRemote from "./EventLogRemote.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L34)

Since v1.0.0
index-EventLogServer.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.EventLogServer

Re-exports all named exports from the "./EventLogServer.js" module as `EventLogServer`.

**Signature**

```ts
export * as EventLogServer from "./EventLogServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L39)

Since v1.0.0
index-ExecutionPlan.md
Package: `effect`<br />
Module: `index`<br />

## index.ExecutionPlan

Re-exports all named exports from the "./ExecutionPlan.js" module as `ExecutionPlan`.

**Signature**

```ts
export * as ExecutionPlan from "./ExecutionPlan.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L270)

Since v3.16.0
index-ExecutionStrategy.md
Package: `effect`<br />
Module: `index`<br />

## index.ExecutionStrategy

Re-exports all named exports from the "./ExecutionStrategy.js" module as `ExecutionStrategy`.

**Signature**

```ts
export * as ExecutionStrategy from "./ExecutionStrategy.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L275)

Since v2.0.0
index-Exit.md
Package: `effect`<br />
Module: `index`<br />

## index.Exit

Re-exports all named exports from the "./Exit.js" module as `Exit`.

**Signature**

```ts
export * as Exit from "./Exit.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L280)

Since v2.0.0
index-FastCheck.md
Package: `effect`<br />
Module: `index`<br />

## index.FastCheck

Re-exports all named exports from the "./FastCheck.js" module as `FastCheck`.

**Signature**

```ts
export * as FastCheck from "./FastCheck.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L285)

Since v3.10.0
index-FetchHttpClient.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.FetchHttpClient

Re-exports all named exports from the "./FetchHttpClient.js" module as `FetchHttpClient`.

**Signature**

```ts
export * as FetchHttpClient from "./FetchHttpClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L39)

Since v1.0.0
index-Fiber.md
Package: `effect`<br />
Module: `index`<br />

## index.Fiber

Re-exports all named exports from the "./Fiber.js" module as `Fiber`.

**Signature**

```ts
export * as Fiber from "./Fiber.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L290)

Since v2.0.0
index-FiberHandle.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberHandle

Re-exports all named exports from the "./FiberHandle.js" module as `FiberHandle`.

**Signature**

```ts
export * as FiberHandle from "./FiberHandle.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L295)

Since v2.0.0
index-FiberId.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberId

Re-exports all named exports from the "./FiberId.js" module as `FiberId`.

**Signature**

```ts
export * as FiberId from "./FiberId.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L300)

Since v2.0.0
index-FiberMap.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberMap

Re-exports all named exports from the "./FiberMap.js" module as `FiberMap`.

**Signature**

```ts
export * as FiberMap from "./FiberMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L305)

Since v2.0.0
index-FiberRef.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberRef

Re-exports all named exports from the "./FiberRef.js" module as `FiberRef`.

**Signature**

```ts
export * as FiberRef from "./FiberRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L310)

Since v2.0.0
index-FiberRefs.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberRefs

Re-exports all named exports from the "./FiberRefs.js" module as `FiberRefs`.

**Signature**

```ts
export * as FiberRefs from "./FiberRefs.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L315)

Since v2.0.0
index-FiberRefsPatch.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberRefsPatch

Re-exports all named exports from the "./FiberRefsPatch.js" module as `FiberRefsPatch`.

**Signature**

```ts
export * as FiberRefsPatch from "./FiberRefsPatch.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L320)

Since v2.0.0
index-FiberSet.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberSet

Re-exports all named exports from the "./FiberSet.js" module as `FiberSet`.

**Signature**

```ts
export * as FiberSet from "./FiberSet.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L325)

Since v2.0.0
index-FiberStatus.md
Package: `effect`<br />
Module: `index`<br />

## index.FiberStatus

Re-exports all named exports from the "./FiberStatus.js" module as `FiberStatus`.

**Signature**

```ts
export * as FiberStatus from "./FiberStatus.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L330)

Since v2.0.0
index-FileSystem.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.FileSystem

Re-exports all named exports from the "./FileSystem.js" module as `FileSystem`.

**Signature**

```ts
export * as FileSystem from "./FileSystem.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L44)

Since v1.0.0
index-Filterable.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Filterable

Re-exports all named exports from the "./Filterable.js" module as `Filterable`.

**Signature**

```ts
export * as Filterable from "./Filterable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L46)

Since v0.24.0
index-FlatMap.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.FlatMap

Re-exports all named exports from the "./FlatMap.js" module as `FlatMap`.

**Signature**

```ts
export * as FlatMap from "./FlatMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L51)

Since v0.24.0
index-Flatten.md
Package: `@effect/printer`<br />
Module: `index`<br />

## index.Flatten

Re-exports all named exports from the "./Flatten.js" module as `Flatten`.

**Signature**

```ts
export * as Flatten from "./Flatten.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/index.ts#L34)

Since v1.0.0
index-Foldable.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Foldable

Re-exports all named exports from the "./Foldable.js" module as `Foldable`.

**Signature**

```ts
export * as Foldable from "./Foldable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L56)

Since v0.24.0
index-Function.md
Package: `effect`<br />
Module: `index`<br />

## index.Function

Re-exports all named exports from the "./Function.js" module as `Function`.

**Signature**

```ts
export * as Function from "./Function.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L335)

Since v2.0.0
index-Generated.md
Package: `@effect/ai-anthropic`<br />
Module: `index`<br />

## index.Generated

Re-exports all named exports from the "./Generated.js" module as `Generated`.

**Signature**

```ts
export * as Generated from "./Generated.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/anthropic/src/index.ts#L24)

Since v1.0.0
index-Geolocation.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.Geolocation

Re-exports all named exports from the "./Geolocation.js" module as `Geolocation`.

**Signature**

```ts
export * as Geolocation from "./Geolocation.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L44)

Since v1.0.0
index-GlobalValue.md
Package: `effect`<br />
Module: `index`<br />

## index.GlobalValue

Re-exports all named exports from the "./GlobalValue.js" module as `GlobalValue`.

**Signature**

```ts
export * as GlobalValue from "./GlobalValue.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L351)

Since v2.0.0
index-GroupBy.md
Package: `effect`<br />
Module: `index`<br />

## index.GroupBy

Re-exports all named exports from the "./GroupBy.js" module as `GroupBy`.

**Signature**

```ts
export * as GroupBy from "./GroupBy.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L356)

Since v2.0.0
index-HKT.md
Package: `effect`<br />
Module: `index`<br />

## index.HKT

Re-exports all named exports from the "./HKT.js" module as `HKT`.

**Signature**

```ts
export * as HKT from "./HKT.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L361)

Since v2.0.0
index-Hash.md
Package: `effect`<br />
Module: `index`<br />

## index.Hash

Re-exports all named exports from the "./Hash.js" module as `Hash`.

**Signature**

```ts
export * as Hash from "./Hash.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L366)

Since v2.0.0
index-HashMap.md
Package: `effect`<br />
Module: `index`<br />

## index.HashMap

Re-exports all named exports from the "./HashMap.js" module as `HashMap`.

**Signature**

```ts
export * as HashMap from "./HashMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L371)

Since v2.0.0
index-HashSet.md
Package: `effect`<br />
Module: `index`<br />

## index.HashSet

Re-exports all named exports from the "./HashSet.js" module as `HashSet`.

**Signature**

```ts
export * as HashSet from "./HashSet.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L626)

Since v2.0.0
index-Headers.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Headers

Re-exports all named exports from the "./Headers.js" module as `Headers`.

**Signature**

```ts
export * as Headers from "./Headers.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L49)

Since v1.0.0
index-HelpDoc.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.HelpDoc

Re-exports all named exports from the "./HelpDoc.js" module as `HelpDoc`.

**Signature**

```ts
export * as HelpDoc from "./HelpDoc.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L49)

Since v1.0.0
index-HttpApi.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApi

Re-exports all named exports from the "./HttpApi.js" module as `HttpApi`.

**Signature**

```ts
export * as HttpApi from "./HttpApi.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L54)

Since v1.0.0
index-HttpApiBuilder.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiBuilder

Re-exports all named exports from the "./HttpApiBuilder.js" module as `HttpApiBuilder`.

**Signature**

```ts
export * as HttpApiBuilder from "./HttpApiBuilder.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L59)

Since v1.0.0
index-HttpApiClient.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiClient

Re-exports all named exports from the "./HttpApiClient.js" module as `HttpApiClient`.

**Signature**

```ts
export * as HttpApiClient from "./HttpApiClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L64)

Since v1.0.0
index-HttpApiEndpoint.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiEndpoint

Re-exports all named exports from the "./HttpApiEndpoint.js" module as `HttpApiEndpoint`.

**Signature**

```ts
export * as HttpApiEndpoint from "./HttpApiEndpoint.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L69)

Since v1.0.0
index-HttpApiError.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiError

Re-exports all named exports from the "./HttpApiError.js" module as `HttpApiError`.

**Signature**

```ts
export * as HttpApiError from "./HttpApiError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L74)

Since v1.0.0
index-HttpApiGroup.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiGroup

Re-exports all named exports from the "./HttpApiGroup.js" module as `HttpApiGroup`.

**Signature**

```ts
export * as HttpApiGroup from "./HttpApiGroup.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L79)

Since v1.0.0
index-HttpApiMiddleware.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiMiddleware

Re-exports all named exports from the "./HttpApiMiddleware.js" module as `HttpApiMiddleware`.

**Signature**

```ts
export * as HttpApiMiddleware from "./HttpApiMiddleware.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L84)

Since v1.0.0
index-HttpApiScalar.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiScalar

Re-exports all named exports from the "./HttpApiScalar.js" module as `HttpApiScalar`.

**Signature**

```ts
export * as HttpApiScalar from "./HttpApiScalar.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L89)

Since v1.0.0
index-HttpApiSchema.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiSchema

Re-exports all named exports from the "./HttpApiSchema.js" module as `HttpApiSchema`.

**Signature**

```ts
export * as HttpApiSchema from "./HttpApiSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L94)

Since v1.0.0
index-HttpApiSecurity.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiSecurity

Re-exports all named exports from the "./HttpApiSecurity.js" module as `HttpApiSecurity`.

**Signature**

```ts
export * as HttpApiSecurity from "./HttpApiSecurity.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L99)

Since v1.0.0
index-HttpApiSwagger.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApiSwagger

Re-exports all named exports from the "./HttpApiSwagger.js" module as `HttpApiSwagger`.

**Signature**

```ts
export * as HttpApiSwagger from "./HttpApiSwagger.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L104)

Since v1.0.0
index-HttpApp.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpApp

Re-exports all named exports from the "./HttpApp.js" module as `HttpApp`.

**Signature**

```ts
export * as HttpApp from "./HttpApp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L109)

Since v1.0.0
index-HttpBody.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpBody

Re-exports all named exports from the "./HttpBody.js" module as `HttpBody`.

**Signature**

```ts
export * as HttpBody from "./HttpBody.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L114)

Since v1.0.0
index-HttpClient.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpClient

Re-exports all named exports from the "./HttpClient.js" module as `HttpClient`.

**Signature**

```ts
export * as HttpClient from "./HttpClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L119)

Since v1.0.0
index-HttpClientError.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpClientError

Re-exports all named exports from the "./HttpClientError.js" module as `HttpClientError`.

**Signature**

```ts
export * as HttpClientError from "./HttpClientError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L124)

Since v1.0.0
index-HttpClientRequest.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpClientRequest

Re-exports all named exports from the "./HttpClientRequest.js" module as `HttpClientRequest`.

**Signature**

```ts
export * as HttpClientRequest from "./HttpClientRequest.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L129)

Since v1.0.0
index-HttpClientResponse.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpClientResponse

Re-exports all named exports from the "./HttpClientResponse.js" module as `HttpClientResponse`.

**Signature**

```ts
export * as HttpClientResponse from "./HttpClientResponse.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L134)

Since v1.0.0
index-HttpCommon.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.HttpCommon

Re-exports all named exports from the "./HttpCommon.js" module as `HttpCommon`.

**Signature**

```ts
export * as HttpCommon from "./HttpCommon.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L69)

Since v1.0.0
index-HttpIncomingMessage.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpIncomingMessage

Re-exports all named exports from the "./HttpIncomingMessage.js" module as `HttpIncomingMessage`.

**Signature**

```ts
export * as HttpIncomingMessage from "./HttpIncomingMessage.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L139)

Since v1.0.0
index-HttpMethod.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpMethod

Re-exports all named exports from the "./HttpMethod.js" module as `HttpMethod`.

**Signature**

```ts
export * as HttpMethod from "./HttpMethod.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L145)

Since v1.0.0
index-HttpMiddleware.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpMiddleware

Re-exports all named exports from the "./HttpMiddleware.js" module as `HttpMiddleware`.

**Signature**

```ts
export * as HttpMiddleware from "./HttpMiddleware.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L150)

Since v1.0.0
index-HttpMultiplex.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpMultiplex

Re-exports all named exports from the "./HttpMultiplex.js" module as `HttpMultiplex`.

**Signature**

```ts
export * as HttpMultiplex from "./HttpMultiplex.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L155)

Since v1.0.0
index-HttpPlatform.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpPlatform

Re-exports all named exports from the "./HttpPlatform.js" module as `HttpPlatform`.

**Signature**

```ts
export * as HttpPlatform from "./HttpPlatform.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L160)

Since v1.0.0
index-HttpRouter.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpRouter

Re-exports all named exports from the "./HttpRouter.js" module as `HttpRouter`.

**Signature**

```ts
export * as HttpRouter from "./HttpRouter.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L165)

Since v1.0.0
index-HttpRunner.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.HttpRunner

Re-exports all named exports from the "./HttpRunner.js" module as `HttpRunner`.

**Signature**

```ts
export * as HttpRunner from "./HttpRunner.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L74)

Since v1.0.0
index-HttpServer.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpServer

Re-exports all named exports from the "./HttpServer.js" module as `HttpServer`.

**Signature**

```ts
export * as HttpServer from "./HttpServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L170)

Since v1.0.0
index-HttpServerError.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpServerError

Re-exports all named exports from the "./HttpServerError.js" module as `HttpServerError`.

**Signature**

```ts
export * as HttpServerError from "./HttpServerError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L175)

Since v1.0.0
index-HttpServerRequest.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpServerRequest

Re-exports all named exports from the "./HttpServerRequest.js" module as `HttpServerRequest`.

**Signature**

```ts
export * as HttpServerRequest from "./HttpServerRequest.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L180)

Since v1.0.0
index-HttpServerRespondable.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpServerRespondable

Re-exports all named exports from the "./HttpServerRespondable.js" module as `HttpServerRespondable`.

**Signature**

```ts
export * as HttpServerRespondable from "./HttpServerRespondable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L185)

Since v1.0.0
index-HttpServerResponse.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpServerResponse

Re-exports all named exports from the "./HttpServerResponse.js" module as `HttpServerResponse`.

**Signature**

```ts
export * as HttpServerResponse from "./HttpServerResponse.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L190)

Since v1.0.0
index-HttpShardManager.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.HttpShardManager

Re-exports all named exports from the "./HttpShardManager.js" module as `HttpShardManager`.

**Signature**

```ts
export * as HttpShardManager from "./HttpShardManager.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L79)

Since v1.0.0
index-HttpTraceContext.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.HttpTraceContext

Re-exports all named exports from the "./HttpTraceContext.js" module as `HttpTraceContext`.

**Signature**

```ts
export * as HttpTraceContext from "./HttpTraceContext.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L195)

Since v1.0.0
index-Inspectable.md
Package: `effect`<br />
Module: `index`<br />

## index.Inspectable

Re-exports all named exports from the "./Inspectable.js" module as `Inspectable`.

**Signature**

```ts
export * as Inspectable from "./Inspectable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L631)

Since v2.0.0
index-Invariant.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Invariant

Re-exports all named exports from the "./Invariant.js" module as `Invariant`.

**Signature**

```ts
export * as Invariant from "./Invariant.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L66)

Since v0.24.0
index-Iterable.md
Package: `effect`<br />
Module: `index`<br />

## index.Iterable

Re-exports all named exports from the "./Iterable.js" module as `Iterable`.

**Signature**

```ts
export * as Iterable from "./Iterable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L638)

Since v2.0.0
index-JSONSchema.md
Package: `effect`<br />
Module: `index`<br />

## index.JSONSchema

Re-exports all named exports from the "./JSONSchema.js" module as `JSONSchema`.

**Signature**

```ts
export * as JSONSchema from "./JSONSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L643)

Since v3.10.0
index-KeyValueStore.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.KeyValueStore

Re-exports all named exports from the "./KeyValueStore.js" module as `KeyValueStore`.

**Signature**

```ts
export * as KeyValueStore from "./KeyValueStore.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L200)

Since v1.0.0
index-KeyedPool.md
Package: `effect`<br />
Module: `index`<br />

## index.KeyedPool

Re-exports all named exports from the "./KeyedPool.js" module as `KeyedPool`.

**Signature**

```ts
export * as KeyedPool from "./KeyedPool.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L648)

Since v2.0.0
index-Layer.md
Package: `effect`<br />
Module: `index`<br />

## index.Layer

Re-exports all named exports from the "./Layer.js" module as `Layer`.

**Signature**

```ts
export * as Layer from "./Layer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L669)

Since v2.0.0
index-LayerMap.md
Package: `effect`<br />
Module: `index`<br />

## index.LayerMap

Re-exports all named exports from the "./LayerMap.js" module as `LayerMap`.

**Signature**

```ts
export * as LayerMap from "./LayerMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L675)

Since v3.14.0
index-Layout.md
Package: `@effect/printer`<br />
Module: `index`<br />

## index.Layout

Re-exports all named exports from the "./Layout.js" module as `Layout`.

**Signature**

```ts
export * as Layout from "./Layout.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/index.ts#L39)

Since v1.0.0
index-LibsqlClient.md
Package: `@effect/sql-libsql`<br />
Module: `index`<br />

## index.LibsqlClient

Re-exports all named exports from the "./LibsqlClient.js" module as `LibsqlClient`.

**Signature**

```ts
export * as LibsqlClient from "./LibsqlClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-libsql/src/index.ts#L4)

Since v1.0.0
index-LibsqlMigrator.md
Package: `@effect/sql-libsql`<br />
Module: `index`<br />

## index.LibsqlMigrator

Re-exports all named exports from the "./LibsqlMigrator.js" module as `LibsqlMigrator`.

**Signature**

```ts
export * as LibsqlMigrator from "./LibsqlMigrator.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-libsql/src/index.ts#L9)

Since v1.0.0
index-List.md
Package: `effect`<br />
Module: `index`<br />

## index.List

Re-exports all named exports from the "./List.js" module as `List`.

**Signature**

```ts
export * as List from "./List.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L689)

Since v2.0.0
index-LogLevel.md
Package: `effect`<br />
Module: `index`<br />

## index.LogLevel

Re-exports all named exports from the "./LogLevel.js" module as `LogLevel`.

**Signature**

```ts
export * as LogLevel from "./LogLevel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L694)

Since v2.0.0
index-LogSpan.md
Package: `effect`<br />
Module: `index`<br />

## index.LogSpan

Re-exports all named exports from the "./LogSpan.js" module as `LogSpan`.

**Signature**

```ts
export * as LogSpan from "./LogSpan.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L699)

Since v2.0.0
index-Logger.md
Package: `effect`<br />
Module: `index`<br />

## index.Logger

Re-exports all named exports from the "./Logger.js" module as `Logger`.

**Signature**

```ts
export * as Logger from "./Logger.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L704)

Since v2.0.0
index-Machine.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.Machine

Re-exports all named exports from the "./Machine.js" module as `Machine`.

**Signature**

```ts
export * as Machine from "./Machine.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L44)

Since v1.0.0
index-MachineId.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.MachineId

Re-exports all named exports from the "./MachineId.js" module as `MachineId`.

**Signature**

```ts
export * as MachineId from "./MachineId.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L84)

Since v1.0.0
index-Mailbox.md
Package: `effect`<br />
Module: `index`<br />

## index.Mailbox

Re-exports all named exports from the "./Mailbox.js" module as `Mailbox`.

**Signature**

```ts
export * as Mailbox from "./Mailbox.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L710)

Since v3.8.0
index-ManagedRuntime.md
Package: `effect`<br />
Module: `index`<br />

## index.ManagedRuntime

Re-exports all named exports from the "./ManagedRuntime.js" module as `ManagedRuntime`.

**Signature**

```ts
export * as ManagedRuntime from "./ManagedRuntime.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L715)

Since v2.0.0
index-Match.md
Package: `effect`<br />
Module: `index`<br />

## index.Match

Re-exports all named exports from the "./Match.js" module as `Match`.

**Signature**

```ts
export * as Match from "./Match.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L745)

Since v1.0.0
index-MergeDecision.md
Package: `effect`<br />
Module: `index`<br />

## index.MergeDecision

Re-exports all named exports from the "./MergeDecision.js" module as `MergeDecision`.

**Signature**

```ts
export * as MergeDecision from "./MergeDecision.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L750)

Since v2.0.0
index-MergeState.md
Package: `effect`<br />
Module: `index`<br />

## index.MergeState

Re-exports all named exports from the "./MergeState.js" module as `MergeState`.

**Signature**

```ts
export * as MergeState from "./MergeState.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L755)

Since v2.0.0
index-MergeStrategy.md
Package: `effect`<br />
Module: `index`<br />

## index.MergeStrategy

Re-exports all named exports from the "./MergeStrategy.js" module as `MergeStrategy`.

**Signature**

```ts
export * as MergeStrategy from "./MergeStrategy.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L760)

Since v2.0.0
index-Message.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Message

Re-exports all named exports from the "./Message.js" module as `Message`.

**Signature**

```ts
export * as Message from "./Message.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L89)

Since v1.0.0
index-MessageStorage.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.MessageStorage

Re-exports all named exports from the "./MessageStorage.js" module as `MessageStorage`.

**Signature**

```ts
export * as MessageStorage from "./MessageStorage.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L94)

Since v1.0.0
index-Metric.md
Package: `effect`<br />
Module: `index`<br />

## index.Metric

Re-exports all named exports from the "./Metric.js" module as `Metric`.

**Signature**

```ts
export * as Metric from "./Metric.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L765)

Since v2.0.0
index-MetricBoundaries.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricBoundaries

Re-exports all named exports from the "./MetricBoundaries.js" module as `MetricBoundaries`.

**Signature**

```ts
export * as MetricBoundaries from "./MetricBoundaries.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L770)

Since v2.0.0
index-MetricHook.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricHook

Re-exports all named exports from the "./MetricHook.js" module as `MetricHook`.

**Signature**

```ts
export * as MetricHook from "./MetricHook.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L775)

Since v2.0.0
index-MetricKey.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricKey

Re-exports all named exports from the "./MetricKey.js" module as `MetricKey`.

**Signature**

```ts
export * as MetricKey from "./MetricKey.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L780)

Since v2.0.0
index-MetricKeyType.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricKeyType

Re-exports all named exports from the "./MetricKeyType.js" module as `MetricKeyType`.

**Signature**

```ts
export * as MetricKeyType from "./MetricKeyType.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L785)

Since v2.0.0
index-MetricLabel.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricLabel

Re-exports all named exports from the "./MetricLabel.js" module as `MetricLabel`.

**Signature**

```ts
export * as MetricLabel from "./MetricLabel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L790)

Since v2.0.0
index-MetricPair.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricPair

Re-exports all named exports from the "./MetricPair.js" module as `MetricPair`.

**Signature**

```ts
export * as MetricPair from "./MetricPair.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L795)

Since v2.0.0
index-MetricPolling.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricPolling

Re-exports all named exports from the "./MetricPolling.js" module as `MetricPolling`.

**Signature**

```ts
export * as MetricPolling from "./MetricPolling.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L800)

Since v2.0.0
index-MetricRegistry.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricRegistry

Re-exports all named exports from the "./MetricRegistry.js" module as `MetricRegistry`.

**Signature**

```ts
export * as MetricRegistry from "./MetricRegistry.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L805)

Since v2.0.0
index-MetricState.md
Package: `effect`<br />
Module: `index`<br />

## index.MetricState

Re-exports all named exports from the "./MetricState.js" module as `MetricState`.

**Signature**

```ts
export * as MetricState from "./MetricState.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L810)

Since v2.0.0
index-Metrics.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.Metrics

Re-exports all named exports from the "./Metrics.js" module as `Metrics`.

**Signature**

```ts
export * as Metrics from "./Metrics.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L9)

Since v1.0.0
index-Micro.md
Package: `effect`<br />
Module: `index`<br />

## index.Micro

Re-exports all named exports from the "./Micro.js" module as `Micro`.

**Signature**

```ts
export * as Micro from "./Micro.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L818)

Since v3.4.0
index-Migrator.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.Migrator

Re-exports all named exports from the "./Migrator.js" module as `Migrator`.

**Signature**

```ts
export * as Migrator from "./Migrator.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L4)

Since v1.0.0
index-Model.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.Model

Re-exports all named exports from the "./Model.js" module as `Model`.

**Signature**

```ts
export * as Model from "./Model.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L9)

Since v1.0.0
index-ModuleVersion.md
Package: `effect`<br />
Module: `index`<br />

## index.ModuleVersion

Re-exports all named exports from the "./ModuleVersion.js" module as `ModuleVersion`.

**Signature**

```ts
export * as ModuleVersion from "./ModuleVersion.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L825)

Since v2.0.0

Enables low level framework authors to run on their own isolated effect version
index-Monad.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Monad

Re-exports all named exports from the "./Monad.js" module as `Monad`.

**Signature**

```ts
export * as Monad from "./Monad.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L71)

Since v0.24.0
index-Monoid.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Monoid

Re-exports all named exports from the "./Monoid.js" module as `Monoid`.

**Signature**

```ts
export * as Monoid from "./Monoid.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L76)

Since v0.24.0
index-MsgPack.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.MsgPack

Re-exports all named exports from the "./MsgPack.js" module as `MsgPack`.

**Signature**

```ts
export * as MsgPack from "./MsgPack.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L205)

Since v1.0.0
index-layer.md
Package: `@effect/vitest`<br />
Module: `index`<br />

## index.layer

Share a `Layer` between multiple tests, optionally wrapping
the tests in a `describe` block if a name is provided.

**Signature**

```ts
declare const layer: <R, E, const ExcludeTestServices extends boolean = false>(layer_: Layer.Layer<R, E>, options?: { readonly memoMap?: Layer.MemoMap; readonly timeout?: Duration.DurationInput; readonly excludeTestServices?: ExcludeTestServices; }) => { (f: (it: Vitest.MethodsNonLive<R, ExcludeTestServices>) => void): void; (name: string, f: (it: Vitest.MethodsNonLive<R, ExcludeTestServices>) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/index.ts#L209)

Since v1.0.0

```ts
import { expect, layer } from "@effect/vitest"
import { Context, Effect, Layer } from "effect"

class Foo extends Context.Tag("Foo")<Foo, "foo">() {
  static Live = Layer.succeed(Foo, "foo")
}

class Bar extends Context.Tag("Bar")<Bar, "bar">() {
  static Live = Layer.effect(
    Bar,
    Effect.map(Foo, () => "bar" as const)
  )
}

layer(Foo.Live)("layer", (it) => {
  it.effect("adds context", () =>
    Effect.gen(function* () {
      const foo = yield* Foo
      expect(foo).toEqual("foo")
    })
  )

  it.layer(Bar.Live)("nested", (it) => {
    it.effect("adds context", () =>
      Effect.gen(function* () {
        const foo = yield* Foo
        const bar = yield* Bar
        expect(foo).toEqual("foo")
        expect(bar).toEqual("bar")
      })
    )
  })
})
```
index-MssqlClient.md
Package: `@effect/sql-mssql`<br />
Module: `index`<br />

## index.MssqlClient

Re-exports all named exports from the "./MssqlClient.js" module as `MssqlClient`.

**Signature**

```ts
export * as MssqlClient from "./MssqlClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-mssql/src/index.ts#L15)

Since v1.0.0
index-MssqlMigrator.md
Package: `@effect/sql-mssql`<br />
Module: `index`<br />

## index.MssqlMigrator

Re-exports all named exports from the "./MssqlMigrator.js" module as `MssqlMigrator`.

**Signature**

```ts
export * as MssqlMigrator from "./MssqlMigrator.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-mssql/src/index.ts#L20)

Since v1.0.0
index-Multipart.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Multipart

Re-exports all named exports from the "./Multipart.js" module as `Multipart`.

**Signature**

```ts
export * as Multipart from "./Multipart.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L210)

Since v1.0.0
index-MutableHashMap.md
Package: `effect`<br />
Module: `index`<br />

## index.MutableHashMap

Re-exports all named exports from the "./MutableHashMap.js" module as `MutableHashMap`.

**Signature**

```ts
export * as MutableHashMap from "./MutableHashMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L830)

Since v2.0.0
index-MutableHashSet.md
Package: `effect`<br />
Module: `index`<br />

## index.MutableHashSet

Re-exports all named exports from the "./MutableHashSet.js" module as `MutableHashSet`.

**Signature**

```ts
export * as MutableHashSet from "./MutableHashSet.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L926)

Since v2.0.0
index-MutableList.md
Package: `effect`<br />
Module: `index`<br />

## index.MutableList

Re-exports all named exports from the "./MutableList.js" module as `MutableList`.

**Signature**

```ts
export * as MutableList from "./MutableList.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L931)

Since v2.0.0
index-MutableQueue.md
Package: `effect`<br />
Module: `index`<br />

## index.MutableQueue

Re-exports all named exports from the "./MutableQueue.js" module as `MutableQueue`.

**Signature**

```ts
export * as MutableQueue from "./MutableQueue.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L936)

Since v2.0.0
index-MutableRef.md
Package: `effect`<br />
Module: `index`<br />

## index.MutableRef

Re-exports all named exports from the "./MutableRef.js" module as `MutableRef`.

**Signature**

```ts
export * as MutableRef from "./MutableRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L941)

Since v2.0.0
index-MysqlClient.md
Package: `@effect/sql-mysql2`<br />
Module: `index`<br />

## index.MysqlClient

Re-exports all named exports from the "./MysqlClient.js" module as `MysqlClient`.

**Signature**

```ts
export * as MysqlClient from "./MysqlClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-mysql2/src/index.ts#L4)

Since v1.0.0
index-MysqlMigrator.md
Package: `@effect/sql-mysql2`<br />
Module: `index`<br />

## index.MysqlMigrator

Re-exports all named exports from the "./MysqlMigrator.js" module as `MysqlMigrator`.

**Signature**

```ts
export * as MysqlMigrator from "./MysqlMigrator.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-mysql2/src/index.ts#L9)

Since v1.0.0
index-Ndjson.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Ndjson

Re-exports all named exports from the "./Ndjson.js" module as `Ndjson`.

**Signature**

```ts
export * as Ndjson from "./Ndjson.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L215)

Since v1.0.0
index-NodeClusterRunnerHttp.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeClusterRunnerHttp

Re-exports all named exports from the "./NodeClusterRunnerHttp.js" module as `NodeClusterRunnerHttp`.

**Signature**

```ts
export * as NodeClusterRunnerHttp from "./NodeClusterRunnerHttp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L4)

Since v1.0.0
index-NodeClusterRunnerSocket.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeClusterRunnerSocket

Re-exports all named exports from the "./NodeClusterRunnerSocket.js" module as `NodeClusterRunnerSocket`.

**Signature**

```ts
export * as NodeClusterRunnerSocket from "./NodeClusterRunnerSocket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L9)

Since v1.0.0
index-NodeClusterShardManagerHttp.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeClusterShardManagerHttp

Re-exports all named exports from the "./NodeClusterShardManagerHttp.js" module as `NodeClusterShardManagerHttp`.

**Signature**

```ts
export * as NodeClusterShardManagerHttp from "./NodeClusterShardManagerHttp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L14)

Since v1.0.0
index-NodeClusterShardManagerSocket.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeClusterShardManagerSocket

Re-exports all named exports from the "./NodeClusterShardManagerSocket.js" module as `NodeClusterShardManagerSocket`.

**Signature**

```ts
export * as NodeClusterShardManagerSocket from "./NodeClusterShardManagerSocket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L19)

Since v1.0.0
index-NodeCommandExecutor.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeCommandExecutor

Re-exports all named exports from the "./NodeCommandExecutor.js" module as `NodeCommandExecutor`.

**Signature**

```ts
export * as NodeCommandExecutor from "./NodeCommandExecutor.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L24)

Since v1.0.0
index-NodeContext.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeContext

Re-exports all named exports from the "./NodeContext.js" module as `NodeContext`.

**Signature**

```ts
export * as NodeContext from "./NodeContext.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L29)

Since v1.0.0
index-NodeFileSystem.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeFileSystem

Re-exports all named exports from the "./NodeFileSystem.js" module as `NodeFileSystem`.

**Signature**

```ts
export * as NodeFileSystem from "./NodeFileSystem.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L34)

Since v1.0.0
index-NodeHttpClient.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeHttpClient

Re-exports all named exports from the "./NodeHttpClient.js" module as `NodeHttpClient`.

**Signature**

```ts
export * as NodeHttpClient from "./NodeHttpClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L39)

Since v1.0.0
index-NodeHttpPlatform.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeHttpPlatform

Re-exports all named exports from the "./NodeHttpPlatform.js" module as `NodeHttpPlatform`.

**Signature**

```ts
export * as NodeHttpPlatform from "./NodeHttpPlatform.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L44)

Since v1.0.0
index-NodeHttpServer.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeHttpServer

Re-exports all named exports from the "./NodeHttpServer.js" module as `NodeHttpServer`.

**Signature**

```ts
export * as NodeHttpServer from "./NodeHttpServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L49)

Since v1.0.0
index-NodeHttpServerRequest.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeHttpServerRequest

Re-exports all named exports from the "./NodeHttpServerRequest.js" module as `NodeHttpServerRequest`.

**Signature**

```ts
export * as NodeHttpServerRequest from "./NodeHttpServerRequest.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L54)

Since v1.0.0
index-NodeKeyValueStore.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeKeyValueStore

Re-exports all named exports from the "./NodeKeyValueStore.js" module as `NodeKeyValueStore`.

**Signature**

```ts
export * as NodeKeyValueStore from "./NodeKeyValueStore.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L59)

Since v1.0.0
index-NodeMultipart.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeMultipart

Re-exports all named exports from the "./NodeMultipart.js" module as `NodeMultipart`.

**Signature**

```ts
export * as NodeMultipart from "./NodeMultipart.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L64)

Since v1.0.0
index-NodePath.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodePath

Re-exports all named exports from the "./NodePath.js" module as `NodePath`.

**Signature**

```ts
export * as NodePath from "./NodePath.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L69)

Since v1.0.0
index-NodeRuntime.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeRuntime

Re-exports all named exports from the "./NodeRuntime.js" module as `NodeRuntime`.

**Signature**

```ts
export * as NodeRuntime from "./NodeRuntime.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L74)

Since v1.0.0
index-NodeSdk.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.NodeSdk

Re-exports all named exports from the "./NodeSdk.js" module as `NodeSdk`.

**Signature**

```ts
export * as NodeSdk from "./NodeSdk.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L14)

Since v1.0.0
index-NodeSink.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeSink

Re-exports all named exports from the "./NodeSink.js" module as `NodeSink`.

**Signature**

```ts
export * as NodeSink from "./NodeSink.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L79)

Since v1.0.0
index-NodeSocket.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeSocket

Re-exports all named exports from the "./NodeSocket.js" module as `NodeSocket`.

**Signature**

```ts
export * as NodeSocket from "./NodeSocket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L84)

Since v1.0.0
index-NodeSocketServer.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeSocketServer

Re-exports all named exports from the "./NodeSocketServer.js" module as `NodeSocketServer`.

**Signature**

```ts
export * as NodeSocketServer from "./NodeSocketServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L89)

Since v1.0.0
index-NodeStream.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeStream

Re-exports all named exports from the "./NodeStream.js" module as `NodeStream`.

**Signature**

```ts
export * as NodeStream from "./NodeStream.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L94)

Since v1.0.0
index-NodeTerminal.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeTerminal

Re-exports all named exports from the "./NodeTerminal.js" module as `NodeTerminal`.

**Signature**

```ts
export * as NodeTerminal from "./NodeTerminal.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L99)

Since v1.0.0
index-NodeWorker.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeWorker

Re-exports all named exports from the "./NodeWorker.js" module as `NodeWorker`.

**Signature**

```ts
export * as NodeWorker from "./NodeWorker.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L104)

Since v1.0.0
index-NodeWorkerRunner.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.NodeWorkerRunner

Re-exports all named exports from the "./NodeWorkerRunner.js" module as `NodeWorkerRunner`.

**Signature**

```ts
export * as NodeWorkerRunner from "./NodeWorkerRunner.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L109)

Since v1.0.0
index-NonEmptyIterable.md
Package: `effect`<br />
Module: `index`<br />

## index.NonEmptyIterable

Re-exports all named exports from the "./NonEmptyIterable.js" module as `NonEmptyIterable`.

**Signature**

```ts
export * as NonEmptyIterable from "./NonEmptyIterable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L946)

Since v2.0.0
index-Number.md
Package: `effect`<br />
Module: `index`<br />

## index.Number

Re-exports all named exports from the "./Number.js" module as `Number`.

**See**

- `module:BigInt` for more similar operations on `bigint` types
- `module:BigDecimal` for more similar operations on `BigDecimal` types

**Signature**

```ts
export * as Number from "./Number.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1044)

Since v2.0.0
index-Of.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Of

Re-exports all named exports from the "./Of.js" module as `Of`.

**Signature**

```ts
export * as Of from "./Of.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L81)

Since v0.24.0
index-OpenAiClient.md
Package: `@effect/ai-openai`<br />
Module: `index`<br />

## index.OpenAiClient

Re-exports all named exports from the "./OpenAiClient.js" module as `OpenAiClient`.

**Signature**

```ts
export * as OpenAiClient from "./OpenAiClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/index.ts#L9)

Since v1.0.0
index-OpenAiConfig.md
Package: `@effect/ai-openai`<br />
Module: `index`<br />

## index.OpenAiConfig

Re-exports all named exports from the "./OpenAiConfig.js" module as `OpenAiConfig`.

**Signature**

```ts
export * as OpenAiConfig from "./OpenAiConfig.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/index.ts#L14)

Since v1.0.0
index-OpenAiEmbeddingModel.md
Package: `@effect/ai-openai`<br />
Module: `index`<br />

## index.OpenAiEmbeddingModel

Re-exports all named exports from the "./OpenAiEmbeddingModel.js" module as `OpenAiEmbeddingModel`.

**Signature**

```ts
export * as OpenAiEmbeddingModel from "./OpenAiEmbeddingModel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/index.ts#L19)

Since v1.0.0
index-OpenAiLanguageModel.md
Package: `@effect/ai-openai`<br />
Module: `index`<br />

## index.OpenAiLanguageModel

Re-exports all named exports from the "./OpenAiLanguageModel.js" module as `OpenAiLanguageModel`.

**Signature**

```ts
export * as OpenAiLanguageModel from "./OpenAiLanguageModel.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/index.ts#L24)

Since v1.0.0
index-OpenAiTelemetry.md
Package: `@effect/ai-openai`<br />
Module: `index`<br />

## index.OpenAiTelemetry

Re-exports all named exports from the "./OpenAiTelemetry.js" module as `OpenAiTelemetry`.

**Signature**

```ts
export * as OpenAiTelemetry from "./OpenAiTelemetry.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/index.ts#L29)

Since v1.0.0
index-OpenAiTokenizer.md
Package: `@effect/ai-openai`<br />
Module: `index`<br />

## index.OpenAiTokenizer

Re-exports all named exports from the "./OpenAiTokenizer.js" module as `OpenAiTokenizer`.

**Signature**

```ts
export * as OpenAiTokenizer from "./OpenAiTokenizer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/index.ts#L34)

Since v1.0.0
index-OpenApi.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.OpenApi

Re-exports all named exports from the "./OpenApi.js" module as `OpenApi`.

**Signature**

```ts
export * as OpenApi from "./OpenApi.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L220)

Since v1.0.0
index-OpenApiJsonSchema.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.OpenApiJsonSchema

Re-exports all named exports from the "./OpenApiJsonSchema.js" module as `OpenApiJsonSchema`.

**Signature**

```ts
export * as OpenApiJsonSchema from "./OpenApiJsonSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L225)

Since v1.0.0
index-OpfsWorker.md
Package: `@effect/sql-sqlite-wasm`<br />
Module: `index`<br />

## index.OpfsWorker

Re-exports all named exports from the "./OpfsWorker.js" module as `OpfsWorker`.

**Signature**

```ts
export * as OpfsWorker from "./OpfsWorker.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-sqlite-wasm/src/index.ts#L4)

Since v1.0.0
index-Optimize.md
Package: `@effect/printer`<br />
Module: `index`<br />

## index.Optimize

Re-exports all named exports from the "./Optimize.js" module as `Optimize`.

**Signature**

```ts
export * as Optimize from "./Optimize.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/index.ts#L44)

Since v1.0.0
index-Option.md
Package: `effect`<br />
Module: `index`<br />

## index.Option

Re-exports all named exports from the "./Option.js" module as `Option`.

**Signature**

```ts
export * as Option from "./Option.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1049)

Since v2.0.0
index-Options.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.Options

Re-exports all named exports from the "./Options.js" module as `Options`.

**Signature**

```ts
export * as Options from "./Options.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L54)

Since v1.0.0
index-Order.md
Package: `effect`<br />
Module: `index`<br />

## index.Order

Re-exports all named exports from the "./Order.js" module as `Order`.

**Signature**

```ts
export * as Order from "./Order.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1069)

Since v2.0.0
index-Ordering.md
Package: `effect`<br />
Module: `index`<br />

## index.Ordering

Re-exports all named exports from the "./Ordering.js" module as `Ordering`.

**Signature**

```ts
export * as Ordering from "./Ordering.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1074)

Since v2.0.0
index-Otlp.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.Otlp

Re-exports all named exports from the "./Otlp.js" module as `Otlp`.

**Signature**

```ts
export * as Otlp from "./Otlp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L19)

Since v1.0.0
index-OtlpLogger.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.OtlpLogger

Re-exports all named exports from the "./OtlpLogger.js" module as `OtlpLogger`.

**Signature**

```ts
export * as OtlpLogger from "./OtlpLogger.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L25)

Since v1.0.0
index-OtlpMetrics.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.OtlpMetrics

Re-exports all named exports from the "./OtlpMetrics.js" module as `OtlpMetrics`.

**Signature**

```ts
export * as OtlpMetrics from "./OtlpMetrics.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L30)

Since v1.0.0
index-OtlpResource.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.OtlpResource

Re-exports all named exports from the "./OtlpResource.js" module as `OtlpResource`.

**Signature**

```ts
export * as OtlpResource from "./OtlpResource.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L35)

Since v1.0.0
index-OtlpTracer.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.OtlpTracer

Re-exports all named exports from the "./OtlpTracer.js" module as `OtlpTracer`.

**Signature**

```ts
export * as OtlpTracer from "./OtlpTracer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L40)

Since v1.0.0
index-PageWidth.md
Package: `@effect/printer`<br />
Module: `index`<br />

## index.PageWidth

Re-exports all named exports from the "./PageWidth.js" module as `PageWidth`.

**Signature**

```ts
export * as PageWidth from "./PageWidth.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/index.ts#L49)

Since v1.0.0
index-Parameter.md
Package: `@effect/sql-mssql`<br />
Module: `index`<br />

## index.Parameter

Re-exports all named exports from the "./Parameter.js" module as `Parameter`.

**Signature**

```ts
export * as Parameter from "./Parameter.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-mssql/src/index.ts#L25)

Since v1.0.0
index-ParseResult.md
Package: `effect`<br />
Module: `index`<br />

## index.ParseResult

Re-exports all named exports from the "./ParseResult.js" module as `ParseResult`.

**Signature**

```ts
export * as ParseResult from "./ParseResult.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1079)

Since v3.10.0
index-Path.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Path

Re-exports all named exports from the "./Path.js" module as `Path`.

**Signature**

```ts
export * as Path from "./Path.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L230)

Since v1.0.0
index-Permissions.md
Package: `@effect/platform-browser`<br />
Module: `index`<br />

## index.Permissions

Re-exports all named exports from the "./Permissions.js" module as `Permissions`.

**Signature**

```ts
export * as Permissions from "./Permissions.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/index.ts#L49)

Since v1.0.0
index-PersistedCache.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.PersistedCache

Re-exports all named exports from the "./PersistedCache.js" module as `PersistedCache`.

**Signature**

```ts
export * as PersistedCache from "./PersistedCache.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L49)

Since v1.0.0
index-Persistence.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.Persistence

Re-exports all named exports from the "./Persistence.js" module as `Persistence`.

**Signature**

```ts
export * as Persistence from "./Persistence.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L54)

Since v1.0.0
index-PgClient.md
Package: `@effect/sql-pg`<br />
Module: `index`<br />

## index.PgClient

Re-exports all named exports from the "./PgClient.js" module as `PgClient`.

**Signature**

```ts
export * as PgClient from "./PgClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-pg/src/index.ts#L4)

Since v1.0.0
index-PgMigrator.md
Package: `@effect/sql-pg`<br />
Module: `index`<br />

## index.PgMigrator

Re-exports all named exports from the "./PgMigrator.js" module as `PgMigrator`.

**Signature**

```ts
export * as PgMigrator from "./PgMigrator.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-pg/src/index.ts#L9)

Since v1.0.0
index-Pipeable.md
Package: `effect`<br />
Module: `index`<br />

## index.Pipeable

Re-exports all named exports from the "./Pipeable.js" module as `Pipeable`.

**Signature**

```ts
export * as Pipeable from "./Pipeable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1084)

Since v2.0.0
index-PlatformConfigProvider.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.PlatformConfigProvider

Re-exports all named exports from the "./PlatformConfigProvider.js" module as `PlatformConfigProvider`.

**Signature**

```ts
export * as PlatformConfigProvider from "./PlatformConfigProvider.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L235)

Since v1.0.0
index-PlatformLogger.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.PlatformLogger

Re-exports all named exports from the "./PlatformLogger.js" module as `PlatformLogger`.

**Signature**

```ts
export * as PlatformLogger from "./PlatformLogger.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L240)

Since v1.0.0
index-Pointed.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Pointed

Re-exports all named exports from the "./Pointed.js" module as `Pointed`.

**Signature**

```ts
export * as Pointed from "./Pointed.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L86)

Since v0.24.0
index-Pool.md
Package: `effect`<br />
Module: `index`<br />

## index.Pool

Re-exports all named exports from the "./Pool.js" module as `Pool`.

**Signature**

```ts
export * as Pool from "./Pool.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1089)

Since v2.0.0
index-Predicate.md
Package: `effect`<br />
Module: `index`<br />

## index.Predicate

Re-exports all named exports from the "./Predicate.js" module as `Predicate`.

**Signature**

```ts
export * as Predicate from "./Predicate.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1094)

Since v2.0.0
index-Pretty.md
Package: `effect`<br />
Module: `index`<br />

## index.Pretty

Re-exports all named exports from the "./Pretty.js" module as `Pretty`.

**Signature**

```ts
export * as Pretty from "./Pretty.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1099)

Since v3.10.0
index-PrimaryKey.md
Package: `effect`<br />
Module: `index`<br />

## index.PrimaryKey

Re-exports all named exports from the "./PrimaryKey.js" module as `PrimaryKey`.

**Signature**

```ts
export * as PrimaryKey from "./PrimaryKey.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1104)

Since v2.0.0
index-Primitive.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.Primitive

Re-exports all named exports from the "./Primitive.js" module as `Primitive`.

**Signature**

```ts
export * as Primitive from "./Primitive.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L59)

Since v1.0.0
index-Procedure.md
Package: `@effect/sql-mssql`<br />
Module: `index`<br />

## index.Procedure

Re-exports all named exports from the "./Procedure.js" module as `Procedure`.

**Signature**

```ts
export * as Procedure from "./Procedure.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-mssql/src/index.ts#L30)

Since v1.0.0
index-Product.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Product

Re-exports all named exports from the "./Product.js" module as `Product`.

**Signature**

```ts
export * as Product from "./Product.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L91)

Since v0.24.0
index-Prompt.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.Prompt

Re-exports all named exports from the "./Prompt.js" module as `Prompt`.

**Signature**

```ts
export * as Prompt from "./Prompt.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L64)

Since v1.0.0
index-PubSub.md
Package: `effect`<br />
Module: `index`<br />

## index.PubSub

Re-exports all named exports from the "./PubSub.js" module as `PubSub`.

**Signature**

```ts
export * as PubSub from "./PubSub.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1109)

Since v2.0.0
index-Queue.md
Package: `effect`<br />
Module: `index`<br />

## index.Queue

Re-exports all named exports from the "./Queue.js" module as `Queue`.

**Signature**

```ts
export * as Queue from "./Queue.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1114)

Since v2.0.0
index-Random.md
Package: `effect`<br />
Module: `index`<br />

## index.Random

Re-exports all named exports from the "./Random.js" module as `Random`.

**Signature**

```ts
export * as Random from "./Random.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1119)

Since v2.0.0
index-RateLimiter.md
Package: `effect`<br />
Module: `index`<br />

## index.RateLimiter

Re-exports all named exports from the "./RateLimiter.js" module as `RateLimiter`.

**Signature**

```ts
export * as RateLimiter from "./RateLimiter.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1126)

Since v2.0.0
index-RcMap.md
Package: `effect`<br />
Module: `index`<br />

## index.RcMap

Re-exports all named exports from the "./RcMap.js" module as `RcMap`.

**Signature**

```ts
export * as RcMap from "./RcMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1131)

Since v3.5.0
index-RcRef.md
Package: `effect`<br />
Module: `index`<br />

## index.RcRef

Re-exports all named exports from the "./RcRef.js" module as `RcRef`.

**Signature**

```ts
export * as RcRef from "./RcRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1136)

Since v3.5.0
index-Reactivity.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.Reactivity

Re-exports all named exports from the "./Reactivity.js" module as `Reactivity`.

**Signature**

```ts
export * as Reactivity from "./Reactivity.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L59)

Since v1.0.0
index-Readable.md
Package: `effect`<br />
Module: `index`<br />

## index.Readable

Re-exports all named exports from the "./Readable.js" module as `Readable`.

**Signature**

```ts
export * as Readable from "./Readable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1141)

Since v2.0.0
index-Record.md
Package: `effect`<br />
Module: `index`<br />

## index.Record

Re-exports all named exports from the "./Record.js" module as `Record`.

**Signature**

```ts
export * as Record from "./Record.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1148)

Since v2.0.0
index-RedBlackTree.md
Package: `effect`<br />
Module: `index`<br />

## index.RedBlackTree

Re-exports all named exports from the "./RedBlackTree.js" module as `RedBlackTree`.

**Signature**

```ts
export * as RedBlackTree from "./RedBlackTree.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1153)

Since v2.0.0
index-Redacted.md
Package: `effect`<br />
Module: `index`<br />

## index.Redacted

Re-exports all named exports from the "./Redacted.js" module as `Redacted`.

**Signature**

```ts
export * as Redacted from "./Redacted.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1163)

Since v3.3.0
index-Ref.md
Package: `effect`<br />
Module: `index`<br />

## index.Ref

Re-exports all named exports from the "./Ref.js" module as `Ref`.

**Signature**

```ts
export * as Ref from "./Ref.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1168)

Since v2.0.0
index-RegExp.md
Package: `effect`<br />
Module: `index`<br />

## index.RegExp

Re-exports all named exports from the "./RegExp.js" module as `RegExp`.

**Signature**

```ts
export * as RegExp from "./RegExp.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1175)

Since v2.0.0
index-Reloadable.md
Package: `effect`<br />
Module: `index`<br />

## index.Reloadable

Re-exports all named exports from the "./Reloadable.js" module as `Reloadable`.

**Signature**

```ts
export * as Reloadable from "./Reloadable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1180)

Since v2.0.0
index-Reply.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Reply

Re-exports all named exports from the "./Reply.js" module as `Reply`.

**Signature**

```ts
export * as Reply from "./Reply.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L99)

Since v1.0.0
index-Request.md
Package: `effect`<br />
Module: `index`<br />

## index.Request

Re-exports all named exports from the "./Request.js" module as `Request`.

**Signature**

```ts
export * as Request from "./Request.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1185)

Since v2.0.0
index-RequestBlock.md
Package: `effect`<br />
Module: `index`<br />

## index.RequestBlock

Re-exports all named exports from the "./RequestBlock.js" module as `RequestBlock`.

**Signature**

```ts
export * as RequestBlock from "./RequestBlock.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1190)

Since v2.0.0
index-RequestResolver.md
Package: `effect`<br />
Module: `index`<br />

## index.RequestResolver

Re-exports all named exports from the "./RequestResolver.js" module as `RequestResolver`.

**Signature**

```ts
export * as RequestResolver from "./RequestResolver.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1195)

Since v2.0.0
index-Resource.md
Package: `effect`<br />
Module: `index`<br />

## index.Resource

Re-exports all named exports from the "./Resource.js" module as `Resource`.

**Signature**

```ts
export * as Resource from "./Resource.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1200)

Since v2.0.0
index-Rpc.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.Rpc

Re-exports all named exports from the "./Rpc.js" module as `Rpc`.

**Signature**

```ts
export * as Rpc from "./Rpc.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L4)

Since v1.0.0
index-RpcClient.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcClient

Re-exports all named exports from the "./RpcClient.js" module as `RpcClient`.

**Signature**

```ts
export * as RpcClient from "./RpcClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L9)

Since v1.0.0
index-RpcGroup.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcGroup

Re-exports all named exports from the "./RpcGroup.js" module as `RpcGroup`.

**Signature**

```ts
export * as RpcGroup from "./RpcGroup.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L14)

Since v1.0.0
index-RpcMessage.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcMessage

Re-exports all named exports from the "./RpcMessage.js" module as `RpcMessage`.

**Signature**

```ts
export * as RpcMessage from "./RpcMessage.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L19)

Since v1.0.0
index-RpcMiddleware.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcMiddleware

Re-exports all named exports from the "./RpcMiddleware.js" module as `RpcMiddleware`.

**Signature**

```ts
export * as RpcMiddleware from "./RpcMiddleware.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L24)

Since v1.0.0
index-RpcSchema.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcSchema

Re-exports all named exports from the "./RpcSchema.js" module as `RpcSchema`.

**Signature**

```ts
export * as RpcSchema from "./RpcSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L29)

Since v1.0.0
index-RpcSerialization.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcSerialization

Re-exports all named exports from the "./RpcSerialization.js" module as `RpcSerialization`.

**Signature**

```ts
export * as RpcSerialization from "./RpcSerialization.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L34)

Since v1.0.0
index-RpcServer.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcServer

Re-exports all named exports from the "./RpcServer.js" module as `RpcServer`.

**Signature**

```ts
export * as RpcServer from "./RpcServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L39)

Since v1.0.0
index-RpcTest.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcTest

Re-exports all named exports from the "./RpcTest.js" module as `RpcTest`.

**Signature**

```ts
export * as RpcTest from "./RpcTest.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L44)

Since v1.0.0
index-RpcWorker.md
Package: `@effect/rpc`<br />
Module: `index`<br />

## index.RpcWorker

Re-exports all named exports from the "./RpcWorker.js" module as `RpcWorker`.

**Signature**

```ts
export * as RpcWorker from "./RpcWorker.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/index.ts#L49)

Since v1.0.0
index-Runner.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Runner

Re-exports all named exports from the "./Runner.js" module as `Runner`.

**Signature**

```ts
export * as Runner from "./Runner.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L104)

Since v1.0.0
index-RunnerAddress.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.RunnerAddress

Re-exports all named exports from the "./RunnerAddress.js" module as `RunnerAddress`.

**Signature**

```ts
export * as RunnerAddress from "./RunnerAddress.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L109)

Since v1.0.0
index-RunnerHealth.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.RunnerHealth

Re-exports all named exports from the "./RunnerHealth.js" module as `RunnerHealth`.

**Signature**

```ts
export * as RunnerHealth from "./RunnerHealth.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L114)

Since v1.0.0
index-RunnerServer.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.RunnerServer

Re-exports all named exports from the "./RunnerServer.js" module as `RunnerServer`.

**Signature**

```ts
export * as RunnerServer from "./RunnerServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L119)

Since v1.0.0
index-Runners.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Runners

Re-exports all named exports from the "./Runners.js" module as `Runners`.

**Signature**

```ts
export * as Runners from "./Runners.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L124)

Since v1.0.0
index-Runtime.md
Package: `effect`<br />
Module: `index`<br />

## index.Runtime

Re-exports all named exports from the "./Runtime.js" module as `Runtime`.

**Signature**

```ts
export * as Runtime from "./Runtime.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1205)

Since v2.0.0
index-RuntimeFlags.md
Package: `effect`<br />
Module: `index`<br />

## index.RuntimeFlags

Re-exports all named exports from the "./RuntimeFlags.js" module as `RuntimeFlags`.

**Signature**

```ts
export * as RuntimeFlags from "./RuntimeFlags.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1210)

Since v2.0.0
index-RuntimeFlagsPatch.md
Package: `effect`<br />
Module: `index`<br />

## index.RuntimeFlagsPatch

Re-exports all named exports from the "./RuntimeFlagsPatch.js" module as `RuntimeFlagsPatch`.

**Signature**

```ts
export * as RuntimeFlagsPatch from "./RuntimeFlagsPatch.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1215)

Since v2.0.0
index-Schedule.md
Package: `effect`<br />
Module: `index`<br />

## index.Schedule

Re-exports all named exports from the "./Schedule.js" module as `Schedule`.

**Signature**

```ts
export * as Schedule from "./Schedule.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1225)

Since v2.0.0
index-ScheduleDecision.md
Package: `effect`<br />
Module: `index`<br />

## index.ScheduleDecision

Re-exports all named exports from the "./ScheduleDecision.js" module as `ScheduleDecision`.

**Signature**

```ts
export * as ScheduleDecision from "./ScheduleDecision.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1230)

Since v2.0.0
index-ScheduleInterval.md
Package: `effect`<br />
Module: `index`<br />

## index.ScheduleInterval

Re-exports all named exports from the "./ScheduleInterval.js" module as `ScheduleInterval`.

**Signature**

```ts
export * as ScheduleInterval from "./ScheduleInterval.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1235)

Since v2.0.0
index-ScheduleIntervals.md
Package: `effect`<br />
Module: `index`<br />

## index.ScheduleIntervals

Re-exports all named exports from the "./ScheduleIntervals.js" module as `ScheduleIntervals`.

**Signature**

```ts
export * as ScheduleIntervals from "./ScheduleIntervals.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1240)

Since v2.0.0
index-Scheduler.md
Package: `effect`<br />
Module: `index`<br />

## index.Scheduler

Re-exports all named exports from the "./Scheduler.js" module as `Scheduler`.

**Signature**

```ts
export * as Scheduler from "./Scheduler.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1245)

Since v2.0.0
index-Schema.md
Package: `effect`<br />
Module: `index`<br />

## index.Schema

Re-exports all named exports from the "./Schema.js" module as `Schema`.

**Signature**

```ts
export * as Schema from "./Schema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1250)

Since v3.10.0
index-SchemaAST.md
Package: `effect`<br />
Module: `index`<br />

## index.SchemaAST

Re-exports all named exports from the "./SchemaAST.js" module as `SchemaAST`.

**Signature**

```ts
export * as SchemaAST from "./SchemaAST.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1255)

Since v3.10.0
index-Scope.md
Package: `effect`<br />
Module: `index`<br />

## index.Scope

Re-exports all named exports from the "./Scope.js" module as `Scope`.

**Signature**

```ts
export * as Scope from "./Scope.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1260)

Since v2.0.0
index-ScopedCache.md
Package: `effect`<br />
Module: `index`<br />

## index.ScopedCache

Re-exports all named exports from the "./ScopedCache.js" module as `ScopedCache`.

**Signature**

```ts
export * as ScopedCache from "./ScopedCache.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1265)

Since v2.0.0
index-ScopedRef.md
Package: `effect`<br />
Module: `index`<br />

## index.ScopedRef

Re-exports all named exports from the "./ScopedRef.js" module as `ScopedRef`.

**Signature**

```ts
export * as ScopedRef from "./ScopedRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1270)

Since v2.0.0
index-Secret.md
Package: `effect`<br />
Module: `index`<br />

## ~~index.Secret~~

Re-exports all named exports from the "./Secret.js" module as `Secret`.

**Signature**

```ts
export * as Secret from "./Secret.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1276)

Since v2.0.0
index-SemiAlternative.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.SemiAlternative

Re-exports all named exports from the "./SemiAlternative.js" module as `SemiAlternative`.

**Signature**

```ts
export * as SemiAlternative from "./SemiAlternative.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L96)

Since v0.24.0
index-SemiApplicative.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.SemiApplicative

Re-exports all named exports from the "./SemiApplicative.js" module as `SemiApplicative`.

**Signature**

```ts
export * as SemiApplicative from "./SemiApplicative.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L101)

Since v0.24.0
index-SemiCoproduct.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.SemiCoproduct

Re-exports all named exports from the "./SemiCoproduct.js" module as `SemiCoproduct`.

**Signature**

```ts
export * as SemiCoproduct from "./SemiCoproduct.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L106)

Since v0.24.0
index-SemiProduct.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.SemiProduct

Re-exports all named exports from the "./SemiProduct.js" module as `SemiProduct`.

**Signature**

```ts
export * as SemiProduct from "./SemiProduct.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L111)

Since v0.24.0
index-Semigroup.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Semigroup

Re-exports all named exports from the "./Semigroup.js" module as `Semigroup`.

**Signature**

```ts
export * as Semigroup from "./Semigroup.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L116)

Since v0.24.0
index-ShardId.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ShardId

Re-exports all named exports from the "./ShardId.js" module as `ShardId`.

**Signature**

```ts
export * as ShardId from "./ShardId.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L129)

Since v1.0.0
index-ShardManager.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ShardManager

Re-exports all named exports from the "./ShardManager.js" module as `ShardManager`.

**Signature**

```ts
export * as ShardManager from "./ShardManager.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L134)

Since v1.0.0
index-ShardStorage.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ShardStorage

Re-exports all named exports from the "./ShardStorage.js" module as `ShardStorage`.

**Signature**

```ts
export * as ShardStorage from "./ShardStorage.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L139)

Since v1.0.0
index-Sharding.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Sharding

Re-exports all named exports from the "./Sharding.js" module as `Sharding`.

**Signature**

```ts
export * as Sharding from "./Sharding.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L144)

Since v1.0.0
index-ShardingConfig.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ShardingConfig

Re-exports all named exports from the "./ShardingConfig.js" module as `ShardingConfig`.

**Signature**

```ts
export * as ShardingConfig from "./ShardingConfig.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L149)

Since v1.0.0
index-ShardingRegistrationEvent.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.ShardingRegistrationEvent

Re-exports all named exports from the "./ShardingRegistrationEvent.js" module as `ShardingRegistrationEvent`.

**Signature**

```ts
export * as ShardingRegistrationEvent from "./ShardingRegistrationEvent.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L154)

Since v1.0.0
index-SingleProducerAsyncInput.md
Package: `effect`<br />
Module: `index`<br />

## index.SingleProducerAsyncInput

Re-exports all named exports from the "./SingleProducerAsyncInput.js" module as `SingleProducerAsyncInput`.

**Signature**

```ts
export * as SingleProducerAsyncInput from "./SingleProducerAsyncInput.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1281)

Since v2.0.0
index-Singleton.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Singleton

Re-exports all named exports from the "./Singleton.js" module as `Singleton`.

**Signature**

```ts
export * as Singleton from "./Singleton.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L159)

Since v1.0.0
index-SingletonAddress.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.SingletonAddress

Re-exports all named exports from the "./SingletonAddress.js" module as `SingletonAddress`.

**Signature**

```ts
export * as SingletonAddress from "./SingletonAddress.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L164)

Since v1.0.0
index-Sink.md
Package: `effect`<br />
Module: `index`<br />

## index.Sink

Re-exports all named exports from the "./Sink.js" module as `Sink`.

**Signature**

```ts
export * as Sink from "./Sink.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1286)

Since v2.0.0
index-Snowflake.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.Snowflake

Re-exports all named exports from the "./Snowflake.js" module as `Snowflake`.

**Signature**

```ts
export * as Snowflake from "./Snowflake.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L169)

Since v1.0.0
index-Socket.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Socket

Re-exports all named exports from the "./Socket.js" module as `Socket`.

**Signature**

```ts
export * as Socket from "./Socket.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L250)

Since v1.0.0
index-SocketRunner.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.SocketRunner

Re-exports all named exports from the "./SocketRunner.js" module as `SocketRunner`.

**Signature**

```ts
export * as SocketRunner from "./SocketRunner.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L174)

Since v1.0.0
index-SocketServer.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.SocketServer

Re-exports all named exports from the "./SocketServer.js" module as `SocketServer`.

**Signature**

```ts
export * as SocketServer from "./SocketServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L255)

Since v1.0.0
index-SocketShardManager.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.SocketShardManager

Re-exports all named exports from the "./SocketShardManager.js" module as `SocketShardManager`.

**Signature**

```ts
export * as SocketShardManager from "./SocketShardManager.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L179)

Since v1.0.0
index-SortedMap.md
Package: `effect`<br />
Module: `index`<br />

## index.SortedMap

Re-exports all named exports from the "./SortedMap.js" module as `SortedMap`.

**Signature**

```ts
export * as SortedMap from "./SortedMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1291)

Since v2.0.0
index-SortedSet.md
Package: `effect`<br />
Module: `index`<br />

## index.SortedSet

Re-exports all named exports from the "./SortedSet.js" module as `SortedSet`.

**Signature**

```ts
export * as SortedSet from "./SortedSet.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1296)

Since v2.0.0
index-Span.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.Span

Re-exports all named exports from the "./HelpDoc/Span.js" module as `Span`.

**Signature**

```ts
export * as Span from "./HelpDoc/Span.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L79)

Since v1.0.0
index-SqlClient.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlClient

Re-exports all named exports from the "./SqlClient.js" module as `SqlClient`.

**Signature**

```ts
export * as SqlClient from "./SqlClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L14)

Since v1.0.0
index-SqlConnection.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlConnection

Re-exports all named exports from the "./SqlConnection.js" module as `SqlConnection`.

**Signature**

```ts
export * as SqlConnection from "./SqlConnection.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L19)

Since v1.0.0
index-STM.md
Package: `effect`<br />
Module: `index`<br />

## index.STM

Re-exports all named exports from the "./STM.js" module as `STM`.

**Signature**

```ts
export * as STM from "./STM.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1220)

Since v2.0.0
index-SqlError.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlError

Re-exports all named exports from the "./SqlError.js" module as `SqlError`.

**Signature**

```ts
export * as SqlError from "./SqlError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L24)

Since v1.0.0
index-SqlEventJournal.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlEventJournal

Re-exports all named exports from the "./SqlEventJournal.js" module as `SqlEventJournal`.

**Signature**

```ts
export * as SqlEventJournal from "./SqlEventJournal.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L29)

Since v1.0.0
index-SqlEventLogServer.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlEventLogServer

Re-exports all named exports from the "./SqlEventLogServer.js" module as `SqlEventLogServer`.

**Signature**

```ts
export * as SqlEventLogServer from "./SqlEventLogServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L34)

Since v1.0.0
index-SqlMessageStorage.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.SqlMessageStorage

Re-exports all named exports from the "./SqlMessageStorage.js" module as `SqlMessageStorage`.

**Signature**

```ts
export * as SqlMessageStorage from "./SqlMessageStorage.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L184)

Since v1.0.0
index-SqlResolver.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlResolver

Re-exports all named exports from the "./SqlResolver.js" module as `SqlResolver`.

**Signature**

```ts
export * as SqlResolver from "./SqlResolver.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L39)

Since v1.0.0
index-SqlSchema.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlSchema

Re-exports all named exports from the "./SqlSchema.js" module as `SqlSchema`.

**Signature**

```ts
export * as SqlSchema from "./SqlSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L44)

Since v1.0.0
index-SqlShardStorage.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.SqlShardStorage

Re-exports all named exports from the "./SqlShardStorage.js" module as `SqlShardStorage`.

**Signature**

```ts
export * as SqlShardStorage from "./SqlShardStorage.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L189)

Since v1.0.0
index-SqlStream.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.SqlStream

Re-exports all named exports from the "./SqlStream.js" module as `SqlStream`.

**Signature**

```ts
export * as SqlStream from "./SqlStream.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L49)

Since v1.0.0
index-SqliteClient.md
Package: `@effect/sql-sqlite-bun`<br />
Module: `index`<br />

## index.SqliteClient

Re-exports all named exports from the "./SqliteClient.js" module as `SqliteClient`.

**Signature**

```ts
export * as SqliteClient from "./SqliteClient.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-sqlite-bun/src/index.ts#L4)

Since v1.0.0
index-SqliteMigrator.md
Package: `@effect/sql-sqlite-bun`<br />
Module: `index`<br />

## index.SqliteMigrator

Re-exports all named exports from the "./SqliteMigrator.js" module as `SqliteMigrator`.

**Signature**

```ts
export * as SqliteMigrator from "./SqliteMigrator.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql-sqlite-bun/src/index.ts#L9)

Since v1.0.0
index-Sse.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.Sse

Re-exports all named exports from the "./Sse.js" module as `Sse`.

**Signature**

```ts
export * as Sse from "./Sse.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L69)

Since v1.0.0
index-Statement.md
Package: `@effect/sql`<br />
Module: `index`<br />

## index.Statement

Re-exports all named exports from the "./Statement.js" module as `Statement`.

**Signature**

```ts
export * as Statement from "./Statement.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/index.ts#L54)

Since v1.0.0
index-Stream.md
Package: `effect`<br />
Module: `index`<br />

## index.Stream

Re-exports all named exports from the "./Stream.js" module as `Stream`.

**Signature**

```ts
export * as Stream from "./Stream.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1301)

Since v2.0.0
index-StreamEmit.md
Package: `effect`<br />
Module: `index`<br />

## index.StreamEmit

Re-exports all named exports from the "./StreamEmit.js" module as `StreamEmit`.

**Signature**

```ts
export * as StreamEmit from "./StreamEmit.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1306)

Since v2.0.0
index-StreamHaltStrategy.md
Package: `effect`<br />
Module: `index`<br />

## index.StreamHaltStrategy

Re-exports all named exports from the "./StreamHaltStrategy.js" module as `StreamHaltStrategy`.

**Signature**

```ts
export * as StreamHaltStrategy from "./StreamHaltStrategy.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1311)

Since v2.0.0
index-Streamable.md
Package: `effect`<br />
Module: `index`<br />

## index.Streamable

Re-exports all named exports from the "./Streamable.js" module as `Streamable`.

**Signature**

```ts
export * as Streamable from "./Streamable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1316)

Since v2.0.0
index-String.md
Package: `effect`<br />
Module: `index`<br />

## index.String

Re-exports all named exports from the "./String.js" module as `String`.

**Signature**

```ts
export * as String from "./String.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1325)

Since v2.0.0
index-Struct.md
Package: `effect`<br />
Module: `index`<br />

## index.Struct

Re-exports all named exports from the "./Struct.js" module as `Struct`.

**Signature**

```ts
export * as Struct from "./Struct.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1332)

Since v2.0.0
index-Subscribable.md
Package: `effect`<br />
Module: `index`<br />

## index.Subscribable

Re-exports all named exports from the "./Subscribable.js" module as `Subscribable`.

**Signature**

```ts
export * as Subscribable from "./Subscribable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1337)

Since v2.0.0
index-SubscriptionRef.md
Package: `effect`<br />
Module: `index`<br />

## index.SubscriptionRef

Re-exports all named exports from the "./SubscriptionRef.js" module as `SubscriptionRef`.

**Signature**

```ts
export * as SubscriptionRef from "./SubscriptionRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1342)

Since v2.0.0
index-Supervisor.md
Package: `effect`<br />
Module: `index`<br />

## index.Supervisor

Re-exports all named exports from the "./Supervisor.js" module as `Supervisor`.

**Signature**

```ts
export * as Supervisor from "./Supervisor.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1350)

Since v2.0.0
index-Symbol.md
Package: `effect`<br />
Module: `index`<br />

## index.Symbol

Re-exports all named exports from the "./Symbol.js" module as `Symbol`.

**Signature**

```ts
export * as Symbol from "./Symbol.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1355)

Since v2.0.0
index-SynchronizedClock.md
Package: `@effect/cluster`<br />
Module: `index`<br />

## index.SynchronizedClock

Re-exports all named exports from the "./SynchronizedClock.js" module as `SynchronizedClock`.

**Signature**

```ts
export * as SynchronizedClock from "./SynchronizedClock.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L194)

Since v1.0.0
index-SynchronizedRef.md
Package: `effect`<br />
Module: `index`<br />

## index.SynchronizedRef

Re-exports all named exports from the "./SynchronizedRef.js" module as `SynchronizedRef`.

**Signature**

```ts
export * as SynchronizedRef from "./SynchronizedRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1360)

Since v2.0.0
index-TArray.md
Package: `effect`<br />
Module: `index`<br />

## index.TArray

Re-exports all named exports from the "./TArray.js" module as `TArray`.

**Signature**

```ts
export * as TArray from "./TArray.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1365)

Since v2.0.0
index-TDeferred.md
Package: `effect`<br />
Module: `index`<br />

## index.TDeferred

Re-exports all named exports from the "./TDeferred.js" module as `TDeferred`.

**Signature**

```ts
export * as TDeferred from "./TDeferred.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1370)

Since v2.0.0
index-TMap.md
Package: `effect`<br />
Module: `index`<br />

## index.TMap

Re-exports all named exports from the "./TMap.js" module as `TMap`.

**Signature**

```ts
export * as TMap from "./TMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1375)

Since v2.0.0
index-TPriorityQueue.md
Package: `effect`<br />
Module: `index`<br />

## index.TPriorityQueue

Re-exports all named exports from the "./TPriorityQueue.js" module as `TPriorityQueue`.

**Signature**

```ts
export * as TPriorityQueue from "./TPriorityQueue.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1380)

Since v2.0.0
index-TPubSub.md
Package: `effect`<br />
Module: `index`<br />

## index.TPubSub

Re-exports all named exports from the "./TPubSub.js" module as `TPubSub`.

**Signature**

```ts
export * as TPubSub from "./TPubSub.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1385)

Since v2.0.0
index-TQueue.md
Package: `effect`<br />
Module: `index`<br />

## index.TQueue

Re-exports all named exports from the "./TQueue.js" module as `TQueue`.

**Signature**

```ts
export * as TQueue from "./TQueue.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1390)

Since v2.0.0
index-TRandom.md
Package: `effect`<br />
Module: `index`<br />

## index.TRandom

Re-exports all named exports from the "./TRandom.js" module as `TRandom`.

**Signature**

```ts
export * as TRandom from "./TRandom.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1395)

Since v2.0.0
index-TReentrantLock.md
Package: `effect`<br />
Module: `index`<br />

## index.TReentrantLock

Re-exports all named exports from the "./TReentrantLock.js" module as `TReentrantLock`.

**Signature**

```ts
export * as TReentrantLock from "./TReentrantLock.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1400)

Since v2.0.0
index-Take.md
Package: `effect`<br />
Module: `index`<br />

## index.Take

Re-exports all named exports from the "./Take.js" module as `Take`.

**Signature**

```ts
export * as Take from "./Take.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1425)

Since v2.0.0
index-Template.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Template

Re-exports all named exports from the "./Template.js" module as `Template`.

**Signature**

```ts
export * as Template from "./Template.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L260)

Since v1.0.0
index-Terminal.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Terminal

Re-exports all named exports from the "./Terminal.js" module as `Terminal`.

**Signature**

```ts
export * as Terminal from "./Terminal.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L265)

Since v1.0.0
index-TestAnnotation.md
Package: `effect`<br />
Module: `index`<br />

## index.TestAnnotation

Re-exports all named exports from the "./TestAnnotation.js" module as `TestAnnotation`.

**Signature**

```ts
export * as TestAnnotation from "./TestAnnotation.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1430)

Since v2.0.0
index-TestAnnotationMap.md
Package: `effect`<br />
Module: `index`<br />

## index.TestAnnotationMap

Re-exports all named exports from the "./TestAnnotationMap.js" module as `TestAnnotationMap`.

**Signature**

```ts
export * as TestAnnotationMap from "./TestAnnotationMap.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1435)

Since v2.0.0
index-TestAnnotations.md
Package: `effect`<br />
Module: `index`<br />

## index.TestAnnotations

Re-exports all named exports from the "./TestAnnotations.js" module as `TestAnnotations`.

**Signature**

```ts
export * as TestAnnotations from "./TestAnnotations.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1440)

Since v2.0.0
index-TestClock.md
Package: `effect`<br />
Module: `index`<br />

## index.TestClock

Re-exports all named exports from the "./TestClock.js" module as `TestClock`.

**Signature**

```ts
export * as TestClock from "./TestClock.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1445)

Since v2.0.0
index-TestConfig.md
Package: `effect`<br />
Module: `index`<br />

## index.TestConfig

Re-exports all named exports from the "./TestConfig.js" module as `TestConfig`.

**Signature**

```ts
export * as TestConfig from "./TestConfig.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1450)

Since v2.0.0
index-TestContext.md
Package: `effect`<br />
Module: `index`<br />

## index.TestContext

Re-exports all named exports from the "./TestContext.js" module as `TestContext`.

**Signature**

```ts
export * as TestContext from "./TestContext.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1455)

Since v2.0.0
index-TestLive.md
Package: `effect`<br />
Module: `index`<br />

## index.TestLive

Re-exports all named exports from the "./TestLive.js" module as `TestLive`.

**Signature**

```ts
export * as TestLive from "./TestLive.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1460)

Since v2.0.0
index-TestServices.md
Package: `effect`<br />
Module: `index`<br />

## index.TestServices

Re-exports all named exports from the "./TestServices.js" module as `TestServices`.

**Signature**

```ts
export * as TestServices from "./TestServices.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1465)

Since v2.0.0
index-TestSized.md
Package: `effect`<br />
Module: `index`<br />

## index.TestSized

Re-exports all named exports from the "./TestSized.js" module as `TestSized`.

**Signature**

```ts
export * as TestSized from "./TestSized.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1470)

Since v2.0.0
index-Tokenizer.md
Package: `@effect/ai`<br />
Module: `index`<br />

## index.Tokenizer

Re-exports all named exports from the "./Tokenizer.js" module as `Tokenizer`.

**Signature**

```ts
export * as Tokenizer from "./Tokenizer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/ai/src/index.ts#L54)

Since v1.0.0
index-Tracer.md
Package: `effect`<br />
Module: `index`<br />

## index.Tracer

Re-exports all named exports from the "./Tracer.js" module as `Tracer`.

**Signature**

```ts
export * as Tracer from "./Tracer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1475)

Since v2.0.0
index-Transferable.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Transferable

Re-exports all named exports from the "./Transferable.js" module as `Transferable`.

**Signature**

```ts
export * as Transferable from "./Transferable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L270)

Since v1.0.0
index-Traversable.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.Traversable

Re-exports all named exports from the "./Traversable.js" module as `Traversable`.

**Signature**

```ts
export * as Traversable from "./Traversable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L121)

Since v0.24.0
index-TraversableFilterable.md
Package: `@effect/typeclass`<br />
Module: `index`<br />

## index.TraversableFilterable

Re-exports all named exports from the "./TraversableFilterable.js" module as `TraversableFilterable`.

**Signature**

```ts
export * as TraversableFilterable from "./TraversableFilterable.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/index.ts#L128)

Since v0.24.0
Invariant-imapComposition.md
Package: `@effect/typeclass`<br />
Module: `Invariant`<br />

## Invariant.imapComposition

Returns a default ternary `imap` composition.

**Signature**

```ts
declare const imapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Invariant<F>, G: Invariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, to: (a: A) => B, from: (b: B) => A) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Invariant.ts#L35)

Since v0.24.0
Invariant-tupled.md
Package: `@effect/typeclass`<br />
Module: `Invariant`<br />

## Invariant.tupled

Convert a value in a singleton array in a given effect.

**Signature**

```ts
declare const tupled: <F extends TypeLambda>(F: Invariant<F>) => <R, O, E, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, [A]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Invariant.ts#L68)

Since v0.24.0
Iterable-append.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.append

Append an element to the end of an `Iterable`, creating a new `Iterable`.

**Signature**

```ts
declare const append: { <B>(last: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, last: B): Iterable<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L169)

Since v2.0.0
Iterable-appendAll.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.appendAll

Concatenates two iterables, combining their elements.

**Signature**

```ts
declare const appendAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L180)

Since v2.0.0
Iterable-cartesian.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.cartesian

Zips this Iterable crosswise with the specified Iterable.

**Signature**

```ts
declare const cartesian: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1077)

Since v2.0.0
Iterable-cartesianWith.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.cartesianWith

Zips this Iterable crosswise with the specified Iterable using the specified combiner.

**Signature**

```ts
declare const cartesianWith: { <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1062)

Since v2.0.0
Iterable-chunksOf.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.chunksOf

Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
the `Iterable`.

**Signature**

```ts
declare const chunksOf: { (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>; <A>(self: Iterable<A>, n: number): Iterable<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L562)

Since v2.0.0
Iterable-contains.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.contains

Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.

**Signature**

```ts
declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L550)

Since v2.0.0
Iterable-containsWith.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.containsWith

Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.

**Signature**

```ts
declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L529)

Since v2.0.0
Iterable-countBy.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.countBy

Counts all the element of the given iterable that pass the given predicate

**Example**

```ts
import { Iterable } from "effect"

const result = Iterable.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)
console.log(result) // 2
```

**Signature**

```ts
declare const countBy: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => number; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1100)

Since v3.16.0
Iterable-dedupeAdjacent.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.dedupeAdjacent

Deduplicates adjacent elements that are identical.

**Signature**

```ts
declare const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1054)

Since v2.0.0
Iterable-dedupeAdjacentWith.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.dedupeAdjacentWith

Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.

**Signature**

```ts
declare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1020)

Since v2.0.0
Iterable-drop.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.drop

Drop a max number of elements from the start of an `Iterable`

**Note**. `n` is normalized to a non negative integer.

**Signature**

```ts
declare const drop: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L359)

Since v2.0.0
Iterable-filterMapWhile.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.filterMapWhile

Transforms all elements of the `Iterable` for as long as the specified function returns some value

**Signature**

```ts
declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L811)

Since v2.0.0
Iterable-findFirst.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

**Signature**

```ts
declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L388)

Since v2.0.0
Iterable-findLast.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.findLast

Find the last element for which a predicate holds.

**Signature**

```ts
declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L422)

Since v2.0.0
Iterable-flatMap.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.flatMap

Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.

**Signature**

```ts
declare const flatMap: { <A, B>(f: (a: NoInfer<A>, i: number) => Iterable<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L736)

Since v2.0.0
Iterable-flatten.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.flatten

Flattens an Iterable of Iterables into a single Iterable

**Signature**

```ts
declare const flatten: <A>(self: Iterable<Iterable<A>>) => Iterable<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L752)

Since v2.0.0
Iterable-forEach.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.forEach

Iterate over the `Iterable` applying `f`.

**Signature**

```ts
declare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L986)

Since v2.0.0
Iterable-fromRecord.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.fromRecord

Takes a record and returns an Iterable of tuples containing its keys and values.

**Example**

```ts
import * as assert from "node:assert"
import { fromRecord } from "effect/Iterable"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(Array.from(fromRecord(x)), [["a", 1], ["b", 2], ["c", 3]])
```

**Signature**

```ts
declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Iterable<[K, A]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L117)

Since v2.0.0
Iterable-getLefts.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.getLefts

Retrieves the `Left` values from an `Iterable` of `Either`s.

**Example**

```ts
import * as assert from "node:assert"
import { Iterable, Either } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getLefts([Either.right(1), Either.left("err"), Either.right(2)])),
  ["err"]
)
```

**Signature**

```ts
declare const getLefts: <R, L>(self: Iterable<Either<R, L>>) => Iterable<L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L870)

Since v2.0.0
Iterable-getRights.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.getRights

Retrieves the `Right` values from an `Iterable` of `Either`s.

**Example**

```ts
import * as assert from "node:assert"
import { Iterable, Either } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getRights([Either.right(1), Either.left("err"), Either.right(2)])),
  [1, 2]
)
```

**Signature**

```ts
declare const getRights: <R, L>(self: Iterable<Either<R, L>>) => Iterable<R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L889)

Since v2.0.0
Iterable-getSomes.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.getSomes

Retrieves the `Some` values from an `Iterable` of `Option`s.

**Example**

```ts
import * as assert from "node:assert"
import { Iterable, Option } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),
  [1, 2]
)
```

**Signature**

```ts
declare const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L851)

Since v2.0.0
Iterable-group.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.group

Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.

**Signature**

```ts
declare const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L645)

Since v2.0.0
Iterable-groupBy.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.groupBy

Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
function on each element, and grouping the results according to values returned

**Signature**

```ts
declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L656)

Since v2.0.0
index-TRef.md
Package: `effect`<br />
Module: `index`<br />

## index.TRef

Re-exports all named exports from the "./TRef.js" module as `TRef`.

**Signature**

```ts
export * as TRef from "./TRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1405)

Since v2.0.0
index-TSemaphore.md
Package: `effect`<br />
Module: `index`<br />

## index.TSemaphore

Re-exports all named exports from the "./TSemaphore.js" module as `TSemaphore`.

**Signature**

```ts
export * as TSemaphore from "./TSemaphore.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1410)

Since v2.0.0
index-TSet.md
Package: `effect`<br />
Module: `index`<br />

## index.TSet

Re-exports all named exports from the "./TSet.js" module as `TSet`.

**Signature**

```ts
export * as TSet from "./TSet.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1415)

Since v2.0.0
index-TSubscriptionRef.md
Package: `effect`<br />
Module: `index`<br />

## index.TSubscriptionRef

Re-exports all named exports from the "./TSubscriptionRef.js" module as `TSubscriptionRef`.

**Signature**

```ts
export * as TSubscriptionRef from "./TSubscriptionRef.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1420)

Since v3.10.0
index-Trie.md
Package: `effect`<br />
Module: `index`<br />

## index.Trie

Re-exports all named exports from the "./Trie.js" module as `Trie`.

**Signature**

```ts
export * as Trie from "./Trie.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1494)

Since v2.0.0
index-Tuple.md
Package: `effect`<br />
Module: `index`<br />

## index.Tuple

Re-exports all named exports from the "./Tuple.js" module as `Tuple`.

**Signature**

```ts
export * as Tuple from "./Tuple.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1501)

Since v2.0.0
index-Types.md
Package: `effect`<br />
Module: `index`<br />

## index.Types

Re-exports all named exports from the "./Types.js" module as `Types`.

**Signature**

```ts
export * as Types from "./Types.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1508)

Since v2.0.0
index-Undici.md
Package: `@effect/platform-node`<br />
Module: `index`<br />

## index.Undici

Re-exports all named exports from the "./Undici.js" module as `Undici`.

**Signature**

```ts
export * as Undici from "./Undici.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/index.ts#L114)

Since v1.0.0
index-Unify.md
Package: `effect`<br />
Module: `index`<br />

## index.Unify

Re-exports all named exports from the "./Unify.js" module as `Unify`.

**Signature**

```ts
export * as Unify from "./Unify.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1513)

Since v2.0.0
index-UpstreamPullRequest.md
Package: `effect`<br />
Module: `index`<br />

## index.UpstreamPullRequest

Re-exports all named exports from the "./UpstreamPullRequest.js" module as `UpstreamPullRequest`.

**Signature**

```ts
export * as UpstreamPullRequest from "./UpstreamPullRequest.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1518)

Since v2.0.0
index-UpstreamPullStrategy.md
Package: `effect`<br />
Module: `index`<br />

## index.UpstreamPullStrategy

Re-exports all named exports from the "./UpstreamPullStrategy.js" module as `UpstreamPullStrategy`.

**Signature**

```ts
export * as UpstreamPullStrategy from "./UpstreamPullStrategy.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1523)

Since v2.0.0
index-Url.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Url

Re-exports all named exports from the "./Url.js" module as `Url`.

**Signature**

```ts
export * as Url from "./Url.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L275)

Since v1.0.0
index-UrlParams.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.UrlParams

Re-exports all named exports from the "./UrlParams.js" module as `UrlParams`.

**Signature**

```ts
export * as UrlParams from "./UrlParams.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L280)

Since v1.0.0
index-Usage.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.Usage

Re-exports all named exports from the "./Usage.js" module as `Usage`.

**Signature**

```ts
export * as Usage from "./Usage.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L69)

Since v1.0.0
index-Utils.md
Package: `effect`<br />
Module: `index`<br />

## index.Utils

Re-exports all named exports from the "./Utils.js" module as `Utils`.

**Signature**

```ts
export * as Utils from "./Utils.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/index.ts#L1528)

Since v2.0.0
index-ValidationError.md
Package: `@effect/cli`<br />
Module: `index`<br />

## index.ValidationError

Re-exports all named exports from the "./ValidationError.js" module as `ValidationError`.

**Signature**

```ts
export * as ValidationError from "./ValidationError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/index.ts#L74)

Since v1.0.0
index-VariantSchema.md
Package: `@effect/experimental`<br />
Module: `index`<br />

## index.VariantSchema

Re-exports all named exports from the "./VariantSchema.js" module as `VariantSchema`.

**Signature**

```ts
export * as VariantSchema from "./VariantSchema.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/index.ts#L74)

Since v1.0.0
index-WebSdk.md
Package: `@effect/opentelemetry`<br />
Module: `index`<br />

## index.WebSdk

Re-exports all named exports from the "./WebSdk.js" module as `WebSdk`.

**Signature**

```ts
export * as WebSdk from "./WebSdk.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/index.ts#L55)

Since v1.0.0
index-Worker.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.Worker

Re-exports all named exports from the "./Worker.js" module as `Worker`.

**Signature**

```ts
export * as Worker from "./Worker.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L285)

Since v1.0.0
index-WorkerError.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.WorkerError

Re-exports all named exports from the "./WorkerError.js" module as `WorkerError`.

**Signature**

```ts
export * as WorkerError from "./WorkerError.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L290)

Since v1.0.0
index-WorkerRunner.md
Package: `@effect/platform`<br />
Module: `index`<br />

## index.WorkerRunner

Re-exports all named exports from the "./WorkerRunner.js" module as `WorkerRunner`.

**Signature**

```ts
export * as WorkerRunner from "./WorkerRunner.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L295)

Since v1.0.0
index-Workflow.md
Package: `@effect/workflow`<br />
Module: `index`<br />

## index.Workflow

Re-exports all named exports from the "./Workflow.js" module as `Workflow`.

**Signature**

```ts
export * as Workflow from "./Workflow.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L19)

Since v1.0.0
index-WorkflowEngine.md
Package: `@effect/workflow`<br />
Module: `index`<br />

## index.WorkflowEngine

Re-exports all named exports from the "./WorkflowEngine.js" module as `WorkflowEngine`.

**Signature**

```ts
export * as WorkflowEngine from "./WorkflowEngine.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L24)

Since v1.0.0
index-WorkflowProxy.md
Package: `@effect/workflow`<br />
Module: `index`<br />

## index.WorkflowProxy

Re-exports all named exports from the "./WorkflowProxy.js" module as `WorkflowProxy`.

**Signature**

```ts
export * as WorkflowProxy from "./WorkflowProxy.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L29)

Since v1.0.0
index-WorkflowProxyServer.md
Package: `@effect/workflow`<br />
Module: `index`<br />

## index.WorkflowProxyServer

Re-exports all named exports from the "./WorkflowProxyServer.js" module as `WorkflowProxyServer`.

**Signature**

```ts
export * as WorkflowProxyServer from "./WorkflowProxyServer.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/index.ts#L34)

Since v1.0.0
Iterable-groupWith.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.groupWith

Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.

**Signature**

```ts
declare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L599)

Since v2.0.0
Iterable-head.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.head

Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.

**Signature**

```ts
declare const head: <A>(self: Iterable<A>) => Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L278)

Since v2.0.0
Iterable-intersperse.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.intersperse

Places an element in between members of an `Iterable`.
If the input is a non-empty array, the result is also a non-empty array.

**Signature**

```ts
declare const intersperse: { <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L498)

Since v2.0.0
Iterable-isEmpty.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.isEmpty

Determine if an `Iterable` is empty

**Example**

```ts
import * as assert from "node:assert"
import { isEmpty } from "effect/Iterable"

assert.deepStrictEqual(isEmpty([]), true);
assert.deepStrictEqual(isEmpty([1, 2, 3]), false);
```

**Signature**

```ts
declare const isEmpty: <A>(self: Iterable<A>) => self is Iterable<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L252)

Since v2.0.0
Iterable-makeBy.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.makeBy

Return a `Iterable` with element `i` initialized with `f(i)`.

If the `length` is not specified, the `Iterable` will be infinite.

**Note**. `length` is normalized to an integer >= 1.

**Example**

```ts
import * as assert from "node:assert"
import { makeBy } from "effect/Iterable"

assert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])
```

**Signature**

```ts
declare const makeBy: <A>(f: (i: number) => A, options?: { readonly length?: number; }) => Iterable<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L37)

Since v2.0.0
Iterable-of.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.of

Constructs a new `Iterable<A>` from the specified value.

**Signature**

```ts
declare const of: <A>(a: A) => Iterable<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L703)

Since v2.0.0
Iterable-prepend.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.prepend

Prepend an element to the front of an `Iterable`, creating a new `Iterable`.

**Signature**

```ts
declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, head: B): Iterable<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L133)

Since v2.0.0
Iterable-prependAll.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.prependAll

Prepends the specified prefix iterable to the beginning of the specified iterable.

**Example**

```ts
import * as assert from "node:assert"
import { Iterable } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.prependAll([1, 2], ["a", "b"])),
  ["a", "b", 1, 2]
)
```

**Signature**

```ts
declare const prependAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L155)

Since v2.0.0
Iterable-range.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.range

Return a `Iterable` containing a range of integers, including both endpoints.

If `end` is omitted, the range will not have an upper bound.

**Example**

```ts
import * as assert from "node:assert"
import { range } from "effect/Iterable"

assert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])
```

**Signature**

```ts
declare const range: (start: number, end?: number) => Iterable<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L72)

Since v2.0.0
Iterable-replicate.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.replicate

Return a `Iterable` containing a value repeated the specified number of times.

**Note**. `n` is normalized to an integer >= 1.

**Example**

```ts
import * as assert from "node:assert"
import { replicate } from "effect/Iterable"

assert.deepStrictEqual(Array.from(replicate("a", 3)), ["a", "a", "a"])
```

**Signature**

```ts
declare const replicate: { (n: number): <A>(a: A) => Iterable<A>; <A>(a: A, n: number): Iterable<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L97)

Since v2.0.0
Iterable-scan.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.scan

Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.

**Signature**

```ts
declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L214)

Since v2.0.0
Iterable-size.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.size

Return the number of elements in a `Iterable`.

**Signature**

```ts
declare const size: <A>(self: Iterable<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L263)

Since v2.0.0
Iterable-some.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.some

Check if a predicate holds true for some `Iterable` element.

**Signature**

```ts
declare const some: { <A>(predicate: (a: A, i: number) => boolean): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L944)

Since v2.0.0
Iterable-take.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.take

Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.

**Note**. `n` is normalized to a non negative integer.

**Signature**

```ts
declare const take: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L305)

Since v2.0.0
Iterable-takeWhile.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.takeWhile

Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.

**Signature**

```ts
declare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L330)

Since v2.0.0
Iterable-unsafeHead.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.unsafeHead

Get the first element of a `Iterable`, or throw an error if the `Iterable` is empty.

**Signature**

```ts
declare const unsafeHead: <A>(self: Iterable<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L290)

Since v3.3.0
Iterable-zip.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.zip

Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.

**Signature**

```ts
declare const zip: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L457)

Since v2.0.0
Iterable-zipWith.md
Package: `effect`<br />
Module: `Iterable`<br />

## Iterable.zipWith

Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one
input `Iterable` is short, excess elements of the longer `Iterable` are discarded.

**Signature**

```ts
declare const zipWith: { <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L472)

Since v2.0.0
JSONSchema-fromAST.md
Package: `effect`<br />
Module: `JSONSchema`<br />

## JSONSchema.fromAST

Returns a JSON Schema with additional options and definitions.

**Warning**

This function is experimental and subject to change.

**Options**

- `definitions`: A record of definitions that are included in the schema.
- `definitionPath`: The path to the definitions within the schema (defaults
  to "#/$defs/").
- `target`: Which spec to target. Possible values are:
  - `'jsonSchema7'`: JSON Schema draft-07 (default behavior).
  - `'jsonSchema2019-09'`: JSON Schema draft-2019-09.
  - `'openApi3.1'`: OpenAPI 3.1.
- `topLevelReferenceStrategy`: Controls the handling of the top-level
  reference. Possible values are:
  - `"keep"`: Keep the top-level reference (default behavior).
  - `"skip"`: Skip the top-level reference.
- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:
  - `"strict"`: Disallow additional properties (default behavior).
  - `"allow"`: Allow additional properties.

**Signature**

```ts
declare const fromAST: (ast: AST.AST, options: { readonly definitions: Record<string, JsonSchema7>; readonly definitionPath?: string | undefined; readonly target?: Target | undefined; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; }) => JsonSchema7
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L306)

Since v3.11.5
KeyValueStore-layerStorage.md
Package: `@effect/platform`<br />
Module: `KeyValueStore`<br />

## KeyValueStore.layerStorage

Creates an KeyValueStorage from an instance of the `Storage` api.

**See**

- https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API

**Signature**

```ts
declare const layerStorage: (evaluate: LazyArg<Storage>) => Layer.Layer<KeyValueStore>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/KeyValueStore.ts#L241)

Since v1.0.0
KeyedPool-KeyedPool.md
Package: `effect`<br />
Module: `KeyedPool`<br />

## KeyedPool.KeyedPool

A `KeyedPool<K, A, E>` is a pool of `Pool`s of items of type `A`. Each pool
in the `KeyedPool` is associated with a key of type `K`.

**Signature**

```ts
export interface KeyedPool<in K, in out A, out E = never> extends KeyedPool.Variance<K, A, E>, Pipeable {
  /**
   * Retrieves an item from the pool belonging to the given key in a scoped
   * effect. Note that if acquisition fails, then the returned effect will fail
   * for that same reason. Retrying a failed acquisition attempt will repeat the
   * acquisition attempt.
   */
  get(key: K): Effect.Effect<A, E, Scope.Scope>

  /**
   * Invalidates the specified item. This will cause the pool to eventually
   * reallocate the item, although this reallocation may occur lazily rather
   * than eagerly.
   */
  invalidate(item: A): Effect.Effect<void>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L30)

Since v2.0.0
KeyedPool-get.md
Package: `effect`<br />
Module: `KeyedPool`<br />

## KeyedPool.get

Retrieves an item from the pool belonging to the given key in a scoped
effect. Note that if acquisition fails, then the returned effect will fail
for that same reason. Retrying a failed acquisition attempt will repeat the
acquisition attempt.

**Signature**

```ts
declare const get: { <K>(key: K): <A, E>(self: KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>; <K, A, E>(self: KeyedPool<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L151)

Since v2.0.0
KeyedPool-invalidate.md
Package: `effect`<br />
Module: `KeyedPool`<br />

## KeyedPool.invalidate

Invalidates the specified item. This will cause the pool to eventually
reallocate the item, although this reallocation may occur lazily rather
than eagerly.

**Signature**

```ts
declare const invalidate: { <A>(item: A): <K, E>(self: KeyedPool<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: KeyedPool<K, A, E>, item: A): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L164)

Since v2.0.0
KeyedPool-make.md
Package: `effect`<br />
Module: `KeyedPool`<br />

## KeyedPool.make

Makes a new pool of the specified fixed size. The pool is returned in a
`Scope`, which governs the lifetime of the pool. When the pool is shutdown
because the `Scope` is closed, the individual items allocated by the pool
will be released in some unspecified order.

**Signature**

```ts
declare const make: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L73)

Since v2.0.0
KeyedPool-makeWith.md
Package: `effect`<br />
Module: `KeyedPool`<br />

## KeyedPool.makeWith

Makes a new pool of the specified fixed size. The pool is returned in a
`Scope`, which governs the lifetime of the pool. When the pool is shutdown
because the `Scope` is closed, the individual items allocated by the pool
will be released in some unspecified order.

The size of the underlying pools can be configured per key.

**Signature**

```ts
declare const makeWith: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: (key: K) => number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L91)

Since v2.0.0
KeyedPool-makeWithTTL.md
Package: `effect`<br />
Module: `KeyedPool`<br />

## KeyedPool.makeWithTTL

Makes a new pool with the specified minimum and maximum sizes and time to
live before a pool whose excess items are not being used will be shrunk
down to the minimum size. The pool is returned in a `Scope`, which governs
the lifetime of the pool. When the pool is shutdown because the `Scope` is
used, the individual items allocated by the pool will be released in some
unspecified order.

The size of the underlying pools can be configured per key.

**Signature**

```ts
declare const makeWithTTL: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L111)

Since v2.0.0
KeyedPool-makeWithTTLBy.md
Package: `effect`<br />
Module: `KeyedPool`<br />

## KeyedPool.makeWithTTLBy

Makes a new pool with the specified minimum and maximum sizes and time to
live before a pool whose excess items are not being used will be shrunk
down to the minimum size. The pool is returned in a `Scope`, which governs
the lifetime of the pool. When the pool is shutdown because the `Scope` is
used, the individual items allocated by the pool will be released in some
unspecified order.

The size of the underlying pools can be configured per key.

**Signature**

```ts
declare const makeWithTTLBy: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: (key: K) => Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L133)

Since v2.0.0
Layer-build.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.build

Builds a layer into a scoped value.

**Signature**

```ts
declare const build: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, Scope.Scope | RIn>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L197)

Since v2.0.0
Layer-buildWithMemoMap.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.buildWithMemoMap

Builds a layer into an `Effect` value, using the specified `MemoMap` to memoize
the layer construction.

**Signature**

```ts
declare const buildWithMemoMap: { (memoMap: MemoMap, scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1116)

Since v2.0.0
Layer-buildWithScope.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.buildWithScope

Builds a layer into an `Effect` value. Any resources associated with this
layer will be released when the specified scope is closed unless their scope
has been extended. This allows building layers where the lifetime of some of
the services output by the layer exceed the lifetime of the effect the
layer is provided to.

**Signature**

```ts
declare const buildWithScope: { (scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L211)

Since v2.0.0
Layer-catchAll.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.catchAll

Recovers from all errors.

**Signature**

```ts
declare const catchAll: { <E, RIn2, E2, ROut2>(onError: (error: E) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, onError: (error: E) => Layer<ROut2, E2, RIn2>): Layer<ROut & ROut2, E2, RIn | RIn2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L222)

Since v2.0.0
Layer-catchAllCause.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.catchAllCause

Recovers from all errors.

**Signature**

```ts
declare const catchAllCause: { <E, RIn2, E2, ROut2>(onError: (cause: Cause.Cause<E>) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut22>(self: Layer<ROut, E, RIn>, onError: (cause: Cause.Cause<E>) => Layer<ROut22, E2, RIn2>): Layer<ROut & ROut22, E2, RIn | RIn2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L238)

Since v2.0.0
Layer-context.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.context

Constructs a `Layer` that passes along the specified context as an
output.

**Signature**

```ts
declare const context: <R>() => Layer<R, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L255)

Since v2.0.0
Layer-die.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.die

Constructs a layer that dies with the specified defect.

**Signature**

```ts
declare const die: (defect: unknown) => Layer<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L263)

Since v2.0.0
Layer-dieSync.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.dieSync

Constructs a layer that dies with the specified defect.

**Signature**

```ts
declare const dieSync: (evaluate: LazyArg<unknown>) => Layer<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L271)

Since v2.0.0
Layer-discard.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.discard

Replaces the layer's output with `never` and includes the layer only for its
side-effects.

**Signature**

```ts
declare const discard: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<never, E, RIn>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L280)

Since v2.0.0
Layer-effect.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.effect

Constructs a layer from the specified effect.

**Signature**

```ts
declare const effect: { <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, R>; <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L288)

Since v2.0.0
Layer-effectContext.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.effectContext

Constructs a layer from the specified effect, which must return one or more
services.

**Signature**

```ts
declare const effectContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L308)

Since v2.0.0
Layer-effectDiscard.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.effectDiscard

Constructs a layer from the specified effect, discarding its output.

**Signature**

```ts
declare const effectDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L299)

Since v2.0.0
Layer-empty.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.empty

A Layer that constructs an empty Context.

**Signature**

```ts
declare const empty: Layer<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L317)

Since v2.0.0
Layer-extendScope.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.extendScope

Extends the scope of this layer, returning a new layer that when provided
to an effect will not immediately release its associated resources when
that effect completes execution but instead when the scope the resulting
effect depends on is closed.

**Signature**

```ts
declare const extendScope: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, Scope.Scope | RIn>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L328)

Since v2.0.0
Layer-fail.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.fail

Constructs a layer that fails with the specified error.

**Signature**

```ts
declare const fail: <E>(error: E) => Layer<unknown, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L337)

Since v2.0.0
Layer-failCause.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.failCause

Constructs a layer that fails with the specified cause.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Layer<unknown, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L353)

Since v2.0.0
Layer-failCauseSync.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.failCauseSync

Constructs a layer that fails with the specified cause.

**Signature**

```ts
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Layer<unknown, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L361)

Since v2.0.0
Layer-failSync.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.failSync

Constructs a layer that fails with the specified error.

**Signature**

```ts
declare const failSync: <E>(evaluate: LazyArg<E>) => Layer<unknown, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L345)

Since v2.0.0
Layer-flatMap.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.flatMap

Constructs a layer dynamically based on the output of this layer.

**Signature**

```ts
declare const flatMap: { <A, A2, E2, R2>(f: (context: Context.Context<A>) => Layer<A2, E2, R2>): <E, R>(self: Layer<A, E, R>) => Layer<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Layer<A2, E2, R2>): Layer<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L369)

Since v2.0.0
Layer-flatten.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.flatten

Flattens layers nested in the context of an effect.

**Signature**

```ts
declare const flatten: { <I, A, E2, R2>(tag: Context.Tag<I, Layer<A, E2, R2>>): <E, R>(self: Layer<I, E, R>) => Layer<A, E2 | E, R2 | R>; <I, E, R, A, E2, R2>(self: Layer<I, E, R>, tag: Context.Tag<I, Layer<A, E2, R2>>): Layer<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L385)

Since v2.0.0
Layer-fresh.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.fresh

Creates a fresh version of this layer that will not be shared.

**Signature**

```ts
declare const fresh: <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L396)

Since v2.0.0
Layer-function.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.function

Constructs a layer from the context using the specified function.

**Signature**

```ts
declare const function: <I1, S1, I2, S2>(tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>) => Layer<I2, never, I1>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L411)

Since v2.0.0
Layer-isFresh.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.isFresh

Returns `true` if the specified `Layer` is a fresh version that will not be
shared, `false` otherwise.

**Signature**

```ts
declare const isFresh: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L167)

Since v2.0.0
Layer-isLayer.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.isLayer

Returns `true` if the specified value is a `Layer`, `false` otherwise.

**Signature**

```ts
declare const isLayer: (u: unknown) => u is Layer<unknown, unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L158)

Since v2.0.0
Layer-launch.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.launch

Builds this layer and uses it until it is interrupted. This is useful when
your entire application is a layer, such as an HTTP server.

**Signature**

```ts
declare const launch: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<never, E, RIn>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L421)

Since v2.0.0
Layer-makeMemoMap.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.makeMemoMap

Constructs a `MemoMap` that can be used to build additional layers.

**Signature**

```ts
declare const makeMemoMap: Effect.Effect<MemoMap, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1107)

Since v2.0.0
Layer-map.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.map

Returns a new layer whose output is mapped by the specified function.

**Signature**

```ts
declare const map: { <A, B>(f: (context: Context.Context<A>) => Context.Context<B>): <E, R>(self: Layer<A, E, R>) => Layer<B, E, R>; <A, E, R, B>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Context.Context<B>): Layer<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L429)

Since v2.0.0
Layer-mapError.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.mapError

Returns a layer with its error channel mapped using the specified function.

**Signature**

```ts
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Layer<A, E, R>) => Layer<A, E2, R>; <A, E, R, E2>(self: Layer<A, E, R>, f: (error: E) => E2): Layer<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L440)

Since v2.0.0
Layer-match.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.match

Feeds the error or output services of this layer into the input of either
the specified `failure` or `success` layers, resulting in a new layer with
the inputs of this layer, and the error or outputs of the specified layer.

**Signature**

```ts
declare const match: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L453)

Since v2.0.0
Layer-matchCause.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.matchCause

Feeds the error or output services of this layer into the input of either
the specified `failure` or `success` layers, resulting in a new layer with
the inputs of this layer, and the error or outputs of the specified layer.

**Signature**

```ts
declare const matchCause: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L477)

Since v2.0.0
Layer-memoize.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.memoize

Returns a scoped effect that, if evaluated, will return the lazily computed
result of this layer.

**Signature**

```ts
declare const memoize: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Layer<ROut, E, RIn>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L500)

Since v2.0.0
Layer-merge.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.merge

Merges this layer with the specified layer concurrently, producing a new layer with combined input and output types.

**Signature**

```ts
declare const merge: { <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>): <RIn, E1, ROut>(self: Layer<ROut, E1, RIn>) => Layer<ROut2 | ROut, E2 | E1, RIn2 | RIn>; <RIn, E1, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E1, RIn>, that: Layer<ROut2, E2, RIn2>): Layer<ROut | ROut2, E1 | E2, RIn | RIn2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L510)

Since v2.0.0
Layer-mergeAll.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.mergeAll

Combines all the provided layers concurrently, creating a new layer with merged input, error, and output types.

**Signature**

```ts
declare const mergeAll: <Layers extends [Layer<never, any, any>, ...Array<Layer<never, any, any>>]>(...layers: Layers) => Layer<{ [k in keyof Layers]: Layer.Success<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L526)

Since v2.0.0
Layer-orDie.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.orDie

Translates effect failure into death of the fiber, making all failures
unchecked and not a part of the type of the layer.

**Signature**

```ts
declare const orDie: <A, E, R>(self: Layer<A, E, R>) => Layer<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L541)

Since v2.0.0
Layer-orElse.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.orElse

Executes this layer and returns its output, if it succeeds, but otherwise
executes the specified layer.

**Signature**

```ts
declare const orElse: { <A2, E2, R2>(that: LazyArg<Layer<A2, E2, R2>>): <A, E, R>(self: Layer<A, E, R>) => Layer<A & A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, that: LazyArg<Layer<A2, E2, R2>>): Layer<A & A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L550)

Since v2.0.0
Layer-parentSpan.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.parentSpan

Adds the provided span to the span stack.

**Signature**

```ts
declare const parentSpan: (span: Tracer.AnySpan) => Layer<Tracer.ParentSpan>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L948)

Since v2.0.0
Layer-passthrough.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.passthrough

Returns a new layer that produces the outputs of this layer but also
passes through the inputs.

**Signature**

```ts
declare const passthrough: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<RIn | ROut, E, RIn>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L562)

Since v2.0.0
Layer-project.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.project

Projects out part of one of the services output by this layer using the
specified function.

**Signature**

```ts
declare const project: { <I1, S1, I2, S2>(tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): <RIn, E>(self: Layer<I1, E, RIn>) => Layer<I2, E, RIn>; <RIn, E, I1, S1, I2, S2>(self: Layer<I1, E, RIn>, tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): Layer<I2, E, RIn>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L571)

Since v2.0.0
Layer-provide.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.provide

Feeds the output services of this builder into the input of the specified
builder, resulting in a new builder with the inputs of this builder as
well as any leftover inputs, and the outputs of the specified builder.

**Signature**

```ts
declare const provide: { <RIn, E, ROut>(that: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(self: Layer<ROut2, E2, RIn2>) => Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <const Layers extends [Layer.Any, ...Array<Layer.Any>]>(that: Layers): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <RIn2, E2, ROut2, RIn, E, ROut>(self: Layer<ROut2, E2, RIn2>, that: Layer<ROut, E, RIn>): Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <A, E, R, const Layers extends [Layer.Any, ...Array<Layer.Any>]>(self: Layer<A, E, R>, that: Layers): Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L842)

Since v2.0.0
Layer-provideMerge.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.provideMerge

Feeds the output services of this layer into the input of the specified
layer, resulting in a new layer with the inputs of this layer, and the
outputs of both layers.

**Signature**

```ts
declare const provideMerge: { <RIn, E, ROut>(self: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>) => Layer<ROut | ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <RIn2, E2, ROut2, RIn, E, ROut>(that: Layer<ROut2, E2, RIn2>, self: Layer<ROut, E, RIn>): Layer<ROut2 | ROut, E2 | E, RIn | Exclude<RIn2, ROut>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L879)

Since v2.0.0
Layer-retry.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.retry

Retries constructing this layer according to the specified schedule.

**Signature**

```ts
declare const retry: { <X, E, RIn2>(schedule: Schedule.Schedule<X, NoInfer<E>, RIn2>): <ROut, RIn>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, RIn2 | RIn>; <ROut, E, RIn, X, RIn2>(self: Layer<ROut, E, RIn>, schedule: Schedule.Schedule<X, E, RIn2>): Layer<ROut, E, RIn | RIn2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L643)

Since v2.0.0
Layer-scope.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.scope

A layer that constructs a scope and closes it when the workflow the layer
is provided to completes execution, whether by success, failure, or
interruption. This can be used to close a scope when providing a layer to a
workflow.

**Signature**

```ts
declare const scope: Layer<Scope.Scope, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L662)

Since v2.0.0
Layer-scoped.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.scoped

Constructs a layer from the specified scoped effect.

**Signature**

```ts
declare const scoped: { <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, Exclude<R, Scope.Scope>>; <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, Exclude<R, Scope.Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L670)

Since v2.0.0
Layer-scopedContext.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.scopedContext

Constructs a layer from the specified scoped effect, which must return one
or more services.

**Signature**

```ts
declare const scopedContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L696)

Since v2.0.0
Layer-scopedDiscard.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.scopedDiscard

Constructs a layer from the specified scoped effect.

**Signature**

```ts
declare const scopedDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L686)

Since v2.0.0
Layer-service.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.service

Constructs a layer that accesses and returns the specified service from the
context.

**Signature**

```ts
declare const service: <I, S>(tag: Context.Tag<I, S>) => Layer<I, never, I>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L707)

Since v2.0.0
Layer-setConfigProvider.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.setConfigProvider

Sets the current `ConfigProvider`.

**Signature**

```ts
declare const setConfigProvider: (configProvider: ConfigProvider) => Layer<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L940)

Since v2.0.0
Layer-setTracer.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.setTracer

Create a Layer that sets the current Tracer

**Signature**

```ts
declare const setTracer: (tracer: Tracer.Tracer) => Layer<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1033)

Since v2.0.0
Layer-span.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.span

Create and add a span to the current span stack.

The span is ended when the Layer is released.

**Signature**

```ts
declare const span: (name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }) => Layer<Tracer.ParentSpan>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1018)

Since v2.0.0
Layer-succeed.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.succeed

Constructs a layer from the specified value.

**Signature**

```ts
declare const succeed: { <I, S>(tag: Context.Tag<I, S>): (resource: Types.NoInfer<S>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, resource: Types.NoInfer<S>): Layer<I>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L715)

Since v2.0.0
Layer-succeedContext.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.succeedContext

Constructs a layer from the specified value, which must return one or more
services.

**Signature**

```ts
declare const succeedContext: <A>(context: Context.Context<A>) => Layer<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L727)

Since v2.0.0
Layer-suspend.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.suspend

Lazily constructs a layer. This is useful to avoid infinite recursion when
creating layers that refer to themselves.

**Signature**

```ts
declare const suspend: <RIn, E, ROut>(evaluate: LazyArg<Layer<ROut, E, RIn>>) => Layer<ROut, E, RIn>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L736)

Since v2.0.0
Layer-sync.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.sync

Lazily constructs a layer from the specified value.

**Signature**

```ts
declare const sync: { <I, S>(tag: Context.Tag<I, S>): (evaluate: LazyArg<Types.NoInfer<S>>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, evaluate: LazyArg<Types.NoInfer<S>>): Layer<I>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L744)

Since v2.0.0
Layer-syncContext.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.syncContext

Lazily constructs a layer from the specified value, which must return one or more
services.

**Signature**

```ts
declare const syncContext: <A>(evaluate: LazyArg<Context.Context<A>>) => Layer<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L756)

Since v2.0.0
Layer-tap.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.tap

Performs the specified effect if this layer succeeds.

**Signature**

```ts
declare const tap: { <ROut, XR extends ROut, RIn2, E2, X>(f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): <RIn, E>(self: Layer<ROut, E, RIn>) => Layer<ROut, E2 | E, RIn2 | RIn>; <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L764)

Since v2.0.0
Layer-tapError.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.tapError

Performs the specified effect if this layer fails.

**Signature**

```ts
declare const tapError: { <E, XE extends E, RIn2, E2, X>(f: (e: XE) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (e: XE) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L780)

Since v2.0.0
Layer-tapErrorCause.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.tapErrorCause

Performs the specified effect if this layer fails.

**Signature**

```ts
declare const tapErrorCause: { <E, XE extends E, RIn2, E2, X>(f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L796)

Since v2.0.0
Layer-toRuntime.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.toRuntime

Converts a layer that requires no services into a scoped runtime, which can
be used to execute effects.

**Signature**

```ts
declare const toRuntime: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L813)

Since v2.0.0
Layer-toRuntimeWithMemoMap.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.toRuntimeWithMemoMap

Converts a layer that requires no services into a scoped runtime, which can
be used to execute effects.

**Signature**

```ts
declare const toRuntimeWithMemoMap: { (memoMap: MemoMap): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap): Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L824)

Since v2.0.0
Layer-updateService.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.updateService

Updates a service in the context with a new implementation.

**Details**

This function modifies the existing implementation of a service in the
context. It retrieves the current service, applies the provided
transformation function `f`, and replaces the old service with the
transformed one.

**When to Use**

This is useful for adapting or extending a service's behavior during the
creation of a layer.

**Signature**

```ts
declare const updateService: (<I, A>(tag: Context.Tag<I, A>, f: (a: A) => A) => <A1, E1, R1>(layer: Layer<A1, E1, R1>) => Layer<A1, E1, I | R1>) & (<A1, E1, R1, I, A>(layer: Layer<A1, E1, R1>, tag: Context.Tag<I, A>, f: (a: A) => A) => Layer<A1, E1, I | R1>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1146)

Since v3.13.0
Layer-zipWith.md
Package: `effect`<br />
Module: `Layer`<br />

## Layer.zipWith

Combines this layer with the specified layer concurrently, creating a new layer with merged input types and
combined output types using the provided function.

**Signature**

```ts
declare const zipWith: { <B, E2, R2, A, C>(that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): <E, R>(self: Layer<A, E, R>) => Layer<C, E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Layer<A, E, R>, that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): Layer<C, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L896)

Since v2.0.0
Layout-Layout.FittingPredicate.md
Package: `@effect/printer`<br />
Module: `Layout`<br />

## Layout.Layout.FittingPredicate

Decides whether a `DocStream` fits the given constraints, namely:
- original indentation of the current column
- initial indentation of the alternative `DocStream` if it starts with
  a line break (used by `layoutSmart`)
- width in which to fit the first line

**Signature**

```ts
export interface FittingPredicate<A> {
    (
      stream: DocStream<A>,
      indentation: number,
      currentColumn: number,
      comparator: LazyArg<DocStream<A>>
    ): boolean
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Layout.ts#L48)

Since v1.0.0
Layout-Layout.Options.md
Package: `@effect/printer`<br />
Module: `Layout`<br />

## Layout.Layout.Options

Represents the options that will influence the layout algorithms.

**Signature**

```ts
export interface Options {
    readonly pageWidth: PageWidth
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Layout.ts#L34)

Since v1.0.0
Layout-compact.md
Package: `@effect/printer`<br />
Module: `Layout`<br />

## Layout.compact

A layout algorithm which will lay out a document without adding any
indentation and without preserving annotations.

Since no pretty-printing is involved, this layout algorithm is very fast. The
resulting output contains fewer characters than a pretty-printed version and
can be used for output that is read by other programs.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = pipe(
  Doc.vsep([
    Doc.text("lorem"),
    Doc.text("ipsum"),
    pipe(
      Doc.vsep([Doc.text("dolor"), Doc.text("sit")]),
      Doc.hang(4)
    )
  ]),
  Doc.hang(4)
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |    ipsum
     |    dolor
     |        sit`
  )
)

assert.strictEqual(
  Doc.render(doc, { style: "compact" }),
  String.stripMargin(
    `|lorem
     |ipsum
     |dolor
     |sit`
  )
)
```

**Signature**

```ts
declare const compact: <A>(self: Doc<A>) => DocStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Layout.ts#L137)

Since v1.0.0
Layout-defaultOptions.md
Package: `@effect/printer`<br />
Module: `Layout`<br />

## Layout.defaultOptions

The default layout options, which are suitable when you want to obtain output
but do not care about the details.

**Signature**

```ts
declare const defaultOptions: Layout.Options
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Layout.ts#L71)

Since v1.0.0
Layout-pretty.md
Package: `@effect/printer`<br />
Module: `Layout`<br />

## Layout.pretty

The `pretty` layout algorithm is the default algorithm for rendering
documents.

`pretty` commits to rendering something in a certain way if the next
element fits the layout constrants. In other words, it has one `DocStream`
element lookahead when rendering.

Consider using the smarter, but slightly less performant `smart`
algorithm if the results seem to run off to the right before having lots of
line breaks.

**Signature**

```ts
declare const pretty: { (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>; <A>(self: Doc<A>, options: Layout.Options): DocStream<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Layout.ts#L154)

Since v1.0.0
Layout-smart.md
Package: `@effect/printer`<br />
Module: `Layout`<br />

## Layout.smart

A layout algorithm with more look ahead than `pretty`, which will introduce
line breaks into a document earlier if the content does not, or will not, fit
onto one line.

**Example**

```ts
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import type * as DocStream from "@effect/printer/DocStream"
import * as Layout from "@effect/printer/Layout"
import * as PageWidth from "@effect/printer/PageWidth"
import { pipe } from "effect/Function"
import * as String from "effect/String"

// Consider the following python-ish document:
const fun = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  Doc.hcat([
    pipe(
      Doc.hcat([Doc.text("fun("), Doc.softLineBreak, doc]),
      Doc.hang(2)
    ),
    Doc.text(")")
  ])

const funs = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  pipe(doc, fun, fun, fun, fun, fun)

const doc = funs(Doc.align(Doc.list(Doc.words("abcdef ghijklm"))))

// The document will be rendered using the following pipeline, where the choice
// of layout algorithm has been left open:
const pageWidth = PageWidth.availablePerLine(26, 1)
const layoutOptions = Layout.options(pageWidth)
const dashes = Doc.text(Array.from({ length: 26 - 2 }, () => "-").join(""))
const hr = Doc.hcat([Doc.vbar, dashes, Doc.vbar])

const render = <A>(
  doc: Doc.Doc<A>
) =>
  (
    layoutAlgorithm: (options: Layout.Layout.Options) => (doc: Doc.Doc<A>) => DocStream.DocStream<A>
  ): string => pipe(Doc.vsep([hr, doc, hr]), layoutAlgorithm(layoutOptions), Doc.renderStream)

// If rendered using `Layout.pretty`, with a page width of `26` characters per line,
// all the calls to `fun` will fit into the first line. However, this exceeds the
// desired `26` character page width.
assert.strictEqual(
  render(doc)(Layout.pretty),
  String.stripMargin(
    `||------------------------|
     |fun(fun(fun(fun(fun(
     |                  [ abcdef
     |                  , ghijklm ])))))
     ||------------------------|`
  )
)

// The same document, rendered with `Layout.smart`, fits the layout contstraints:
assert.strictEqual(
  render(doc)(Layout.smart),
  String.stripMargin(
    `||------------------------|
     |fun(
     |  fun(
     |    fun(
     |      fun(
     |        fun(
     |          [ abcdef
     |          , ghijklm ])))))
     ||------------------------|`
  )
)

// The key difference between `Layout.pretty` and `Layout.smart` is that the
// latter will check the potential document until it encounters a line with the
// same indentation or less than the start of the document. Any line encountered
// earlier is assumed to belong to the same syntactic structure. In contrast,
// `Layout.pretty` checks only the first line.

// Consider for example the question of whether the `A`s fit into the document
// below:
// > 1 A
// > 2   A
// > 3  A
// > 4 B
// > 5   B

// `pretty` will check only the first line, ignoring whether the second line
// may already be too wide. In contrast, `Layout.smart` stops only once it reaches
// the fourth line 4, where the `B` has the same indentation as the first `A`.
```

**Signature**

```ts
declare const smart: { (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>; <A>(self: Doc<A>, options: Layout.Options): DocStream<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Layout.ts#L255)

Since v1.0.0
Layout-unbounded.md
Package: `@effect/printer`<br />
Module: `Layout`<br />

## Layout.unbounded

The `unbounded` layout algorithm will lay out a document an `Unbounded`
page width.

**Signature**

```ts
declare const unbounded: <A>(self: Doc<A>) => DocStream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Layout.ts#L267)

Since v1.0.0
List-append.md
Package: `effect`<br />
Module: `List`<br />

## List.append

Appends the specified element to the end of the `List`, creating a new `Cons`.

**Signature**

```ts
declare const append: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L318)

Since v2.0.0
List-appendAll.md
Package: `effect`<br />
Module: `List`<br />

## List.appendAll

Concatenates two lists, combining their elements.
If either list is non-empty, the result is also a non-empty list.

**Example**

```ts
import * as assert from "node:assert"
import { List } from "effect"

assert.deepStrictEqual(
  List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),
  [1, 2, "a", "b"]
)
```

**Signature**

```ts
declare const appendAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L341)

Since v2.0.0
List-compact.md
Package: `effect`<br />
Module: `List`<br />

## List.compact

Removes all `None` values from the specified list.

**Signature**

```ts
declare const compact: <A>(self: List<Option.Option<A>>) => List<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L617)

Since v2.0.0
List-cons.md
Package: `effect`<br />
Module: `List`<br />

## List.cons

Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.

**Signature**

```ts
declare const cons: <A>(head: A, tail: List<A>) => Cons<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L259)

Since v2.0.0
List-drop.md
Package: `effect`<br />
Module: `List`<br />

## List.drop

Drops the first `n` elements from the specified list.

**Signature**

```ts
declare const drop: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L427)

Since v2.0.0
List-List.md
Package: `effect`<br />
Module: `List`<br />

## List.List

Represents an immutable linked list of elements of type `A`.

A `List` is optimal for last-in-first-out (LIFO), stack-like access patterns.
If you need another access pattern, for example, random access or FIFO,
consider using a collection more suited for that other than `List`.

**Signature**

```ts
type List<A> = Cons<A> | Nil<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L49)

Since v2.0.0
List-empty.md
Package: `effect`<br />
Module: `List`<br />

## List.empty

Constructs a new empty `List<A>`.

Alias of `nil`.

**Signature**

```ts
declare const empty: <A = never>() => List<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L269)

Since v2.0.0
List-every.md
Package: `effect`<br />
Module: `List`<br />

## List.every

Check if a predicate holds true for every `List` element.

**Signature**

```ts
declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>; <A>(predicate: Predicate<A>): (self: List<A>) => boolean; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>; <A>(self: List<A>, predicate: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L452)

Since v2.0.0
List-filter.md
Package: `effect`<br />
Module: `List`<br />

## List.filter

Filters a list using the specified predicate.

**Signature**

```ts
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>; <A>(self: List<A>, predicate: Predicate<A>): List<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L492)

Since v2.0.0
List-filterMap.md
Package: `effect`<br />
Module: `List`<br />

## List.filterMap

Filters and maps a list using the specified partial function. The resulting
list may be smaller than the input list due to the possibility of the partial
function not being defined for some elements.

**Signature**

```ts
declare const filterMap: { <A, B>(f: (a: A) => Option.Option<B>): (self: List<A>) => List<B>; <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L597)

Since v2.0.0
List-findFirst.md
Package: `effect`<br />
Module: `List`<br />

## List.findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

**Signature**

```ts
declare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option.Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option.Option<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option.Option<B>; <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L626)

Since v2.0.0
List-flatMap.md
Package: `effect`<br />
Module: `List`<br />

## List.flatMap

Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.

**Signature**

```ts
declare const flatMap: { <S extends List<any>, T extends List<any>>(f: (a: List.Infer<S>, i: number) => T): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>; <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>; <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L648)

Since v2.0.0
List-forEach.md
Package: `effect`<br />
Module: `List`<br />

## List.forEach

Applies the specified function to each element of the `List`.

**Signature**

```ts
declare const forEach: { <A, B>(f: (a: A) => B): (self: List<A>) => void; <A, B>(self: List<A>, f: (a: A) => B): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L684)

Since v2.0.0
List-fromIterable.md
Package: `effect`<br />
Module: `List`<br />

## List.fromIterable

Creates a new `List` from an iterable collection of values.

**Signature**

```ts
declare const fromIterable: <A>(prefix: Iterable<A>) => List<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L285)

Since v2.0.0
List-head.md
Package: `effect`<br />
Module: `List`<br />

## List.head

Returns the first element of the specified list, or `None` if the list is
empty.

**Signature**

```ts
declare const head: <A>(self: List<A>) => Option.Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L702)

Since v2.0.0
List-isCons.md
Package: `effect`<br />
Module: `List`<br />

## List.isCons

Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.

**Signature**

```ts
declare const isCons: <A>(self: List<A>) => self is Cons<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L227)

Since v2.0.0
List-isList.md
Package: `effect`<br />
Module: `List`<br />

## List.isList

Returns `true` if the specified value is a `List`, `false` otherwise.

**Signature**

```ts
declare const isList: { <A>(u: Iterable<A>): u is List<A>; (u: unknown): u is List<unknown>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L208)

Since v2.0.0
List-isNil.md
Package: `effect`<br />
Module: `List`<br />

## List.isNil

Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.

**Signature**

```ts
declare const isNil: <A>(self: List<A>) => self is Nil<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L219)

Since v2.0.0
List-last.md
Package: `effect`<br />
Module: `List`<br />

## List.last

Returns the last element of the specified list, or `None` if the list is
empty.

**Signature**

```ts
declare const last: <A>(self: List<A>) => Option.Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L711)

Since v2.0.0
List-make.md
Package: `effect`<br />
Module: `List`<br />

## List.make

Constructs a new `List<A>` from the specified values.

**Signature**

```ts
declare const make: <Elements extends readonly [any, ...Array<any>]>(...elements: Elements) => Cons<Elements[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L308)

Since v2.0.0
List-map.md
Package: `effect`<br />
Module: `List`<br />

## List.map

Applies the specified mapping function to each element of the list.

**Signature**

```ts
declare const map: { <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>; <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L749)

Since v2.0.0
List-nil.md
Package: `effect`<br />
Module: `List`<br />

## List.nil

Constructs a new empty `List<A>`.

**Signature**

```ts
declare const nil: <A = never>() => List<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L251)

Since v2.0.0
List-of.md
Package: `effect`<br />
Module: `List`<br />

## List.of

Constructs a new `List<A>` from the specified value.

**Signature**

```ts
declare const of: <A>(value: A) => Cons<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L277)

Since v2.0.0
List-partition.md
Package: `effect`<br />
Module: `List`<br />

## List.partition

Partition a list into two lists, where the first list contains all elements
that did not satisfy the specified predicate, and the second list contains
all elements that did satisfy the specified predicate.

**Signature**

```ts
declare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>]; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L778)

Since v2.0.0
List-partitionMap.md
Package: `effect`<br />
Module: `List`<br />

## List.partitionMap

Partition a list into two lists, where the first list contains all elements
for which the specified function returned a `Left`, and the second list
contains all elements for which the specified function returned a `Right`.

**Signature**

```ts
declare const partitionMap: { <A, B, C>(f: (a: A) => Either.Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]; <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L806)

Since v2.0.0
List-prepend.md
Package: `effect`<br />
Module: `List`<br />

## List.prepend

Prepends the specified element to the beginning of the list.

**Signature**

```ts
declare const prepend: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L354)

Since v2.0.0
List-prependAll.md
Package: `effect`<br />
Module: `List`<br />

## List.prependAll

Prepends the specified prefix list to the beginning of the specified list.
If either list is non-empty, the result is also a non-empty list.

**Example**

```ts
import * as assert from "node:assert"
import { List } from "effect"

assert.deepStrictEqual(
  List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),
  ["a", "b", 1, 2]
)
```

**Signature**

```ts
declare const prependAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L377)

Since v2.0.0
List-prependAllReversed.md
Package: `effect`<br />
Module: `List`<br />

## List.prependAllReversed

Prepends the specified prefix list (in reverse order) to the beginning of the
specified list.

**Signature**

```ts
declare const prependAllReversed: { <B>(prefix: List<B>): <A>(self: List<A>) => List<A | B>; <A, B>(self: List<A>, prefix: List<B>): List<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L408)

Since v2.0.0
List-reduce.md
Package: `effect`<br />
Module: `List`<br />

## List.reduce

Folds over the elements of the list using the specified function, using the
specified initial value.

**Signature**

```ts
declare const reduce: { <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z; <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L830)

Since v2.0.0
List-reduceRight.md
Package: `effect`<br />
Module: `List`<br />

## List.reduceRight

Folds over the elements of the list using the specified function, beginning
with the last element of the list, using the specified initial value.

**Signature**

```ts
declare const reduceRight: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z; <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L850)

Since v2.0.0
List-reverse.md
Package: `effect`<br />
Module: `List`<br />

## List.reverse

Returns a new list with the elements of the specified list in reverse order.

**Signature**

```ts
declare const reverse: <A>(self: List<A>) => List<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L869)

Since v2.0.0
List-size.md
Package: `effect`<br />
Module: `List`<br />

## List.size

Returns the number of elements contained in the specified `List`

**Signature**

```ts
declare const size: <A>(self: List<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L235)

Since v2.0.0
List-some.md
Package: `effect`<br />
Module: `List`<br />

## List.some

Check if a predicate holds true for some `List` element.

**Signature**

```ts
declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>; <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L472)

Since v2.0.0
List-splitAt.md
Package: `effect`<br />
Module: `List`<br />

## List.splitAt

Splits the specified list into two lists at the specified index.

**Signature**

```ts
declare const splitAt: { (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]; <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L885)

Since v2.0.0
List-tail.md
Package: `effect`<br />
Module: `List`<br />

## List.tail

Returns the tail of the specified list, or `None` if the list is empty.

**Signature**

```ts
declare const tail: <A>(self: List<A>) => Option.Option<List<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L896)

Since v2.0.0
List-take.md
Package: `effect`<br />
Module: `List`<br />

## List.take

Takes the specified number of elements from the beginning of the specified
list.

**Signature**

```ts
declare const take: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L905)

Since v2.0.0
List-toArray.md
Package: `effect`<br />
Module: `List`<br />

## List.toArray

Converts the specified `List` to an `Array`.

**Signature**

```ts
declare const toArray: <A>(self: List<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L89)

Since v2.0.0
List-toChunk.md
Package: `effect`<br />
Module: `List`<br />

## List.toChunk

Converts the specified `List` to a `Chunk`.

**Signature**

```ts
declare const toChunk: <A>(self: List<A>) => Chunk.Chunk<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L930)

Since v2.0.0
List-unsafeHead.md
Package: `effect`<br />
Module: `List`<br />

## List.unsafeHead

Unsafely returns the first element of the specified `List`.

**Signature**

```ts
declare const unsafeHead: <A>(self: List<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L940)

Since v2.0.0
List-unsafeLast.md
Package: `effect`<br />
Module: `List`<br />

## List.unsafeLast

Unsafely returns the last element of the specified `List`.

**Signature**

```ts
declare const unsafeLast: <A>(self: List<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L953)

Since v2.0.0
List-unsafeTail.md
Package: `effect`<br />
Module: `List`<br />

## List.unsafeTail

Unsafely returns the tail of the specified `List`.

**Signature**

```ts
declare const unsafeTail: <A>(self: List<A>) => List<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L972)

Since v2.0.0
Logger-batched.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.batched

Creates a batched logger that groups log messages together and processes them
in intervals.

**Example**

```ts
import { Console, Effect, Logger } from "effect"

const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  Logger.logfmtLogger.pipe(
    Logger.batched("500 millis", (messages) => Console.log("BATCH", `[\n${messages.join("\n")}\n]`))
  )
)

const program = Effect.gen(function*() {
  yield* Effect.log("one")
  yield* Effect.log("two")
  yield* Effect.log("three")
}).pipe(Effect.provide(LoggerLive))

Effect.runFork(program)
// BATCH [
// timestamp=... level=INFO fiber=#0 message=one
// timestamp=... level=INFO fiber=#0 message=two
// timestamp=... level=INFO fiber=#0 message=three
// ]
```

**Signature**

```ts
declare const batched: { <Output, R>(window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>; <Message, Output, R>(self: Logger<Message, Output>, window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): Effect<Logger<Message, void>, never, Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L225)

Since v2.0.0
Logger-filterLogLevel.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.filterLogLevel

Returns a version of this logger that only logs messages when the log level
satisfies the specified predicate.

**Signature**

```ts
declare const filterLogLevel: { (f: (logLevel: LogLevel.LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>; <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel.LogLevel) => boolean): Logger<Message, Option.Option<Output>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L169)

Since v2.0.0
Logger-isLogger.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.isLogger

Returns `true` if the specified value is a `Logger`, otherwise returns `false`.

**Signature**

```ts
declare const isLogger: (u: unknown) => u is Logger<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L702)

Since v1.0.0
Logger-json.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.json

The `json` logger formats log entries as JSON objects, making them easy to
integrate with logging systems that consume JSON data.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.json)))
// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}
```

**Signature**

```ts
declare const json: Layer.Layer<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L588)

Since v2.0.0
Logger-jsonLogger.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.jsonLogger

The `jsonLogger` logger formats log entries as JSON objects, making them easy to
integrate with logging systems that consume JSON data.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.json)))
// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}
```

**Signature**

```ts
declare const jsonLogger: Logger<unknown, string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L446)

Since v2.0.0
Logger-logFmt.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.logFmt

This logger outputs logs in a human-readable format that is easy to read
during development or in a production console.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1
```

**Signature**

```ts
declare const logFmt: Layer.Layer<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L610)

Since v2.0.0
Logger-logfmtLogger.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.logfmtLogger

This logger outputs logs in a human-readable format that is easy to read
during development or in a production console.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1
```

**Signature**

```ts
declare const logfmtLogger: Logger<unknown, string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L468)

Since v2.0.0
Logger-make.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.make

Creates a custom logger that formats log messages according to the provided
function.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const logger = Logger.make(({ logLevel, message }) => {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})

const task1 = Effect.logDebug("task1 done")
const task2 = Effect.logDebug("task2 done")

const program = Effect.gen(function*() {
  yield* Effect.log("start")
  yield* task1
  yield* task2
  yield* Effect.log("done")
}).pipe(
  Logger.withMinimumLogLevel(LogLevel.Debug),
  Effect.provide(Logger.replace(Logger.defaultLogger, logger))
)

Effect.runFork(program)
// [INFO] start
// [DEBUG] task1 done
// [DEBUG] task2 done
// [INFO] done
```

**Signature**

```ts
declare const make: <Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L110)

Since v2.0.0
Logger-minimumLogLevel.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.minimumLogLevel

Sets the minimum log level for logging operations, allowing control over
which log messages are displayed based on their severity.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

// Logging disabled using a layer
Effect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))
// task done
```

**Signature**

```ts
declare const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L694)

Since v2.0.0
Logger-none.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.none

A logger that does nothing in response to logging events.

**Signature**

```ts
declare const none: Logger<unknown, void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L279)

Since v2.0.0
Logger-pretty.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.pretty

The pretty logger utilizes the capabilities of the console API to generate
visually engaging and color-enhanced log outputs. This feature is
particularly useful for improving the readability of log messages during
development and debugging processes.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
//         green --v                      v-- bold and cyan
// [07:51:54.434] INFO (#0) myspan=1ms: message1
//   message2
//    v-- bold
//   key2: value2
//   key1: value1
```

**Signature**

```ts
declare const pretty: Layer.Layer<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L639)

Since v3.5.0
Logger-prettyLogger.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.prettyLogger

The pretty logger utilizes the capabilities of the console API to generate
visually engaging and color-enhanced log outputs. This feature is
particularly useful for improving the readability of log messages during
development and debugging processes.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
//         green --v                      v-- bold and cyan
// [07:51:54.434] INFO (#0) myspan=1ms: message1
//   message2
//    v-- bold
//   key2: value2
//   key1: value1
```

**Signature**

```ts
declare const prettyLogger: (options?: { readonly colors?: "auto" | boolean | undefined; readonly stderr?: boolean | undefined; readonly formatDate?: ((date: Date) => string) | undefined; readonly mode?: "browser" | "tty" | "auto" | undefined; }) => Logger<unknown, void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L503)

Since v3.5.0
Logger-prettyLoggerDefault.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.prettyLoggerDefault

A default version of the pretty logger.

**Signature**

```ts
declare const prettyLoggerDefault: Logger<unknown, void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L518)

Since v3.8.0
Logger-structured.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.structured

The structured logger provides detailed log outputs, structured in a way that
retains comprehensive traceability of the events, suitable for deeper
analysis and troubleshooting.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }
```

**Signature**

```ts
declare const structured: Layer.Layer<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L670)

Since v2.0.0
LogLevel-LogLevel.md
Package: `effect`<br />
Module: `LogLevel`<br />

## LogLevel.LogLevel

A `LogLevel` represents the log level associated with an individual logging
operation. Log levels are used both to describe the granularity (or
importance) of individual log statements, as well as to enable tuning
verbosity of log output.

**Signature**

```ts
type LogLevel = All | Fatal | Error | Warning | Info | Debug | Trace | None
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L23)

Since v2.0.0
LogLevel-locally.md
Package: `effect`<br />
Module: `LogLevel`<br />

## LogLevel.locally

Temporarily sets a `LogLevel` for an `Effect` workflow.

**Details**

This function allows you to apply a specific `LogLevel` locally to an
`Effect` workflow. Once the workflow completes, the `LogLevel` reverts to its
previous state.

**When to Use**

This is particularly useful when you want to adjust the verbosity of logging
for specific parts of your program without affecting the global log level.

**Example**

```ts
import { Effect, LogLevel } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("message1")
  yield* Effect.gen(function*() {
    yield* Effect.log("message2")
    yield* Effect.log("message3")
  }).pipe(LogLevel.locally(LogLevel.Warning))
})

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message=message1
// timestamp=... level=WARN fiber=#0 message=message2
// timestamp=... level=WARN fiber=#0 message=message3
```

**Signature**

```ts
declare const locally: { (self: LogLevel): <A, E, R>(use: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L208)

Since v2.0.0
Logger-structuredLogger.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.structuredLogger

The structured logger provides detailed log outputs, structured in a way that
retains comprehensive traceability of the events, suitable for deeper
analysis and troubleshooting.

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }
```

**Signature**

```ts
declare const structuredLogger: Logger<unknown, { readonly logLevel: string; readonly fiberId: string; readonly timestamp: string; readonly message: unknown; readonly cause: string | undefined; readonly annotations: Record<string, unknown>; readonly spans: Record<string, number>; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L549)

Since v2.0.0
Logger-withLeveledConsole.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.withLeveledConsole

Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method
based on the log level.

**Example**

```ts
import { Logger, Effect } from "effect"

const loggerLayer = Logger.replace(
  Logger.defaultLogger,
  Logger.withLeveledConsole(Logger.stringLogger),
)

Effect.gen(function* () {
  yield* Effect.logError("an error")
  yield* Effect.logInfo("an info")
}).pipe(Effect.provide(loggerLayer))
```

**Signature**

```ts
declare const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L265)

Since v3.8.0
Logger-withMinimumLogLevel.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.withMinimumLogLevel

Sets the minimum log level for subsequent logging operations, allowing
control over which log messages are displayed based on their severity.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message1
```

**Signature**

```ts
declare const withMinimumLogLevel: { (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L363)

Since v2.0.0
Logger-zip.md
Package: `effect`<br />
Module: `Logger`<br />

## Logger.zip

Combines this logger with the specified logger to produce a new logger that
logs to both this logger and that logger.

**Signature**

```ts
declare const zip: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L382)

Since v2.0.0
Machine-procedures.md
Package: `@effect/experimental`<br />
Module: `Machine`<br />

## Machine.procedures

Re-exports all named exports from the "./Machine/ProcedureList.js" module as `procedures`.

**Signature**

```ts
export * as procedures from "./Machine/ProcedureList.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/Machine.ts#L38)

Since v1.0.0
Machine-serializable.md
Package: `@effect/experimental`<br />
Module: `Machine`<br />

## Machine.serializable

Re-exports all named exports from the "./Machine/SerializableProcedureList.js" module as `serializable`.

**Signature**

```ts
export * as serializable from "./Machine/SerializableProcedureList.js"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/Machine.ts#L44)

Since v1.0.0
Mailbox-Mailbox.md
Package: `effect`<br />
Module: `Mailbox`<br />

## Mailbox.Mailbox

A `Mailbox` is a queue that can be signaled to be done or failed.

**Signature**

```ts
export interface Mailbox<in out A, in out E = never> extends ReadonlyMailbox<A, E> {
  readonly [TypeId]: TypeId
  /**
   * Add a message to the mailbox. Returns `false` if the mailbox is done.
   */
  readonly offer: (message: A) => Effect<boolean>
  /**
   * Add a message to the mailbox. Returns `false` if the mailbox is done.
   */
  readonly unsafeOffer: (message: A) => boolean
  /**
   * Add multiple messages to the mailbox. Returns the remaining messages that
   * were not added.
   */
  readonly offerAll: (messages: Iterable<A>) => Effect<Chunk<A>>
  /**
   * Add multiple messages to the mailbox. Returns the remaining messages that
   * were not added.
   */
  readonly unsafeOfferAll: (messages: Iterable<A>) => Chunk<A>
  /**
   * Fail the mailbox with an error. If the mailbox is already done, `false` is
   * returned.
   */
  readonly fail: (error: E) => Effect<boolean>
  /**
   * Fail the mailbox with a cause. If the mailbox is already done, `false` is
   * returned.
   */
  readonly failCause: (cause: Cause<E>) => Effect<boolean>
  /**
   * Signal that the mailbox is complete. If the mailbox is already done, `false` is
   * returned.
   */
  readonly end: Effect<boolean>
  /**
   * Signal that the mailbox is done. If the mailbox is already done, `false` is
   * returned.
   */
  readonly done: (exit: Exit<void, E>) => Effect<boolean>
  /**
   * Signal that the mailbox is done. If the mailbox is already done, `false` is
   * returned.
   */
  readonly unsafeDone: (exit: Exit<void, E>) => boolean
  /**
   * Shutdown the mailbox, canceling any pending operations.
   * If the mailbox is already done, `false` is returned.
   */
  readonly shutdown: Effect<boolean>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L67)

Since v3.8.0
Mailbox-ReadonlyMailbox.md
Package: `effect`<br />
Module: `Mailbox`<br />

## Mailbox.ReadonlyMailbox

A `ReadonlyMailbox` represents a mailbox that can only be read from.

**Signature**

```ts
export interface ReadonlyMailbox<out A, out E = never>
  extends Effect<readonly [messages: Chunk<A>, done: boolean], E>, Inspectable
{
  readonly [ReadonlyTypeId]: ReadonlyTypeId
  /**
   * Take all messages from the mailbox, returning an empty Chunk if the mailbox
   * is empty or done.
   */
  readonly clear: Effect<Chunk<A>, E>
  /**
   * Take all messages from the mailbox, or wait for messages to be available.
   *
   * If the mailbox is done, the `done` flag will be `true`. If the mailbox
   * fails, the Effect will fail with the error.
   */
  readonly takeAll: Effect<readonly [messages: Chunk<A>, done: boolean], E>
  /**
   * Take a specified number of messages from the mailbox. It will only take
   * up to the capacity of the mailbox.
   *
   * If the mailbox is done, the `done` flag will be `true`. If the mailbox
   * fails, the Effect will fail with the error.
   */
  readonly takeN: (n: number) => Effect<readonly [messages: Chunk<A>, done: boolean], E>
  /**
   * Take a single message from the mailbox, or wait for a message to be
   * available.
   *
   * If the mailbox is done, it will fail with `NoSuchElementException`. If the
   * mailbox fails, the Effect will fail with the error.
   */
  readonly take: Effect<A, E | NoSuchElementException>
  /** Wait for the mailbox to be done. */
  readonly await: Effect<void, E>
  /**
   * Check the size of the mailbox.
   *
   * If the mailbox is complete, it will return `None`.
   */
  readonly size: Effect<Option<number>>
  /**
   * Check the size of the mailbox.
   *
   * If the mailbox is complete, it will return `None`.
   */
  readonly unsafeSize: () => Option<number>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L126)

Since v3.8.0
Mailbox-fromStream.md
Package: `effect`<br />
Module: `Mailbox`<br />

## Mailbox.fromStream

Create a `ReadonlyMailbox` from a `Stream`.

**Signature**

```ts
declare const fromStream: { (options?: { readonly capacity?: number | undefined; readonly strategy?: "suspend" | "dropping" | "sliding" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect<ReadonlyMailbox<A, E>, never, R | Scope>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; readonly strategy?: "suspend" | "dropping" | "sliding" | undefined; }): Effect<ReadonlyMailbox<A, E>, never, R | Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L254)

Since v3.11.0
Mailbox-into.md
Package: `effect`<br />
Module: `Mailbox`<br />

## Mailbox.into

Run an `Effect` into a `Mailbox`, where success ends the mailbox and failure
fails the mailbox.

**Signature**

```ts
declare const into: { <A, E>(self: Mailbox<A, E>): <AX, EX extends E, RX>(effect: Effect<AX, EX, RX>) => Effect<boolean, never, RX>; <AX, E, EX extends E, RX, A>(effect: Effect<AX, EX, RX>, self: Mailbox<A, E>): Effect<boolean, never, RX>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L224)

Since v3.8.0
Mailbox-make.md
Package: `effect`<br />
Module: `Mailbox`<br />

## Mailbox.make

A `Mailbox` is a queue that can be signaled to be done or failed.

**Example**

```ts
import * as assert from "node:assert"
import { Effect, Mailbox } from "effect"

Effect.gen(function*() {
  const mailbox = yield* Mailbox.make<number, string>()

  // add messages to the mailbox
  yield* mailbox.offer(1)
  yield* mailbox.offer(2)
  yield* mailbox.offerAll([3, 4, 5])

  // take messages from the mailbox
  const [messages, done] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages, [1, 2, 3, 4, 5])
  assert.strictEqual(done, false)

  // signal that the mailbox is done
  yield* mailbox.end
  const [messages2, done2] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages2, [])
  assert.strictEqual(done2, true)

  // signal that the mailbox has failed
  yield* mailbox.fail("boom")
})
```

**Signature**

```ts
declare const make: <A, E = never>(capacity?: number | { readonly capacity?: number; readonly strategy?: "suspend" | "dropping" | "sliding"; } | undefined) => Effect<Mailbox<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L209)

Since v3.8.0
Mailbox-toChannel.md
Package: `effect`<br />
Module: `Mailbox`<br />

## Mailbox.toChannel

Create a `Channel` from a `Mailbox`.

**Signature**

```ts
declare const toChannel: <A, E>(self: ReadonlyMailbox<A, E>) => Channel<Chunk<A>, unknown, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L236)

Since v3.8.0
Mailbox-toStream.md
Package: `effect`<br />
Module: `Mailbox`<br />

## Mailbox.toStream

Create a `Stream` from a `Mailbox`.

**Signature**

```ts
declare const toStream: <A, E>(self: ReadonlyMailbox<A, E>) => Stream<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L245)

Since v3.8.0
ManagedRuntime-isManagedRuntime.md
Package: `effect`<br />
Module: `ManagedRuntime`<br />

## ManagedRuntime.isManagedRuntime

Checks if the provided argument is a `ManagedRuntime`.

**Signature**

```ts
declare const isManagedRuntime: (input: unknown) => input is ManagedRuntime<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L31)

Since v3.9.0
ManagedRuntime-make.md
Package: `effect`<br />
Module: `ManagedRuntime`<br />

## ManagedRuntime.make

Convert a Layer into an ManagedRuntime, that can be used to run Effect's using
your services.

**Example**

```ts
import { Console, Effect, Layer, ManagedRuntime } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {
  static Live = Layer.succeed(this, { notify: (message) => Console.log(message) })
}

async function main() {
  const runtime = ManagedRuntime.make(Notifications.Live)
  await runtime.runPromise(Notifications.notify("Hello, world!"))
  await runtime.dispose()
}

main()
```

**Signature**

```ts
declare const make: <R, E>(layer: Layer.Layer<R, E, never>, memoMap?: Layer.MemoMap | undefined) => ManagedRuntime<R, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L177)

Since v2.0.0
Match-Matcher.md
Package: `effect`<br />
Module: `Match`<br />

## Match.Matcher

Pattern matching follows a structured process:

- **Creating a matcher**: Define a `Matcher` that operates on either a
  specific `Match.type` or `Match.value`.

- **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,
  and `Match.tag` to specify matching conditions.

- **Completing the match**: Apply a finalizer such as `Match.exhaustive`,
  `Match.orElse`, or `Match.option` to determine how unmatched cases should
  be handled.

**Example**

```ts
import { Match } from "effect"

// Simulated dynamic input that can be a string or a number
const input: string | number = "some input"

//       string
//      
const result = Match.value(input).pipe(
  // Match if the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Match if the value is a string
  Match.when(Match.string, (s) => `string: ${s}`),
  // Ensure all possible cases are covered
  Match.exhaustive
)

console.log(result)
// Output: "string: some input"
```

**Signature**

```ts
type Matcher<Input, Filters, RemainingApplied, Result, Provided, Return> = | TypeMatcher<Input, Filters, RemainingApplied, Result, Return>
  | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided, Return>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L87)

Since v1.0.0
Match-any.md
Package: `effect`<br />
Module: `Match`<br />

## Match.any

Matches any value without restrictions.

**Signature**

```ts
declare const any: SafeRefinement<unknown, any>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L983)

Since v1.0.0
Match-bigint.md
Package: `effect`<br />
Module: `Match`<br />

## Match.bigint

Matches values of type `bigint`.

**Signature**

```ts
declare const bigint: Predicate.Refinement<unknown, bigint>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1029)

Since v1.0.0
Match-boolean.md
Package: `effect`<br />
Module: `Match`<br />

## Match.boolean

Matches values of type `boolean`.

**Signature**

```ts
declare const boolean: Predicate.Refinement<unknown, boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L999)

Since v1.0.0
Match-date.md
Package: `effect`<br />
Module: `Match`<br />

## Match.date

Matches values that are instances of `Date`.

**Signature**

```ts
declare const date: Predicate.Refinement<unknown, Date>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1045)

Since v1.0.0
Match-defined.md
Package: `effect`<br />
Module: `Match`<br />

## Match.defined

Matches any defined (non-null and non-undefined) value.

**Signature**

```ts
declare const defined: <A>(u: A) => u is A & {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L991)

Since v1.0.0
Match-discriminator.md
Package: `effect`<br />
Module: `Match`<br />

## Match.discriminator

Matches values based on a specified discriminant field.

**Details**

This function is used to define pattern matching on objects that follow a
**discriminated union** structure, where a specific field (e.g., `type`,
`kind`, `_tag`) determines the variant of the object. It allows matching
multiple values of the discriminant and provides a function to handle the
matched cases.

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminator("type")("A", "B", (_) => `A or B: ${_.type}`),
  Match.discriminator("type")("C", (_) => `C(${_.c})`),
  Match.exhaustive
)
```

**Signature**

```ts
declare const discriminator: <D extends string>(field: D) => <R, P extends Types.Tags<D, R> & string, Ret, Fn extends (_: Extract<R, Record<D, P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>, A | ReturnType<Fn>, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L527)

Since v1.0.0
Match-discriminatorStartsWith.md
Package: `effect`<br />
Module: `Match`<br />

## Match.discriminatorStartsWith

Matches values where a specified field starts with a given prefix.

**Details**

This function is useful for working with discriminated unions where the
discriminant field follows a hierarchical or namespaced structure. It allows
you to match values based on whether the specified field starts with a given
prefix, making it easier to handle grouped cases.

Instead of checking for exact matches, this function lets you match values
that share a common prefix. For example, if your discriminant field contains
hierarchical names like `"A"`, `"A.A"`, and `"B"`, you can match all values
starting with `"A"` using a single rule.

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A" } | { type: "B" } | { type: "A.A" } | {}>(),
  Match.discriminatorStartsWith("type")("A", (_) => 1 as const),
  Match.discriminatorStartsWith("type")("B", (_) => 2 as const),
  Match.orElse((_) => 3 as const)
)

console.log(match({ type: "A" })) // 1
console.log(match({ type: "B" })) // 2
console.log(match({ type: "A.A" })) // 1
```

**Signature**

```ts
declare const discriminatorStartsWith: <D extends string>(field: D) => <R, P extends string, Ret, Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>, A | ReturnType<Fn>, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L576)

Since v1.0.0
Match-discriminators.md
Package: `effect`<br />
Module: `Match`<br />

## Match.discriminators

Matches values based on a field that serves as a discriminator, mapping each
possible value to a corresponding handler.

**Details**

This function simplifies working with discriminated unions by letting you
define a set of handlers for each possible value of a given field. Instead of
chaining multiple calls to `discriminator`, this function allows
defining all possible cases at once using an object where the keys are the
possible values of the field, and the values are the corresponding handler
functions.

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminators("type")({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  }),
  Match.exhaustive
)
```

**Signature**

```ts
declare const discriminators: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L623)

Since v1.0.0
Match-discriminatorsExhaustive.md
Package: `effect`<br />
Module: `Match`<br />

## Match.discriminatorsExhaustive

Matches values based on a discriminator field and **ensures all cases are
handled**.

**Details*+

This function is similar to `discriminators`, but **requires that all
possible cases** are explicitly handled. It is useful when working with
discriminated unions, where a specific field (e.g., `"type"`) determines the
shape of an object. Each possible value of the field must have a
corresponding handler, ensuring **exhaustiveness checking** at compile time.

This function **does not require** `Match.exhaustive` at the end of the
pipeline because it enforces exhaustiveness by design.

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminatorsExhaustive("type")({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  })
)
```

**Signature**

```ts
declare const discriminatorsExhaustive: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L676)

Since v1.0.0
Match-either.md
Package: `effect`<br />
Module: `Match`<br />

## Match.either

Wraps the match result in an `Either`, distinguishing matched and unmatched
cases.

**Details**

This function ensures that the result of a matcher is always wrapped in an
`Either`, allowing clear differentiation between successful matches
(`Right(value)`) and cases where no pattern matched (`Left(unmatched
value)`).

This approach is particularly useful when handling optional values or when an
unmatched case should be explicitly handled rather than returning a default
value or throwing an error.

**Example** (Extracting a User Role with `Match.either`)

```ts
import { Match } from "effect"

type User = { readonly role: "admin" | "editor" | "viewer" }

// Create a matcher to extract user roles
const getRole = Match.type<User>().pipe(
  Match.when({ role: "admin" }, () => "Has full access"),
  Match.when({ role: "editor" }, () => "Can edit content"),
  Match.either // Wrap the result in an Either
)

console.log(getRole({ role: "admin" }))
// Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }

console.log(getRole({ role: "viewer" }))
// Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }
```

**Signature**

```ts
declare const either: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1172)

Since v1.0.0
Match-exhaustive.md
Package: `effect`<br />
Module: `Match`<br />

## Match.exhaustive

The `Match.exhaustive` method finalizes the pattern matching process by
ensuring that all possible cases are accounted for. If any case is missing,
TypeScript will produce a type error. This is particularly useful when
working with unions, as it helps prevent unintended gaps in pattern matching.

**Example** (Ensuring All Cases Are Covered)

```ts
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Mark the match as exhaustive, ensuring all cases are handled
  // TypeScript will throw an error if any case is missing
  // @ts-expect-error Type 'string' is not assignable to type 'never'
  Match.exhaustive
)
```

**Signature**

```ts
declare const exhaustive: <I, F, A, Pr, Ret>(self: Matcher<I, F, never, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1242)

Since v1.0.0
Match-instanceOf.md
Package: `effect`<br />
Module: `Match`<br />

## Match.instanceOf

Matches instances of a given class.

**Signature**

```ts
declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A) => SafeRefinement<InstanceType<A>, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1061)

Since v1.0.0
Match-is.md
Package: `effect`<br />
Module: `Match`<br />

## Match.is

Matches a specific set of literal values (e.g., `Match.is("a", 42, true)`).

**Signature**

```ts
declare const is: <Literals extends ReadonlyArray<string | number | bigint | boolean | null>>(...literals: Literals) => SafeRefinement<Literals[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L957)

Since v1.0.0
Match-nonEmptyString.md
Package: `effect`<br />
Module: `Match`<br />

## Match.nonEmptyString

Matches non-empty strings.

**Signature**

```ts
declare const nonEmptyString: SafeRefinement<string, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L949)

Since v1.0.0
Match-not.md
Package: `effect`<br />
Module: `Match`<br />

## Match.not

Excludes a specific value from matching while allowing all others.

**Details**

This function is useful when you need to **handle all values except one or
more specific cases**. Instead of listing all possible matches manually, this
function simplifies the logic by allowing you to specify values to exclude.
Any excluded value will bypass the provided function and continue matching
through other cases.

**Example** (Ignoring a Specific Value)

```ts
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match any value except "hi", returning "ok"
  Match.not("hi", () => "ok"),
  // Fallback case for when the value is "hi"
  Match.orElse(() => "fallback")
)

console.log(match("hello"))
// Output: "ok"

console.log(match("hi"))
// Output: "fallback"
```

**Signature**

```ts
declare const not: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Types.NotMatch<R, P>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddOnly<F, Types.WhenMatch<R, P>>, Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>, A | ReturnType<Fn>, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L924)

Since v1.0.0
Match-null.md
Package: `effect`<br />
Module: `Match`<br />

## Match.null

Matches the value `null`.

**Signature**

```ts
declare const null: Predicate.Refinement<unknown, null>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1020)

Since v1.0.0
Match-number.md
Package: `effect`<br />
Module: `Match`<br />

## Match.number

Matches values of type `number`.

**Signature**

```ts
declare const number: Predicate.Refinement<unknown, number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L975)

Since v1.0.0
Match-option.md
Package: `effect`<br />
Module: `Match`<br />

## Match.option

Wraps the match result in an `Option`, representing an optional match.

**Details**

This function ensures that the result of a matcher is wrapped in an `Option`,
making it easy to handle cases where no pattern matches. If a match is found,
it returns `Some(value)`, otherwise, it returns `None`.

This is useful in cases where a missing match is expected and should be
handled explicitly rather than throwing an error or returning a default
value.

**Example** (Extracting a User Role with `Match.option`)

```ts
import { Match } from "effect"

type User = { readonly role: "admin" | "editor" | "viewer" }

// Create a matcher to extract user roles
const getRole = Match.type<User>().pipe(
  Match.when({ role: "admin" }, () => "Has full access"),
  Match.when({ role: "editor" }, () => "Can edit content"),
  Match.option // Wrap the result in an Option
)

console.log(getRole({ role: "admin" }))
// Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }

console.log(getRole({ role: "viewer" }))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const option: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1213)

Since v1.0.0
Match-orElse.md
Package: `effect`<br />
Module: `Match`<br />

## Match.orElse

Provides a fallback value when no patterns match.

**Details**

This function ensures that a matcher always returns a valid result, even if
no defined patterns match. It acts as a default case, similar to the
`default` clause in a `switch` statement or the final `else` in an `if-else`
chain.

**Example** (Providing a Default Value When No Patterns Match)

```ts
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match when the value is "a"
  Match.when("a", () => "ok"),
  // Fallback when no patterns match
  Match.orElse(() => "fallback")
)

console.log(match("a"))
// Output: "ok"

console.log(match("b"))
// Output: "fallback"
```

**Signature**

```ts
declare const orElse: <RA, Ret, F extends (_: RA) => Ret>(f: F) => <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1106)

Since v1.0.0
Match-orElseAbsurd.md
Package: `effect`<br />
Module: `Match`<br />

## Match.orElseAbsurd

Throws an error if no pattern matches.

**Details**

This function finalizes a matcher by ensuring that if no patterns match, an
error is thrown. It is useful when all cases should be covered, and any
unexpected input should trigger an error instead of returning a default
value.

When used, this function removes the need for an explicit fallback case and
ensures that an unmatched value is never silently ignored.

**Signature**

```ts
declare const orElseAbsurd: <I, R, RA, A, Pr, Ret>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1129)

Since v1.0.0
Match-record.md
Package: `effect`<br />
Module: `Match`<br />

## Match.record

Matches objects where keys are `string` or `symbol` and values are `unknown`.

**Signature**

```ts
declare const record: Predicate.Refinement<unknown, { [x: string]: unknown; [x: symbol]: unknown; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1053)

Since v1.0.0
Match-string.md
Package: `effect`<br />
Module: `Match`<br />

## Match.string

Matches values of type `string`.

**Signature**

```ts
declare const string: Predicate.Refinement<unknown, string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L967)

Since v1.0.0
Match-symbol.md
Package: `effect`<br />
Module: `Match`<br />

## Match.symbol

Matches values of type `symbol`.

**Signature**

```ts
declare const symbol: Predicate.Refinement<unknown, symbol>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1037)

Since v1.0.0
Match-tag.md
Package: `effect`<br />
Module: `Match`<br />

## Match.tag

The `Match.tag` function allows pattern matching based on the `_tag` field in
a [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).
You can specify multiple tags to match within a single pattern.

**Note**

The `Match.tag` function relies on the convention within the Effect ecosystem
of naming the tag field as `"_tag"`. Ensure that your discriminated unions
follow this naming convention for proper functionality.

**Example** (Matching a Discriminated Union by Tag)

```ts
import { Match } from "effect"

type Event =
  | { readonly _tag: "fetch" }
  | { readonly _tag: "success"; readonly data: string }
  | { readonly _tag: "error"; readonly error: Error }
  | { readonly _tag: "cancel" }

// Create a Matcher for Either<number, string>
const match = Match.type<Event>().pipe(
  // Match either "fetch" or "success"
  Match.tag("fetch", "success", () => `Ok!`),
  // Match "error" and extract the error message
  Match.tag("error", (event) => `Error: ${event.error.message}`),
  // Match "cancel"
  Match.tag("cancel", () => "Cancelled"),
  Match.exhaustive
)

console.log(match({ _tag: "success", data: "Hello" }))
// Output: "Ok!"

console.log(match({ _tag: "error", error: new Error("Oops!") }))
// Output: "Error: Oops!"
```

**Signature**

```ts
declare const tag: <R, P extends Types.Tags<"_tag", R> & string, Ret, Fn extends (_: Extract<R, Record<"_tag", P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<"_tag", P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", P>>>>, ReturnType<Fn> | A, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L734)

Since v1.0.0
Match-tagStartsWith.md
Package: `effect`<br />
Module: `Match`<br />

## Match.tagStartsWith

Matches values where the `_tag` field starts with a given prefix.

**Details**

This function allows you to match on values in a **discriminated union**
based on whether the `_tag` field starts with a specified prefix. It is
useful for handling hierarchical or namespaced tags, where multiple related
cases share a common prefix.

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A" } | { _tag: "B" } | { _tag: "A.A" } | {}>(),
  Match.tagStartsWith("A", (_) => 1 as const),
  Match.tagStartsWith("B", (_) => 2 as const),
  Match.orElse((_) => 3 as const)
)

console.log(match({ _tag: "A" })) // 1
console.log(match({ _tag: "B" })) // 2
console.log(match({ _tag: "A.A" })) // 1
```

**Signature**

```ts
declare const tagStartsWith: <R, P extends string, Ret, Fn extends (_: Extract<R, Record<"_tag", `${P}${string}`>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<"_tag", `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", `${P}${string}`>>>>, ReturnType<Fn> | A, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L781)

Since v1.0.0
Match-tags.md
Package: `effect`<br />
Module: `Match`<br />

## Match.tags

Matches values based on their `_tag` field, mapping each tag to a
corresponding handler.

**Details**

This function provides a way to handle discriminated unions by mapping `_tag`
values to specific functions. Each handler receives the matched value and
returns a transformed result. If all possible tags are handled, you can
enforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A"; a: string } | { _tag: "B"; b: number } | { _tag: "C"; c: boolean }>(),
  Match.tags({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  }),
  Match.exhaustive
)
```

**Signature**

```ts
declare const tags: <R, Ret, P extends { readonly [Tag in Types.Tags<"_tag", R> & string]?: ((_: Extract<R, Record<"_tag", Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<"_tag", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<"_tag", keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L829)

Since v1.0.0
Match-tagsExhaustive.md
Package: `effect`<br />
Module: `Match`<br />

## Match.tagsExhaustive

Matches values based on their `_tag` field and requires handling of all
possible cases.

**Details**

This function is designed for **discriminated unions** where every possible
`_tag` value must have a corresponding handler. Unlike `tags`, this
function ensures **exhaustiveness**, meaning all cases must be explicitly
handled. If a `_tag` value is missing from the mapping, TypeScript will
report an error.

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A"; a: string } | { _tag: "B"; b: number } | { _tag: "C"; c: boolean }>(),
  Match.tagsExhaustive({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  })
)
```

**Signature**

```ts
declare const tagsExhaustive: <R, Ret, P extends { readonly [Tag in Types.Tags<"_tag", R> & string]: (_: Extract<R, Record<"_tag", Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<"_tag", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L877)

Since v1.0.0
Match-type.md
Package: `effect`<br />
Module: `Match`<br />

## Match.type

Creates a matcher for a specific type.

**Details**

This function defines a `Matcher` that operates on a given type, allowing you
to specify conditions for handling different cases. Once the matcher is
created, you can use pattern-matching functions like `when` to define
how different values should be processed.

**Example** (Matching Numbers and Strings)

```ts
import { Match } from "effect"

// Create a matcher for values that are either strings or numbers
//
//       (u: string | number) => string
//      
const match = Match.type<string | number>().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Match when the value is a string
  Match.when(Match.string, (s) => `string: ${s}`),
  // Ensure all possible cases are handled
  Match.exhaustive
)

console.log(match(0))
// Output: "number: 0"

console.log(match("hello"))
// Output: "string: hello"
```

**See**

- `value` for creating a matcher from a specific value.

**Signature**

```ts
declare const type: <I>() => Matcher<I, Types.Without<never>, I, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L193)

Since v1.0.0
Match-undefined.md
Package: `effect`<br />
Module: `Match`<br />

## Match.undefined

Matches the value `undefined`.

**Signature**

```ts
declare const undefined: Predicate.Refinement<unknown, undefined>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1009)

Since v1.0.0
Match-value.md
Package: `effect`<br />
Module: `Match`<br />

## Match.value

Creates a matcher from a specific value.

**Details**

This function allows you to define a `Matcher` directly from a given value,
rather than from a type. This is useful when working with known values,
enabling structured pattern matching on objects, primitives, or any data
structure.

Once the matcher is created, you can use pattern-matching functions like
`when` to define how different cases should be handled.

**Example** (Matching an Object by Property)

```ts
import { Match } from "effect"

const input = { name: "John", age: 30 }

// Create a matcher for the specific object
const result = Match.value(input).pipe(
  // Match when the 'name' property is "John"
  Match.when(
    { name: "John" },
    (user) => `${user.name} is ${user.age} years old`
  ),
  // Provide a fallback if no match is found
  Match.orElse(() => "Oh, not John")
)

console.log(result)
// Output: "John is 30 years old"
```

**See**

- `type` for creating a matcher from a specific type.

**Signature**

```ts
declare const value: <const I>(i: I) => Matcher<I, Types.Without<never>, I, never, I>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L235)

Since v1.0.0
Match-when.md
Package: `effect`<br />
Module: `Match`<br />

## Match.when

Defines a condition for matching values.

**Details**

This function enables pattern matching by checking whether a given value
satisfies a condition. It supports both direct value comparisons and
predicate functions. If the condition is met, the associated function is
executed.

This function is useful when defining matchers that need to check for
specific values or apply logical conditions to determine a match. It works
well with structured objects and primitive types.

**Example** (Matching with Values and Predicates)

```ts
import { Match } from "effect"

// Create a matcher for objects with an "age" property
const match = Match.type<{ age: number }>().pipe(
  // Match when age is greater than 18
  Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),
  // Match when age is exactly 18
  Match.when({ age: 18 }, () => "You can vote"),
  // Fallback case for all other ages
  Match.orElse((user) => `${user.age} is too young`)
)

console.log(match({ age: 20 }))
// Output: "Age: 20"

console.log(match({ age: 18 }))
// Output: "You can vote"

console.log(match({ age: 4 }))
// Output: "4 is too young"
```

**See**

- `whenOr` Use this when multiple patterns should match in a single
condition.
- `whenAnd` Use this when a value must match all provided patterns.
- `orElse` Provides a fallback when no patterns match.

**Signature**

```ts
declare const when: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Types.WhenMatch<R, P>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>, A | ReturnType<Fn>, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L366)

Since v1.0.0
Match-whenAnd.md
Package: `effect`<br />
Module: `Match`<br />

## Match.whenAnd

Matches a value that satisfies all provided patterns.

**Details**

This function allows defining a condition where a value must match all the
given patterns simultaneously. If the value satisfies every pattern, the
associated function is executed.

Unlike `when`, which matches a single pattern at a time, this function
ensures that multiple conditions are met before executing the callback. It is
useful when checking for values that need to fulfill multiple criteria at
once.

**Example**

```ts
import { Match } from "effect"

type User = { readonly age: number; readonly role: "admin" | "user" }

const checkUser = Match.type<User>().pipe(
  Match.whenAnd(
    { age: (n) => n >= 18 },
    { role: "admin" },
    () => "Admin access granted"
  ),
  Match.orElse(() => "Access denied")
)

console.log(checkUser({ age: 20, role: "admin" }))
// Output: "Admin access granted"

console.log(checkUser({ age: 20, role: "user" }))
// Output: "Access denied"
```

**Signature**

```ts
declare const whenAnd: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, T.UnionToIntersection<P[number]>>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>>, A | ReturnType<Fn>, Pr>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L484)

Since v1.0.0
Match-whenOr.md
Package: `effect`<br />
Module: `Match`<br />

## Match.whenOr

Matches one of multiple patterns in a single condition.

**Details**

This function allows defining a condition where a value matches any of the
provided patterns. If a match is found, the associated function is executed.
It simplifies cases where multiple patterns share the same handling logic.

Unlike `when`, which requires separate conditions for each pattern,
this function enables combining them into a single statement, making the
matcher more concise.

**Example**

```ts
import { Match } from "effect"

type ErrorType =
  | { readonly _tag: "NetworkError"; readonly message: string }
  | { readonly _tag: "TimeoutError"; readonly duration: number }
  | { readonly _tag: "ValidationError"; readonly field: string }

const handleError = Match.type<ErrorType>().pipe(
  Match.whenOr(
    { _tag: "NetworkError" },
    { _tag: "TimeoutError" },
    () => "Retry the request"
  ),
  Match.when({ _tag: "ValidationError" }, (_) => `Invalid field: ${_.field}`),
  Match.exhaustive
)

console.log(handleError({ _tag: "NetworkError", message: "No connection" }))
// Output: "Retry the request"

console.log(handleError({ _tag: "ValidationError", field: "email" }))
// Output: "Invalid field: email"
```

**Signature**

```ts
declare const whenOr: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P[number]>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>, A | ReturnType<Fn>, Pr, Ret>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L427)

Since v1.0.0
Match-withReturnType.md
Package: `effect`<br />
Module: `Match`<br />

## Match.withReturnType

Ensures that all branches of a matcher return a specific type.

**Details**

This function enforces a consistent return type across all pattern-matching
branches. By specifying a return type, TypeScript will check that every
matching condition produces a value of the expected type.

**Important:** This function must be the first step in the matcher pipeline.
If used later, TypeScript will not enforce type consistency correctly.

**Example** (Validating Return Type Consistency)

```ts
import { Match } from "effect"

const match = Match.type<{ a: number } | { b: string }>().pipe(
  // Ensure all branches return a string
  Match.withReturnType<string>(),
  //  Type error: 'number' is not assignable to type 'string'
  // @ts-expect-error
  Match.when({ a: Match.number }, (_) => _.a),
  //  Correct: returns a string
  Match.when({ b: Match.string }, (_) => _.b),
  Match.exhaustive
)
```

**Signature**

```ts
declare const withReturnType: <Ret>() => <I, F, R, A, Pr, _>(self: Matcher<I, F, R, A, Pr, _>) => [Ret] extends [[A] extends [never] ? any : A] ? Matcher<I, F, R, A, Pr, Ret> : "withReturnType constraint does not extend Result type"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L314)

Since v1.0.0
MergeDecision-isMergeDecision.md
Package: `effect`<br />
Module: `MergeDecision`<br />

## MergeDecision.isMergeDecision

Returns `true` if the specified value is a `MergeDecision`, `false`
otherwise.

**Signature**

```ts
declare const isMergeDecision: (u: unknown) => u is MergeDecision<unknown, unknown, unknown, unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L74)

Since v2.0.0
MergeState-isBothRunning.md
Package: `effect`<br />
Module: `MergeState`<br />

## MergeState.isBothRunning

Returns `true` if the specified `MergeState` is a `BothRunning`, `false`
otherwise.

**Signature**

```ts
declare const isBothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L120)

Since v2.0.0
MergeState-isLeftDone.md
Package: `effect`<br />
Module: `MergeState`<br />

## MergeState.isLeftDone

Returns `true` if the specified `MergeState` is a `LeftDone`, `false`
otherwise.

**Signature**

```ts
declare const isLeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L131)

Since v2.0.0
MergeState-isMergeState.md
Package: `effect`<br />
Module: `MergeState`<br />

## MergeState.isMergeState

Returns `true` if the specified value is a `MergeState`, `false` otherwise.

**Signature**

```ts
declare const isMergeState: (u: unknown) => u is MergeState<unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L109)

Since v2.0.0
MergeState-isRightDone.md
Package: `effect`<br />
Module: `MergeState`<br />

## MergeState.isRightDone

Returns `true` if the specified `MergeState` is a `RightDone`, `false`
otherwise.

**Signature**

```ts
declare const isRightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L142)

Since v2.0.0
MergeStrategy-isBackPressure.md
Package: `effect`<br />
Module: `MergeStrategy`<br />

## MergeStrategy.isBackPressure

Returns `true` if the specified `MergeStrategy` is a `BackPressure`, `false`
otherwise.

**Signature**

```ts
declare const isBackPressure: (self: MergeStrategy) => self is BackPressure
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L81)

Since v2.0.0
MergeStrategy-isBufferSliding.md
Package: `effect`<br />
Module: `MergeStrategy`<br />

## MergeStrategy.isBufferSliding

Returns `true` if the specified `MergeStrategy` is a `BufferSliding`, `false`
otherwise.

**Signature**

```ts
declare const isBufferSliding: (self: MergeStrategy) => self is BufferSliding
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L90)

Since v2.0.0
MergeStrategy-isMergeStrategy.md
Package: `effect`<br />
Module: `MergeStrategy`<br />

## MergeStrategy.isMergeStrategy

Returns `true` if the specified value is a `MergeStrategy`, `false`
otherwise.

**Signature**

```ts
declare const isMergeStrategy: (u: unknown) => u is MergeStrategy
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L72)

Since v2.0.0
MergeStrategy-match.md
Package: `effect`<br />
Module: `MergeStrategy`<br />

## MergeStrategy.match

Folds an `MergeStrategy` into a value of type `A`.

**Signature**

```ts
declare const match: { <A>(options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): (self: MergeStrategy) => A; <A>(self: MergeStrategy, options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L98)

Since v2.0.0
Metric-Metric.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.Metric

A `Metric<Type, In, Out>` represents a concurrent metric which accepts
updates of type `In` and are aggregated to a stateful value of type `Out`.

For example, a counter metric would have type `Metric<number, number>`,
representing the fact that the metric can be updated with numbers (the amount
to increment or decrement the counter by), and the state of the counter is a
number.

There are five primitive metric types supported by Effect:

  - Counters
  - Frequencies
  - Gauges
  - Histograms
  - Summaries

**Signature**

```ts
export interface Metric<in out Type, in In, out Out> extends Metric.Variance<Type, In, Out>, Pipeable {
  /**
   * The type of the underlying primitive metric. For example, this could be
   * `MetricKeyType.Counter` or `MetricKeyType.Gauge`.
   */
  readonly keyType: Type
  unsafeUpdate(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void
  unsafeValue(extraTags: ReadonlyArray<MetricLabel.MetricLabel>): Out
  unsafeModify(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void
  register(): this
  <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L51)

Since v2.0.0
Metric-counter.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.counter

Represents a Counter metric that tracks cumulative numerical values over time.
Counters can be incremented and decremented and provide a running total of changes.

**Options**

- description - A description of the counter.
- bigint - Indicates if the counter uses 'bigint' data type.
- incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.

**Example**

```ts
import { Metric } from "effect"

const numberCounter = Metric.counter("count", {
  description: "A number counter"
});

const bigintCounter = Metric.counter("count", {
  description: "A bigint counter",
  bigint: true
});
```

**Signature**

```ts
declare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): Metric.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): Metric.Counter<bigint>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L186)

Since v2.0.0
Metric-frequency.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.frequency

Creates a Frequency metric to count occurrences of events.
Frequency metrics are used to count the number of times specific events or incidents occur.

**Example**

```ts
import { Metric } from "effect"

const errorFrequency = Metric.frequency("error_frequency", {
   description: "Counts the occurrences of errors."
});
```

**Signature**

```ts
declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => Metric.Frequency<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L221)

Since v2.0.0
Metric-gauge.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.gauge

Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.
Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.

**Options**

- description - A description of the gauge metric.
- bigint - Indicates if the counter uses 'bigint' data type.

**Example**

```ts
import { Metric } from "effect"

const numberGauge = Metric.gauge("memory_usage", {
  description: "A gauge for memory usage"
});

const bigintGauge = Metric.gauge("cpu_load", {
  description: "A gauge for CPU load",
  bigint: true
});
```

**Signature**

```ts
declare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): Metric.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): Metric.Gauge<bigint>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L276)

Since v2.0.0
Metric-histogram.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.histogram

Represents a Histogram metric that records observations in specified value boundaries.
Histogram metrics are useful for measuring the distribution of values within a range.

**Example**

```ts
import { Metric, MetricBoundaries } from "effect"

const latencyHistogram = Metric.histogram("latency_histogram",
  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),
  "Measures the distribution of request latency."
);
```

**Signature**

```ts
declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L304)

Since v2.0.0
Metric-map.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.map

Returns a new metric that is powered by this one, but which outputs a new
state type, determined by transforming the state type of this metric by the
specified function.

**Signature**

```ts
declare const map: { <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>; <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L337)

Since v2.0.0
Metric-mapInput.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.mapInput

Returns a new metric that is powered by this one, but which accepts updates
of the specified new type, which must be transformable to the input type of
this metric.

**Signature**

```ts
declare const mapInput: { <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>; <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L154)

Since v2.0.0
Metric-modify.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.modify

Modifies the metric with the specified update message. For example, if the
metric were a gauge, the update would increment the method by the provided
amount.

**Signature**

```ts
declare const modify: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L359)

Since v3.6.5
Metric-snapshot.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.snapshot

Captures a snapshot of all metrics recorded by the application.

**Signature**

```ts
declare const snapshot: Effect.Effect<Array<MetricPair.MetricPair.Untyped>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L381)

Since v2.0.0
Metric-succeed.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.succeed

Creates a metric that ignores input and produces constant output.

**Signature**

```ts
declare const succeed: <Out>(out: Out) => Metric<void, unknown, Out>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L389)

Since v2.0.0
Metric-summary.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.summary

Creates a Summary metric that records observations and calculates quantiles.
Summary metrics provide statistical information about a set of values, including quantiles.

**Options**

- name - The name of the Summary metric.
- maxAge - The maximum age of observations to retain.
- maxSize - The maximum number of observations to keep.
- error - The error percentage when calculating quantiles.
- quantiles - An `Chunk` of quantiles to calculate (e.g., [0.5, 0.9]).
- description - An optional description of the Summary metric.

**Example**

```ts
import { Metric, Chunk } from "effect"

const responseTimesSummary = Metric.summary({
  name: "response_times_summary",
  maxAge: "60 seconds", // Retain observations for 60 seconds.
  maxSize: 1000, // Keep a maximum of 1000 observations.
  error: 0.01, // Allow a 1% error when calculating quantiles.
  quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.
  description: "Measures the distribution of response times."
});
```

**Signature**

```ts
declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => Metric.Summary<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L429)

Since v2.0.0
Metric-sync.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.sync

Creates a metric that ignores input and produces constant output.

**Signature**

```ts
declare const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L397)

Since v2.0.0
Metric-tagged.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.tagged

Returns a new metric, which is identical in every way to this one, except
the specified tags have been added to the tags of this metric.

**Signature**

```ts
declare const tagged: { <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L463)

Since v2.0.0
Metric-taggedWithLabels.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.taggedWithLabels

Returns a new metric, which is identical in every way to this one, except
the specified tags have been added to the tags of this metric.

**Signature**

```ts
declare const taggedWithLabels: { <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): Metric<Type, In, Out>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L494)

Since v2.0.0
Metric-taggedWithLabelsInput.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.taggedWithLabelsInput

Returns a new metric, which is identical in every way to this one, except
dynamic tags are added based on the update values. Note that the metric
returned by this method does not return any useful information, due to the
dynamic nature of the added tags.

**Signature**

```ts
declare const taggedWithLabelsInput: { <In>(f: (input: In) => Iterable<MetricLabel.MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>; <Type, In, Out>(self: Metric<Type, In, Out>, f: (input: In) => Iterable<MetricLabel.MetricLabel>): Metric<Type, In, void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L477)

Since v2.0.0
Metric-timer.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.timer

Creates a timer metric, based on a histogram, which keeps track of
durations in milliseconds. The unit of time will automatically be added to
the metric as a tag (i.e. `"time_unit: milliseconds"`).

**Signature**

```ts
declare const timer: (name: string, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L507)

Since v2.0.0
Metric-timerWithBoundaries.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.timerWithBoundaries

Creates a timer metric, based on a histogram created from the provided
boundaries, which keeps track of durations in milliseconds. The unit of time
will automatically be added to the metric as a tag (i.e.
`"time_unit: milliseconds"`).

**Signature**

```ts
declare const timerWithBoundaries: (name: string, boundaries: ReadonlyArray<number>, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L522)

Since v2.0.0
Metric-trackAll.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackAll

Returns an aspect that will update this metric with the specified constant
value every time the aspect is applied to an effect, regardless of whether
that effect fails or succeeds.

**Signature**

```ts
declare const trackAll: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L537)

Since v2.0.0
Metric-trackDefect.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackDefect

Returns an aspect that will update this metric with the defects of the
effects that it is applied to.

**Signature**

```ts
declare const trackDefect: { <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L554)

Since v2.0.0
Metric-trackDefectWith.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackDefectWith

Returns an aspect that will update this metric with the result of applying
the specified function to the defect throwables of the effects that the
aspect is applied to.

**Signature**

```ts
declare const trackDefectWith: { <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (defect: unknown) => In): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L567)

Since v2.0.0
Metric-trackDuration.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackDuration

Returns an aspect that will update this metric with the duration that the
effect takes to execute. To call this method, the input type of the metric
must be `Duration`.

**Signature**

```ts
declare const trackDuration: { <Type, Out>(metric: Metric<Type, Duration.Duration, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, Duration.Duration, Out>): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L587)

Since v2.0.0
Metric-trackDurationWith.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackDurationWith

Returns an aspect that will update this metric with the duration that the
effect takes to execute. To call this method, you must supply a function
that can convert the `Duration` to the input type of this metric.

**Signature**

```ts
declare const trackDurationWith: { <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L605)

Since v2.0.0
Metric-trackError.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackError

Returns an aspect that will update this metric with the failure value of
the effects that it is applied to.

**Signature**

```ts
declare const trackError: { <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E extends In, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L624)

Since v2.0.0
Metric-trackErrorWith.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackErrorWith

Returns an aspect that will update this metric with the result of applying
the specified function to the error value of the effects that the aspect is
applied to.

**Signature**

```ts
declare const trackErrorWith: { <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (error: In2) => In): <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E extends In2, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (error: In2) => In): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L642)

Since v2.0.0
Metric-trackSuccess.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackSuccess

Returns an aspect that will update this metric with the success value of
the effects that it is applied to.

**Signature**

```ts
declare const trackSuccess: { <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L661)

Since v2.0.0
Metric-trackSuccessWith.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.trackSuccessWith

Returns an aspect that will update this metric with the result of applying
the specified function to the success value of the effects that the aspect is
applied to.

**Signature**

```ts
declare const trackSuccessWith: { <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (value: In2) => In): <A extends In2, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A extends In2, E, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (value: In2) => In): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L679)

Since v2.0.0
Metric-unsafeSnapshot.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.unsafeSnapshot

Unsafely captures a snapshot of all metrics recorded by the application.

**Signature**

```ts
declare const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L749)

Since v2.0.0
Metric-update.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.update

Updates the metric with the specified update message. For example, if the
metric were a counter, the update would increment the method by the
provided amount.

**Signature**

```ts
declare const update: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L699)

Since v2.0.0
Metric-value.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.value

Retrieves a snapshot of the value of the metric at this moment in time.

**Signature**

```ts
declare const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L710)

Since v2.0.0
Metric-withConstantInput.md
Package: `effect`<br />
Module: `Metric`<br />

## Metric.withConstantInput

Returns a new metric that is powered by this one, but which accepts updates
of any type, and translates them to updates with the specified constant
update value.

**Signature**

```ts
declare const withConstantInput: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L236)

Since v2.0.0
MetricBoundaries-exponential.md
Package: `effect`<br />
Module: `MetricBoundaries`<br />

## MetricBoundaries.exponential

A helper method to create histogram bucket boundaries for a histogram
with exponentially increasing values.

**Signature**

```ts
declare const exponential: (options: { readonly start: number; readonly factor: number; readonly count: number; }) => MetricBoundaries
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L63)

Since v2.0.0
MetricBoundaries-linear.md
Package: `effect`<br />
Module: `MetricBoundaries`<br />

## MetricBoundaries.linear

A helper method to create histogram bucket boundaries for a histogram
with linear increasing values.

**Signature**

```ts
declare const linear: (options: { readonly start: number; readonly width: number; readonly count: number; }) => MetricBoundaries
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L48)

Since v2.0.0
MetricKey-MetricKey.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.MetricKey

A `MetricKey` is a unique key associated with each metric. The key is based
on a combination of the metric type, the name and tags associated with the
metric, an optional description of the key, and any other information to
describe a metric, such as the boundaries of a histogram. In this way, it is
impossible to ever create different metrics with conflicting keys.

**Signature**

```ts
export interface MetricKey<out Type extends MetricKeyType.MetricKeyType<any, any>>
  extends MetricKey.Variance<Type>, Equal.Equal, Pipeable
{
  readonly name: string
  readonly keyType: Type
  readonly description: Option.Option<string>
  readonly tags: ReadonlyArray<MetricLabel.MetricLabel>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L36)

Since v2.0.0
MetricKey-counter.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.counter

Creates a metric key for a counter, with the specified name.

**Signature**

```ts
declare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): MetricKey.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): MetricKey.Counter<bigint>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L109)

Since v2.0.0
MetricKey-frequency.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.frequency

Creates a metric key for a categorical frequency table, with the specified
name.

**Signature**

```ts
declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => MetricKey.Frequency
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L135)

Since v2.0.0
MetricKey-gauge.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.gauge

Creates a metric key for a gauge, with the specified name.

**Signature**

```ts
declare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): MetricKey.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): MetricKey.Gauge<bigint>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L151)

Since v2.0.0
MetricKey-histogram.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.histogram

Creates a metric key for a histogram, with the specified name and boundaries.

**Signature**

```ts
declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => MetricKey.Histogram
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L168)

Since v2.0.0
MetricKey-summary.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.summary

Creates a metric key for a summary, with the specified name, maxAge,
maxSize, error, and quantiles.

**Signature**

```ts
declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => MetricKey.Summary
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L181)

Since v2.0.0
MetricKey-tagged.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.tagged

Returns a new `MetricKey` with the specified tag appended.

**Signature**

```ts
declare const tagged: { (key: string, value: string): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, key: string, value: string): MetricKey<Type>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L198)

Since v2.0.0
MetricKey-taggedWithLabels.md
Package: `effect`<br />
Module: `MetricKey`<br />

## MetricKey.taggedWithLabels

Returns a new `MetricKey` with the specified tags appended.

**Signature**

```ts
declare const taggedWithLabels: { (extraTags: ReadonlyArray<MetricLabel.MetricLabel>): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): MetricKey<Type>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L216)

Since v2.0.0
MetricLabel-MetricLabel.md
Package: `effect`<br />
Module: `MetricLabel`<br />

## MetricLabel.MetricLabel

A `MetricLabel` represents a key value pair that allows analyzing metrics at
an additional level of granularity.

For example if a metric tracks the response time of a service labels could
be used to create separate versions that track response times for different
clients.

**Signature**

```ts
export interface MetricLabel extends Equal.Equal, Pipeable {
  readonly [MetricLabelTypeId]: MetricLabelTypeId
  readonly key: string
  readonly value: string
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricLabel.ts#L31)

Since v2.0.0
MetricPolling-MetricPolling.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.MetricPolling

A `MetricPolling` is a combination of a metric and an effect that polls for
updates to the metric.

**Signature**

```ts
export interface MetricPolling<in out Type, in out In, out R, out E, out Out> extends Pipeable {
  readonly [MetricPollingTypeId]: MetricPollingTypeId
  /**
   * The metric that this `MetricPolling` polls to update.
   */
  readonly metric: Metric.Metric<Type, In, Out>
  /**
   * An effect that polls a value that may be fed to the metric.
   */
  readonly poll: Effect.Effect<In, E, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L31)

Since v2.0.0
MetricPolling-collectAll.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.collectAll

Collects all of the polling metrics into a single polling metric, which
polls for, updates, and produces the outputs of all individual metrics.

**Signature**

```ts
declare const collectAll: <R, E, Out>(iterable: Iterable<MetricPolling<any, any, R, E, Out>>) => MetricPolling<Array<any>, Array<any>, R, E, Array<Out>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L61)

Since v2.0.0
MetricPolling-launch.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.launch

Returns an effect that will launch the polling metric in a background
fiber, using the specified schedule.

**Signature**

```ts
declare const launch: { <A2, R2>(schedule: Schedule.Schedule<A2, unknown, R2>): <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<Fiber.Fiber<A2, E>, never, R2 | R | Scope.Scope>; <Type, In, R, E, Out, A2, R2>(self: MetricPolling<Type, In, R, E, Out>, schedule: Schedule.Schedule<A2, unknown, R2>): Effect.Effect<Fiber.Fiber<A2, E>, never, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L72)

Since v2.0.0
MetricPolling-make.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.make

Constructs a new polling metric from a metric and poll effect.

**Signature**

```ts
declare const make: <Type, In, Out, R, E>(metric: Metric.Metric<Type, In, Out>, poll: Effect.Effect<In, E, R>) => MetricPolling<Type, In, R, E, Out>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L49)

Since v2.0.0
MetricPolling-poll.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.poll

An effect that polls a value that may be fed to the metric.

**Signature**

```ts
declare const poll: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L90)

Since v2.0.0
MetricPolling-pollAndUpdate.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.pollAndUpdate

An effect that polls for a value and uses the value to update the metric.

**Signature**

```ts
declare const pollAndUpdate: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<void, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L99)

Since v2.0.0
MetricPolling-retry.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.retry

Returns a new polling metric whose poll function will be retried with the
specified retry policy.

**Signature**

```ts
declare const retry: { <X, E, R2>(policy: Schedule.Schedule<X, NoInfer<E>, R2>): <Type, In, R, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<Type, In, R2 | R, E, Out>; <Type, In, R, E, Out, X, R2>(self: MetricPolling<Type, In, R, E, Out>, policy: Schedule.Schedule<X, E, R2>): MetricPolling<Type, In, R | R2, E, Out>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L110)

Since v2.0.0
MetricPolling-zip.md
Package: `effect`<br />
Module: `MetricPolling`<br />

## MetricPolling.zip

Zips this polling metric with the specified polling metric.

**Signature**

```ts
declare const zip: { <Type2, In2, R2, E2, Out2>(that: MetricPolling<Type2, In2, R2, E2, Out2>): <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<readonly [Type, Type2], readonly [In, In2], R2 | R, E2 | E, [Out, Out2]>; <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(self: MetricPolling<Type, In, R, E, Out>, that: MetricPolling<Type2, In2, R2, E2, Out2>): MetricPolling<readonly [Type, Type2], readonly [In, In2], R | R2, E | E2, [Out, Out2]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L126)

Since v2.0.0
MetricState-MetricState.md
Package: `effect`<br />
Module: `MetricState`<br />

## MetricState.MetricState

A `MetricState` describes the state of a metric. The type parameter of a
metric state corresponds to the type of the metric key (`MetricStateType`).
This phantom type parameter is used to tie keys to their expected states.

**Signature**

```ts
export interface MetricState<in A> extends MetricState.Variance<A>, Equal.Equal, Pipeable {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L91)

Since v2.0.0
Micro-Do.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.Do

Start a do notation block.

**Signature**

```ts
declare const Do: Micro<{}, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4036)

Since v3.4.0
Micro-acquireRelease.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.acquireRelease

Create a resource with a cleanup `Micro` effect, ensuring the cleanup is
executed when the `MicroScope` is closed.

**Signature**

```ts
declare const acquireRelease: <A, E, R>(acquire: Micro<A, E, R>, release: (a: A, exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<A, E, R | MicroScope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3441)

Since v3.4.0
Micro-acquireUseRelease.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.acquireUseRelease

Acquire a resource, use it, and then release the resource when the `use`
effect has completed.

**Signature**

```ts
declare const acquireUseRelease: <Resource, E, R, A, E2, R2, E3, R3>(acquire: Micro<Resource, E, R>, use: (a: Resource) => Micro<A, E2, R2>, release: (a: Resource, exit: MicroExit<A, E2>) => Micro<void, E3, R3>) => Micro<A, E | E2 | E3, R | R2 | R3>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3600)

Since v3.4.0
Micro-addFinalizer.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.addFinalizer

Add a finalizer to the current `MicroScope`.

**Signature**

```ts
declare const addFinalizer: (finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<void, never, MicroScope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3457)

Since v3.4.0
Micro-all.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.all

Runs all the provided effects in sequence respecting the structure provided in input.

Supports multiple arguments, a single argument tuple / array or record / struct.

**Signature**

```ts
declare const all: <const Arg extends Iterable<Micro<any, any, any>> | Record<string, Micro<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly discard?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3800)

Since v3.4.0
Micro-andThen.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.andThen

A more flexible version of `flatMap` that combines `map` and `flatMap` into a
single API.

It also lets you directly pass a `Micro` effect, which will be executed after
the current effect.

**Signature**

```ts
declare const andThen: { <A, X>(f: (a: A) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: A) => X): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1297)

Since v3.4.0
Micro-as.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.as

Create a `Micro` effect that will replace the success value of the given
effect.

**Signature**

```ts
declare const as: { <A, B>(value: B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1259)

Since v3.4.0
Micro-asSome.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.asSome

Wrap the success value of this `Micro` effect in a `Some`.

**Signature**

```ts
declare const asSome: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1271)

Since v3.4.0
Micro-asVoid.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.asVoid

Replace the success value of the `Micro` effect with `void`.

**Signature**

```ts
declare const asVoid: <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1377)

Since v3.4.0
Micro-async.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.async

Create a `Micro` effect from an asynchronous computation.

You can return a cleanup effect that will be run when the effect is aborted.
It is also passed an `AbortSignal` that is triggered when the effect is
aborted.

**Signature**

```ts
declare const async: <A, E = never, R = never>(register: (resume: (effect: Micro<A, E, R>) => void, signal: AbortSignal) => void | Micro<void, never, R>) => Micro<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1197)

Since v3.4.0
Micro-bind.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.bind

Bind the success value of this `Micro` effect to the provided name.

**Signature**

```ts
declare const bind: { <N extends string, A extends Record<string, any>, B, E2, R2>(name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; <A extends Record<string, any>, E, R, B, E2, R2, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4057)

Since v3.4.0
Micro-bindTo.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.bindTo

Bind the success value of this `Micro` effect to the provided name.

**Signature**

```ts
declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Micro<A, E, R>) => Micro<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Micro<A, E, R>, name: N): Micro<{ [K in N]: A; }, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4045)

Since v3.4.0
Micro-catchAll.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.catchAll

Catch the error of the given `Micro` effect, allowing you to recover from it.

It only catches expected errors.

**Signature**

```ts
declare const catchAll: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2643)

Since v3.4.6
Micro-catchAllCause.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.catchAllCause

Catch the full `MicroCause` object of the given `Micro` effect, allowing you to
recover from any kind of cause.

**Signature**

```ts
declare const catchAllCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2567)

Since v3.4.6
Micro-catchAllDefect.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.catchAllDefect

Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.

**Signature**

```ts
declare const catchAllDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2663)

Since v3.4.6
Micro-catchCauseIf.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.catchCauseIf

Selectively catch a `MicroCause` object of the given `Micro` effect,
using the provided predicate to determine if the failure should be caught.

**Signature**

```ts
declare const catchCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <E, B, E2, R2>(predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2603)

Since v3.4.6
Micro-catchIf.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.catchIf

Catch any expected errors that match the specified predicate.

**Signature**

```ts
declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Micro<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Micro<A2, E2, R2>): Micro<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<E>, f: (e: E) => Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2776)

Since v3.4.0
Micro-catchTag.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.catchTag

Recovers from the specified tagged error.

**Signature**

```ts
declare const catchTag: { <K extends E extends { _tag: string; } ? E["_tag"] : never, E, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): <A, R>(self: Micro<A, E, R>) => Micro<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, R1, E1, A1>(self: Micro<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): Micro<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2816)

Since v3.4.0
Micro-context.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.context

Access the current `Context` from the environment.

**Signature**

```ts
declare const context: <R>() => Micro<Context.Context<R>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1941)

Since v3.4.0
Micro-delay.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.delay

Returns an effect that will delay the execution of this effect by the
specified duration.

**Signature**

```ts
declare const delay: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3186)

Since v3.4.0
Micro-die.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.die

Creates a `Micro` effect that will die with the specified error.

This results in a `Die` variant of the `MicroCause` type, where the error is
not tracked at the type level.

**Signature**

```ts
declare const die: (defect: unknown) => Micro<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L970)

Since v3.4.0
Micro-either.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.either

Replace the success value of the given `Micro` effect with an `Either`,
wrapping the success value in `Right` and wrapping any expected errors with
a `Left`.

**Signature**

```ts
declare const either: <A, E, R>(self: Micro<A, E, R>) => Micro<Either.Either<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2934)

Since v3.4.0
Micro-ensuring.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.ensuring

Regardless of the result of the this `Micro` effect, run the finalizer effect.

**Signature**

```ts
declare const ensuring: { <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3498)

Since v3.4.0
Micro-exit.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.exit

Access the `MicroExit` of the given `Micro` effect.

**Signature**

```ts
declare const exit: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroExit<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1386)

Since v3.4.6
Micro-fail.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.fail

Creates a `Micro` effect that fails with the given error.

This results in a `Fail` variant of the `MicroCause` type, where the error is
tracked at the type level.

**Signature**

```ts
declare const fail: <E>(error: E) => Micro<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L865)

Since v3.4.0
Micro-failCause.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.failCause

Creates a `Micro` effect that will fail with the specified `MicroCause`.

**Signature**

```ts
declare const failCause: <E>(cause: MicroCause<E>) => Micro<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L843)

Since v3.4.6
Micro-failCauseSync.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.failCauseSync

Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.

**Signature**

```ts
declare const failCauseSync: <E>(evaluate: LazyArg<MicroCause<E>>) => Micro<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L957)

Since v3.4.0
Micro-failSync.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.failSync

Creates a `Micro` effect that will fail with the lazily evaluated error.

This results in a `Fail` variant of the `MicroCause` type, where the error is
tracked at the type level.

**Signature**

```ts
declare const failSync: <E>(error: LazyArg<E>) => Micro<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L982)

Since v3.4.6
Micro-filter.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.filter

Effectfully filter the elements of the provided iterable.

Use the `concurrency` option to control how many elements are processed
concurrently.

**Signature**

```ts
declare const filter: <A, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly negate?: boolean | undefined; }) => Micro<Array<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3982)

Since v3.4.0
Micro-filterMap.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.filterMap

Effectfully filter the elements of the provided iterable.

Use the `concurrency` option to control how many elements are processed
concurrently.

**Signature**

```ts
declare const filterMap: <A, B, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<Option.Option<B>, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }) => Micro<Array<B>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4002)

Since v3.4.0
Micro-filterOrFail.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.filterOrFail

Filter the specified effect with the provided function, failing with specified
error if the predicate fails.

In addition to the filtering capabilities discussed earlier, you have the option to further
refine and narrow down the type of the success channel by providing a

**Signature**

```ts
declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Micro<B, E | E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Micro<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2211)

Since v3.4.0
Micro-filterOrFailCause.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.filterOrFailCause

Filter the specified effect with the provided function, failing with specified
`MicroCause` if the predicate fails.

In addition to the filtering capabilities discussed earlier, you have the option to further
refine and narrow down the type of the success channel by providing a

**Signature**

```ts
declare const filterOrFailCause: { <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => MicroCause<E2>): Micro<B, E | E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => MicroCause<E2>): Micro<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2175)

Since v3.4.0
Micro-flatMap.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.flatMap

Map the success value of this `Micro` effect to another `Micro` effect, then
flatten the result.

**Signature**

```ts
declare const flatMap: { <A, B, E2, R2>(f: (a: A) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<B, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1525)

Since v3.4.0
Micro-flatten.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.flatten

Flattens any nested `Micro` effects, merging the error and requirement types.

**Signature**

```ts
declare const flatten: <A, E, R, E2, R2>(self: Micro<Micro<A, E, R>, E2, R2>) => Micro<A, E | E2, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1564)

Since v3.4.0
Micro-flip.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.flip

Swap the error and success types of the `Micro` effect.

**Signature**

```ts
declare const flip: <A, E, R>(self: Micro<A, E, R>) => Micro<E, A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1280)

Since v3.4.0
Micro-forEach.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.forEach

For each element of the provided iterable, run the effect and collect the
results.

If the `discard` option is set to `true`, the results will be discarded and
the effect will return `void`.

The `concurrency` option can be set to control how many effects are run
concurrently. By default, the effects are run sequentially.

**Signature**

```ts
declare const forEach: { <A, B, E, R>(iterable: Iterable<A>, f: (a: A, index: number) => Micro<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Micro<Array<B>, E, R>; <A, B, E, R>(iterable: Iterable<A>, f: (a: A, index: number) => Micro<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Micro<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3869)

Since v3.4.0
Micro-forever.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.forever

Repeat the given `Micro` effect forever, only stopping if the effect fails.

**Signature**

```ts
declare const forever: <A, E, R>(self: Micro<A, E, R>) => Micro<never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2421)

Since v3.4.0
Micro-fork.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.fork

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

When the parent `Micro` finishes, this `Micro` will be aborted.

**Signature**

```ts
declare const fork: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4106)

Since v3.4.0
Micro-forkDaemon.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.forkDaemon

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

It will not be aborted when the parent `Micro` finishes.

**Signature**

```ts
declare const forkDaemon: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4143)

Since v3.4.0
Micro-Micro.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.Micro

A lightweight alternative to the `Effect` data type, with a subset of the functionality.

**Signature**

```ts
export interface Micro<out A, out E = never, out R = never> extends Effect<A, E, R> {
  readonly [TypeId]: Micro.Variance<A, E, R>
  [Symbol.iterator](): MicroIterator<Micro<A, E, R>>
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: MicroUnify<this>
  [Unify.ignoreSymbol]?: MicroUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L72)

Since v3.4.0
Micro-MicroCause.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.MicroCause

A `MicroCause` is a data type that represents the different ways a `Micro` can fail.

**Details**

`MicroCause` comes in three forms:

- `Die`: Indicates an unforeseen defect that wasn't planned for in the system's logic.
- `Fail`: Covers anticipated errors that are recognized and typically handled within the application.
- `Interrupt`: Signifies an operation that has been purposefully stopped.

**Signature**

```ts
type MicroCause<E> = | MicroCause.Die
  | MicroCause.Fail<E>
  | MicroCause.Interrupt
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L186)

Since v3.4.6
Micro-MicroExit.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.MicroExit

The `MicroExit` type is used to represent the result of a `Micro` computation. It
can either be successful, containing a value of type `A`, or it can fail,
containing an error of type `E` wrapped in a `MicroCause`.

**Signature**

```ts
type MicroExit<A, E> = | MicroExit.Success<A, E>
  | MicroExit.Failure<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1597)

Since v3.4.6
Micro-MicroSchedule.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.MicroSchedule

The `MicroSchedule` type represents a function that can be used to calculate
the delay between repeats.

The function takes the current attempt number and the elapsed time since the
first attempt, and returns the delay for the next attempt. If the function
returns `None`, the repetition will stop.

**Signature**

```ts
type MicroSchedule = (attempt: number, elapsed: number) => Option.Option<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2439)

Since v3.4.6
Micro-NoSuchElementException.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.NoSuchElementException

Represents a checked exception which occurs when an expected element was
unable to be found.

**Signature**

```ts
declare class NoSuchElementException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4396)

Since v3.4.4
Micro-forkIn.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.forkIn

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

The lifetime of the handle will be attached to the provided `MicroScope`.

**Signature**

```ts
declare const forkIn: { (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>; <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4157)

Since v3.4.0
Micro-forkScoped.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.forkScoped

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

The lifetime of the handle will be attached to the current `MicroScope`.

**Signature**

```ts
declare const forkScoped: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R | MicroScope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4182)

Since v3.4.0
Micro-fromEither.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.fromEither

Converts an `Either` into a `Micro` effect, that will fail with the left side
of the either if it is a `Left`. Otherwise, it will succeed with the right
side of the either.

**Signature**

```ts
declare const fromEither: <R, L>(either: Either.Either<R, L>) => Micro<R, L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1005)

Since v3.4.0
Micro-fromOption.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.fromOption

Converts an `Option` into a `Micro` effect, that will fail with
`NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the
value of the option.

**Signature**

```ts
declare const fromOption: <A>(option: Option.Option<A>) => Micro<A, NoSuchElementException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L993)

Since v3.4.0
Micro-ignore.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.ignore

Ignore any expected errors of the given `Micro` effect, returning `void`.

**Signature**

```ts
declare const ignore: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2896)

Since v3.4.0
Micro-ignoreLogged.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.ignoreLogged

Ignore any expected errors of the given `Micro` effect, returning `void`.

**Signature**

```ts
declare const ignoreLogged: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2906)

Since v3.4.0
Micro-interrupt.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.interrupt

Abort the current `Micro` effect.

**Signature**

```ts
declare const interrupt: Micro<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3627)

Since v3.4.6
Micro-interruptible.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.interruptible

Flag the effect as interruptible, which means that when the effect is
interrupted, it will be interrupted immediately.

**Signature**

```ts
declare const interruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3665)

Since v3.4.0
Micro-let.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.let

Bind the result of a synchronous computation to the given name.

**Signature**

```ts
declare const let: { <N extends string, A extends Record<string, any>, B>(name: N, f: (a: NoInfer<A>) => B): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E, R>; <A extends Record<string, any>, E, R, B, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => B): Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4089)

Since v3.4.0
Micro-map.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.map

Transforms the success value of the `Micro` effect with the specified
function.

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1576)

Since v3.4.0
Micro-mapError.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.mapError

Transform any expected errors of the given `Micro` effect.

**Signature**

```ts
declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2856)

Since v3.4.0
Micro-mapErrorCause.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.mapErrorCause

Transform the full `MicroCause` object of the given `Micro` effect.

**Signature**

```ts
declare const mapErrorCause: { <E, E2>(f: (e: MicroCause<E>) => MicroCause<E2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2840)

Since v3.4.6
Micro-never.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.never

A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent
the Javascript runtime from exiting.

**Signature**

```ts
declare const never: Micro<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1212)

Since v3.4.0
Micro-onError.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.onError

When the `Micro` effect fails, run the given finalizer effect with the
`MicroCause` of the executed effect.

**Signature**

```ts
declare const onError: { <A, E, XE, XR>(f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3558)

Since v3.4.6
Micro-onExit.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.onExit

When the `Micro` effect is completed, run the given finalizer effect with the
`MicroExit` of the executed effect.

**Signature**

```ts
declare const onExit: { <A, E, XE, XR>(f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3469)

Since v3.4.6
Micro-onExitIf.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.onExitIf

When the `Micro` effect is completed, run the given finalizer effect if it
matches the specified predicate.

**Signature**

```ts
declare const onExitIf: { <A, E, XE, XR, B extends MicroExit<A, E>>(refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, XE, XR>(predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR, B extends MicroExit<A, E>>(self: Micro<A, E, R>, refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3522)

Since v3.4.6
Micro-onInterrupt.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.onInterrupt

If this `Micro` effect is aborted, run the finalizer effect.

**Signature**

```ts
declare const onInterrupt: { <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3581)

Since v3.4.6
Micro-option.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.option

Replace the success value of the given `Micro` effect with an `Option`,
wrapping the success value in `Some` and returning `None` if the effect fails
with an expected error.

**Signature**

```ts
declare const option: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2922)

Since v3.4.0
Micro-orDie.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.orDie

Elevate any expected errors of the given `Micro` effect to unexpected errors,
resulting in an error type of `never`.

**Signature**

```ts
declare const orDie: <A, E, R>(self: Micro<A, E, R>) => Micro<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2872)

Since v3.4.0
Micro-orElseSucceed.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.orElseSucceed

Recover from all errors by succeeding with the given value.

**Signature**

```ts
declare const orElseSucceed: { <B>(f: LazyArg<B>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | B, never, R>; <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2881)

Since v3.4.0
Micro-promise.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.promise

Wrap a `Promise` into a `Micro` effect.

Any errors will result in a `Die` variant of the `MicroCause` type, where the
error is not tracked at the type level.

**Signature**

```ts
declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Micro<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1063)

Since v3.4.0
Micro-provideContext.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.provideContext

Merge the given `Context` with the current context.

**Signature**

```ts
declare const provideContext: { <XR>(context: Context.Context<XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, XR>>; <A, E, R, XR>(self: Micro<A, E, R>, context: Context.Context<XR>): Micro<A, E, Exclude<R, XR>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1951)

Since v3.4.0
Micro-provideScope.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.provideScope

Provide a `MicroScope` to an effect.

**Signature**

```ts
declare const provideScope: { (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>; <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<A, E, Exclude<R, MicroScope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3410)

Since v3.4.0
Micro-provideService.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.provideService

Add the provided service to the current context.

**Signature**

```ts
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: S): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, service: S): Micro<A, E, Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1974)

Since v3.4.0
Micro-provideServiceEffect.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.provideServiceEffect

Create a service using the provided `Micro` effect, and add it to the
current context.

**Signature**

```ts
declare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | E2, Exclude<R, I> | R2>; <A, E, R, I, S, E2, R2>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): Micro<A, E | E2, Exclude<R, I> | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2001)

Since v3.4.6
Micro-race.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.race

Returns an effect that races two effects, yielding the value of the first
effect to succeed. Losers of the race will be interrupted immediately.

**Signature**

```ts
declare const race: { <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1491)

Since v3.4.0
Micro-raceAll.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.raceAll

Returns an effect that races all the specified effects,
yielding the value of the first effect to succeed with a value. Losers of
the race will be interrupted immediately

**Signature**

```ts
declare const raceAll: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1410)

Since v3.4.0
Micro-raceAllFirst.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.raceAllFirst

Returns an effect that races all the specified effects,
yielding the value of the first effect to succeed or fail. Losers of
the race will be interrupted immediately.

**Signature**

```ts
declare const raceAllFirst: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1457)

Since v3.4.0
Micro-raceFirst.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.raceFirst

Returns an effect that races two effects, yielding the value of the first
effect to succeed *or* fail. Losers of the race will be interrupted immediately.

**Signature**

```ts
declare const raceFirst: { <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1508)

Since v3.4.0
Micro-repeat.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.repeat

Repeat the given `Micro` effect using the provided options. Only successful
results will be repeated.

**Signature**

```ts
declare const repeat: { <A, E>(options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): Micro<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2320)

Since v3.4.0
Micro-repeatExit.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.repeatExit

Repeat the given `Micro` using the provided options.

The `while` predicate will be checked after each iteration, and can use the
fall `MicroExit` of the effect to determine if the repetition should continue.

**Signature**

```ts
declare const repeatExit: { <A, E>(options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): Micro<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2270)

Since v3.4.6
Micro-replicate.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.replicate

Replicates the given effect `n` times.

**Signature**

```ts
declare const replicate: { (n: number): <A, E, R>(self: Micro<A, E, R>) => Array<Micro<A, E, R>>; <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2356)

Since v3.11.0
Micro-replicateEffect.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.replicateEffect

Performs this effect the specified number of times and collects the
results.

**Signature**

```ts
declare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): <A, E, R>(self: Micro<A, E, R>) => Micro<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>; <A, E, R>(self: Micro<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Micro<Array<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Micro<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2371)

Since v3.11.0
Micro-retry.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.retry

Retry the given `Micro` effect using the provided options.

**Signature**

```ts
declare const retry: { <A, E>(options?: { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options?: { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): Micro<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2944)

Since v3.4.0
Micro-runFork.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.runFork

Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,
or aborted.

You can listen for the result by adding an observer using the handle's
`addObserver` method.

**Example**

```ts
import * as Micro from "effect/Micro"

const handle = Micro.succeed(42).pipe(
  Micro.delay(1000),
  Micro.runFork
)

handle.addObserver((exit) => {
  console.log(exit)
})
```

**Signature**

```ts
declare const runFork: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => MicroFiberImpl<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4214)

Since v3.4.0
Micro-runPromise.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.runPromise

Execute the `Micro` effect and return a `Promise` that resolves with the
successful value of the computation.

**Signature**

```ts
declare const runPromise: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4265)

Since v3.4.0
Micro-runPromiseExit.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.runPromiseExit

Execute the `Micro` effect and return a `Promise` that resolves with the
`MicroExit` of the computation.

**Signature**

```ts
declare const runPromiseExit: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<MicroExit<A, E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4245)

Since v3.4.6
Micro-runSync.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.runSync

Attempt to execute the `Micro` effect synchronously and return the success
value.

**Signature**

```ts
declare const runSync: <A, E>(effect: Micro<A, E>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4304)

Since v3.4.0
Micro-runSyncExit.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.runSyncExit

Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.

If any asynchronous effects are encountered, the function will return a
`CauseDie` containing the `MicroFiber`.

**Signature**

```ts
declare const runSyncExit: <A, E>(effect: Micro<A, E>) => MicroExit<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4289)

Since v3.4.6
Micro-sandbox.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.sandbox

Replace the error type of the given `Micro` with the full `MicroCause` object.

**Signature**

```ts
declare const sandbox: <A, E, R>(self: Micro<A, E, R>) => Micro<A, MicroCause<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1399)

Since v3.4.0
Micro-scheduleAddDelay.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleAddDelay

Returns a new `MicroSchedule` with an added calculated delay to each delay
returned by this schedule.

**Signature**

```ts
declare const scheduleAddDelay: { (f: () => number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, f: () => number): MicroSchedule; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2478)

Since v3.4.6
Micro-scheduleExponential.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleExponential

Create a `MicroSchedule` that will generate a delay with an exponential backoff.

**Signature**

```ts
declare const scheduleExponential: (baseMillis: number, factor?: number) => MicroSchedule
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2467)

Since v3.4.6
Micro-scheduleIntersect.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleIntersect

Combines two `MicroSchedule`s, by recurring only if both schedules want to
recur, using the maximum of the two durations between recurrences.

**Signature**

```ts
declare const scheduleIntersect: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2546)

Since v3.4.6
Micro-scheduleRecurs.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleRecurs

Create a `MicroSchedule` that will stop repeating after the specified number
of attempts.

**Signature**

```ts
declare const scheduleRecurs: (n: number) => MicroSchedule
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2449)

Since v3.4.6
Micro-scheduleSpaced.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleSpaced

Create a `MicroSchedule` that will generate a constant delay.

**Signature**

```ts
declare const scheduleSpaced: (millis: number) => MicroSchedule
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2458)

Since v3.4.6
Micro-TimeoutException.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.TimeoutException

Represents a checked exception which occurs when a timeout occurs.

**Signature**

```ts
declare class TimeoutException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4405)

Since v3.4.4
Micro-scheduleUnion.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleUnion

Combines two `MicroSchedule`s, by recurring if either schedule wants to
recur, using the minimum of the two durations between recurrences.

**Signature**

```ts
declare const scheduleUnion: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2529)

Since v3.4.6
Micro-scheduleWithMaxDelay.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleWithMaxDelay

Transform a `MicroSchedule` to one that will have a delay that will never exceed
the specified maximum.

**Signature**

```ts
declare const scheduleWithMaxDelay: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2495)

Since v3.4.6
Micro-scheduleWithMaxElapsed.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scheduleWithMaxElapsed

Transform a `MicroSchedule` to one that will stop repeating after the specified
amount of time.

**Signature**

```ts
declare const scheduleWithMaxElapsed: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2512)

Since v3.4.6
Micro-scope.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scope

Access the current `MicroScope`.

**Signature**

```ts
declare const scope: Micro<MicroScope, never, MicroScope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3401)

Since v3.4.0
Micro-scoped.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.scoped

Provide a `MicroScope` to the given effect, closing it after the effect has
finished executing.

**Signature**

```ts
declare const scoped: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3427)

Since v3.4.0
Micro-service.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.service

Access the given `Context.Tag` from the environment.

**Signature**

```ts
declare const service: { <I, S>(tag: Context.Reference<I, S>): Micro<S>; <I, S>(tag: Context.Tag<I, S>): Micro<S, never, I>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1835)

Since v3.4.0
Micro-serviceOption.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.serviceOption

Access the given `Context.Tag` from the environment, without tracking the
dependency at the type level.

It will return an `Option` of the service, depending on whether it is
available in the environment or not.

**Signature**

```ts
declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Micro<Option.Option<S>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1853)

Since v3.4.0
Micro-sleep.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.sleep

Create a `Micro` effect that will sleep for the specified duration.

**Signature**

```ts
declare const sleep: (millis: number) => Micro<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3168)

Since v3.4.0
Micro-succeed.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.succeed

Creates a `Micro` effect that will succeed with the specified constant value.

**Signature**

```ts
declare const succeed: <A>(value: A) => Micro<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L827)

Since v3.4.0
Micro-succeedNone.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.succeedNone

Creates a `Micro` effect that succeeds with `None`.

**Signature**

```ts
declare const succeedNone: Micro<Option.Option<never>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L948)

Since v3.4.0
Micro-succeedSome.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.succeedSome

Creates a `Micro` effect that will succeed with the value wrapped in `Some`.

**Signature**

```ts
declare const succeedSome: <A>(a: A) => Micro<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L939)

Since v3.4.0
Micro-suspend.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.suspend

Lazily creates a `Micro` effect from the given side-effect.

**Signature**

```ts
declare const suspend: <A, E, R>(evaluate: LazyArg<Micro<A, E, R>>) => Micro<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L893)

Since v3.4.0
Micro-sync.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.sync

Creates a `Micro` effect that succeeds with a lazily evaluated value.

If the evaluation of the value throws an error, the effect will fail with a
`Die` variant of the `MicroCause` type.

**Signature**

```ts
declare const sync: <A>(evaluate: LazyArg<A>) => Micro<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L877)

Since v3.4.0
Micro-tap.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.tap

Execute a side effect from the success value of the `Micro` effect.

It is similar to the `andThen` api, but the success value is ignored.

**Signature**

```ts
declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1338)

Since v3.4.0
Micro-tapDefect.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.tapDefect

Perform a side effect from unexpected errors of the given `Micro`.

**Signature**

```ts
declare const tapDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2758)

Since v3.4.6
Micro-tapError.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.tapError

Perform a side effect from expected errors of the given `Micro`.

**Signature**

```ts
declare const tapError: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2740)

Since v3.4.6
Micro-tapErrorCause.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.tapErrorCause

Perform a side effect using the full `MicroCause` object of the given `Micro`.

**Signature**

```ts
declare const tapErrorCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2681)

Since v3.4.6
Micro-tapErrorCauseIf.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.tapErrorCauseIf

Perform a side effect using if a `MicroCause` object matches the specified
predicate.

**Signature**

```ts
declare const tapErrorCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <E, B, E2, R2>(predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2705)

Since v3.4.0
Micro-timeout.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.timeout

Returns an effect that will timeout this effect, that will fail with a
`TimeoutException` if the timeout elapses before the effect has produced a
value.

If the timeout elapses, the running effect will be safely interrupted.

**Signature**

```ts
declare const timeout: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | TimeoutException, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3233)

Since v3.4.0
Micro-timeoutOption.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.timeoutOption

Returns an effect that will timeout this effect, succeeding with a `None`
if the timeout elapses before the effect has produced a value; and `Some` of
the produced value otherwise.

If the timeout elapses, the running effect will be safely interrupted.

**Signature**

```ts
declare const timeoutOption: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3253)

Since v3.4.0
Micro-timeoutOrElse.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.timeoutOrElse

Returns an effect that will timeout this effect, that will execute the
fallback effect if the timeout elapses before the effect has produced a value.

If the timeout elapses, the running effect will be safely interrupted.

**Signature**

```ts
declare const timeoutOrElse: { <A2, E2, R2>(options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): Micro<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3204)

Since v3.4.0
Micro-try.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.try

The `Micro` equivalent of a try / catch block, which allows you to map
thrown errors to a specific error type.

**Example**

```ts
import { Micro } from "effect"

Micro.try({
  try: () => { throw new Error("boom") },
  catch: (cause) => new Error("caught", { cause })
})
```

**Signature**

```ts
declare const try: <A, E>(options: { try: LazyArg<A>; catch: (error: unknown) => E; }) => Micro<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1050)

Since v3.4.0
Micro-tryPromise.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.tryPromise

Wrap a `Promise` into a `Micro` effect. Any errors will be caught and
converted into a specific error type.

**Example**

```ts
import { Micro } from "effect"

Micro.tryPromise({
  try: () => Promise.resolve("success"),
  catch: (cause) => new Error("caught", { cause })
})
```

**Signature**

```ts
declare const tryPromise: <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }) => Micro<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1089)

Since v3.4.0
Micro-uninterruptible.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.uninterruptible

Flag the effect as uninterruptible, which means that when the effect is
interrupted, it will be allowed to continue running until completion.

**Signature**

```ts
declare const uninterruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3637)

Since v3.4.0
Micro-uninterruptibleMask.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.uninterruptibleMask

Wrap the given `Micro` effect in an uninterruptible region, preventing the
effect from being aborted.

You can use the `restore` function to restore a `Micro` effect to the
interruptibility state before the `uninterruptibleMask` was applied.

**Example**

```ts
import * as Micro from "effect/Micro"

Micro.uninterruptibleMask((restore) =>
  Micro.sleep(1000).pipe( // uninterruptible
    Micro.andThen(restore(Micro.sleep(1000))) // interruptible
  )
)
```

**Signature**

```ts
declare const uninterruptibleMask: <A, E, R>(f: (restore: <A, E, R>(effect: Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3698)

Since v3.4.0
Micro-updateContext.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.updateContext

Update the Context with the given mapping function.

**Signature**

```ts
declare const updateContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): <A, E>(self: Micro<A, E, R>) => Micro<A, E, R2>; <A, E, R, R2>(self: Micro<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): Micro<A, E, R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1864)

Since v3.11.0
Micro-updateService.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.updateService

Update the service for the given `Context.Tag` in the environment.

**Signature**

```ts
declare const updateService: { <I, A>(tag: Context.Reference<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R>; <I, A>(tag: Context.Tag<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R | I>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Reference<I, A>, f: (value: A) => A): Micro<XA, E, R>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Tag<I, A>, f: (value: A) => A): Micro<XA, E, R | I>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1895)

Since v3.11.0
Micro-void.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.void

A `Micro` effect that will succeed with `void` (`undefined`).

**Signature**

```ts
declare const void: Micro<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1017)

Since v3.4.0
Micro-when.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.when

The moral equivalent of `if (p) exp`.

**Signature**

```ts
declare const when: { <E2 = never, R2 = never>(condition: LazyArg<boolean> | Micro<boolean, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E | E2, R | R2>; <A, E, R, E2 = never, R2 = never>(self: Micro<A, E, R>, condition: LazyArg<boolean> | Micro<boolean, E2, R2>): Micro<Option.Option<A>, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2239)

Since v3.4.0
Micro-withConcurrency.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.withConcurrency

If you have a `Micro` that uses `concurrency: "inherit"`, you can use this
api to control the concurrency of that `Micro` when it is run.

**Example**

```ts
import * as Micro from "effect/Micro"

Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {
  concurrency: "inherit"
}).pipe(
  Micro.withConcurrency(2) // use a concurrency of 2
)
```

**Signature**

```ts
declare const withConcurrency: { (concurrency: "unbounded" | number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, concurrency: "unbounded" | number): Micro<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2082)

Since v3.4.0
Micro-withMicroFiber.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.withMicroFiber

Create a `Micro` effect using the current `MicroFiber`.

**Signature**

```ts
declare const withMicroFiber: <A, E = never, R = never>(evaluate: (fiber: MicroFiberImpl<A, E>) => Micro<A, E, R>) => Micro<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1111)

Since v3.4.0
Micro-withTrace.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.withTrace

Add a stack trace to any failures that occur in the effect. The trace will be
added to the `traces` field of the `MicroCause` object.

**Signature**

```ts
declare const withTrace: { (name: string): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, name: string): Micro<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2983)

Since v3.4.0
Micro-yieldFlush.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.yieldFlush

Flush any yielded effects that are waiting to be executed.

**Signature**

```ts
declare const yieldFlush: Micro<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1127)

Since v3.4.0
Micro-yieldNow.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.yieldNow

Pause the execution of the current `Micro` effect, and resume it on the next
scheduler tick.

**Signature**

```ts
declare const yieldNow: Micro<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L930)

Since v3.4.0
Micro-yieldNowWith.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.yieldNowWith

Pause the execution of the current `Micro` effect, and resume it on the next
scheduler tick.

**Signature**

```ts
declare const yieldNowWith: (priority?: number) => Micro<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L908)

Since v3.4.0
Micro-zip.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.zip

Combine two `Micro` effects into a single effect that produces a tuple of
their results.

**Signature**

```ts
declare const zip: { <A2, E2, R2>(that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, E, R>(self: Micro<A, E, R>) => Micro<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; }): Micro<[A, A2], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2110)

Since v3.4.0
Micro-zipWith.md
Package: `effect`<br />
Module: `Micro`<br />

## Micro.zipWith

The `Micro.zipWith` function combines two `Micro` effects and allows you to
apply a function to the results of the combined effects, transforming them
into a single value.

**Signature**

```ts
declare const zipWith: { <A2, E2, R2, A, B>(that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): Micro<B, E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2137)

Since v3.4.3
Model-BooleanFromNumber.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.BooleanFromNumber

A boolean parsed from 0 or 1

**Signature**

```ts
declare class BooleanFromNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L669)

Since v1.0.0
Model-Class.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.Class

A base class used for creating domain model schemas.

It supports common variants for database and JSON apis.

**Example**

```ts
import { Schema } from "effect"
import { Model } from "@effect/sql"

export const GroupId = Schema.Number.pipe(Schema.brand("GroupId"))

export class Group extends Model.Class<Group>("Group")({
  id: Model.Generated(GroupId),
  name: Schema.NonEmptyTrimmedString,
  createdAt: Model.DateTimeInsertFromDate,
  updatedAt: Model.DateTimeUpdateFromDate
}) {}

// schema used for selects
Group

// schema used for inserts
Group.insert

// schema used for updates
Group.update

// schema used for json api
Group.json
Group.jsonCreate
Group.jsonUpdate

// you can also turn them into classes
class GroupJson extends Schema.Class<GroupJson>("GroupJson")(Group.json) {
  get upperName() {
    return this.name.toUpperCase()
  }
}
```

**Signature**

```ts
declare const Class: <Self = never>(identifier: string) => <const Fields extends VariantSchema.Struct.Fields>(fields: Fields & VariantSchema.Struct.Validate<Fields, "insert" | "update" | "json" | "jsonCreate" | "jsonUpdate" | "select">, annotations?: Schema.Annotations.Schema<Self, readonly []> | undefined) => [Self] extends [never] ? "Missing `Self` generic - use `class Self extends Class<Self>()({ ... })`" : ClassFromFields<Self, Fields, { [K in keyof VariantSchema.ExtractFields<"select", Fields, true>]: VariantSchema.ExtractFields<"select", Fields, true>[K]; }> & { readonly insert: Schema.Struct<{ [K in keyof VariantSchema.ExtractFields<"insert", Fields, false>]: VariantSchema.ExtractFields<"insert", Fields, false>[K]; }>; readonly update: Schema.Struct<{ [K in keyof VariantSchema.ExtractFields<"update", Fields, false>]: VariantSchema.ExtractFields<"update", Fields, false>[K]; }>; readonly json: Schema.Struct<{ [K in keyof VariantSchema.ExtractFields<"json", Fields, false>]: VariantSchema.ExtractFields<"json", Fields, false>[K]; }>; readonly jsonCreate: Schema.Struct<{ [K in keyof VariantSchema.ExtractFields<"jsonCreate", Fields, false>]: VariantSchema.ExtractFields<"jsonCreate", Fields, false>[K]; }>; readonly jsonUpdate: Schema.Struct<{ [K in keyof VariantSchema.ExtractFields<"jsonUpdate", Fields, false>]: VariantSchema.ExtractFields<"jsonUpdate", Fields, false>[K]; }>; readonly select: Schema.Struct<{ [K in keyof VariantSchema.ExtractFields<"select", Fields, false>]: VariantSchema.ExtractFields<"select", Fields, false>[K]; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L116)

Since v1.0.0
Model-Date.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.Date

A schema for a `DateTime.Utc` that is serialized as a date string in the
format `YYYY-MM-DD`.

**Signature**

```ts
declare const Date: Date
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L346)

Since v1.0.0
Model-DateTimeInsert.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.DateTimeInsert

A field that represents a date-time value that is inserted as the current
`DateTime.Utc`. It is serialized as a string for the database.

It is omitted from updates and is available for selection.

**Signature**

```ts
declare const DateTimeInsert: DateTimeInsert
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L430)

Since v1.0.0
Model-DateTimeInsertFromDate.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.DateTimeInsertFromDate

A field that represents a date-time value that is inserted as the current
`DateTime.Utc`. It is serialized as a `Date` for the database.

It is omitted from updates and is available for selection.

**Signature**

```ts
declare const DateTimeInsertFromDate: DateTimeInsertFromDate
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L457)

Since v1.0.0
Model-DateTimeInsertFromNumber.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.DateTimeInsertFromNumber

A field that represents a date-time value that is inserted as the current
`DateTime.Utc`. It is serialized as a `number`.

It is omitted from updates and is available for selection.

**Signature**

```ts
declare const DateTimeInsertFromNumber: DateTimeInsertFromNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L484)

Since v1.0.0
Model-DateTimeUpdate.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.DateTimeUpdate

A field that represents a date-time value that is updated as the current
`DateTime.Utc`. It is serialized as a string for the database.

It is set to the current `DateTime.Utc` on updates and inserts and is
available for selection.

**Signature**

```ts
declare const DateTimeUpdate: DateTimeUpdate
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L513)

Since v1.0.0
Model-DateTimeUpdateFromDate.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.DateTimeUpdateFromDate

A field that represents a date-time value that is updated as the current
`DateTime.Utc`. It is serialized as a `Date` for the database.

It is set to the current `DateTime.Utc` on updates and inserts and is
available for selection.

**Signature**

```ts
declare const DateTimeUpdateFromDate: DateTimeUpdateFromDate
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L543)

Since v1.0.0
Model-DateTimeUpdateFromNumber.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.DateTimeUpdateFromNumber

A field that represents a date-time value that is updated as the current
`DateTime.Utc`. It is serialized as a `number`.

It is set to the current `DateTime.Utc` on updates and inserts and is
available for selection.

**Signature**

```ts
declare const DateTimeUpdateFromNumber: DateTimeUpdateFromNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L573)

Since v1.0.0
Model-FieldOption.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.FieldOption

Convert a field to one that is optional for all variants.

For the database variants, it will accept `null`able values.
For the JSON variants, it will also accept missing keys.

**Signature**

```ts
export interface FieldOption<S extends Schema.Schema.Any> extends
  VariantSchema.Field<{
    readonly select: Schema.OptionFromNullOr<S>
    readonly insert: Schema.OptionFromNullOr<S>
    readonly update: Schema.OptionFromNullOr<S>
    readonly json: Schema.optionalWith<S, { as: "Option" }>
    readonly jsonCreate: Schema.optionalWith<S, { as: "Option"; nullable: true }>
    readonly jsonUpdate: Schema.optionalWith<S, { as: "Option"; nullable: true }>
  }>
{}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L269)

Since v1.0.0
Model-Generated.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.Generated

A field that represents a column that is generated by the database.

It is available for selection and update, but not for insertion.

**Signature**

```ts
declare const Generated: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Generated<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L191)

Since v1.0.0
Model-GeneratedByApp.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.GeneratedByApp

A field that represents a column that is generated by the application.

It is required by the database, but not by the JSON variants.

**Signature**

```ts
declare const GeneratedByApp: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => GeneratedByApp<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L222)

Since v1.0.0
Model-JsonFromString.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.JsonFromString

A field that represents a JSON value stored as text in the database.

The "json" variants will use the object schema directly.

**Signature**

```ts
declare const JsonFromString: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => JsonFromString<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L604)

Since v1.0.0
Model-Sensitive.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.Sensitive

A field that represents a sensitive value that should not be exposed in the
JSON variants.

**Signature**

```ts
declare const Sensitive: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Sensitive<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L251)

Since v1.0.0
Model-UuidV4Insert.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.UuidV4Insert

A field that represents a binary UUID v4 that is generated on inserts.

**Signature**

```ts
declare const UuidV4Insert: <const B extends string | symbol>(schema: Schema.brand<typeof Schema.Uint8ArrayFromSelf, B>) => UuidV4Insert<B>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L653)

Since v1.0.0
Model-makeDataLoaders.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.makeDataLoaders

Create some simple data loaders from a model.

**Signature**

```ts
declare const makeDataLoaders: <S extends AnyNoContext, Id extends (keyof S["Type"]) & (keyof S["update"]["Type"]) & (keyof S["fields"])>(Model: S, options: { readonly tableName: string; readonly spanPrefix: string; readonly idColumn: Id; readonly window: DurationInput; readonly maxBatchSize?: number | undefined; }) => Effect.Effect<{ readonly insert: (insert: S["insert"]["Type"]) => Effect.Effect<S["Type"]>; readonly insertVoid: (insert: S["insert"]["Type"]) => Effect.Effect<void>; readonly findById: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<Option.Option<S["Type"]>>; readonly delete: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<void>; }, never, SqlClient | Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L846)

Since v1.0.0
Model-makeRepository.md
Package: `@effect/sql`<br />
Module: `Model`<br />

## Model.makeRepository

Create a simple CRUD repository from a model.

**Signature**

```ts
declare const makeRepository: <S extends Any, Id extends (keyof S["Type"]) & (keyof S["update"]["Type"]) & (keyof S["fields"])>(Model: S, options: { readonly tableName: string; readonly spanPrefix: string; readonly idColumn: Id; }) => Effect.Effect<{ readonly insert: (insert: S["insert"]["Type"]) => Effect.Effect<S["Type"], never, S["Context"] | S["insert"]["Context"]>; readonly insertVoid: (insert: S["insert"]["Type"]) => Effect.Effect<void, never, S["Context"] | S["insert"]["Context"]>; readonly update: (update: S["update"]["Type"]) => Effect.Effect<S["Type"], never, S["Context"] | S["update"]["Context"]>; readonly updateVoid: (update: S["update"]["Type"]) => Effect.Effect<void, never, S["Context"] | S["update"]["Context"]>; readonly findById: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<Option.Option<S["Type"]>, never, S["Context"] | Schema.Schema.Context<S["fields"][Id]>>; readonly delete: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<void, never, Schema.Schema.Context<S["fields"][Id]>>; }, never, SqlClient>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/Model.ts#L684)

Since v1.0.0
Monoid-array.md
Package: `@effect/typeclass`<br />
Module: `Monoid`<br />

## Monoid.array

Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.

The `empty` value is the empty array.

**Signature**

```ts
declare const array: <A>() => Monoid<ReadonlyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Monoid.ts#L88)

Since v0.24.0
Monoid-max.md
Package: `@effect/typeclass`<br />
Module: `Monoid`<br />

## Monoid.max

Get a monoid where `combine` will return the maximum, based on the provided bounded order.

The `empty` value is the `minimum` value.

**Signature**

```ts
declare const max: <A>(B: Bounded<A>) => Monoid<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Monoid.ts#L46)

Since v0.24.0
Monoid-min.md
Package: `@effect/typeclass`<br />
Module: `Monoid`<br />

## Monoid.min

Get a monoid where `combine` will return the minimum, based on the provided bounded order.

The `empty` value is the `maxBound` value.

**Signature**

```ts
declare const min: <A>(B: Bounded<A>) => Monoid<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Monoid.ts#L36)

Since v0.24.0
Monoid-reverse.md
Package: `@effect/typeclass`<br />
Module: `Monoid`<br />

## Monoid.reverse

The dual of a `Monoid`, obtained by swapping the arguments of `combine`.

**Signature**

```ts
declare const reverse: <A>(M: Monoid<A>) => Monoid<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Monoid.ts#L54)

Since v0.24.0
Monoid-struct.md
Package: `@effect/typeclass`<br />
Module: `Monoid`<br />

## Monoid.struct

This function creates and returns a new `Monoid` for a struct of values based on the given `Monoid`s for each property in the struct.
The returned `Monoid` combines two structs of the same type by applying the corresponding `Monoid` passed as arguments to each property in the struct.

The `empty` value of the returned `Monoid` is a struct where each property is the `empty` value of the corresponding `Monoid` in the input `monoids` object.

It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.

**Signature**

```ts
declare const struct: <R extends { readonly [x: string]: Monoid<any>; }>(fields: R) => Monoid<{ readonly [K in keyof R]: [R[K]] extends [Monoid<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Monoid.ts#L101)

Since v0.24.0
Monoid-tuple.md
Package: `@effect/typeclass`<br />
Module: `Monoid`<br />

## Monoid.tuple

Similar to `Promise.all` but operates on `Monoid`s.

```
[Monoid<A>, Monoid<B>, ...] -> Monoid<[A, B, ...]>
```

This function creates and returns a new `Monoid` for a tuple of values based on the given `Monoid`s for each element in the tuple.
The returned `Monoid` combines two tuples of the same type by applying the corresponding `Monoid` passed as arguments to each element in the tuple.

The `empty` value of the returned `Monoid` is the tuple of `empty` values of the input `Monoid`s.

It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.

**Signature**

```ts
declare const tuple: <T extends ReadonlyArray<Monoid<any>>>(...elements: T) => Monoid<{ readonly [I in keyof T]: [T[I]] extends [Monoid<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Monoid.ts#L73)

Since v0.24.0
MutableHashMap-fromIterable.md
Package: `effect`<br />
Module: `MutableHashMap`<br />

## MutableHashMap.fromIterable

Creates a new `MutableHashMap` from an iterable collection of key/value pairs.

**Signature**

```ts
declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => MutableHashMap<K, V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L130)

Since v2.0.0
MutableHashMap-modify.md
Package: `effect`<br />
Module: `MutableHashMap`<br />

## MutableHashMap.modify

Updates the value of the specified key within the `MutableHashMap` if it exists.

**Signature**

```ts
declare const modify: { <K, V>(key: K, f: (v: V) => V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V): MutableHashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L270)

Since v2.0.0
MutableHashMap-modifyAt.md
Package: `effect`<br />
Module: `MutableHashMap`<br />

## MutableHashMap.modifyAt

Set or remove the specified key in the `MutableHashMap` using the specified
update function.

**Signature**

```ts
declare const modifyAt: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): MutableHashMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L305)

Since v2.0.0
MutableHashSet-add.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.add

**Checks** whether the `MutableHashSet` contains the given element, and
**adds** it if not.

Time complexity: **`O(1)`** average

**Syntax**

```ts
import { MutableHashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(
  MutableHashSet.empty(),
  MutableHashSet.add(0),
  MutableHashSet.add(0)
)

// or piped with the pipe function
MutableHashSet.empty().pipe(MutableHashSet.add(0))

// or with data-first API
MutableHashSet.add(MutableHashSet.empty(), 0)
```

**See**

- Other `MutableHashSet` elements are `module:MutableHashSet.remove` `module:MutableHashSet.size` `module:MutableHashSet.clear` `module:MutableHashSet.has`

**Signature**

```ts
declare const add: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L402)

Since v2.0.0
MutableHashSet-clear.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.clear

Removes all values from the `MutableHashSet`.

This function operates by delegating the clearing action to the underlying
key map associated with the given `MutableHashSet`. It ensures that the hash
set becomes empty while maintaining its existence and structure.

**Example**

```ts
import { MutableHashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.deepStrictEqual(
  pipe(
    MutableHashSet.make(1, 2, 3, 4),
    MutableHashSet.clear,
    MutableHashSet.size
  ),
  0
)
```

**See**

- Other `MutableHashSet` elements are `module:MutableHashSet.add` `module:MutableHashSet.has` `module:MutableHashSet.remove` `module:MutableHashSet.size`

**Signature**

```ts
declare const clear: <V>(self: MutableHashSet<V>) => MutableHashSet<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L704)

Since v2.0.0
MutableHashSet-empty.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.empty

Creates an empty mutable hash set.

This function initializes and returns an empty `MutableHashSet` instance,
which allows for efficient storage and manipulation of unique elements.

Time complexity: **`O(1)`**

**Example**

```ts
import { MutableHashSet } from "effect"

type T = unknown // replace with your type

// in places where the type can't be inferred, replace with your type
const set: MutableHashSet.MutableHashSet<T> = MutableHashSet.empty<T>()
```

**See**

- Other `MutableHashSet` constructors are `module:MutableHashSet.make` `module:MutableHashSet.fromIterable`

**Signature**

```ts
declare const empty: <K = never>() => MutableHashSet<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L179)

Since v2.0.0
MutableHashSet-fromIterable.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.fromIterable

Creates a new `MutableHashSet` from an iterable collection of values.
Duplicate values are omitted.

Time complexity: **`O(n)`** where n is the number of elements in the iterable

Creating a `MutableHashSet` from an `Array`

```ts
import { MutableHashSet } from "effect"

const array: Iterable<number> = [1, 2, 3, 4, 5, 1, 2, 3] // Array<T> is also Iterable<T>
const mutableHashSet: MutableHashSet.MutableHashSet<number> =
  MutableHashSet.fromIterable(array)

console.log(
  // MutableHashSet.MutableHashSet<T> is also an Iterable<T>
  Array.from(mutableHashSet)
) // Output: [1, 2, 3, 4, 5]
```

Creating a `MutableHashSet` from a `Set`

```ts
import { MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    // Set<string> is an Iterable<string>
    new Set(["apple", "banana", "orange", "apple"]),
    // constructs MutableHashSet from an Iterable Set
    MutableHashSet.fromIterable,
    // since MutableHashSet it is itself an Iterable, we can pass it to other functions expecting an Iterable
    Array.from
  )
) // Output: ["apple", "banana", "orange"]
```

Creating a `MutableHashSet` from a `Generator`

```ts
import { MutableHashSet } from "effect"

// Generator functions return iterables
function* fibonacci(n: number): Generator<number, void, never> {
  let [a, b] = [0, 1]
  for (let i = 0; i < n; i++) {
    yield a
    ;[a, b] = [b, a + b]
  }
}

// Create a MutableHashSet from the first 10 Fibonacci numbers
const fibonacciSet = MutableHashSet.fromIterable(fibonacci(10))

console.log(Array.from(fibonacciSet))
// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order
```

Creating a `MutableHashSet` from another `module:MutableHashSet`

```ts
import { MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    MutableHashSet.make(1, 2, 3, 4),
    MutableHashSet.fromIterable,
    Array.from
  )
) // Output: [1, 2, 3, 4]
```

Creating a `MutableHashSet` from an `module:HashSet`

```ts
import { HashSet, MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    HashSet.make(1, 2, 3, 4), // it works also with its immutable HashSet sibling
    MutableHashSet.fromIterable,
    Array.from
  )
) // Output: [1, 2, 3, 4]
```

Creating a `MutableHashSet` from other Effect's data structures like
`Chunk`

```ts
import { Chunk, MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    Chunk.make(1, 2, 3, 4), //  Chunk is also an Iterable<T>
    MutableHashSet.fromIterable,
    Array.from
  )
) // Outputs: [1, 2, 3, 4]
```

**See**

- Other `MutableHashSet` constructors are `module:MutableHashSet.empty` `module:MutableHashSet.make`

**Signature**

```ts
declare const fromIterable: <K = never>(keys: Iterable<K>) => MutableHashSet<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L294)

Since v2.0.0
MutableHashSet-has.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.has

Checks if the specified value exists in the `MutableHashSet`.

Time complexity: `O(1)` average

**Syntax**

```ts
import { MutableHashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.equal(
  // with `data-last`, a.k.a. `pipeable` API
  pipe(MutableHashSet.make(0, 1, 2), MutableHashSet.has(3)),
  false
)

assert.equal(
  // or piped with the pipe function
  MutableHashSet.make(0, 1, 2).pipe(MutableHashSet.has(3)),
  false
)

assert.equal(
  // or with `data-first` API
  MutableHashSet.has(MutableHashSet.make(0, 1, 2), 3),
  false
)
```

**See**

- Other `MutableHashSet` elements are `module:MutableHashSet.add` `module:MutableHashSet.remove` `module:MutableHashSet.size` `module:MutableHashSet.clear`

**Signature**

```ts
declare const has: { <V>(key: V): (self: MutableHashSet<V>) => boolean; <V>(self: MutableHashSet<V>, key: V): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L501)

Since v2.0.0
MutableHashSet-make.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.make

Construct a new `MutableHashSet` from a variable number of values.

Time complexity: **`O(n)`** where n is the number of elements

**Example**

```ts
import { Equal, Hash, MutableHashSet } from "effect"
import assert from "node:assert/strict"

class Character implements Equal.Equal {
  readonly name: string
  readonly trait: string

  constructor(name: string, trait: string) {
    this.name = name
    this.trait = trait
  }

  // Define equality based on name, and trait
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Character) {
      return (
        Equal.equals(this.name, that.name) &&
        Equal.equals(this.trait, that.trait)
      )
    }
    return false
  }

  // Generate a hash code based on the sum of the character's name and trait
  [Hash.symbol](): number {
    return Hash.hash(this.name + this.trait)
  }

  static readonly of = (name: string, trait: string): Character => {
    return new Character(name, trait)
  }
}

const mutableCharacterHashSet = MutableHashSet.make(
  Character.of("Alice", "Curious"),
  Character.of("Alice", "Curious"),
  Character.of("White Rabbit", "Always late"),
  Character.of("Mad Hatter", "Tea enthusiast")
)

assert.equal(
  MutableHashSet.has(
    mutableCharacterHashSet,
    Character.of("Alice", "Curious")
  ),
  true
)
assert.equal(
  MutableHashSet.has(
    mutableCharacterHashSet,
    Character.of("Fluffy", "Kind")
  ),
  false
)
```

**See**

- Other `MutableHashSet` constructors are `module:MutableHashSet.fromIterable` `module:MutableHashSet.empty`

**Signature**

```ts
declare const make: <Keys extends ReadonlyArray<unknown>>(...keys: Keys) => MutableHashSet<Keys[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L368)

Since v2.0.0
MutableHashSet-remove.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.remove

Removes a value from the `MutableHashSet`.

Time complexity: **`O(1)`** average

**Syntax**

```ts
import { MutableHashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.equal(
  // with `data-last`, a.k.a. `pipeable` API
  pipe(
    MutableHashSet.make(0, 1, 2),
    MutableHashSet.remove(0),
    MutableHashSet.has(0)
  ),
  false
)

assert.equal(
  // or piped with the pipe function
  MutableHashSet.make(0, 1, 2).pipe(
    MutableHashSet.remove(0),
    MutableHashSet.has(0)
  ),
  false
)

assert.equal(
  // or with `data-first` API
  MutableHashSet.remove(MutableHashSet.make(0, 1, 2), 0).pipe(
    MutableHashSet.has(0)
  ),
  false
)
```

**See**

- Other `MutableHashSet` elements are `module:MutableHashSet.add` `module:MutableHashSet.has` `module:MutableHashSet.size` `module:MutableHashSet.clear`

**Signature**

```ts
declare const remove: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L584)

Since v2.0.0
MutableHashSet-size.md
Package: `effect`<br />
Module: `MutableHashSet`<br />

## MutableHashSet.size

Calculates the number of values in the `HashSet`.

Time complexity: **`O(1)`**

**Example**

```ts
import { MutableHashSet } from "effect"
import assert from "node:assert/strict"

assert.equal(MutableHashSet.size(MutableHashSet.empty()), 0)

assert.equal(
  MutableHashSet.size(MutableHashSet.make(1, 2, 2, 3, 4, 3)),
  4
)
```

**See**

- Other `MutableHashSet` elements are `module:MutableHashSet.add` `module:MutableHashSet.has` `module:MutableHashSet.remove` `module:MutableHashSet.clear`

**Signature**

```ts
declare const size: <V>(self: MutableHashSet<V>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L672)

Since v2.0.0
MutableList-append.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.append

Appends the specified element to the end of the `MutableList`.

**Signature**

```ts
declare const append: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L200)

Since v2.0.0
MutableList-empty.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.empty

Creates an empty `MutableList`.

**Signature**

```ts
declare const empty: <A = never>() => MutableList<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L100)

Since v2.0.0
MutableList-forEach.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.forEach

Executes the specified function `f` for each element in the list.

**Signature**

```ts
declare const forEach: { <A>(f: (element: A) => void): (self: MutableList<A>) => void; <A>(self: MutableList<A>, f: (element: A) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L168)

Since v2.0.0
MutableList-fromIterable.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.fromIterable

Creates a new `MutableList` from an iterable collection of values.

**Signature**

```ts
declare const fromIterable: <A>(iterable: Iterable<A>) => MutableList<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L114)

Since v2.0.0
MutableList-head.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.head

Returns the first element of the list, if it exists.

**Signature**

```ts
declare const head: <A>(self: MutableList<A>) => A | undefined
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L160)

Since v2.0.0
MutableList-isEmpty.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.isEmpty

Returns `true` if the list contains zero elements, `false`, otherwise.

**Signature**

```ts
declare const isEmpty: <A>(self: MutableList<A>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L136)

Since v2.0.0
MutableList-length.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.length

Returns the length of the list.

**Signature**

```ts
declare const length: <A>(self: MutableList<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L144)

Since v2.0.0
MutableList-make.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.make

Creates a new `MutableList` from the specified elements.

**Signature**

```ts
declare const make: <A>(...elements: ReadonlyArray<A>) => MutableList<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L128)

Since v2.0.0
MutableList-pop.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.pop

Removes the last value from the list and returns it, if it exists.

**Signature**

```ts
declare const pop: <A>(self: MutableList<A>) => A | undefined
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L241)

Since v0.0.1
MutableList-prepend.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.prepend

Prepends the specified value to the beginning of the list.

**Signature**

```ts
declare const prepend: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L256)

Since v2.0.0
MutableList-reset.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.reset

Removes all elements from the doubly-linked list.

**Signature**

```ts
declare const reset: <A>(self: MutableList<A>) => MutableList<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L187)

Since v2.0.0
MutableList-shift.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.shift

Removes the first value from the list and returns it, if it exists.

**Signature**

```ts
declare const shift: <A>(self: MutableList<A>) => A | undefined
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L227)

Since v0.0.1
MutableList-tail.md
Package: `effect`<br />
Module: `MutableList`<br />

## MutableList.tail

Returns the last element of the list, if it exists.

**Signature**

```ts
declare const tail: <A>(self: MutableList<A>) => A | undefined
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L152)

Since v2.0.0
MutableQueue-bounded.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.bounded

Creates a new bounded `MutableQueue`.

**Signature**

```ts
declare const bounded: <A>(capacity: number) => MutableQueue<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L83)

Since v2.0.0
MutableQueue-capacity.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.capacity

The **maximum** number of elements that a queue can hold.

**Note**: unbounded queues can still implement this interface with
`capacity = Infinity`.

**Signature**

```ts
declare const capacity: <A>(self: MutableQueue<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L127)

Since v2.0.0
MutableQueue-isEmpty.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.isEmpty

Returns `true` if the queue is empty, `false` otherwise.

**Signature**

```ts
declare const isEmpty: <A>(self: MutableQueue<A>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L107)

Since v2.0.0
MutableQueue-isFull.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.isFull

Returns `true` if the queue is full, `false` otherwise.

**Signature**

```ts
declare const isFull: <A>(self: MutableQueue<A>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L115)

Since v2.0.0
MutableQueue-length.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.length

Returns the current number of elements in the queue.

**Signature**

```ts
declare const length: <A>(self: MutableQueue<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L99)

Since v2.0.0
MutableQueue-offer.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.offer

Offers an element to the queue.

Returns whether the enqueue was successful or not.

**Signature**

```ts
declare const offer: { <A>(self: MutableQueue<A>, value: A): boolean; <A>(value: A): (self: MutableQueue<A>) => boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L136)

Since v2.0.0
MutableQueue-offerAll.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.offerAll

Enqueues a collection of values into the queue.

Returns a `Chunk` of the values that were **not** able to be enqueued.

**Signature**

```ts
declare const offerAll: { <A>(values: Iterable<A>): (self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, values: Iterable<A>): Chunk.Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L158)

Since v2.0.0
MutableQueue-poll.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.poll

Dequeues an element from the queue.

Returns either an element from the queue, or the `def` param.

**Note**: if there is no meaningful default for your type, you can always
use `poll(MutableQueue.EmptyMutableQueue)`.

**Signature**

```ts
declare const poll: { <D>(def: D): <A>(self: MutableQueue<A>) => D | A; <A, D>(self: MutableQueue<A>, def: D): A | D; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L189)

Since v2.0.0
MutableQueue-pollUpTo.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.pollUpTo

Dequeues up to `n` elements from the queue.

Returns a `List` of up to `n` elements.

**Signature**

```ts
declare const pollUpTo: { (n: number): <A>(self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, n: number): Chunk.Chunk<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L209)

Since v2.0.0
MutableQueue-unbounded.md
Package: `effect`<br />
Module: `MutableQueue`<br />

## MutableQueue.unbounded

Creates a new unbounded `MutableQueue`.

**Signature**

```ts
declare const unbounded: <A>() => MutableQueue<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L91)

Since v2.0.0
Ndjson-NdjsonOptions.md
Package: `@effect/platform`<br />
Module: `Ndjson`<br />

## Ndjson.NdjsonOptions

Represents a set of options which can be used to control how the newline
delimited JSON is handled.

**Signature**

```ts
export interface NdjsonOptions {
  /**
   * Whether or not the newline delimited JSON parser should ignore empty lines.
   *
   * Defaults to `false`.
   *
   * From the [newline delimited JSON spec](https://github.com/ndjson/ndjson-spec):
   * ```text
   * The parser MAY silently ignore empty lines, e.g. \n\n. This behavior MUST
   * be documented and SHOULD be configurable by the user of the parser.
   * ```
   *
   * @since 1.0.0
   */
  readonly ignoreEmptyLines?: boolean
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Ndjson.ts#L48)

Since v1.0.0
NodeFileSystem-ParcelWatcher-layer.md
Package: `@effect/platform-node-shared`<br />
Module: `ParcelWatcher`<br />

## ParcelWatcher.layer

You can provide this Layer to use `@parcel/watcher` as the backend for watching files.

**Signature**

```ts
declare const layer: Layer<WatchBackend, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node-shared/src/ParcelWatcher.ts#L15)

Since v1.0.0
NodeHttpServer-layerContext.md
Package: `@effect/platform-node`<br />
Module: `NodeHttpServer`<br />

## NodeHttpServer.layerContext

A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`
services.

The `FileSystem` service is a no-op implementation, so this layer is only
useful for platforms that have no file system.

**Signature**

```ts
declare const layerContext: Layer.Layer<Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/NodeHttpServer.ts#L130)

Since v1.0.0
NodeHttpServer-layerTest.md
Package: `@effect/platform-node`<br />
Module: `NodeHttpServer`<br />

## NodeHttpServer.layerTest

Layer starting a server on a random port and producing an `HttpClient`
with prepended url of the running http server.

**Example**

```ts
import * as assert from "node:assert"
import { HttpClient, HttpRouter, HttpServer } from "@effect/platform"
import { NodeHttpServer } from "@effect/platform-node"
import { Effect } from "effect"

Effect.gen(function*() {
  yield* HttpServer.serveEffect(HttpRouter.empty)
  const response = yield* HttpClient.get("/")
  assert.strictEqual(response.status, 404)
}).pipe(Effect.provide(NodeHttpServer.layerTest))
```

**Signature**

```ts
declare const layerTest: Layer.Layer<Server.HttpServer | Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext | HttpClient.HttpClient, ServeError, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-node/src/NodeHttpServer.ts#L111)

Since v1.0.0
Number-between.md
Package: `effect`<br />
Module: `Number`<br />

## Number.between

Checks if a `number` is between a `minimum` and `maximum` value (inclusive).

**Example**

```ts
import * as assert from "node:assert/strict"
import { Number } from "effect"

const between = Number.between({ minimum: 0, maximum: 5 })

assert.equal(between(3), true)
assert.equal(between(-1), false)
assert.equal(between(6), false)
```

**Signature**

```ts
declare const between: { (options: { minimum: number; maximum: number; }): (self: number) => boolean; (self: number, options: { minimum: number; maximum: number; }): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L854)

Since v2.0.0
Number-clamp.md
Package: `effect`<br />
Module: `Number`<br />

## Number.clamp

Restricts the given `number` to be within the range specified by the
`minimum` and `maximum` values.

- If the `number` is less than the `minimum` value, the function returns the
  `minimum` value.
- If the `number` is greater than the `maximum` value, the function returns the
  `maximum` value.
- Otherwise, it returns the original `number`.

**Example**

```ts
import * as assert from "node:assert/strict"
import { Number } from "effect"

const clamp = Number.clamp({ minimum: 1, maximum: 5 })

assert.equal(clamp(3), 3)
assert.equal(clamp(0), 1)
assert.equal(clamp(6), 5)
```

**Signature**

```ts
declare const clamp: { (options: { minimum: number; maximum: number; }): (self: number) => number; (self: number, options: { minimum: number; maximum: number; }): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L890)

Since v2.0.0
Number-decrement.md
Package: `effect`<br />
Module: `Number`<br />

## Number.decrement

Decrements a number by `1`.

**Example**

```ts
import * as assert from "node:assert/strict"
import { decrement } from "effect/Number"

assert.equal(decrement(3), 2)
```

**Signature**

```ts
declare const decrement: (n: number) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L727)

Since v2.0.0
Number-divide.md
Package: `effect`<br />
Module: `Number`<br />

## Number.divide

Performs division in the set of JavaScript numbers, returning the result
wrapped in an `Option` to handle division by zero.

**Example**

```ts
import * as assert from "node:assert/strict"
import { pipe, Option } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.divide(6, 3), Option.some(2)) // 6  3 = 2
assert.equal(Number.divide(-8, 4), Option.some(-2)) // (-8)  4 = -2
assert.equal(Number.divide(-10, -5), Option.some(2)) // (-10)  (-5) = 2
assert.equal(Number.divide(1, 3), Option.some(0.3333333333333333)) // Note: floating-point approximation

// Handling division by zero
assert.equal(Number.divide(6, 0), Option.none()) // 6  0 is undefined

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.divide(2) // 10  2 = 5
  ),
  Option.some(5)
)

// Chaining multiple divisions using Option combinators
assert.equal(
  pipe(
    Option.some(24),
    Option.flatMap((n) => Number.divide(n, 2)), // 24  2 = 12
    Option.flatMap(Number.divide(3)), // 12  3 = 4
    Option.flatMap(Number.divide(2)) // 4  2 = 2
  ),
  Option.some(2)
)

// Division-by-one property: a  1 = a
assert.equal(Number.divide(42, 1), Option.some(42))

// Self-division property: a  a = 1 (for a  0)
assert.equal(Number.divide(42, 42), Option.some(1))

// Non-commutative property: a  b  b  a
assert.notDeepStrictEqual(
  Number.divide(6, 3), // 6  3 = 2
  Number.divide(3, 6) // 3  6 = 0.5
)
```

**Signature**

```ts
declare const divide: { (divisor: number): (dividend: number) => Option<number>; (dividend: number, divisor: number): Option<number>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L589)

Since v2.0.0
Number-greaterThan.md
Package: `effect`<br />
Module: `Number`<br />

## Number.greaterThan

Returns `true` if the first argument is greater than the second, otherwise
`false`.

**Example**

```ts
import * as assert from "node:assert/strict"
import { greaterThan } from "effect/Number"

assert.equal(greaterThan(2, 3), false)
assert.equal(greaterThan(3, 3), false)
assert.equal(greaterThan(4, 3), true)
```

**Signature**

```ts
declare const greaterThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L807)

Since v2.0.0
Number-greaterThanOrEqualTo.md
Package: `effect`<br />
Module: `Number`<br />

## Number.greaterThanOrEqualTo

Returns a function that checks if a given `number` is greater than or equal
to the provided one.

**Example**

```ts
import * as assert from "node:assert/strict"
import { greaterThanOrEqualTo } from "effect/Number"

assert.equal(greaterThanOrEqualTo(2, 3), false)
assert.equal(greaterThanOrEqualTo(3, 3), true)
assert.equal(greaterThanOrEqualTo(4, 3), true)
```

**Signature**

```ts
declare const greaterThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L830)

Since v2.0.0
Number-increment.md
Package: `effect`<br />
Module: `Number`<br />

## Number.increment

Returns the result of adding `1` to a given number.

**Example**

```ts
import * as assert from "node:assert/strict"
import { increment } from "effect/Number"

assert.equal(increment(2), 3)
```

**Signature**

```ts
declare const increment: (n: number) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L710)

Since v2.0.0
Number-isNumber.md
Package: `effect`<br />
Module: `Number`<br />

## Number.isNumber

Type guard that tests if a value is a member of the set of JavaScript
numbers.

**Example**

```ts
import * as assert from "node:assert/strict"
import * as Number from "effect/Number"

// Regular numbers
assert.equal(Number.isNumber(2), true)
assert.equal(Number.isNumber(-3.14), true)
assert.equal(Number.isNumber(0), true)

// Special numeric values
assert.equal(Number.isNumber(Infinity), true)
assert.equal(Number.isNumber(NaN), true)

// Non-number values
assert.equal(Number.isNumber("2"), false)
assert.equal(Number.isNumber(true), false)
assert.equal(Number.isNumber(null), false)
assert.equal(Number.isNumber(undefined), false)
assert.equal(Number.isNumber({}), false)
assert.equal(Number.isNumber([]), false)

// Using as a type guard in conditionals
function processValue(value: unknown): string {
  if (Number.isNumber(value)) {
    // TypeScript now knows 'value' is a number
    return `Numeric value: ${value.toFixed(2)}`
  }
  return "Not a number"
}

assert.strictEqual(processValue(42), "Numeric value: 42.00")
assert.strictEqual(processValue("hello"), "Not a number")

// Filtering for numbers in an array
const mixed = [1, "two", 3, false, 5]
const onlyNumbers = mixed.filter(Number.isNumber)
assert.equal(onlyNumbers, [1, 3, 5])
```

**Signature**

```ts
declare const isNumber: (input: unknown) => input is number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L160)

Since v2.0.0
Number-lessThan.md
Package: `effect`<br />
Module: `Number`<br />

## Number.lessThan

Returns `true` if the first argument is less than the second, otherwise
`false`.

**Example**

```ts
import * as assert from "node:assert/strict"
import { lessThan } from "effect/Number"

assert.equal(lessThan(2, 3), true)
assert.equal(lessThan(3, 3), false)
assert.equal(lessThan(4, 3), false)
```

**Signature**

```ts
declare const lessThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L761)

Since v2.0.0
Number-lessThanOrEqualTo.md
Package: `effect`<br />
Module: `Number`<br />

## Number.lessThanOrEqualTo

Returns a function that checks if a given `number` is less than or equal to
the provided one.

**Example**

```ts
import * as assert from "node:assert/strict"
import { lessThanOrEqualTo } from "effect/Number"

assert.equal(lessThanOrEqualTo(2, 3), true)
assert.equal(lessThanOrEqualTo(3, 3), true)
assert.equal(lessThanOrEqualTo(4, 3), false)
```

**Signature**

```ts
declare const lessThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L784)

Since v2.0.0
Number-max.md
Package: `effect`<br />
Module: `Number`<br />

## Number.max

Returns the maximum between two `number`s.

**Example**

```ts
import * as assert from "node:assert/strict"
import { max } from "effect/Number"

assert.equal(max(2, 3), 3)
```

**Signature**

```ts
declare const max: { (that: number): (self: number) => number; (self: number, that: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L934)

Since v2.0.0
Number-min.md
Package: `effect`<br />
Module: `Number`<br />

## Number.min

Returns the minimum between two `number`s.

**Example**

```ts
import * as assert from "node:assert/strict"
import { min } from "effect/Number"

assert.equal(min(2, 3), 2)
```

**Signature**

```ts
declare const min: { (that: number): (self: number) => number; (self: number, that: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L915)

Since v2.0.0
Number-multiply.md
Package: `effect`<br />
Module: `Number`<br />

## Number.multiply

Performs **multiplication** in the set of JavaScript numbers.

**Example**

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.multiply(2, 3), 6) // 2  3 = 6
assert.equal(Number.multiply(-4, 5), -20) // (-4)  5 = -20
assert.equal(Number.multiply(-3, -2), 6) // (-3)  (-2) = 6
assert.equal(Number.multiply(0.1, 0.2), 0.020000000000000004) // Note: floating-point precision limitation

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.multiply(5) // 10  5 = 50
  ),
  50
)

// Chaining multiple multiplications
assert.equal(
  pipe(
    2,
    Number.multiply(3), // 2  3 = 6
    Number.multiply(4), // 6  4 = 24
    Number.multiply(0.5) // 24  0.5 = 12
  ),
  12
)

// Identity property: a  1 = a
assert.equal(Number.multiply(42, 1), 42)

// Zero property: a  0 = 0
assert.equal(Number.multiply(42, 0), 0)

// Commutative property: a  b = b  a
assert.equal(Number.multiply(5, 3), Number.multiply(3, 5))

// Associative property: (a  b)  c = a  (b  c)
const a = 2,
  b = 3,
  c = 4
assert.equal(
  Number.multiply(Number.multiply(a, b), c),
  Number.multiply(a, Number.multiply(b, c))
)
```

**Signature**

```ts
declare const multiply: { (multiplicand: number): (multiplier: number) => number; (multiplier: number, multiplicand: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L450)

Since v2.0.0
Number-multiplyAll.md
Package: `effect`<br />
Module: `Number`<br />

## Number.multiplyAll

Computes the product of all elements in an iterable collection of numbers.

**Example**

```ts
import * as assert from "node:assert/strict"
import * as Number from "effect/Number"

// Basic products
assert.equal(Number.multiplyAll([2, 3, 4]), 24) // 2  3  4 = 24
assert.equal(Number.multiplyAll([1.5, 2, 3]), 9) // 1.5  2  3 = 9

// Empty collection returns the multiplicative identity (1)
assert.equal(Number.multiplyAll([]), 1)

// Single element collection
assert.equal(Number.multiplyAll([42]), 42)

// Products with negative numbers
assert.equal(Number.multiplyAll([2, -3, 4]), -24) // 2  (-3)  4 = -24
assert.equal(Number.multiplyAll([-2, -3]), 6) // (-2)  (-3) = 6

// Zero property - if any element is zero, product is zero
assert.equal(Number.multiplyAll([2, 0, 3]), 0)

// Works with any iterable
assert.equal(Number.multiplyAll(new Set([2, 3, 4])), 24)

// Using with generated sequences
function* range(start: number, end: number) {
  for (let i = start; i <= end; i++) yield i
}

// Compute factorial: 5! = 5  4  3  2  1 = 120
assert.equal(Number.multiplyAll(range(1, 5)), 120)
```

**Signature**

```ts
declare const multiplyAll: (collection: Iterable<number>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L522)

Since v2.0.0
Number-negate.md
Package: `effect`<br />
Module: `Number`<br />

## Number.negate

Returns the additive inverse of a number, effectively negating it.

**Example**

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

assert.equal(
  Number.negate(5), //
  -5
)

assert.equal(
  Number.negate(-5), //
  5
)

assert.equal(
  Number.negate(0), //
  0
)
```

**Signature**

```ts
declare const negate: (n: number) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L194)

Since v3.14.6
Number-nextPow2.md
Package: `effect`<br />
Module: `Number`<br />

## Number.nextPow2

Returns the next power of 2 greater than or equal to the given number.

- For `positive` inputs, returns the smallest power of 2 that is >= the input
- For `zero`, returns 2
- For `negative` inputs, returns NaN (as logarithms of negative numbers are
  undefined)
- For `NaN` input, returns NaN
- For `Infinity`, returns Infinity

**Example**

```ts
import * as assert from "node:assert/strict"
import { nextPow2 } from "effect/Number"

assert.equal(nextPow2(5), 8)
assert.equal(nextPow2(17), 32)
assert.equal(nextPow2(0), 2)
assert.equal(Number.isNaN(nextPow2(-1)), true) // Negative inputs result in NaN
```

**Signature**

```ts
declare const nextPow2: (n: number) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L1016)

Since v2.0.0
Number-parse.md
Package: `effect`<br />
Module: `Number`<br />

## Number.parse

Tries to parse a `number` from a `string` using the `Number()` function. The
following special string values are supported: "NaN", "Infinity",
"-Infinity".

**Signature**

```ts
declare const parse: (s: string) => Option<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L1030)

Since v2.0.0
Number-remainder.md
Package: `effect`<br />
Module: `Number`<br />

## Number.remainder

Returns the remainder left over when one operand is divided by a second
operand.

It always takes the sign of the dividend.

**Example**

```ts
import * as assert from "node:assert/strict"
import { remainder } from "effect/Number"

assert.equal(remainder(2, 2), 0)
assert.equal(remainder(3, 2), 1)
assert.equal(remainder(-4, 2), -0)
```

**Signature**

```ts
declare const remainder: { (divisor: number): (dividend: number) => number; (dividend: number, divisor: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L978)

Since v2.0.0
Number-round.md
Package: `effect`<br />
Module: `Number`<br />

## Number.round

Returns the number rounded with the given precision.

**Example**

```ts
import * as assert from "node:assert/strict"
import { round } from "effect/Number"

assert.equal(round(1.1234, 2), 1.12)
assert.equal(round(1.567, 2), 1.57)
```

**Signature**

```ts
declare const round: { (precision: number): (self: number) => number; (self: number, precision: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L1065)

Since v3.8.0
Number-sign.md
Package: `effect`<br />
Module: `Number`<br />

## Number.sign

Determines the sign of a given `number`.

**Example**

```ts
import * as assert from "node:assert/strict"
import { sign } from "effect/Number"

assert.equal(sign(-5), -1)
assert.equal(sign(0), 0)
assert.equal(sign(5), 1)
```

**Signature**

```ts
declare const sign: (n: number) => Ordering
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L956)

Since v2.0.0
Number-subtract.md
Package: `effect`<br />
Module: `Number`<br />

## Number.subtract

Performs subtraction in the set of JavaScript numbers.

**Example**

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.subtract(2, 3), -1) // 2 - 3 = -1
assert.equal(Number.subtract(10, 5), 5) // 10 - 5 = 5
assert.equal(Number.subtract(0.3, 0.1), 0.19999999999999998) // Note: floating-point precision limitation

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.subtract(5) // 10 - 5 = 5
  ),
  5
)

// Chaining multiple subtractions
assert.equal(
  pipe(
    20,
    Number.subtract(5), // 20 - 5 = 15
    Number.subtract(3), // 15 - 3 = 12
    Number.subtract(2) // 12 - 2 = 10
  ),
  10
)

// Right identity property: a - 0 = a
assert.equal(Number.subtract(42, 0), 42)

// Self-annihilation property: a - a = 0
assert.equal(Number.subtract(42, 42), 0)

// Non-commutative property: a - b  b - a
assert.equal(Number.subtract(5, 3), 2) // 5 - 3 = 2
assert.equal(Number.subtract(3, 5), -2) // 3 - 5 = -2

// Inverse relation: a - b = -(b - a)
assert.equal(Number.subtract(5, 3), -Number.subtract(3, 5))
```

**Signature**

```ts
declare const subtract: { (subtrahend: number): (minuend: number) => number; (minuend: number, subtrahend: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L366)

Since v2.0.0
Number-sum.md
Package: `effect`<br />
Module: `Number`<br />

## Number.sum

Performs addition in the set of JavaScript numbers.

**Example**

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.sum(2, 3), 5)
assert.equal(Number.sum(-10, 5), -5)
assert.equal(Number.sum(0.1, 0.2), 0.30000000000000004) // Note: floating-point precision limitation

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.sum(5) // 10 + 5 = 15
  ),
  15
)

// Chaining multiple additions
assert.equal(
  pipe(
    1,
    Number.sum(2), // 1 + 2 = 3
    Number.sum(3), // 3 + 3 = 6
    Number.sum(4) // 6 + 4 = 10
  ),
  10
)

// Identity property: a + 0 = a
assert.equal(Number.sum(42, 0), 42)

// Commutative property: a + b = b + a
assert.equal(Number.sum(5, 3), Number.sum(3, 5))
```

**Signature**

```ts
declare const sum: { (that: number): (self: number) => number; (self: number, that: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L241)

Since v2.0.0
Number-sumAll.md
Package: `effect`<br />
Module: `Number`<br />

## Number.sumAll

Computes the sum of all elements in an iterable collection of numbers.

**Example**

```ts
import * as assert from "node:assert/strict"
import * as Number from "effect/Number"

// Basic sums
assert.equal(Number.sumAll([2, 3, 4]), 9) // 2 + 3 + 4 = 9
assert.equal(Number.sumAll([1.1, 2.2, 3.3]), 6.6) // 1.1 + 2.2 + 3.3 = 6.6

// Empty collection returns the additive identity (0)
assert.equal(Number.sumAll([]), 0)

// Single element collection
assert.equal(Number.sumAll([42]), 42)

// Sums with negative numbers
assert.equal(Number.sumAll([2, -3, 4]), 3) // 2 + (-3) + 4 = 3
assert.equal(Number.sumAll([-2, -3, -4]), -9) // (-2) + (-3) + (-4) = -9

// Works with any iterable
assert.equal(Number.sumAll(new Set([2, 3, 4])), 9)

// Using with generated sequences
function* range(start: number, end: number) {
  for (let i = start; i <= end; i++) yield i
}

// Compute sum of first 5 natural numbers: 1 + 2 + 3 + 4 + 5 = 15
assert.equal(Number.sumAll(range(1, 5)), 15)

// Floating point precision example
assert.equal(
  Number.sumAll([0.1, 0.2]),
  0.30000000000000004 // Note IEEE 754 precision limitation
)
```

**Signature**

```ts
declare const sumAll: (collection: Iterable<number>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L312)

Since v2.0.0
Number-unsafeDivide.md
Package: `effect`<br />
Module: `Number`<br />

## Number.unsafeDivide

Performs division in the set of JavaScript numbers, but misbehaves for
division by zero.

Unlike `module:Number.divide` which returns an Option, this function
directly returns a number or `Infinity` or `NaN`.

- If the `divisor` is zero, it returns `Infinity`.
- If both the `dividend` and the `divisor` are zero, then it returns `NaN`.

**Throws**

An {@link module:Number.DivisionByZeroError} if the divisor is zero.

**Example**

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.unsafeDivide(6, 3), 2) // 6  3 = 2
assert.equal(Number.unsafeDivide(-8, 4), -2) // (-8)  4 = -2
assert.equal(Number.unsafeDivide(-10, -5), 2) // (-10)  (-5) = 2
assert.equal(Number.unsafeDivide(1, 3), 0.3333333333333333)

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.unsafeDivide(2) // 10  2 = 5
  ),
  5
)

// Chaining multiple divisions
assert.equal(
  pipe(
    24,
    Number.unsafeDivide(2), // 24  2 = 12
    Number.unsafeDivide(3), // 12  3 = 4
    Number.unsafeDivide(2) // 4  2 = 2
  ),
  2
)

assert.equal(Number.unsafeDivide(6, 0), Infinity)

assert.equal(Number.unsafeDivide(0, 0), NaN)

// Compare with safe division
const safeResult = Number.divide(6, 3) // Option.some(2)
const unsafeResult = Number.unsafeDivide(6, 3) // 2 directly
```

**See**

- `module:Number.divide` - Safe division returning an Option

**Signature**

```ts
declare const unsafeDivide: { (divisor: number): (dividend: number) => number; (dividend: number, divisor: number): number; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L670)

Since v2.0.0
Of-ofComposition.md
Package: `@effect/typeclass`<br />
Module: `Of`<br />

## Of.ofComposition

Returns a default `of` composition.

**Signature**

```ts
declare const ofComposition: <F extends TypeLambda, G extends TypeLambda>(F: Of<F>, G: Of<G>) => <A>(a: A) => Kind<F, unknown, never, never, Kind<G, unknown, never, never, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Of.ts#L19)

Since v0.24.0
OpenAiTelemetry-AllAttributes.md
Package: `@effect/ai-openai`<br />
Module: `OpenAiTelemetry`<br />

## OpenAiTelemetry.AllAttributes

All telemetry attributes which are part of the GenAI specification,
including the OpenAi-specific attributes.

**Signature**

```ts
type AllAttributes = AiTelemetry.AllAttributes & RequestAttributes & ResponseAttributes
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/OpenAiTelemetry.ts#L33)

Since v1.0.0
OpenAiTelemetry-OpenAiTelemetryAttributes.md
Package: `@effect/ai-openai`<br />
Module: `OpenAiTelemetry`<br />

## OpenAiTelemetry.OpenAiTelemetryAttributes

The attributes used to describe telemetry in the context of Generative
Artificial Intelligence (GenAI) Models requests and responses.

{@see https://opentelemetry.io/docs/specs/semconv/attributes-registry/gen-ai/}

**Signature**

```ts
type OpenAiTelemetryAttributes = Simplify<
  & AiTelemetry.GenAITelemetryAttributes
  & AiTelemetry.AttributesWithPrefix<RequestAttributes, "gen_ai.openai.request">
  & AiTelemetry.AttributesWithPrefix<ResponseAttributes, "gen_ai.openai.request">
>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/OpenAiTelemetry.ts#L20)

Since v1.0.0
OpenAiTelemetry-RequestAttributes.md
Package: `@effect/ai-openai`<br />
Module: `OpenAiTelemetry`<br />

## OpenAiTelemetry.RequestAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai.openai.request`.

**Signature**

```ts
export interface RequestAttributes {
  /**
   * The response format that is requested.
   */
  readonly responseFormat?: (string & {}) | WellKnownResponseFormat | null | undefined
  /**
   * The service tier requested. May be a specific tier, `default`, or `auto`.
   */
  readonly serviceTier?: (string & {}) | WellKnownServiceTier | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/OpenAiTelemetry.ts#L42)

Since v1.0.0
OpenAiTelemetry-ResponseAttributes.md
Package: `@effect/ai-openai`<br />
Module: `OpenAiTelemetry`<br />

## OpenAiTelemetry.ResponseAttributes

Telemetry attributes which are part of the GenAI specification and are
namespaced by `gen_ai.openai.response`.

**Signature**

```ts
export interface ResponseAttributes {
  /**
   * The service tier used for the response.
   */
  readonly serviceTier?: string | null | undefined
  /**
   * A fingerprint to track any eventual change in the Generative AI
   * environment.
   */
  readonly systemFingerprint?: string | null | undefined
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/OpenAiTelemetry.ts#L60)

Since v1.0.0
OpenAiTelemetry-WellKnownResponseFormat.md
Package: `@effect/ai-openai`<br />
Module: `OpenAiTelemetry`<br />

## OpenAiTelemetry.WellKnownResponseFormat

The `gen_ai.openai.request.response_format` attribute has the following
list of well-known values.

If one of them applies, then the respective value **MUST** be used;
otherwise, a custom value **MAY** be used.

**Signature**

```ts
type WellKnownResponseFormat = "json_object" | "json_schema" | "text"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/OpenAiTelemetry.ts#L82)

Since v1.0.0
OpenAiTelemetry-WellKnownServiceTier.md
Package: `@effect/ai-openai`<br />
Module: `OpenAiTelemetry`<br />

## OpenAiTelemetry.WellKnownServiceTier

The `gen_ai.openai.request.service_tier` attribute has the following
list of well-known values.

If one of them applies, then the respective value **MUST** be used;
otherwise, a custom value **MAY** be used.

**Signature**

```ts
type WellKnownServiceTier = "auto" | "default"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/OpenAiTelemetry.ts#L94)

Since v1.0.0
OpenAiTelemetry-addGenAIAnnotations.md
Package: `@effect/ai-openai`<br />
Module: `OpenAiTelemetry`<br />

## OpenAiTelemetry.addGenAIAnnotations

Applies the specified OpenAi GenAI telemetry attributes to the provided
`Span`.

**NOTE**: This method will mutate the `Span` **in-place**.

**Signature**

```ts
declare const addGenAIAnnotations: ((options: OpenAiTelemetryAttributeOptions) => (span: Span) => void) & ((span: Span, options: OpenAiTelemetryAttributeOptions) => void)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/ai/openai/src/OpenAiTelemetry.ts#L123)

Since v1.0.0, Utilities
OpenApi-OpenAPISpec.md
Package: `@effect/platform`<br />
Module: `OpenApi`<br />

## OpenApi.OpenAPISpec

This model describes the OpenAPI specification (version 3.1.0) returned by
`fromApi`. It is not intended to describe the entire OpenAPI
specification, only the output of `fromApi`.

**Signature**

```ts
export interface OpenAPISpec {
  openapi: "3.1.0"
  info: OpenAPISpecInfo
  paths: OpenAPISpecPaths
  components: OpenAPIComponents
  security: Array<OpenAPISecurityRequirement>
  tags: Array<OpenAPISpecTag>
  servers?: Array<OpenAPISpecServer>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/OpenApi.ts#L496)

Since v1.0.0
OpenApi-Transform.md
Package: `@effect/platform`<br />
Module: `OpenApi`<br />

## OpenApi.Transform

Transforms the generated OpenAPI specification

**Signature**

```ts
declare class Transform
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/OpenApi.ts#L102)

Since v1.0.0
OpenApi-fromApi.md
Package: `@effect/platform`<br />
Module: `OpenApi`<br />

## OpenApi.fromApi

Converts an `HttpApi` instance into an OpenAPI Specification object.

**Details**

This function takes an `HttpApi` instance, which defines a structured API,
and generates an OpenAPI Specification (`OpenAPISpec`). The resulting spec
adheres to the OpenAPI 3.1.0 standard and includes detailed metadata such as
paths, operations, security schemes, and components. The function processes
the API's annotations, middleware, groups, and endpoints to build a complete
and accurate representation of the API in OpenAPI format.

The function also deduplicates schemas, applies transformations, and
integrates annotations like descriptions, summaries, external documentation,
and overrides. Cached results are used for better performance when the same
`HttpApi` instance is processed multiple times.

**Options**

- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:
  - `"strict"`: Disallow additional properties (default behavior).
  - `"allow"`: Allow additional properties.

**Example**

```ts
import { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from "@effect/platform"
import { Schema } from "effect"

const api = HttpApi.make("api").add(
  HttpApiGroup.make("group").add(
    HttpApiEndpoint.get("get", "/items")
      .addSuccess(Schema.Array(Schema.String))
  )
)

const spec = OpenApi.fromApi(api)

console.log(JSON.stringify(spec, null, 2))
// Output: OpenAPI specification in JSON format
```

**Signature**

```ts
declare const fromApi: <Id extends string, Groups extends HttpApiGroup.Any, E, R>(api: HttpApi.HttpApi<Id, Groups, E, R>, options?: { readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; } | undefined) => OpenAPISpec
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/OpenApi.ts#L229)

Since v1.0.0
OpenApiJsonSchema-makeWithDefs.md
Package: `@effect/platform`<br />
Module: `OpenApiJsonSchema`<br />

## OpenApiJsonSchema.makeWithDefs

Creates a schema with additional options and definitions.

**Options**

- `defs`: A record of definitions that are included in the schema.
- `defsPath`: The path to the definitions within the schema (defaults to "#/$defs/").
- `topLevelReferenceStrategy`: Controls the handling of the top-level reference. Possible values are:
  - `"keep"`: Keep the top-level reference (default behavior).
  - `"skip"`: Skip the top-level reference.
- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:
  - `"strict"`: Disallow additional properties (default behavior).
  - `"allow"`: Allow additional properties.

**Signature**

```ts
declare const makeWithDefs: <A, I, R>(schema: Schema.Schema<A, I, R>, options: { readonly defs: Record<string, any>; readonly defsPath?: string | undefined; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; }) => JsonSchema
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/OpenApiJsonSchema.ts#L279)

Since v1.0.0
Optimize-Deep.md
Package: `@effect/printer`<br />
Module: `Optimize`<br />

## Optimize.Deep

Instructs the document fusion optimizer to recurse into all leaves of the
document tree, including different layout alternatives and all
location-sensitive values (i.e. those created by `nesting`), which cannot be
fused before, but only during, the layout process. As a result, the
performance cost of using deep document fusion optimization is often hard to
predict and depends on the interplay between page layout and the document
that is to be pretty printed.

This value should only be utilized if profiling demonstrates that it is
**significantly** faster than using `Shallow`.

**Signature**

```ts
export interface Deep {
  readonly _tag: "Deep"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Optimize.ts#L68)

Since v1.0.0
Optimize-FusionDepth.md
Package: `@effect/printer`<br />
Module: `Optimize`<br />

## Optimize.FusionDepth

Represents an instruction that determines how deeply the document fusion
optimizer should traverse the document tree.

**Signature**

```ts
type FusionDepth = Shallow | Deep
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Optimize.ts#L40)

Since v1.0.0
Optimize-Optimize.md
Package: `@effect/printer`<br />
Module: `Optimize`<br />

## Optimize.Optimize

Represents optimization of a given document tree through fusion of redundant
document nodes.

**Signature**

```ts
export interface Optimize<A> {
  (depth: Optimize.Depth): Doc<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Optimize.ts#L19)

Since v1.0.0
Optimize-Shallow.md
Package: `@effect/printer`<br />
Module: `Optimize`<br />

## Optimize.Shallow

Instructs the document fusion optimizer to avoid diving deeply into nested
documents, fusing mostly concatenations of text nodes together.

**Signature**

```ts
export interface Shallow {
  readonly _tag: "Shallow"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Optimize.ts#L49)

Since v1.0.0
Optimize-optimize.md
Package: `@effect/printer`<br />
Module: `Optimize`<br />

## Optimize.optimize

The `optimize` function will combine text nodes so that they can be rendered
more efficiently. An optimized document is always laid out in an identical
manner to its un-optimized counterpart.

When laying a `Doc` out to a `SimpleDocStream`, every component of the input
document is translated directly to the simpler output format. This sometimes
yields undesirable chunking when many pieces have been concatenated together.

It is therefore a good idea to run `fuse` on concatenations of lots of small
strings that are used many times.

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as Optimize from "@effect/printer/Optimize"

// The document below contains a chain of four entries in the output `DocStream`
const inefficient = Doc.hsep([
  Doc.char("a"),
  Doc.char("b"),
  Doc.char("c"),
  Doc.char("d")
])

// However, the above document is fully equivalent to the tightly packed
// document below which is only a single entry in the output `DocStream` and
// can be processed much more efficiently.
const efficient = Doc.text("abcd")

// We can optimize the `inefficient` document using `Optimize`
Optimize.optimize(Optimize.Deep)(inefficient)
```

**Signature**

```ts
declare const optimize: { (depth: FusionDepth): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, depth: FusionDepth): Doc<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/Optimize.ts#L129)

Since v1.0.0
Option-all.md
Package: `effect`<br />
Module: `Option`<br />

## Option.all

Combines a structure of `Option`s into a single `Option` containing the
values with the same structure.

**Details**

This function takes a structure of `Option`s (a tuple, struct, or iterable)
and produces a single `Option` that contains the values from the input
structure if all `Option`s are `Some`. If any `Option` in the input is
`None`, the result is `None`. The structure of the input is preserved in the
output.

- If the input is a tuple (e.g., an array), the result will be an `Option`
  containing a tuple with the same length.
- If the input is a struct (e.g., an object), the result will be an `Option`
  containing a struct with the same keys.
- If the input is an iterable, the result will be an `Option` containing an
  array.

**Example**

```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

//       Option<[string, number]>
//      
const tuple = Option.all([maybeName, maybeAge])
console.log(tuple)
// Output:
// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }

//       Option<{ name: string; age: number; }>
//      
const struct = Option.all({ name: maybeName, age: maybeAge })
console.log(struct)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }
```

**Signature**

```ts
declare const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(input: I) => [I] extends [ReadonlyArray<Option<any>>] ? Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }> : [I] extends [Iterable<Option<infer A>>] ? Option<Array<A>> : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1389)

Since v2.0.0
Option-andThen.md
Package: `effect`<br />
Module: `Option`<br />

## Option.andThen

Chains two `Option`s together. The second `Option` can either be a static
value or depend on the result of the first `Option`.

**Details**

This function enables sequencing of two `Option` computations. If the first
`Option` is `Some`, the second `Option` is evaluated. The second `Option` can
either:

- Be a static `Option` value.
- Be a function that produces an `Option`, optionally based on the value of
  the first `Option`.

If the first `Option` is `None`, the function skips the evaluation of the
second `Option` and directly returns `None`.

**Signature**

```ts
declare const andThen: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>; <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; <A, B>(self: Option<A>, f: Option<B>): Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1075)

Since v2.0.0
Option-ap.md
Package: `effect`<br />
Module: `Option`<br />

## Option.ap

Applies a function inside a `Some` to a value inside another `Some`,
combining them into a new `Option`.

**Details**

This function allows you to apply a function wrapped in an `Option` (`self`)
to a value wrapped in another `Option` (`that`). If both `Option`s are
`Some`, the function is applied to the value, and the result is wrapped in a
new `Some`. If either `Option` is `None`, the result is `None`.

**Signature**

```ts
declare const ap: { <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>; <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1478)

Since v2.0.0
Option-as.md
Package: `effect`<br />
Module: `Option`<br />

## Option.as

Replaces the value inside a `Some` with the specified constant value, leaving
`None` unchanged.

**Details**

This function transforms an `Option` by replacing the value inside a `Some`
with the given constant value `b`. If the `Option` is `None`, it remains
unchanged.

This is useful when you want to preserve the presence of a value (`Some`) but
replace its content with a fixed value.

**Example**

```ts
import { Option } from "effect"

// Replacing the value of a `Some`
const someValue = Option.some(42)

console.log(Option.as(someValue, "new value"))
// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }

// Replacing a `None` (no effect)
const noneValue = Option.none<number>()

console.log(Option.as(noneValue, "new value"))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const as: { <B>(b: B): <X>(self: Option<X>) => Option<B>; <X, B>(self: Option<X>, b: B): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L964)

Since v2.0.0
Option-asVoid.md
Package: `effect`<br />
Module: `Option`<br />

## Option.asVoid

Replaces the value inside a `Some` with the constant value `void`, leaving
`None` unchanged.

**Details**

This function transforms an `Option` by replacing the value inside a `Some`
with `void`. If the `Option` is `None`, it remains unchanged.

This is particularly useful in scenarios where the presence or absence of a
value is significant, but the actual content of the value is irrelevant.

**Signature**

```ts
declare const asVoid: <_>(self: Option<_>) => Option<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L984)

Since v2.0.0
Option-bind.md
Package: `effect`<br />
Module: `Option`<br />

## Option.bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bindTo`
- `let`

**Signature**

```ts
declare const bind: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L2064)

Since v2.0.0
Option-bindTo.md
Package: `effect`<br />
Module: `Option`<br />

## Option.bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bind`
- `let`

**Signature**

```ts
declare const bindTo: { <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A; }>; <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1977)

Since v2.0.0
Option-composeK.md
Package: `effect`<br />
Module: `Option`<br />

## Option.composeK

Composes two functions that return `Option` values, creating a new function
that chains them together.

**Details**

This function allows you to compose two computations, each represented by a
function that returns an `Option`. The result of the first function is passed
to the second function if it is `Some`. If the first function returns `None`,
the composed function short-circuits and returns `None` without invoking the
second function.

**Example**

```ts
import { Option } from "effect"

const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))

const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()

const parseAndDouble = Option.composeK(parse, double)

console.log(parseAndDouble("42"))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }

console.log(parseAndDouble("not a number"))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const composeK: { <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>; <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1250)

Since v2.0.0
Option-contains.md
Package: `effect`<br />
Module: `Option`<br />

## Option.contains

Returns a function that checks if an `Option` contains a specified value
using the default `Equivalence`.

**Details**

This function allows you to check whether an `Option` contains a specific
value. It uses the default `Equivalence` for equality comparison. If the
`Option` is `Some` and its value is equivalent to the provided value, the
result is `true`. If the `Option` is `None` or the values are not equivalent,
the result is `false`.

**Example**

```ts
import { Option } from "effect"

console.log(Option.some(2).pipe(Option.contains(2)))
// Output: true

console.log(Option.some(1).pipe(Option.contains(2)))
// Output: false

console.log(Option.none().pipe(Option.contains(2)))
// Output: false
```

**See**

- `containsWith` for a version that allows you to specify a custom equivalence function.

**Signature**

```ts
declare const contains: { <A>(a: A): (self: Option<A>) => boolean; <A>(self: Option<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1892)

Since v2.0.0
Option-containsWith.md
Package: `effect`<br />
Module: `Option`<br />

## Option.containsWith

Returns a function that checks if an `Option` contains a specified value,
using a provided equivalence function.

**Details**

This function allows you to check whether an `Option` contains a specific
value. It uses an equivalence function `isEquivalent` to compare the value
inside the `Option` to the provided value. If the `Option` is `Some` and the
equivalence function returns `true`, the result is `true`. If the `Option` is
`None` or the values are not equivalent, the result is `false`.

**Example**

```ts
import { Number, Option } from "effect"

const contains = Option.containsWith(Number.Equivalence)

console.log(Option.some(2).pipe(contains(2)))
// Output: true

console.log(Option.some(1).pipe(contains(2)))
// Output: false

console.log(Option.none().pipe(contains(2)))
// Output: false
```

**See**

- `contains` for a version that uses the default `Equivalence`.

**Signature**

```ts
declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Option<A>) => boolean; (self: Option<A>, a: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1854)

Since v2.0.0
Option-Do.md
Package: `effect`<br />
Module: `Option`<br />

## Option.Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

**See**

- `bindTo`
- `bind`
- `let`

**Signature**

```ts
declare const Do: Option<{}>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L2109)

Since v2.0.0
Option-Option.Value.md
Package: `effect`<br />
Module: `Option`<br />

## Option.Option.Value

Extracts the type of the value contained in an `Option`.

**Example** (Getting the Value Type of an Option)

```ts
import { Option } from "effect"

// Declare an Option holding a string
declare const myOption: Option.Option<string>

// Extract the type of the value within the Option
//
//       string
//      
type MyType = Option.Option.Value<typeof myOption>
```

**Signature**

```ts
type Value<T> = [T] extends [Option<infer _A>] ? _A : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L118)

Since v2.0.0
Option-Option.md
Package: `effect`<br />
Module: `Option`<br />

## Option.Option

The `Option` data type represents optional values. An `Option<A>` can either
be `Some<A>`, containing a value of type `A`, or `None`, representing the
absence of a value.

**When to Use**

You can use `Option` in scenarios like:

- Using it for initial values
- Returning values from functions that are not defined for all possible
  inputs (referred to as partial functions)
- Managing optional fields in data structures
- Handling optional function arguments

**Signature**

```ts
type Option<A> = None<A> | Some<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L40)

Since v2.0.0
Option-exists.md
Package: `effect`<br />
Module: `Option`<br />

## Option.exists

Checks if a value in an `Option` satisfies a given predicate or refinement.

**Details**

This function allows you to check if a value inside a `Some` meets a
specified condition. If the `Option` is `None`, the result is `false`. If the
`Option` is `Some`, the provided predicate or refinement is applied to the
value:

- If the condition is met, the result is `true`.
- If the condition is not met, the result is `false`.

**Example**

```ts
import { Option } from "effect"

const isEven = (n: number) => n % 2 === 0

console.log(Option.some(2).pipe(Option.exists(isEven)))
// Output: true

console.log(Option.some(1).pipe(Option.exists(isEven)))
// Output: false

console.log(Option.none().pipe(Option.exists(isEven)))
// Output: false
```

**Signature**

```ts
declare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1929)

Since v2.0.0
Option-filter.md
Package: `effect`<br />
Module: `Option`<br />

## Option.filter

Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.

If you need to change the type of the `Option` in addition to filtering, see `filterMap`.

**Example**

```ts
import { Option } from "effect"

const removeEmptyString = (input: Option.Option<string>) =>
  Option.filter(input, (value) => value !== "")

console.log(removeEmptyString(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("a")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

**Signature**

```ts
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1638)

Since v2.0.0
Option-filterMap.md
Package: `effect`<br />
Module: `Option`<br />

## Option.filterMap

Alias of `flatMap`.

**Example**

```ts
import { Option } from "effect"

// Transform and filter numbers
const transformEven = (n: Option.Option<number>): Option.Option<string> =>
  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))

console.log(transformEven(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(1)))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(2)))
// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }
```

**Signature**

```ts
declare const filterMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1608)

Since v2.0.0
Option-firstSomeOf.md
Package: `effect`<br />
Module: `Option`<br />

## Option.firstSomeOf

Returns the first `Some` value found in an `Iterable` collection of
`Option`s, or `None` if no `Some` is found.

**Details**

This function iterates over a collection of `Option` values and returns the
first `Some` it encounters. If the collection contains only `None` values,
the result will also be `None`. This utility is useful for efficiently
finding the first valid value in a sequence of potentially empty or invalid
options.

The iteration stops as soon as a `Some` is found, making this function
efficient for large collections.

**Example**

```ts
import { Option } from "effect"

console.log(Option.firstSomeOf([
  Option.none(),
  Option.some(1),
  Option.some(2)
]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

**Signature**

```ts
declare const firstSomeOf: <T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(collection: C) => [C] extends [Iterable<Option<infer A>>] ? Option<A> : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L651)

Since v2.0.0
Option-flatMap.md
Package: `effect`<br />
Module: `Option`<br />

## Option.flatMap

Applies a function to the value of a `Some` and flattens the resulting
`Option`. If the input is `None`, it remains `None`.

**Details**

This function allows you to chain computations that return `Option` values.
If the input `Option` is `Some`, the provided function `f` is applied to the
contained value, and the resulting `Option` is returned. If the input is
`None`, the function is not applied, and the result remains `None`.

This utility is particularly useful for sequencing operations that may fail
or produce optional results, enabling clean and concise workflows for
handling such cases.

**Example**

```ts
import { Option } from "effect"

interface Address {
  readonly city: string
  readonly street: Option.Option<string>
}

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option<string>
  readonly address: Option.Option<Address>
}

const user: User = {
  id: 1,
  username: "john_doe",
  email: Option.some("john.doe@example.com"),
  address: Option.some({
    city: "New York",
    street: Option.some("123 Main St")
  })
}

// Use flatMap to extract the street value
const street = user.address.pipe(
  Option.flatMap((address) => address.street)
)

console.log(street)
// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }
```

**Signature**

```ts
declare const flatMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1047)

Since v2.0.0
Option-flatMapNullable.md
Package: `effect`<br />
Module: `Option`<br />

## Option.flatMapNullable

Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`
using a function that may return `null` or `undefined`.

**Details**

This function applies a transformation function `f` to the value inside a
`Some`. The function `f` may return a value, `null`, or `undefined`. If `f`
returns a value, it is wrapped in a `Some`. If `f` returns `null` or
`undefined`, the result is `None`. If the input `Option` is `None`, the
function is not applied, and `None` is returned.

This utility is particularly useful when working with deeply nested optional
values or chaining computations that may result in `null` or `undefined` at
some point.

**Example**

```ts
import { Option } from "effect"

interface Employee {
  company?: {
    address?: {
      street?: {
        name?: string
      }
    }
  }
}

const employee1: Employee = { company: { address: { street: { name: "high street" } } } }

// Extracting a deeply nested property
console.log(
  Option.some(employee1)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }

const employee2: Employee = { company: { address: { street: {} } } }

// Property does not exist
console.log(
  Option.some(employee2)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>; <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1145)

Since v2.0.0
Option-flatten.md
Package: `effect`<br />
Module: `Option`<br />

## Option.flatten

Flattens an `Option` of `Option` into a single `Option`.

**Details**

This function takes an `Option` that wraps another `Option` and flattens it
into a single `Option`. If the outer `Option` is `Some`, the function
extracts the inner `Option`. If the outer `Option` is `None`, the result
remains `None`.

This is useful for simplifying nested `Option` structures that may arise
during functional operations.

**Signature**

```ts
declare const flatten: <A>(self: Option<Option<A>>) => Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1170)

Since v2.0.0
Option-fromIterable.md
Package: `effect`<br />
Module: `Option`<br />

## Option.fromIterable

Converts an `Iterable` into an `Option`, wrapping the first element if it
exists.

**Details**

This function takes an `Iterable` (e.g., an array, a generator, or any object
implementing the `Iterable` interface) and returns an `Option` based on its
content:

- If the `Iterable` contains at least one element, the first element is
  wrapped in a `Some` and returned.
- If the `Iterable` is empty, `None` is returned, representing the absence of
  a value.

This utility is useful for safely handling collections that might be empty,
ensuring you explicitly handle both cases where a value exists or doesn't.

**Example**

```ts
import { Option } from "effect"

console.log(Option.fromIterable([1, 2, 3]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.fromIterable([]))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const fromIterable: <A>(collection: Iterable<A>) => Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L390)

Since v2.0.0
Option-fromNullable.md
Package: `effect`<br />
Module: `Option`<br />

## Option.fromNullable

Converts a nullable value into an `Option`. Returns `None` if the value is
`null` or `undefined`, otherwise wraps the value in a `Some`.

**Example**

```ts
import { Option } from "effect"

console.log(Option.fromNullable(undefined))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(null))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

**Signature**

```ts
declare const fromNullable: <A>(nullableValue: A) => Option<NonNullable<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L684)

Since v2.0.0
Option-gen.md
Package: `effect`<br />
Module: `Option`<br />

## Option.gen

Similar to `Effect.gen`, `Option.gen` provides a more readable,
generator-based syntax for working with `Option` values, making code that
involves `Option` easier to write and understand. This approach is similar to
using `async/await` but tailored for `Option`.

**Example** (Using `Option.gen` to Create a Combined Value)

```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

const person = Option.gen(function* () {
  const name = (yield* maybeName).toUpperCase()
  const age = yield* maybeAge
  return { name, age }
})

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }
```

**Signature**

```ts
declare const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L2141)

Since v2.0.0
Option-getEquivalence.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getEquivalence

Creates an `Equivalence` instance for comparing `Option` values, using a
provided `Equivalence` for the inner type.

**Details**

This function takes an `Equivalence` instance for a specific type `A` and
produces an `Equivalence` instance for `Option<A>`. The resulting
`Equivalence` determines whether two `Option` values are equivalent:

- Two `None`s are considered equivalent.
- A `Some` and a `None` are not equivalent.
- Two `Some` values are equivalent if their inner values are equivalent
  according to the provided `Equivalence`.

**Example** (Comparing Optional Numbers for Equivalence)

```ts
import { Number, Option } from "effect"

const isEquivalent = Option.getEquivalence(Number.Equivalence)

console.log(isEquivalent(Option.none(), Option.none()))
// Output: true

console.log(isEquivalent(Option.none(), Option.some(1)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.none()))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(2)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(1)))
// Output: true
```

**Signature**

```ts
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1690)

Since v2.0.0
Option-getLeft.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getLeft

Converts an `Either` into an `Option` by discarding the right value and
extracting the left value.

**Details**

This function transforms an `Either` into an `Option` as follows:

- If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.
- If the `Either` is a `Right`, the value is discarded, and `None` is
  returned.

This utility is useful when you only care about the error case (`Left`) of an
`Either` and want to handle it as an `Option`. By discarding the right value,
it simplifies error-focused workflows.

**Example**

```ts
import { Either, Option } from "effect"

console.log(Option.getLeft(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.getLeft(Either.left("err")))
// Output: { _id: 'Option', _tag: 'Some', value: 'err' }
```

**See**

- `getRight` for the opposite operation.

**Signature**

```ts
declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L465)

Since v2.0.0
Option-getOrElse.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getOrElse

Returns the value contained in the `Option` if it is `Some`, otherwise
evaluates and returns the result of `onNone`.

**Details**

This function allows you to provide a fallback value or computation for when
an `Option` is `None`. If the `Option` contains a value (`Some`), that value
is returned. If it is empty (`None`), the `onNone` function is executed, and
its result is returned instead.

This utility is helpful for safely handling `Option` values by ensuring you
always receive a meaningful result, whether or not the `Option` contains a
value. It is particularly useful for providing default values or alternative
logic when working with optional values.

**Example**

```ts
import { Option } from "effect"

console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))
// Output: 1

console.log(Option.none().pipe(Option.getOrElse(() => 0)))
// Output: 0
```

**See**

- `getOrNull` for a version that returns `null` instead of executing a function.
- `getOrUndefined` for a version that returns `undefined` instead of executing a function.

**Signature**

```ts
declare const getOrElse: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A; <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L500)

Since v2.0.0
Option-getOrNull.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getOrNull

Returns the value contained in the `Option` if it is `Some`; otherwise,
returns `null`.

**Details**

This function provides a way to extract the value of an `Option` while
falling back to `null` if the `Option` is `None`.

It is particularly useful in scenarios where `null` is an acceptable
placeholder for the absence of a value, such as when interacting with APIs or
systems that use `null` as a default for missing values.

**Example**

```ts
import { Option } from "effect"

console.log(Option.getOrNull(Option.some(1)))
// Output: 1

console.log(Option.getOrNull(Option.none()))
// Output: null
```

**Signature**

```ts
declare const getOrNull: <A>(self: Option<A>) => A | null
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L753)

Since v2.0.0
Option-getOrThrow.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getOrThrow

Extracts the value of an `Option` or throws a default error if the `Option`
is `None`.

**Details**

This function extracts the value from an `Option` if it is `Some`. If the
`Option` is `None`, it throws a default error. It is useful for fail-fast
scenarios where the absence of a value is treated as an exceptional case and
a default error is sufficient.

**Example**

```ts
import * as assert from "node:assert"
import { Option } from "effect"

assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
assert.throws(() => Option.getOrThrow(Option.none()))
```

**See**

- `getOrThrowWith` for a version that allows you to provide a custom error.

**Signature**

```ts
declare const getOrThrow: <A>(self: Option<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L887)

Since v2.0.0
Option-getOrThrowWith.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getOrThrowWith

Extracts the value of an `Option` or throws an error if the `Option` is
`None`, using a custom error factory.

**Details**

This function allows you to extract the value of an `Option` when it is
`Some`. If the `Option` is `None`, it throws an error generated by the
provided `onNone` function. This utility is particularly useful when you need
a fail-fast behavior for empty `Option` values and want to provide a custom
error message or object.

**Example**

```ts
import * as assert from "node:assert"
import { Option } from "effect"

assert.deepStrictEqual(
  Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
  1
)
assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))
```

**See**

- `getOrThrow` for a version that throws a default error.

**Signature**

```ts
declare const getOrThrowWith: { (onNone: () => unknown): <A>(self: Option<A>) => A; <A>(self: Option<A>, onNone: () => unknown): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L852)

Since v2.0.0
Option-getOrUndefined.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getOrUndefined

Returns the value contained in the `Option` if it is `Some`; otherwise,
returns `undefined`.

**Details**

This function provides a way to extract the value of an `Option` while
falling back to `undefined` if the `Option` is `None`.

It is particularly useful in scenarios where `undefined` is an acceptable
placeholder for the absence of a value, such as when interacting with APIs or
systems that use `undefined` as a default for missing values.

**Example**

```ts
import { Option } from "effect"

console.log(Option.getOrUndefined(Option.some(1)))
// Output: 1

console.log(Option.getOrUndefined(Option.none()))
// Output: undefined
```

**Signature**

```ts
declare const getOrUndefined: <A>(self: Option<A>) => A | undefined
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L782)

Since v2.0.0
Option-getOrder.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getOrder

Creates an `Order` instance for comparing `Option` values, using a provided
`Order` for the inner type.

**Details**

This function produces an `Order` instance for `Option<A>`, allowing `Option`
values to be compared:

- `None` is always considered less than any `Some` value.
- If both are `Some`, their inner values are compared using the provided
  `Order` instance.

**Example**

```ts
import { Number, Option } from "effect"

const order = Option.getOrder(Number.Order)

console.log(order(Option.none(), Option.none()))
// Output: 0

console.log(order(Option.none(), Option.some(1)))
// Output: -1

console.log(order(Option.some(1), Option.none()))
// Output: 1

console.log(order(Option.some(1), Option.some(2)))
// Output: -1

console.log(order(Option.some(1), Option.some(1)))
// Output: 0
```

**Signature**

```ts
declare const getOrder: <A>(O: Order<A>) => Order<Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1731)

Since v2.0.0
Option-getRight.md
Package: `effect`<br />
Module: `Option`<br />

## Option.getRight

Converts an `Either` into an `Option` by discarding the error and extracting
the right value.

**Details**

This function takes an `Either` and returns an `Option` based on its value:

- If the `Either` is a `Right`, its value is wrapped in a `Some` and
  returned.
- If the `Either` is a `Left`, the error is discarded, and `None` is
  returned.

This is particularly useful when you only care about the success case
(`Right`) of an `Either` and want to handle the result using `Option`. By
using this function, you can convert `Either` into a simpler structure for
cases where error handling is not required.

**Example**

```ts
import { Either, Option } from "effect"

console.log(Option.getRight(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }

console.log(Option.getRight(Either.left("err")))
// Output: { _id: 'Option', _tag: 'None' }
```

**See**

- `getLeft` for the opposite operation.

**Signature**

```ts
declare const getRight: <R, L>(self: Either<R, L>) => Option<R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L431)

Since v2.0.0
Option-isNone.md
Package: `effect`<br />
Module: `Option`<br />

## Option.isNone

Checks whether an `Option` represents the absence of a value (`None`).

**Example**

```ts
import { Option } from "effect"

console.log(Option.isNone(Option.some(1)))
// Output: false

console.log(Option.isNone(Option.none()))
// Output: true
```

**See**

- `isSome` for the opposite check.

**Signature**

```ts
declare const isNone: <A>(self: Option<A>) => self is None<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L237)

Since v2.0.0
Option-isOption.md
Package: `effect`<br />
Module: `Option`<br />

## Option.isOption

Determines whether the given value is an `Option`.

**Details**

This function checks if a value is an instance of `Option`. It returns `true`
if the value is either `Option.some` or `Option.none`, and `false` otherwise.
This is particularly useful when working with unknown values or when you need
to ensure type safety in your code.

**Example**

```ts
import { Option } from "effect"

console.log(Option.isOption(Option.some(1)))
// Output: true

console.log(Option.isOption(Option.none()))
// Output: true

console.log(Option.isOption({}))
// Output: false
```

**Signature**

```ts
declare const isOption: (input: unknown) => input is Option<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L216)

Since v2.0.0
Option-isSome.md
Package: `effect`<br />
Module: `Option`<br />

## Option.isSome

Checks whether an `Option` contains a value (`Some`).

**Example**

```ts
import { Option } from "effect"

console.log(Option.isSome(Option.some(1)))
// Output: true

console.log(Option.isSome(Option.none()))
// Output: false
```

**See**

- `isNone` for the opposite check.

**Signature**

```ts
declare const isSome: <A>(self: Option<A>) => self is Some<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L258)

Since v2.0.0
Option-let.md
Package: `effect`<br />
Module: `Option`<br />

## Option.let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

**Example**

```ts
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bind`
- `bindTo`

**Signature**

```ts
declare const let: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L2028)

Since v2.0.0
Option-lift2.md
Package: `effect`<br />
Module: `Option`<br />

## Option.lift2

Lifts a binary function to work with `Option` values, allowing the function
to operate on two `Option`s.

**Details**

This function takes a binary function `f` and returns a new function that
applies `f` to the values of two `Option`s (`self` and `that`). If both
`Option`s are `Some`, the binary function `f` is applied to their values, and
the result is wrapped in a new `Some`. If either `Option` is `None`, the
result is `None`.

**Example**

```ts
import { Option } from "effect"

// A binary function to add two numbers
const add = (a: number, b: number): number => a + b

// Lift the `add` function to work with `Option` values
const addOptions = Option.lift2(add)

// Both `Option`s are `Some`
console.log(addOptions(Option.some(2), Option.some(3)))
// Output: { _id: 'Option', _tag: 'Some', value: 5 }

// One `Option` is `None`
console.log(addOptions(Option.some(2), Option.none()))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const lift2: <A, B, C>(f: (a: A, b: B) => C) => { (that: Option<B>): (self: Option<A>) => Option<C>; (self: Option<A>, that: Option<B>): Option<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1768)

Since v2.0.0
Option-liftNullable.md
Package: `effect`<br />
Module: `Option`<br />

## Option.liftNullable

Lifts a function that returns `null` or `undefined` into the `Option`
context.

**Details**

This function takes a function `f` that might return `null` or `undefined`
and transforms it into a function that returns an `Option`. The resulting
function will return:
- `Some` if the original function produces a non-null, non-undefined value.
- `None` if the original function produces `null` or `undefined`.

**Example**

```ts
import { Option } from "effect"

const parse = (s: string): number | undefined => {
  const n = parseFloat(s)
  return isNaN(n) ? undefined : n
}

const parseOption = Option.liftNullable(parse)

console.log(parseOption("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parseOption("not a number"))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const liftNullable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Option<NonNullable<B>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L721)

Since v2.0.0
Option-liftPredicate.md
Package: `effect`<br />
Module: `Option`<br />

## Option.liftPredicate

Lifts a `Predicate` or `Refinement` into the `Option` context, returning a
`Some` of the input value if the predicate is satisfied, or `None` otherwise.

**Details**

This function transforms a `Predicate` (or a more specific `Refinement`) into
a function that produces an `Option`. If the predicate evaluates to `true`,
the input value is wrapped in a `Some`. If the predicate evaluates to
`false`, the result is `None`.

**Example**

```ts
import { Option } from "effect"

// Check if a number is positive
const isPositive = (n: number) => n > 0

//       (b: number) => Option<number>
//      
const parsePositive = Option.liftPredicate(isPositive)

console.log(parsePositive(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parsePositive(-1))
// OUtput: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const liftPredicate: { <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>; <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>; <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>; <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1805)

Since v2.0.0
Option-liftThrowable.md
Package: `effect`<br />
Module: `Option`<br />

## Option.liftThrowable

Lifts a function that throws exceptions into a function that returns an
`Option`.

**Details**

This utility function takes a function `f` that might throw an exception and
transforms it into a safer function that returns an `Option`. If the original
function executes successfully, the result is wrapped in a `Some`. If an
exception is thrown, the result is `None`, allowing the developer to handle
errors in a functional, type-safe way.

**Example**

```ts
import { Option } from "effect"

const parse = Option.liftThrowable(JSON.parse)

console.log(parse("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parse(""))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const liftThrowable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (...a: A) => Option<B>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L812)

Since v2.0.0
Option-map.md
Package: `effect`<br />
Module: `Option`<br />

## Option.map

Transforms the value inside a `Some` to a new value using the provided
function, while leaving `None` unchanged.

**Details**

This function applies a mapping function `f` to the value inside an `Option`
if it is a `Some`. If the `Option` is `None`, it remains unchanged. The
result is a new `Option` with the transformed value (if it was a `Some`) or
still `None`.

This utility is particularly useful for chaining transformations in a
functional way without needing to manually handle `None` cases.

**Example**

```ts
import { Option } from "effect"

// Mapping over a `Some`
const someValue = Option.some(2)

console.log(Option.map(someValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'Some', value: 4 }

// Mapping over a `None`
const noneValue = Option.none<number>()

console.log(Option.map(noneValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L923)

Since v2.0.0
Option-match.md
Package: `effect`<br />
Module: `Option`<br />

## Option.match

Performs pattern matching on an `Option` to handle both `Some` and `None`
cases.

**Details**

This function allows you to match against an `Option` and handle both
scenarios: when the `Option` is `None` (i.e., contains no value), and when
the `Option` is `Some` (i.e., contains a value). It executes one of the
provided functions based on the case:

- If the `Option` is `None`, the `onNone` function is executed and its result
  is returned.
- If the `Option` is `Some`, the `onSome` function is executed with the
  contained value, and its result is returned.

This function provides a concise and functional way to handle optional values
without resorting to `if` or manual checks, making your code more declarative
and readable.

**Example** (Pattern Matching with Option)

```ts
import { Option } from "effect"

const foo = Option.some(1)

const message = Option.match(foo, {
  onNone: () => "Option is empty",
  onSome: (value) => `Option has a value: ${value}`
})

console.log(message)
// Output: "Option has a value: 1"
```

**Signature**

```ts
declare const match: { <B, A, C = B>(options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): (self: Option<A>) => B | C; <A, B, C = B>(self: Option<A>, options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): B | C; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L299)

Since v2.0.0
Option-none.md
Package: `effect`<br />
Module: `Option`<br />

## Option.none

Represents the absence of a value by creating an empty `Option`.

`Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.
This means you can use it in place of any `Option<A>` regardless of the type
`A`.

**Example** (Creating an Option with No Value)

```ts
import { Option } from "effect"

// An Option holding no value
//
//       Option<never>
//      
const noValue = Option.none()

console.log(noValue)
// Output: { _id: 'Option', _tag: 'None' }
```

**See**

- `some` for the opposite operation.

**Signature**

```ts
declare const none: <A = never>() => Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L162)

Since v2.0.0
Option-orElse.md
Package: `effect`<br />
Module: `Option`<br />

## Option.orElse

Returns the provided `Option` `that` if the current `Option` (`self`) is
`None`; otherwise, it returns `self`.

**Details**

This function provides a fallback mechanism for `Option` values. If the
current `Option` is `None` (i.e., it contains no value), the `that` function
is evaluated, and its resulting `Option` is returned. If the current `Option`
is `Some` (i.e., it contains a value), the original `Option` is returned
unchanged.

This is particularly useful for chaining fallback values or computations,
allowing you to provide alternative `Option` values when the first one is
empty.

**Example**

```ts
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

console.log(Option.none().pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

**Signature**

```ts
declare const orElse: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L544)

Since v2.0.0
Option-orElseEither.md
Package: `effect`<br />
Module: `Option`<br />

## Option.orElseEither

Similar to `orElse`, but returns an `Either` wrapped in an `Option` to
indicate the source of the value.

**Details**

This function allows you to provide a fallback `Option` in case the current
`Option` (`self`) is `None`. However, unlike `orElse`, it returns the value
wrapped in an `Either` object, providing additional information about where
the value came from:

- If the value is from the fallback `Option` (`that`), it is wrapped in an
  `Either.right`.
- If the value is from the original `Option` (`self`), it is wrapped in an
  `Either.left`.

This is especially useful when you need to differentiate between values
originating from the primary `Option` and those coming from the fallback,
while still maintaining the `Option`-style handling.

**Signature**

```ts
declare const orElseEither: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L612)

Since v2.0.0
Option-orElseSome.md
Package: `effect`<br />
Module: `Option`<br />

## Option.orElseSome

Returns the provided default value wrapped in `Some` if the current `Option`
(`self`) is `None`; otherwise, returns `self`.

**Details**

This function provides a way to supply a default value for cases where an
`Option` is `None`. If the current `Option` is empty (`None`), the `onNone`
function is executed to compute the default value, which is then wrapped in a
`Some`. If the current `Option` contains a value (`Some`), it is returned as
is.

This is particularly useful for handling optional values where a fallback
default needs to be provided explicitly in case of absence.

**Example**

```ts
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

**Signature**

```ts
declare const orElseSome: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L581)

Since v2.0.0
Option-partitionMap.md
Package: `effect`<br />
Module: `Option`<br />

## Option.partitionMap

Splits an `Option` into two `Option`s based on the result of a mapping
function that produces an `Either`.

**Details**

This function takes an `Option` and a mapping function `f` that converts its
value into an `Either`. It returns a tuple of two `Option`s:

- The first `Option` (`left`) contains the value from the `Left` side of the
  `Either` if it exists, otherwise `None`.
- The second `Option` (`right`) contains the value from the `Right` side of
  the `Either` if it exists, otherwise `None`.

If the input `Option` is `None`, both returned `Option`s are `None`.

This utility is useful for filtering and categorizing the contents of an
`Option` based on a bifurcating computation.

**Signature**

```ts
declare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]; <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1569)

Since v2.0.0
Option-product.md
Package: `effect`<br />
Module: `Option`<br />

## Option.product

Combines two `Option` values into a single `Option` containing a tuple of
their values if both are `Some`.

**Details**

This function takes two `Option`s and combines their values into a tuple `[A,
B]` if both are `Some`. If either of the `Option`s is `None`, the result is
`None`. This is particularly useful for combining multiple `Option` values
into a single one, ensuring both contain valid values.

**Signature**

```ts
declare const product: <A, B>(self: Option<A>, that: Option<B>) => Option<[A, B]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1310)

Since v2.0.0
Option-productMany.md
Package: `effect`<br />
Module: `Option`<br />

## Option.productMany

Combines an `Option` with a collection of `Option`s into a single `Option`
containing a tuple of their values if all are `Some`.

**Details**

This function takes a primary `Option` and a collection of `Option`s and
combines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If
the primary `Option` or any `Option` in the collection is `None`, the result
is `None`.

**Signature**

```ts
declare const productMany: <A>(self: Option<A>, collection: Iterable<Option<A>>) => Option<[A, ...Array<A>]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1327)

Since v2.0.0
Option-reduceCompact.md
Package: `effect`<br />
Module: `Option`<br />

## Option.reduceCompact

Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring
elements that are `None`.

**Details**

This function takes an initial value of type `B` and a reducing function `f`
that combines the accumulator with values of type `A`. It processes an
iterable of `Option<A>`, applying `f` only to the `Some` values while
ignoring the `None` values. The result is a single value of type `B`.

This utility is particularly useful for aggregating values from an iterable
of `Option`s while skipping the absent (`None`) values.

**Example**

```ts
import { Option, pipe } from "effect"

const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]

console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))
// Output: 3
```

**Signature**

```ts
declare const reduceCompact: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B; <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1510)

Since v2.0.0
Option-some.md
Package: `effect`<br />
Module: `Option`<br />

## Option.some

Wraps the given value into an `Option` to represent its presence.

**Example** (Creating an Option with a Value)

```ts
import { Option } from "effect"

// An Option holding the number 1
//
//       Option<number>
//      
const value = Option.some(1)

console.log(value)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

**See**

- `none` for the opposite operation.

**Signature**

```ts
declare const some: <A>(value: A) => Option<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L187)

Since v2.0.0
Option-tap.md
Package: `effect`<br />
Module: `Option`<br />

## Option.tap

Applies the provided function `f` to the value of the `Option` if it is
`Some` and returns the original `Option`, unless `f` returns `None`, in which
case it returns `None`.

**Details**

This function allows you to perform additional computations on the value of
an `Option` without modifying its original value. If the `Option` is `Some`,
the provided function `f` is executed with the value, and its result
determines whether the original `Option` is returned (`Some`) or the result
is `None` if `f` returns `None`. If the input `Option` is `None`, the
function is not executed, and `None` is returned.

This is particularly useful for applying side conditions or performing
validation checks while retaining the original `Option`'s value.

**Example**

```ts
import { Option } from "effect"

const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()

console.log(Option.tap(Option.none(), getInteger))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.tap(Option.some(1), getInteger))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.tap(Option.some(1.14), getInteger))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
declare const tap: { <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>; <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1291)

Since v2.0.0
Option-toArray.md
Package: `effect`<br />
Module: `Option`<br />

## Option.toArray

Converts an `Option` into an `Array`.
If the input is `None`, an empty array is returned.
If the input is `Some`, its value is wrapped in a single-element array.

**Example**

```ts
import { Option } from "effect"

console.log(Option.toArray(Option.some(1)))
// Output: [1]

console.log(Option.toArray(Option.none()))
// Output: []
```

**Signature**

```ts
declare const toArray: <A>(self: Option<A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1545)

Since v2.0.0
Option-toRefinement.md
Package: `effect`<br />
Module: `Option`<br />

## Option.toRefinement

Converts an `Option`-returning function into a type guard.

**Details**

This function transforms a function that returns an `Option` into a type
guard, ensuring type safety when validating or narrowing types. The returned
type guard function checks whether the input satisfies the condition defined
in the original `Option`-returning function.

If the original function returns `Option.some`, the type guard evaluates to
`true`, confirming the input is of the desired type. If the function returns
`Option.none`, the type guard evaluates to `false`.

This utility is especially useful for validating types in union types,
filtering arrays, or ensuring safe handling of specific subtypes.

**Example**

```ts
import { Option } from "effect"

type MyData = string | number

const parseString = (data: MyData): Option.Option<string> =>
  typeof data === "string" ? Option.some(data) : Option.none()

//       (a: MyData) => a is string
//      
const isString = Option.toRefinement(parseString)

console.log(isString("a"))
// Output: true

console.log(isString(1))
// Output: false
```

**Signature**

```ts
declare const toRefinement: <A, B extends A>(f: (a: A) => Option<B>) => (a: A) => a is B
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L356)

Since v2.0.0
Option-zipLeft.md
Package: `effect`<br />
Module: `Option`<br />

## Option.zipLeft

Combines two `Option`s, keeping the value from the first `Option` if both are
`Some`.

**Details**

This function takes two `Option`s and returns the first one if it is `Some`.
If either the first `Option` or the second `Option` is `None`, the result
will be `None`. This operation "zips" the two `Option`s while discarding the
value from the second `Option`.

This is useful when sequencing computations where the second `Option`
represents a dependency or condition that must hold, but its value is
irrelevant.

**Signature**

```ts
declare const zipLeft: { <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>; <A, X>(self: Option<A>, that: Option<X>): Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1213)

Since v2.0.0
Option-zipRight.md
Package: `effect`<br />
Module: `Option`<br />

## Option.zipRight

Combines two `Option`s, keeping the value from the second `Option` if both
are `Some`.

**Details**

This function takes two `Option`s and returns the second one if the first is
`Some`. If the first `Option` is `None`, the result will also be `None`,
regardless of the second `Option`. It effectively "zips" the two `Option`s
while discarding the value from the first `Option`.

This is particularly useful when sequencing computations where the result of
the first computation is not needed, and you only care about the result of
the second computation.

**Signature**

```ts
declare const zipRight: { <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>; <X, B>(self: Option<X>, that: Option<B>): Option<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1190)

Since v2.0.0
Option-zipWith.md
Package: `effect`<br />
Module: `Option`<br />

## Option.zipWith

Combines two `Option` values into a new `Option` by applying a provided
function to their values.

**Details**

This function takes two `Option` values (`self` and `that`) and a combining
function `f`. If both `Option` values are `Some`, the function `f` is applied
to their values, and the result is wrapped in a new `Some`. If either
`Option` is `None`, the result is `None`.

This utility is useful for combining two optional computations into a single
result while maintaining type safety and avoiding explicit checks for `None`.

**Example**

```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

// Combine the name and age into a person object
const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }
```

**Signature**

```ts
declare const zipWith: { <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>; <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1455)

Since v2.0.0
Options-choice.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.choice

Constructs command-line `Options` that represent a choice between several
inputs. The input will be mapped to it's associated value during parsing.

**Example**

```ts
import * as Options from "@effect/cli/Options"

export const animal: Options.Options<"dog" | "cat"> = Options.choice(
  "animal",
  ["dog", "cat"]
)
```

**Signature**

```ts
declare const choice: <A extends string, C extends ReadonlyArray<A>>(name: string, choices: C) => Options<C[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L170)

Since v1.0.0
Options-choiceWithValue.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.choiceWithValue

Constructs command-line `Options` that represent a choice between several
inputs. The input will be mapped to it's associated value during parsing.

**Example**

```ts
import * as Options from "@effect/cli/Options"
import * as Data from "effect/Data"

export type Animal = Dog | Cat

export interface Dog {
  readonly _tag: "Dog"
}

export const Dog = Data.tagged<Dog>("Dog")

export interface Cat {
  readonly _tag: "Cat"
}

export const Cat = Data.tagged<Cat>("Cat")

export const animal: Options.Options<Animal> = Options.choiceWithValue("animal", [
  ["dog", Dog()],
  ["cat", Cat()],
])
```

**Signature**

```ts
declare const choiceWithValue: <C extends ReadonlyArray<[string, any]>>(name: string, choices: C) => Options<C[number][1]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L208)

Since v1.0.0
Options-directory.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.directory

Creates a parameter expecting path to a directory.

**Signature**

```ts
declare const directory: (name: string, config?: Options.PathOptionsConfig) => Options<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L225)

Since v1.0.0
Options-file.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.file

Creates a parameter expecting path to a file.

**Signature**

```ts
declare const file: (name: string, config?: Options.PathOptionsConfig) => Options<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L234)

Since v1.0.0
Options-fileContent.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.fileContent

Creates a parameter expecting path to a file and reads its contents.

**Signature**

```ts
declare const fileContent: (name: string) => Options<readonly [path: string, content: Uint8Array]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L242)

Since v1.0.0
Options-fileParse.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.fileParse

Creates a parameter expecting path to a file and parse its contents.

**Signature**

```ts
declare const fileParse: (name: string, format?: "json" | "yaml" | "ini" | "toml" | undefined) => Options<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L251)

Since v1.0.0
Options-fileSchema.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.fileSchema

Creates a parameter expecting path to a file, parse its contents and validate
it with a Schema.

**Signature**

```ts
declare const fileSchema: <I, A>(name: string, schema: Schema<A, I, FileSystem | Path | Terminal>, format?: "json" | "yaml" | "ini" | "toml" | undefined) => Options<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L261)

Since v1.0.0
Options-fileText.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.fileText

Creates a parameter expecting path to a file and reads its contents.

**Signature**

```ts
declare const fileText: (name: string) => Options<readonly [path: string, content: string]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L273)

Since v1.0.0
Options-isBool.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.isBool

Returns `true` if the specified `Options` is a boolean flag, `false`
otherwise.

**Signature**

```ts
declare const isBool: <A>(self: Options<A>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L388)

Since v1.0.0
Options-processCommandLine.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.processCommandLine

Processes the provided command-line arguments, searching for the specified
`Options`.

Returns an `Option<ValidationError>`, any leftover arguments, and the
constructed value of type `A`. The possible error inside
`Option<ValidationError>` would only be triggered if there is an error when
parsing the command-line arguments. This is because `ValidationError`s are
also used internally to control the end of the command-line arguments (i.e.
the command-line symbol `--`) corresponding to options.

**Signature**

```ts
declare const processCommandLine: { (args: ReadonlyArray<string>, config: CliConfig): <A>(self: Options<A>) => Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>; <A>(self: Options<A>, args: ReadonlyArray<string>, config: CliConfig): Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L483)

Since v1.0.0
Options-repeated.md
Package: `@effect/cli`<br />
Module: `Options`<br />

## Options.repeated

Indicates that the specified command-line option can be repeated `0` or more
times.

**NOTE**: if the command-line option is not provided, and empty array will be
returned as the value for said option.

**Signature**

```ts
declare const repeated: <A>(self: Options<A>) => Options<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Options.ts#L467)

Since v1.0.0
Order-array.md
Package: `effect`<br />
Module: `Order`<br />

## Order.array

This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
If all elements are equal, the arrays are then compared based on their length.
It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.

**Signature**

```ts
declare const array: <A>(O: Order<A>) => Order<ReadonlyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L221)

Since v2.0.0
Order-between.md
Package: `effect`<br />
Module: `Order`<br />

## Order.between

Test whether a value is between a minimum and a maximum (inclusive).

**Signature**

```ts
declare const between: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => boolean; (self: A, options: { minimum: A; maximum: A; }): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L357)

Since v2.0.0
Order-clamp.md
Package: `effect`<br />
Module: `Order`<br />

## Order.clamp

Clamp a value between a minimum and a maximum.

**Example**

```ts
import * as assert from "node:assert"
import { Order, Number } from "effect"

const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })

assert.equal(clamp(3), 3)
assert.equal(clamp(0), 1)
assert.equal(clamp(6), 5)
```

**Signature**

```ts
declare const clamp: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => A; (self: A, options: { minimum: A; maximum: A; }): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L334)

Since v2.0.0
Order-greaterThan.md
Package: `effect`<br />
Module: `Order`<br />

## Order.greaterThan

Test whether one value is _strictly greater than_ another.

**Signature**

```ts
declare const greaterThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L272)

Since v2.0.0
Order-greaterThanOrEqualTo.md
Package: `effect`<br />
Module: `Order`<br />

## Order.greaterThanOrEqualTo

Test whether one value is _non-strictly greater than_ another.

**Signature**

```ts
declare const greaterThanOrEqualTo: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L292)

Since v2.0.0
Order-lessThan.md
Package: `effect`<br />
Module: `Order`<br />

## Order.lessThan

Test whether one value is _strictly less than_ another.

**Signature**

```ts
declare const lessThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L262)

Since v2.0.0
Order-lessThanOrEqualTo.md
Package: `effect`<br />
Module: `Order`<br />

## Order.lessThanOrEqualTo

Test whether one value is _non-strictly less than_ another.

**Signature**

```ts
declare const lessThanOrEqualTo: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L282)

Since v2.0.0
Order-max.md
Package: `effect`<br />
Module: `Order`<br />

## Order.max

Take the maximum of two values. If they are considered equal, the first argument is chosen.

**Signature**

```ts
declare const max: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L312)

Since v2.0.0
Order-min.md
Package: `effect`<br />
Module: `Order`<br />

## Order.min

Take the minimum of two values. If they are considered equal, the first argument is chosen.

**Signature**

```ts
declare const min: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L302)

Since v2.0.0
Order-struct.md
Package: `effect`<br />
Module: `Order`<br />

## Order.struct

This function creates and returns a new `Order` for a struct of values based on the given `Order`s
for each property in the struct.

**Signature**

```ts
declare const struct: <R extends { readonly [x: string]: Order<any>; }>(fields: R) => Order<{ [K in keyof R]: [R[K]] extends [Order<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L242)

Since v2.0.0
Order-tuple.md
Package: `effect`<br />
Module: `Order`<br />

## Order.tuple

Similar to `Promise.all` but operates on `Order`s.

```
[Order<A>, Order<B>, ...] -> Order<[A, B, ...]>
```

This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
of the tuple.

**Signature**

```ts
declare const tuple: <T extends ReadonlyArray<Order<any>>>(...elements: T) => Order<Readonly<{ [I in keyof T]: [T[I]] extends [Order<infer A>] ? A : never; }>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L208)

Since v2.0.0
Ordering-match.md
Package: `effect`<br />
Module: `Ordering`<br />

## Ordering.match

Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.

**Example**

```ts
import * as assert from "node:assert"
import { Ordering } from "effect"
import { constant } from "effect/Function"

const toMessage = Ordering.match({
  onLessThan: constant('less than'),
  onEqual: constant('equal'),
  onGreaterThan: constant('greater than')
})

assert.deepStrictEqual(toMessage(-1), "less than")
assert.deepStrictEqual(toMessage(0), "equal")
assert.deepStrictEqual(toMessage(1), "greater than")
```

**Signature**

```ts
declare const match: { <A, B, C = B>(options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): (self: Ordering) => A | B | C; <A, B, C = B>(o: Ordering, options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): A | B | C; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L53)

Since v2.0.0
Ordering-reverse.md
Package: `effect`<br />
Module: `Ordering`<br />

## Ordering.reverse

Inverts the ordering of the input `Ordering`.

**Example**

```ts
import * as assert from "node:assert"
import { reverse } from "effect/Ordering"

assert.deepStrictEqual(reverse(1), -1)
assert.deepStrictEqual(reverse(-1), 1)
assert.deepStrictEqual(reverse(0), 0)
```

**Signature**

```ts
declare const reverse: (o: Ordering) => Ordering
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L28)

Since v2.0.0
PageWidth-AvailablePerLine.md
Package: `@effect/printer`<br />
Module: `PageWidth`<br />

## PageWidth.AvailablePerLine

Represents a `PageWidth` setting that informs the layout algorithms to avoid
exceeding the specified space per line.

**Signature**

```ts
export interface AvailablePerLine extends PageWidth.Proto {
  readonly _tag: "AvailablePerLine"
  /**
   * The number of characters, including whitespace, that can fit on a single
   * line.
   */
  readonly lineWidth: number
  /**
   * The fraction of the total page width that can be printed on. This allows
   * limiting the length of printable text per line. Values must be between
   * `0` and `1` (`0.4` to `1` is typical).
   */
  readonly ribbonFraction: number
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/PageWidth.ts#L54)

Since v1.0.0
PageWidth-PageWidth.md
Package: `@effect/printer`<br />
Module: `PageWidth`<br />

## PageWidth.PageWidth

Represents the maximum number of characters that fit onto a single line in a
document. The layout algorithms will try to avoid exceeding the set character
limit by inserting line breaks where appropriate (e.g., via `softLine`).

**Signature**

```ts
type PageWidth = AvailablePerLine | Unbounded
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/PageWidth.ts#L32)

Since v1.0.0
PageWidth-Unbounded.md
Package: `@effect/printer`<br />
Module: `PageWidth`<br />

## PageWidth.Unbounded

Represents a `PageWidth` setting that informs the layout algorithms to avoid
introducing line breaks into a document.

**Signature**

```ts
export interface Unbounded extends PageWidth.Proto {
  readonly _tag: "Unbounded"
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/PageWidth.ts#L76)

Since v1.0.0
PageWidth-isAvailablePerLine.md
Package: `@effect/printer`<br />
Module: `PageWidth`<br />

## PageWidth.isAvailablePerLine

Returns `true` if the specified `PageWidth` is an `AvailablePerLine`, `false`
otherwise.

**Signature**

```ts
declare const isAvailablePerLine: (self: PageWidth) => self is AvailablePerLine
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/PageWidth.ts#L99)

Since v1.0.0
PageWidth-isPageWidth.md
Package: `@effect/printer`<br />
Module: `PageWidth`<br />

## PageWidth.isPageWidth

Returns `true` if the specified value is a `PageWidth`, `false` otherwise.

**Signature**

```ts
declare const isPageWidth: (u: unknown) => u is PageWidth
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/PageWidth.ts#L90)

Since v1.0.0
PageWidth-isUnbounded.md
Package: `@effect/printer`<br />
Module: `PageWidth`<br />

## PageWidth.isUnbounded

Returns `true` if the specified `PageWidth` is an `Unbounded`, `false`
otherwise.

**Signature**

```ts
declare const isUnbounded: (self: PageWidth) => self is Unbounded
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/PageWidth.ts#L108)

Since v1.0.0
PageWidth-remainingWidth.md
Package: `@effect/printer`<br />
Module: `PageWidth`<br />

## PageWidth.remainingWidth

Calculates the remaining width on the current line.

**Signature**

```ts
declare const remainingWidth: (lineLength: number, ribbonFraction: number, lineIndent: number, currentColumn: number) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/printer/src/PageWidth.ts#L142)

Since v1.0.0
ParseResult-ArrayFormatterIssue.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.ArrayFormatterIssue

Represents an issue returned by the `ArrayFormatter` formatter.

**Signature**

```ts
export interface ArrayFormatterIssue {
  /**
   * The tag identifying the type of parse issue.
   */
  readonly _tag: ParseIssue["_tag"]

  /**
   * The path to the property where the issue occurred.
   */
  readonly path: ReadonlyArray<PropertyKey>

  /**
   * A descriptive message explaining the issue.
   */
  readonly message: string
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L1953)

Since v3.10.0
ParseResult-Composite.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.Composite

Error that contains multiple issues.

**Signature**

```ts
declare class Composite { constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly issues: SingleOrNonEmpty<ParseIssue>,
    readonly output?: unknown
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L122)

Since v3.10.0
ParseResult-Forbidden.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.Forbidden

The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).

**Signature**

```ts
declare class Forbidden { constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly message?: string
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L198)

Since v3.10.0
ParseResult-Missing.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.Missing

Error that occurs when a required key or index is missing.

**Signature**

```ts
declare class Missing { constructor(
    /**
     * @since 3.10.0
     */
    readonly ast: AST.Type,
    /**
     * @since 3.10.0
     */
    readonly message?: string
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L95)

Since v3.10.0
ParseResult-ParseIssue.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.ParseIssue

`ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.

**Signature**

```ts
type ParseIssue = | Type
  | Missing
  | Unexpected
  | Forbidden
  // composite
  | Pointer
  | Refinement
  | Transformation
  | Composite
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L29)

Since v3.10.0
ParseResult-Refinement.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.Refinement

Error that occurs when a refinement has an error.

**Signature**

```ts
declare class Refinement { constructor(
    readonly ast: AST.Refinement,
    readonly actual: unknown,
    readonly kind: "From" | "Predicate",
    readonly issue: ParseIssue
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L141)

Since v3.10.0
ParseResult-Transformation.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.Transformation

Error that occurs when a transformation has an error.

**Signature**

```ts
declare class Transformation { constructor(
    readonly ast: AST.Transformation,
    readonly actual: unknown,
    readonly kind: "Encoded" | "Transformation" | "Type",
    readonly issue: ParseIssue
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L160)

Since v3.10.0
ParseResult-Type.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.Type

The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.

**Signature**

```ts
declare class Type { constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly message?: string
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L180)

Since v3.10.0
ParseResult-Unexpected.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.Unexpected

Error that occurs when an unexpected key or index is present.

**Signature**

```ts
declare class Unexpected { constructor(
    readonly actual: unknown,
    /**
     * @since 3.10.0
     */
    readonly message?: string
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L75)

Since v3.10.0
ParseResult-asserts.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.asserts

By default the option `exact` is set to `true`.

**Throws**

`ParseError`

**Signature**

```ts
declare const asserts: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L677)

Since v3.10.0
ParseResult-is.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.is

By default the option `exact` is set to `true`.

**Signature**

```ts
declare const is: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions | number) => u is A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L664)

Since v3.10.0
ParseResult-isComposite.md
Package: `effect`<br />
Module: `ParseResult`<br />

## ParseResult.isComposite

Returns `true` if the value is a `Composite`.

**Signature**

```ts
declare const isComposite: (issue: ParseIssue) => issue is Composite
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L1834)

Since v3.10.0
Path-layer.md
Package: `@effect/platform`<br />
Module: `Path`<br />

## Path.layer

An implementation of the Path interface that can be used in all environments
(including browsers).

It uses the POSIX standard for paths.

**Signature**

```ts
declare const layer: Layer<Path, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Path.ts#L77)

Since v1.0.0
Permissions-Permissions.md
Package: `@effect/platform-browser`<br />
Module: `Permissions`<br />

## Permissions.Permissions

Wrapper on the Permission API (`navigator.permissions`)
with methods for querying status of permissions.

**Signature**

```ts
export interface Permissions {
  readonly [TypeId]: TypeId

  /**
   * Returns the state of a user permission on the global scope.
   */
  readonly query: <Name extends PermissionName>(
    name: Name
  ) => Effect.Effect<
    // `name` is identical to the name passed to Permissions.query
    // https://developer.mozilla.org/en-US/docs/Web/API/PermissionStatus
    Omit<PermissionStatus, "name"> & { name: Name },
    PermissionsError
  >
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/Permissions.ts#L28)

Since v1.0.0
Permissions-layer.md
Package: `@effect/platform-browser`<br />
Module: `Permissions`<br />

## Permissions.layer

A layer that directly interfaces with the `navigator.permissions` api

**Signature**

```ts
declare const layer: Layer.Layer<Permissions, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform-browser/src/Permissions.ts#L84)

Since v1.0.0
PlatformConfigProvider-fromDotEnv.md
Package: `@effect/platform`<br />
Module: `PlatformConfigProvider`<br />

## PlatformConfigProvider.fromDotEnv

Create a dotenv ConfigProvider.

**Signature**

```ts
declare const fromDotEnv: (paths: string) => Effect.Effect<ConfigProvider.ConfigProvider, PlatformError, FileSystem.FileSystem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/PlatformConfigProvider.ts#L122)

Since v1.0.0
PlatformConfigProvider-layerDotEnv.md
Package: `@effect/platform`<br />
Module: `PlatformConfigProvider`<br />

## PlatformConfigProvider.layerDotEnv

Add the dotenv ConfigProvider to the environment, replacing the current ConfigProvider.

**Signature**

```ts
declare const layerDotEnv: (path: string) => Layer.Layer<never, PlatformError, FileSystem.FileSystem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/PlatformConfigProvider.ts#L142)

Since v1.0.0
PlatformConfigProvider-layerDotEnvAdd.md
Package: `@effect/platform`<br />
Module: `PlatformConfigProvider`<br />

## PlatformConfigProvider.layerDotEnvAdd

Add the dotenv ConfigProvider to the environment, as a fallback to the current ConfigProvider.
If the file is not found, a debug log is produced and empty layer is returned.

**Signature**

```ts
declare const layerDotEnvAdd: (path: string) => Layer.Layer<never, never, FileSystem.FileSystem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/PlatformConfigProvider.ts#L133)

Since v1.0.0
PlatformConfigProvider-layerFileTree.md
Package: `@effect/platform`<br />
Module: `PlatformConfigProvider`<br />

## PlatformConfigProvider.layerFileTree

Add the file tree ConfigProvider to the environment, replacing the current ConfigProvider.

**Signature**

```ts
declare const layerFileTree: (options?: { readonly rootDirectory?: string; }) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/PlatformConfigProvider.ts#L108)

Since v1.0.0
PlatformConfigProvider-layerFileTreeAdd.md
Package: `@effect/platform`<br />
Module: `PlatformConfigProvider`<br />

## PlatformConfigProvider.layerFileTreeAdd

Add the file tree ConfigProvider to the environment, as a fallback to the current ConfigProvider.

**Signature**

```ts
declare const layerFileTreeAdd: (options?: { readonly rootDirectory?: string; }) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/PlatformConfigProvider.ts#L89)

Since v1.0.0
PlatformLogger-toFile.md
Package: `@effect/platform`<br />
Module: `PlatformLogger`<br />

## PlatformLogger.toFile

Create a Logger from another string Logger that writes to the specified file.

**Example**

```ts
import { PlatformLogger } from "@effect/platform"
import { NodeFileSystem, NodeRuntime } from "@effect/platform-node"
import { Effect, Layer, Logger } from "effect"

const fileLogger = Logger.logfmtLogger.pipe(
  PlatformLogger.toFile("/tmp/log.txt")
)
const LoggerLive = Logger.replaceScoped(Logger.defaultLogger, fileLogger).pipe(
  Layer.provide(NodeFileSystem.layer)
)

Effect.log("a").pipe(
  Effect.zipRight(Effect.log("b")),
  Effect.zipRight(Effect.log("c")),
  Effect.provide(LoggerLive),
  NodeRuntime.runMain
)
```

**Signature**

```ts
declare const toFile: { (path: string, options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined; }) | undefined): <Message>(self: Logger.Logger<Message, string>) => Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>; <Message>(self: Logger.Logger<Message, string>, path: string, options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined; }) | undefined): Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/PlatformLogger.ts#L39)

Since v1.0.0
Pool-get.md
Package: `effect`<br />
Module: `Pool`<br />

## Pool.get

Retrieves an item from the pool in a scoped effect. Note that if
acquisition fails, then the returned effect will fail for that same reason.
Retrying a failed acquisition attempt will repeat the acquisition attempt.

**Signature**

```ts
declare const get: <A, E>(self: Pool<A, E>) => Effect.Effect<A, E, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L191)

Since v2.0.0
Pool-Pool.md
Package: `effect`<br />
Module: `Pool`<br />

## Pool.Pool

A `Pool<A, E>` is a pool of items of type `A`, each of which may be
associated with the acquisition and release of resources. An attempt to get
an item `A` from a pool may fail with an error of type `E`.

**Signature**

```ts
export interface Pool<in out A, out E = never> extends Pool.Variance<A, E>, Effect.Effect<A, E, Scope.Scope>, Pipeable {
  /**
   * Retrieves an item from the pool in a scoped effect. Note that if
   * acquisition fails, then the returned effect will fail for that same reason.
   * Retrying a failed acquisition attempt will repeat the acquisition attempt.
   */
  readonly get: Effect.Effect<A, E, Scope.Scope>

  /**
   * Invalidates the specified item. This will cause the pool to eventually
   * reallocate the item, although this reallocation may occur lazily rather
   * than eagerly.
   */
  invalidate(item: A): Effect.Effect<void>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: PoolUnify<this>
  readonly [Unify.ignoreSymbol]?: PoolUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L32)

Since v2.0.0
Pool-invalidate.md
Package: `effect`<br />
Module: `Pool`<br />

## Pool.invalidate

Invalidates the specified item. This will cause the pool to eventually
reallocate the item, although this reallocation may occur lazily rather
than eagerly.

**Signature**

```ts
declare const invalidate: { <A>(value: A): <E>(self: Pool<A, E>) => Effect.Effect<void, never, Scope.Scope>; <A, E>(self: Pool<A, E>, value: A): Effect.Effect<void, never, Scope.Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L201)

Since v2.0.0
Pool-isPool.md
Package: `effect`<br />
Module: `Pool`<br />

## Pool.isPool

Returns `true` if the specified value is a `Pool`, `false` otherwise.

**Signature**

```ts
declare const isPool: (u: unknown) => u is Pool<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L94)

Since v2.0.0
Pool-make.md
Package: `effect`<br />
Module: `Pool`<br />

## Pool.make

Makes a new pool of the specified fixed size. The pool is returned in a
`Scope`, which governs the lifetime of the pool. When the pool is shutdown
because the `Scope` is closed, the individual items allocated by the pool
will be released in some unspecified order.

By setting the `concurrency` parameter, you can control the level of concurrent
access per pool item. By default, the number of permits is set to `1`.

`targetUtilization` determines when to create new pool items. It is a value
between 0 and 1, where 1 means only create new pool items when all the existing
items are fully utilized.

A `targetUtilization` of 0.5 will create new pool items when the existing items are
50% utilized.

**Signature**

```ts
declare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly size: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L115)

Since v2.0.0
Pool-makeWithTTL.md
Package: `effect`<br />
Module: `Pool`<br />

## Pool.makeWithTTL

Makes a new pool with the specified minimum and maximum sizes and time to
live before a pool whose excess items are not being used will be shrunk
down to the minimum size. The pool is returned in a `Scope`, which governs
the lifetime of the pool. When the pool is shutdown because the `Scope` is
used, the individual items allocated by the pool will be released in some
unspecified order.

By setting the `concurrency` parameter, you can control the level of concurrent
access per pool item. By default, the number of permits is set to `1`.

`targetUtilization` determines when to create new pool items. It is a value
between 0 and 1, where 1 means only create new pool items when all the existing
items are fully utilized.

A `targetUtilization` of 0.5 will create new pool items when the existing items are
50% utilized.

The `timeToLiveStrategy` determines how items are invalidated. If set to
"creation", then items are invalidated based on their creation time. If set
to "usage", then items are invalidated based on pool usage.

By default, the `timeToLiveStrategy` is set to "usage".

```ts
import { createConnection } from "mysql2";
import { Duration, Effect, Pool } from "effect"

const acquireDBConnection = Effect.acquireRelease(
  Effect.sync(() => createConnection('mysql://...')),
  (connection) => Effect.sync(() => connection.end(() => {})),
)

const connectionPool = Effect.flatMap(
 Pool.makeWithTTL({
    acquire: acquireDBConnection,
    min: 10,
    max: 20,
    timeToLive: Duration.seconds(60)
  }),
  (pool) => pool.get
)
```

**Signature**

```ts
declare const makeWithTTL: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly min: number; readonly max: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; readonly timeToLive: Duration.DurationInput; readonly timeToLiveStrategy?: "creation" | "usage" | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L171)

Since v2.0.0
Predicate-and.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.and

Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.

**Example**

```ts
import * as assert from "node:assert"
import { Predicate } from "effect"

const minLength = (n: number) => (s: string) => s.length >= n
const maxLength = (n: number) => (s: string) => s.length <= n

const length = (n: number) => Predicate.and(minLength(n), maxLength(n))

assert.deepStrictEqual(length(2)("aa"), true)
assert.deepStrictEqual(length(2)("a"), false)
assert.deepStrictEqual(length(2)("aaa"), false)
```

**Signature**

```ts
declare const and: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L886)

Since v2.0.0
Predicate-hasProperty.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.hasProperty

Checks whether a value is an `object` containing a specified property key.

**Signature**

```ts
declare const hasProperty: { <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown; }; <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown; }; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L467)

Since v2.0.0
Predicate-implies.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.implies

Represents the logical implication combinator for predicates. In formal
logic, the implication operator `->` denotes that if the first proposition
(antecedent) is true, then the second proposition (consequent) must also be
true. In simpler terms, `p implies q` can be interpreted as "if p then q". If
the first predicate holds, then the second predicate must hold
for the given context.

In practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.

Note that if the antecedent is `false`, the result is `true` by default
because the outcome of the consequent cannot be determined.

This function is useful in situations where you need to enforce rules or
constraints that are contingent on certain conditions.
It proves especially helpful in defining property tests.

The example below illustrates the transitive property of order using the
`implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`
must be true.

**Example**

```ts
import * as assert from "node:assert"
import { Predicate } from "effect"

type Triple = {
  readonly a: number
  readonly b: number
  readonly c: number
}

const transitivity = Predicate.implies(
  // antecedent
  (input: Triple) => input.a <= input.b && input.b <= input.c,
  // consequent
  (input: Triple) => input.a <= input.c
)

assert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)
// antecedent is `false`, so the result is `true`
assert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)
```

**Signature**

```ts
declare const implies: { <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>; <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L958)

Since v2.0.0
Predicate-isBigInt.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isBigInt

Tests if a value is a `bigint`.

**Example**

```ts
import * as assert from "node:assert"
import { isBigInt } from "effect/Predicate"

assert.deepStrictEqual(isBigInt(1n), true)

assert.deepStrictEqual(isBigInt(1), false)
```

**Signature**

```ts
declare const isBigInt: (input: unknown) => input is bigint
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L280)

Since v2.0.0
Predicate-isBoolean.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isBoolean

Tests if a value is a `boolean`.

**Example**

```ts
import * as assert from "node:assert"
import { isBoolean } from "effect/Predicate"

assert.deepStrictEqual(isBoolean(true), true)

assert.deepStrictEqual(isBoolean("true"), false)
```

**Signature**

```ts
declare const isBoolean: (input: unknown) => input is boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L262)

Since v2.0.0
Predicate-isDate.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isDate

A guard that succeeds when the input is a `Date`.

**Example**

```ts
import * as assert from "node:assert"
import { isDate } from "effect/Predicate"

assert.deepStrictEqual(isDate(new Date()), true)

assert.deepStrictEqual(isDate(null), false)
assert.deepStrictEqual(isDate({}), false)
```

**Signature**

```ts
declare const isDate: (input: unknown) => input is Date
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L598)

Since v2.0.0
Predicate-isError.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isError

A guard that succeeds when the input is an `Error`.

**Example**

```ts
import * as assert from "node:assert"
import { isError } from "effect/Predicate"

assert.deepStrictEqual(isError(new Error()), true)

assert.deepStrictEqual(isError(null), false)
assert.deepStrictEqual(isError({}), false)
```

**Signature**

```ts
declare const isError: (input: unknown) => input is Error
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L560)

Since v2.0.0
Predicate-isFunction.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isFunction

Tests if a value is a `function`.

**Example**

```ts
import * as assert from "node:assert"
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)

assert.deepStrictEqual(isFunction("function"), false)
```

**Signature**

```ts
declare const isFunction: (input: unknown) => input is Function
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L320)

Since v2.0.0
Predicate-isIterable.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isIterable

A guard that succeeds when the input is an `Iterable`.

**Example**

```ts
import * as assert from "node:assert"
import { isIterable } from "effect/Predicate"

assert.deepStrictEqual(isIterable([]), true)
assert.deepStrictEqual(isIterable(new Set()), true)

assert.deepStrictEqual(isIterable(null), false)
assert.deepStrictEqual(isIterable({}), false)
```

**Signature**

```ts
declare const isIterable: (input: unknown) => input is Iterable<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L618)

Since v2.0.0
Predicate-isMap.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isMap

Tests if a value is a `Map`.

**Example**

```ts
import * as assert from "node:assert"
import { isMap } from "effect/Predicate"

assert.deepStrictEqual(isMap(new Map()), true)
assert.deepStrictEqual(isMap({}), false)
assert.deepStrictEqual(isMap(null), false)
assert.deepStrictEqual(isMap(undefined), false)
```

**Signature**

```ts
declare const isMap: (input: unknown) => input is Map<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L208)

Since v2.0.0
Predicate-isNever.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isNever

A guard that always fails.

**Example**

```ts
import * as assert from "node:assert"
import { isNever } from "effect/Predicate"

assert.deepStrictEqual(isNever(null), false)
assert.deepStrictEqual(isNever(undefined), false)
assert.deepStrictEqual(isNever({}), false)
assert.deepStrictEqual(isNever([]), false)
```

**Signature**

```ts
declare const isNever: (input: unknown) => input is never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L415)

Since v2.0.0
Predicate-isNotNull.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isNotNull

Tests if a value is not `null`.

**Example**

```ts
import * as assert from "node:assert"
import { isNotNull } from "effect/Predicate"

assert.deepStrictEqual(isNotNull(undefined), true)
assert.deepStrictEqual(isNotNull("null"), true)

assert.deepStrictEqual(isNotNull(null), false)
```

**Signature**

```ts
declare const isNotNull: <A>(input: A) => input is Exclude<A, null>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L396)

Since v2.0.0
Predicate-isNotNullable.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isNotNullable

A guard that succeeds when the input is not `null` or `undefined`.

**Example**

```ts
import * as assert from "node:assert"
import { isNotNullable } from "effect/Predicate"

assert.deepStrictEqual(isNotNullable({}), true)
assert.deepStrictEqual(isNotNullable([]), true)

assert.deepStrictEqual(isNotNullable(null), false)
assert.deepStrictEqual(isNotNullable(undefined), false)
```

**Signature**

```ts
declare const isNotNullable: <A>(input: A) => input is NonNullable<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L541)

Since v2.0.0
Predicate-isNotUndefined.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isNotUndefined

Tests if a value is not `undefined`.

**Example**

```ts
import * as assert from "node:assert"
import { isNotUndefined } from "effect/Predicate"

assert.deepStrictEqual(isNotUndefined(null), true)
assert.deepStrictEqual(isNotUndefined("undefined"), true)

assert.deepStrictEqual(isNotUndefined(undefined), false)
```

**Signature**

```ts
declare const isNotUndefined: <A>(input: A) => input is Exclude<A, undefined>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L358)

Since v2.0.0
Predicate-isNull.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isNull

Tests if a value is `null`.

**Example**

```ts
import * as assert from "node:assert"
import { isNull } from "effect/Predicate"

assert.deepStrictEqual(isNull(null), true)

assert.deepStrictEqual(isNull(undefined), false)
assert.deepStrictEqual(isNull("null"), false)
```

**Signature**

```ts
declare const isNull: (input: unknown) => input is null
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L377)

Since v2.0.0
Predicate-isNullable.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isNullable

A guard that succeeds when the input is `null` or `undefined`.

**Example**

```ts
import * as assert from "node:assert"
import { isNullable } from "effect/Predicate"

assert.deepStrictEqual(isNullable(null), true)
assert.deepStrictEqual(isNullable(undefined), true)

assert.deepStrictEqual(isNullable({}), false)
assert.deepStrictEqual(isNullable([]), false)
```

**Signature**

```ts
declare const isNullable: <A>(input: A) => input is Extract<A, null | undefined>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L521)

Since v2.0.0
Predicate-isNumber.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isNumber

Tests if a value is a `number`.

**Example**

```ts
import * as assert from "node:assert"
import { isNumber } from "effect/Predicate"

assert.deepStrictEqual(isNumber(2), true)

assert.deepStrictEqual(isNumber("2"), false)
```

**Signature**

```ts
declare const isNumber: (input: unknown) => input is number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L244)

Since v2.0.0
Predicate-isObject.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isObject

Tests if a value is an `object`.

**Example**

```ts
import * as assert from "node:assert"
import { isObject } from "effect/Predicate"

assert.deepStrictEqual(isObject({}), true)
assert.deepStrictEqual(isObject([]), true)

assert.deepStrictEqual(isObject(null), false)
assert.deepStrictEqual(isObject(undefined), false)
```

**Signature**

```ts
declare const isObject: (input: unknown) => input is object
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L459)

Since v2.0.0
Predicate-isPromise.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isPromise

A guard that succeeds when the input is a Promise.

**Example**

```ts
import * as assert from "node:assert"
import { isPromise } from "effect/Predicate"

assert.deepStrictEqual(isPromise({}), false)
assert.deepStrictEqual(isPromise(Promise.resolve("hello")), true)
```

**Signature**

```ts
declare const isPromise: (input: unknown) => input is Promise<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L683)

Since v2.0.0
Predicate-isReadonlyRecord.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isReadonlyRecord

A guard that succeeds when the input is a readonly record.

**Example**

```ts
import * as assert from "node:assert"
import { isReadonlyRecord } from "effect/Predicate"

assert.deepStrictEqual(isReadonlyRecord({}), true)
assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)

assert.deepStrictEqual(isReadonlyRecord([]), false)
assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)
assert.deepStrictEqual(isReadonlyRecord(null), false)
assert.deepStrictEqual(isReadonlyRecord(undefined), false)
```

**Signature**

```ts
declare const isReadonlyRecord: (input: unknown) => input is { readonly [x: string | symbol]: unknown; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L664)

Since v2.0.0
Predicate-isRecord.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isRecord

A guard that succeeds when the input is a record.

**Example**

```ts
import * as assert from "node:assert"
import { isRecord } from "effect/Predicate"

assert.deepStrictEqual(isRecord({}), true)
assert.deepStrictEqual(isRecord({ a: 1 }), true)

assert.deepStrictEqual(isRecord([]), false)
assert.deepStrictEqual(isRecord([1, 2, 3]), false)
assert.deepStrictEqual(isRecord(null), false)
assert.deepStrictEqual(isRecord(undefined), false)
assert.deepStrictEqual(isRecord(() => null), false)
```

**Signature**

```ts
declare const isRecord: (input: unknown) => input is { [x: string | symbol]: unknown; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L641)

Since v2.0.0
Predicate-isRegExp.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isRegExp

Tests if a value is a `RegExp`.

**Example**

```ts
import * as assert from "node:assert"
import { Predicate } from "effect"

assert.deepStrictEqual(Predicate.isRegExp(/a/), true)
assert.deepStrictEqual(Predicate.isRegExp("a"), false)
```

**Signature**

```ts
declare const isRegExp: (input: unknown) => input is RegExp
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L711)

Since v3.9.0
Predicate-isSet.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isSet

Tests if a value is a `Set`.

**Example**

```ts
import * as assert from "node:assert"
import { isSet } from "effect/Predicate"

assert.deepStrictEqual(isSet(new Set([1, 2])), true)
assert.deepStrictEqual(isSet(new Set()), true)
assert.deepStrictEqual(isSet({}), false)
assert.deepStrictEqual(isSet(null), false)
assert.deepStrictEqual(isSet(undefined), false)
```

**Signature**

```ts
declare const isSet: (input: unknown) => input is Set<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L189)

Since v2.0.0
Predicate-isString.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isString

Tests if a value is a `string`.

**Example**

```ts
import * as assert from "node:assert"
import { isString } from "effect/Predicate"

assert.deepStrictEqual(isString("a"), true)

assert.deepStrictEqual(isString(1), false)
```

**Signature**

```ts
declare const isString: (input: unknown) => input is string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L226)

Since v2.0.0
Predicate-isSymbol.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isSymbol

Tests if a value is a `symbol`.

**Example**

```ts
import * as assert from "node:assert"
import { isSymbol } from "effect/Predicate"

assert.deepStrictEqual(isSymbol(Symbol.for("a")), true)

assert.deepStrictEqual(isSymbol("a"), false)
```

**Signature**

```ts
declare const isSymbol: (input: unknown) => input is symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L298)

Since v2.0.0
Predicate-isTagged.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isTagged

Tests if a value is an `object` with a property `_tag` that matches the given tag.

**Example**

```ts
import * as assert from "node:assert"
import { isTagged } from "effect/Predicate"

assert.deepStrictEqual(isTagged(1, "a"), false)
assert.deepStrictEqual(isTagged(null, "a"), false)
assert.deepStrictEqual(isTagged({}, "a"), false)
assert.deepStrictEqual(isTagged({ a: "a" }, "a"), false)
assert.deepStrictEqual(isTagged({ _tag: "a" }, "a"), true)
assert.deepStrictEqual(isTagged("a")({ _tag: "a" }), true)
```

**Signature**

```ts
declare const isTagged: { <K extends string>(tag: K): (self: unknown) => self is { _tag: K; }; <K extends string>(self: unknown, tag: K): self is { _tag: K; }; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L495)

Since v2.0.0
Predicate-isTruthy.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isTruthy

Tests if a value is `truthy`.

**Example**

```ts
import * as assert from "node:assert"
import { isTruthy } from "effect/Predicate"

assert.deepStrictEqual(isTruthy(1), true)
assert.deepStrictEqual(isTruthy(0), false)
assert.deepStrictEqual(isTruthy(""), false)
```

**Signature**

```ts
declare const isTruthy: (input: unknown) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L169)

Since v2.0.0
Predicate-isTupleOf.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isTupleOf

Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.

An `Array` is considered to be a `TupleOf` if its length is exactly `N`.

**Example**

```ts
import * as assert from "node:assert"
import { isTupleOf } from "effect/Predicate"

assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3];
if (isTupleOf(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number]
}
```

**Signature**

```ts
declare const isTupleOf: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L119)

Since v3.3.0
Predicate-isTupleOfAtLeast.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isTupleOfAtLeast

Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.

An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.

**Example**

```ts
import * as assert from "node:assert"
import { isTupleOfAtLeast } from "effect/Predicate"

assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3, 4];
if (isTupleOfAtLeast(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number, ...number[]]
}
```

**Signature**

```ts
declare const isTupleOfAtLeast: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L148)

Since v3.3.0
Predicate-isUint8Array.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isUint8Array

A guard that succeeds when the input is a `Uint8Array`.

**Example**

```ts
import * as assert from "node:assert"
import { isUint8Array } from "effect/Predicate"

assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)

assert.deepStrictEqual(isUint8Array(null), false)
assert.deepStrictEqual(isUint8Array({}), false)
```

**Signature**

```ts
declare const isUint8Array: (input: unknown) => input is Uint8Array
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L579)

Since v2.0.0
Predicate-isUndefined.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isUndefined

Tests if a value is `undefined`.

**Example**

```ts
import * as assert from "node:assert"
import { isUndefined } from "effect/Predicate"

assert.deepStrictEqual(isUndefined(undefined), true)

assert.deepStrictEqual(isUndefined(null), false)
assert.deepStrictEqual(isUndefined("undefined"), false)
```

**Signature**

```ts
declare const isUndefined: (input: unknown) => input is undefined
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L339)

Since v2.0.0
Predicate-isUnknown.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.isUnknown

A guard that always succeeds.

**Example**

```ts
import * as assert from "node:assert"
import { isUnknown } from "effect/Predicate"

assert.deepStrictEqual(isUnknown(null), true)
assert.deepStrictEqual(isUnknown(undefined), true)

assert.deepStrictEqual(isUnknown({}), true)
assert.deepStrictEqual(isUnknown([]), true)
```

**Signature**

```ts
declare const isUnknown: (input: unknown) => input is unknown
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L435)

Since v2.0.0
Predicate-mapInput.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.mapInput

Given a `Predicate<A>` returns a `Predicate<B>`

**Example**

```ts
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)

assert.deepStrictEqual(minLength3("a"), false)
assert.deepStrictEqual(minLength3("aa"), false)
assert.deepStrictEqual(minLength3("aaa"), true)
assert.deepStrictEqual(minLength3("aaaa"), true)
```

**Signature**

```ts
declare const mapInput: { <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>; <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L90)

Since v2.0.0
Predicate-not.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.not

Negates the result of a given predicate.

**Example**

```ts
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const isPositive = Predicate.not(Number.lessThan(0))

assert.deepStrictEqual(isPositive(-1), false)
assert.deepStrictEqual(isPositive(0), true)
assert.deepStrictEqual(isPositive(1), true)
```

**Signature**

```ts
declare const not: <A>(self: Predicate<A>) => Predicate<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L838)

Since v2.0.0
Predicate-or.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.or

Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.

**Example**

```ts
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))

assert.deepStrictEqual(nonZero(-1), true)
assert.deepStrictEqual(nonZero(0), false)
assert.deepStrictEqual(nonZero(1), true)
```

**Signature**

```ts
declare const or: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L858)

Since v2.0.0
Predicate-struct.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.struct

```ts
{ ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>
{ a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>
{ ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: ; ... }>
```

**Signature**

```ts
declare const struct: <R extends Record<string, Predicate.Any>>(fields: R) => [Extract<R[keyof R], Refinement.Any>] extends [never] ? Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]>; }> : Refinement<{ readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]>; }, { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]>; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L799)

Since v2.0.0
Predicate-tuple.md
Package: `effect`<br />
Module: `Predicate`<br />

## Predicate.tuple

Similar to `Promise.all` but operates on `Predicate`s.

```ts
[Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>
[Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>
[Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>
```

**Signature**

```ts
declare const tuple: <T extends ReadonlyArray<Predicate.Any>>(...elements: T) => [Extract<T[number], Refinement.Any>] extends [never] ? Predicate<{ readonly [I in keyof T]: Predicate.In<T[I]>; }> : Refinement<{ readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.In<T[I]> : Predicate.In<T[I]>; }, { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.Out<T[I]> : Predicate.In<T[I]>; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L780)

Since v2.0.0
Primitive-Primitive.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.Primitive

A `Primitive` represents the primitive types supported by Effect CLI.

Each primitive type has a way to parse and validate from a string.

**Signature**

```ts
export interface Primitive<A> extends Primitive.Variance<A> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L34)

Since v1.0.0
Primitive-boolean.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.boolean

Represents a boolean value.

True values can be passed as one of: `["true", "1", "y", "yes" or "on"]`.
False value can be passed as one of: `["false", "o", "n", "no" or "off"]`.

**Signature**

```ts
declare const boolean: (defaultValue: Option<boolean>) => Primitive<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L89)

Since v1.0.0
Primitive-date.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.date

Represents a date in ISO-8601 format, such as `2007-12-03T10:15:30`.

**Signature**

```ts
declare const date: Primitive<Date>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L103)

Since v1.0.0
Primitive-float.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.float

Represents a floating point number.

**Signature**

```ts
declare const float: Primitive<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L111)

Since v1.0.0
Primitive-getChoices.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.getChoices

Returns a text representation of the valid choices for a primitive type, if
any.

**Signature**

```ts
declare const getChoices: <A>(self: Primitive<A>) => Option<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L120)

Since v1.0.0
Primitive-getHelp.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.getHelp

Returns help documentation for a primitive type.

**Signature**

```ts
declare const getHelp: <A>(self: Primitive<A>) => Span
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L128)

Since v1.0.0
Primitive-getTypeName.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.getTypeName

Returns a string representation of the primitive type.

**Signature**

```ts
declare const getTypeName: <A>(self: Primitive<A>) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L136)

Since v1.0.0
Primitive-integer.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.integer

Represents an integer.

**Signature**

```ts
declare const integer: Primitive<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L144)

Since v1.0.0
Primitive-text.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.text

Represents a user-defined piece of text.

**Signature**

```ts
declare const text: Primitive<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L152)

Since v1.0.0
Primitive-validate.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.validate

Validates that the specified value, if any, matches the specified primitive
type.

**Signature**

```ts
declare const validate: { (value: Option<string>, config: CliConfig): <A>(self: Primitive<A>) => Effect<A, string, FileSystem>; <A>(self: Primitive<A>, value: Option<string>, config: CliConfig): Effect<A, string, FileSystem>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L161)

Since v1.0.0
Primitive-wizard.md
Package: `@effect/cli`<br />
Module: `Primitive`<br />

## Primitive.wizard

Runs a wizard that will prompt the user for input matching the specified
primitive type.

**Signature**

```ts
declare const wizard: { (help: HelpDoc): <A>(self: Primitive<A>) => Prompt<A>; <A>(self: Primitive<A>, help: HelpDoc): Prompt<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Primitive.ts#L180)

Since v1.0.0
Prompt-Prompt.Action.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.Prompt.Action

Represents the action that should be taken by a `Prompt` based upon the
user input received during the current frame.

**Signature**

```ts
type { readonly _tag: "Beep"; } | { readonly _tag: "NextFrame"; readonly state: State; } | { readonly _tag: "Submit"; readonly value: Output; } = TaggedEnum<{
    readonly Beep: {}
    readonly NextFrame: { readonly state: State }
    readonly Submit: { readonly value: Output }
  }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L76)

Since v1.0.0
Prompt-Prompt.ActionDefinition.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.Prompt.ActionDefinition

Represents the definition of an `Action`.

Required to create a `Data.TaggedEnum` with generic type arguments.

**Signature**

```ts
export interface ActionDefinition extends TaggedEnum.WithGenerics<2> {
    readonly taggedEnum: Action<this["A"], this["B"]>
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L90)

Since v1.0.0
Prompt-Prompt.Environment.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.Prompt.Environment

Represents the services available to a custom `Prompt`.

**Signature**

```ts
type Environment = FileSystem | Path | Terminal
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L67)

Since v1.0.0
Prompt-Prompt.Handlers.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.Prompt.Handlers

Represents the set of handlers used by a `Prompt` to:

  - Render the current frame of the prompt
  - Process user input and determine the next `Prompt.Action` to take
  - Clear the terminal screen before the next frame

**Signature**

```ts
export interface Handlers<State, Output> {
    /**
     * A function that is called to render the current frame of the `Prompt`.
     *
     * @param state The current state of the prompt.
     * @param action The `Prompt.Action` for the current frame.
     * @returns An ANSI escape code sequence to display in the terminal screen.
     */
    readonly render: (
      state: State,
      action: Action<State, Output>
    ) => Effect<string, never, Environment>
    /**
     * A function that is called to process user input and determine the next
     * `Prompt.Action` that should be taken.
     *
     * @param input The input the user provided for the current frame.
     * @param state The current state of the prompt.
     * @returns The next `Prompt.Action` that should be taken.
     */
    readonly process: (
      input: UserInput,
      state: State
    ) => Effect<Action<State, Output>, never, Environment>
    /**
     * A function that is called to clear the terminal screen before rendering
     * the next frame of the `Prompt`.
     *
     * @param action The `Prompt.Action` for the current frame.
     * @param columns The current number of columns available in the `Terminal`.
     * @returns An ANSI escape code sequence used to clear the terminal screen.
     */
    readonly clear: (
      state: State,
      action: Action<State, Output>
    ) => Effect<string, never, Environment>
  }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L104)

Since v1.0.0
Prompt-all.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.all

Runs all the provided prompts in sequence respecting the structure provided
in input.

Supports either a tuple / iterable of prompts or a record / struct of prompts
as an argument.

**Example**

```ts
import * as Prompt from "@effect/cli/Prompt"
import * as Effect from "effect/Effect"

const username = Prompt.text({
  message: "Enter your username: "
})

const password = Prompt.password({
  message: "Enter your password: ",
  validate: (value) =>
    value.length === 0
      ? Effect.fail("Password cannot be empty")
      : Effect.succeed(value)
})

const allWithTuple = Prompt.all([username, password])

const allWithRecord = Prompt.all({ username, password })
```

**Signature**

```ts
declare const all: <const Arg extends Iterable<Prompt<any>> | Record<string, Prompt<any>>>(arg: Arg) => All.Return<Arg>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L545)

Since v1.0.0
Prompt-custom.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.custom

Creates a custom `Prompt` from the specified initial state and handlers.

The initial state can either be a pure value or an `Effect`. This is
particularly useful when the initial state of the `Prompt` must be computed
by performing some effectful computation, such as reading data from the file
system.

A `Prompt` is essentially a render loop where user input triggers a new frame
to be rendered to the `Terminal`. The `handlers` of a custom prompt are used
to control what is rendered to the `Terminal` each frame. During each frame,
the following occurs:

  1. The `render` handler is called with this frame's prompt state and prompt
     action and returns an ANSI escape string to be rendered to the
     `Terminal`
  2. The `Terminal` obtains input from the user
  3. The `process` handler is called with the input obtained from the user
     and this frame's prompt state and returns the next prompt action that
     should be performed
  4. The `clear` handler is called with this frame's prompt state and prompt
     action and returns an ANSI escape string used to clear the screen of
     the `Terminal`

**Signature**

```ts
declare const custom: <State, Output>(initialState: State | Effect<State, never, Prompt.Environment>, handlers: Prompt.Handlers<State, Output>) => Prompt<Output>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L581)

Since v1.0.0
Prompt-run.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.run

Executes the specified `Prompt`.

**Signature**

```ts
declare const run: <Output>(self: Prompt<Output>) => Effect<Output, QuitException, Prompt.Environment>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L654)

Since v1.0.0
Prompt-succeed.md
Package: `@effect/cli`<br />
Module: `Prompt`<br />

## Prompt.succeed

Creates a `Prompt` which immediately succeeds with the specified value.

**NOTE**: This method will not attempt to obtain user input or render
anything to the screen.

**Signature**

```ts
declare const succeed: <A>(value: A) => Prompt<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/cli/src/Prompt.ts#L679)

Since v1.0.0
PubSub-PubSub.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.PubSub

A `PubSub<A>` is an asynchronous message hub into which publishers can publish
messages of type `A` and subscribers can subscribe to take messages of type
`A`.

**Signature**

```ts
export interface PubSub<in out A> extends Queue.Enqueue<A>, Pipeable {
  /**
   * Publishes a message to the `PubSub`, returning whether the message was published
   * to the `PubSub`.
   */
  publish(value: A): Effect.Effect<boolean>

  /**
   * Publishes all of the specified messages to the `PubSub`, returning whether they
   * were published to the `PubSub`.
   */
  publishAll(elements: Iterable<A>): Effect.Effect<boolean>

  /**
   * Subscribes to receive messages from the `PubSub`. The resulting subscription can
   * be evaluated multiple times within the scope to take a message from the `PubSub`
   * each time.
   */
  readonly subscribe: Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L18)

Since v2.0.0
PubSub-awaitShutdown.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.awaitShutdown

Waits until the queue is shutdown. The `Effect` returned by this method will
not resume until the queue has been shutdown. If the queue is already
shutdown, the `Effect` will resume right away.

**Signature**

```ts
declare const awaitShutdown: <A>(self: PubSub<A>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L148)

Since v2.0.0
PubSub-bounded.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.bounded

Creates a bounded `PubSub` with the back pressure strategy. The `PubSub` will retain
messages until they have been taken by all subscribers, applying back
pressure to publishers if the `PubSub` is at capacity.

For best performance use capacities that are powers of two.

**Signature**

```ts
declare const bounded: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L49)

Since v2.0.0
PubSub-capacity.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.capacity

Returns the number of elements the queue can hold.

**Signature**

```ts
declare const capacity: <A>(self: PubSub<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L94)

Since v2.0.0
PubSub-dropping.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.dropping

Creates a bounded `PubSub` with the dropping strategy. The `PubSub` will drop new
messages if the `PubSub` is at capacity.

For best performance use capacities that are powers of two.

**Signature**

```ts
declare const dropping: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L62)

Since v2.0.0
PubSub-isEmpty.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.isEmpty

Returns `true` if the `Queue` contains zero elements, `false` otherwise.

**Signature**

```ts
declare const isEmpty: <A>(self: PubSub<A>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L121)

Since v2.0.0
PubSub-isFull.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.isFull

Returns `true` if the `Queue` contains at least one element, `false`
otherwise.

**Signature**

```ts
declare const isFull: <A>(self: PubSub<A>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L113)

Since v2.0.0
PubSub-isShutdown.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

**Signature**

```ts
declare const isShutdown: <A>(self: PubSub<A>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L138)

Since v2.0.0
PubSub-publish.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.publish

Publishes a message to the `PubSub`, returning whether the message was published
to the `PubSub`.

**Signature**

```ts
declare const publish: { <A>(value: A): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, value: A): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L157)

Since v2.0.0
PubSub-publishAll.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.publishAll

Publishes all of the specified messages to the `PubSub`, returning whether they
were published to the `PubSub`.

**Signature**

```ts
declare const publishAll: { <A>(elements: Iterable<A>): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, elements: Iterable<A>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L169)

Since v2.0.0
PubSub-shutdown.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

**Signature**

```ts
declare const shutdown: <A>(self: PubSub<A>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L130)

Since v2.0.0
PubSub-size.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.size

Retrieves the size of the queue, which is equal to the number of elements
in the queue. This may be negative if fibers are suspended waiting for
elements to be added to the queue.

**Signature**

```ts
declare const size: <A>(self: PubSub<A>) => Effect.Effect<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L104)

Since v2.0.0
PubSub-sliding.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.sliding

Creates a bounded `PubSub` with the sliding strategy. The `PubSub` will add new
messages and drop old messages if the `PubSub` is at capacity.

For best performance use capacities that are powers of two.

**Signature**

```ts
declare const sliding: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L75)

Since v2.0.0
PubSub-subscribe.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.subscribe

Subscribes to receive messages from the `PubSub`. The resulting subscription can
be evaluated multiple times within the scope to take a message from the `PubSub`
each time.

**Signature**

```ts
declare const subscribe: <A>(self: PubSub<A>) => Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L182)

Since v2.0.0
PubSub-unbounded.md
Package: `effect`<br />
Module: `PubSub`<br />

## PubSub.unbounded

Creates an unbounded `PubSub`.

**Signature**

```ts
declare const unbounded: <A>(options?: { readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L85)

Since v2.0.0
Queue-BaseQueue.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.BaseQueue

The base interface that all `Queue`s must implement.

**Signature**

```ts
export interface BaseQueue {
  /**
   * Returns the number of elements the queue can hold.
   */
  capacity(): number

  /**
   * Returns false if shutdown has been called.
   */
  isActive(): boolean

  /**
   * Retrieves the size of the queue, which is equal to the number of elements
   * in the queue. This may be negative if fibers are suspended waiting for
   * elements to be added to the queue.
   */
  readonly size: Effect.Effect<number>

  /**
   * Retrieves the size of the queue, which is equal to the number of elements
   * in the queue. This may be negative if fibers are suspended waiting for
   * elements to be added to the queue. Returns None if shutdown has been called
   */
  unsafeSize(): Option.Option<number>

  /**
   * Returns `true` if the `Queue` contains at least one element, `false`
   * otherwise.
   */
  readonly isFull: Effect.Effect<boolean>

  /**
   * Returns `true` if the `Queue` contains zero elements, `false` otherwise.
   */
  readonly isEmpty: Effect.Effect<boolean>

  /**
   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls
   * to `offer*` and `take*` will be interrupted immediately.
   */
  readonly shutdown: Effect.Effect<void>

  /**
   * Returns `true` if `shutdown` has been called, otherwise returns `false`.
   */
  readonly isShutdown: Effect.Effect<boolean>

  /**
   * Waits until the queue is shutdown. The `Effect` returned by this method will
   * not resume until the queue has been shutdown. If the queue is already
   * shutdown, the `Effect` will resume right away.
   */
  readonly awaitShutdown: Effect.Effect<void>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L189)

Since v2.0.0
Queue-awaitShutdown.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.awaitShutdown

Waits until the queue is shutdown. The `Effect` returned by this method will
not resume until the queue has been shutdown. If the queue is already
shutdown, the `Effect` will resume right away.

**Signature**

```ts
declare const awaitShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L526)

Since v2.0.0
Queue-bounded.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.bounded

Makes a new bounded `Queue`. When the capacity of the queue is reached, any
additional calls to `offer` will be suspended until there is more room in
the queue.

**Note**: When possible use only power of 2 capacities; this will provide
better performance by utilising an optimised version of the underlying
`RingBuffer`.

**Signature**

```ts
declare const bounded: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L435)

Since v2.0.0
Queue-capacity.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.capacity

Returns the number of elements the queue can hold.

**Signature**

```ts
declare const capacity: <A>(self: Dequeue<A> | Enqueue<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L481)

Since v2.0.0
Queue-dropping.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.dropping

Makes a new bounded `Queue` with the dropping strategy.

When the capacity of the queue is reached, new elements will be dropped and the
old elements will remain.

**Note**: When possible use only power of 2 capacities; this will provide
better performance by utilising an optimised version of the underlying
`RingBuffer`.

**Signature**

```ts
declare const dropping: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L450)

Since v2.0.0
Queue-isDequeue.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.isDequeue

Returns `true` if the specified value is a `Dequeue`, `false` otherwise.

**Signature**

```ts
declare const isDequeue: (u: unknown) => u is Dequeue<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L389)

Since v2.0.0
Queue-isEmpty.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.isEmpty

Returns `true` if the `Queue` contains zero elements, `false` otherwise.

**Signature**

```ts
declare const isEmpty: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L499)

Since v2.0.0
Queue-isEnqueue.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.isEnqueue

Returns `true` if the specified value is a `Enqueue`, `false` otherwise.

**Signature**

```ts
declare const isEnqueue: (u: unknown) => u is Enqueue<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L397)

Since v2.0.0
Queue-isFull.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.isFull

Returns `true` if the `Queue` contains at least one element, `false`
otherwise.

**Signature**

```ts
declare const isFull: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L508)

Since v2.0.0
Queue-isQueue.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.isQueue

Returns `true` if the specified value is a `Queue`, `false` otherwise.

**Signature**

```ts
declare const isQueue: (u: unknown) => u is Queue<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L381)

Since v2.0.0
Queue-isShutdown.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

**Signature**

```ts
declare const isShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L516)

Since v2.0.0
Queue-offer.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.offer

Places one value in the queue.

**Signature**

```ts
declare const offer: { <A>(value: A): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, value: A): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L543)

Since v2.0.0
Queue-offerAll.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.offerAll

For Bounded Queue: uses the `BackPressure` Strategy, places the values in
the queue and always returns true. If the queue has reached capacity, then
the fiber performing the `offerAll` will be suspended until there is room
in the queue.

For Unbounded Queue: Places all values in the queue and returns true.

For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,
it places the values otherwise it removes the old elements and enqueues the
new ones. Always returns true.

For Dropping Queue: uses `Dropping` Strategy, It places the values in the
queue but if there is no room it will not enqueue them and return false.

**Signature**

```ts
declare const offerAll: { <A>(iterable: Iterable<A>): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, iterable: Iterable<A>): Effect.Effect<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L577)

Since v2.0.0
Queue-poll.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.poll

Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue
is empty.

**Signature**

```ts
declare const poll: <A>(self: Dequeue<A>) => Effect.Effect<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L589)

Since v2.0.0
Queue-shutdown.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

**Signature**

```ts
declare const shutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L535)

Since v2.0.0
Queue-size.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.size

Retrieves the size of the queue, which is equal to the number of elements
in the queue. This may be negative if fibers are suspended waiting for
elements to be added to the queue.

**Signature**

```ts
declare const size: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L491)

Since v2.0.0
Queue-sliding.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.sliding

Makes a new bounded `Queue` with the sliding strategy.

When the capacity of the queue is reached, new elements will be added and the
old elements will be dropped.

**Note**: When possible use only power of 2 capacities; this will provide
better performance by utilising an optimised version of the underlying
`RingBuffer`.

**Signature**

```ts
declare const sliding: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L465)

Since v2.0.0
Queue-take.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.take

Takes the oldest value in the queue. If the queue is empty, this will return
a computation that resumes when an item has been added to the queue.

**Signature**

```ts
declare const take: <A>(self: Dequeue<A>) => Effect.Effect<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L598)

Since v2.0.0
Queue-takeAll.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.takeAll

Takes all the values in the queue and returns the values. If the queue is
empty returns an empty collection.

**Signature**

```ts
declare const takeAll: <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L607)

Since v2.0.0
Queue-takeBetween.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.takeBetween

Takes a number of elements from the queue between the specified minimum and
maximum. If there are fewer than the minimum number of elements available,
suspends until at least the minimum number of elements have been collected.

**Signature**

```ts
declare const takeBetween: { (min: number, max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, min: number, max: number): Effect.Effect<Chunk.Chunk<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L628)

Since v2.0.0
Queue-takeN.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.takeN

Takes the specified number of elements from the queue. If there are fewer
than the specified number of elements available, it suspends until they
become available.

**Signature**

```ts
declare const takeN: { (n: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, n: number): Effect.Effect<Chunk.Chunk<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L641)

Since v2.0.0
Queue-takeUpTo.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.takeUpTo

Takes up to max number of values from the queue.

**Signature**

```ts
declare const takeUpTo: { (max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, max: number): Effect.Effect<Chunk.Chunk<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L615)

Since v2.0.0
Queue-unbounded.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.unbounded

Creates a new unbounded `Queue`.

**Signature**

```ts
declare const unbounded: <A>() => Effect.Effect<Queue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L473)

Since v2.0.0
Queue-unsafeOffer.md
Package: `effect`<br />
Module: `Queue`<br />

## Queue.unsafeOffer

Places one value in the queue.

**Signature**

```ts
declare const unsafeOffer: { <A>(value: A): (self: Enqueue<A>) => boolean; <A>(self: Enqueue<A>, value: A): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L554)

Since v2.0.0
Random-choice.md
Package: `effect`<br />
Module: `Random`<br />

## Random.choice

Get a random element from an iterable.

**Example**

```ts
import { Effect, Random } from "effect"

Effect.gen(function* () {
  const randomItem = yield* Random.choice([1, 2, 3])
  console.log(randomItem)
})
```

**Signature**

```ts
declare const choice: <Self extends Iterable<unknown>>(elements: Self) => Self extends NonEmptyIterable.NonEmptyIterable<infer A> ? Effect.Effect<A> : Self extends Array.NonEmptyReadonlyArray<infer A> ? Effect.Effect<A> : Self extends Iterable<infer A> ? Effect.Effect<A, Cause.NoSuchElementException> : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L125)

Since v3.6.0
Random-make.md
Package: `effect`<br />
Module: `Random`<br />

## Random.make

Constructs the `Random` service, seeding the pseudo-random number generator
with an hash of the specified seed.
This constructor is useful for generating predictable sequences of random values for specific use cases.

Example uses:
- Generating random UI data for visual tests.
- Creating data that needs to change daily but remain the same throughout a single day, such as using a date as the seed.

**Example**

```ts
import * as assert from "node:assert"
import { Effect, Random } from "effect"

const random1 = Random.make("myseed")
const random2 = Random.make("myseed")

assert.equal(Effect.runSync(random1.next), Effect.runSync(random2.next))
```

**Signature**

```ts
declare const make: <A>(seed: A) => Random
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L171)

Since v3.5.0
Random-next.md
Package: `effect`<br />
Module: `Random`<br />

## Random.next

Returns the next numeric value from the pseudo-random number generator.

**Signature**

```ts
declare const next: Effect.Effect<number, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L65)

Since v2.0.0
Random-nextBoolean.md
Package: `effect`<br />
Module: `Random`<br />

## Random.nextBoolean

Returns the next boolean value from the pseudo-random number generator.

**Signature**

```ts
declare const nextBoolean: Effect.Effect<boolean, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L81)

Since v2.0.0
Random-nextInt.md
Package: `effect`<br />
Module: `Random`<br />

## Random.nextInt

Returns the next integer value from the pseudo-random number generator.

**Signature**

```ts
declare const nextInt: Effect.Effect<number, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L73)

Since v2.0.0
Random-nextIntBetween.md
Package: `effect`<br />
Module: `Random`<br />

## Random.nextIntBetween

Returns the next integer value in the specified range from the
pseudo-random number generator.

**Signature**

```ts
declare const nextIntBetween: (min: number, max: number) => Effect.Effect<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L99)

Since v2.0.0
Random-nextRange.md
Package: `effect`<br />
Module: `Random`<br />

## Random.nextRange

Returns the next numeric value in the specified range from the
pseudo-random number generator.

**Signature**

```ts
declare const nextRange: (min: number, max: number) => Effect.Effect<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L90)

Since v2.0.0
Random-randomWith.md
Package: `effect`<br />
Module: `Random`<br />

## Random.randomWith

Retreives the `Random` service from the context and uses it to run the
specified workflow.

**Signature**

```ts
declare const randomWith: <A, E, R>(f: (random: Random) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L139)

Since v2.0.0
Random-shuffle.md
Package: `effect`<br />
Module: `Random`<br />

## Random.shuffle

Uses the pseudo-random number generator to shuffle the specified iterable.

**Signature**

```ts
declare const shuffle: <A>(elements: Iterable<A>) => Effect.Effect<Chunk.Chunk<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L107)

Since v2.0.0
RateLimiter-RateLimiter.md
Package: `effect`<br />
Module: `RateLimiter`<br />

## RateLimiter.RateLimiter

Limits the number of calls to a resource to a maximum amount in some interval.

Note that only the moment of starting the effect is rate limited: the number
of concurrent executions is not bounded.

**Signature**

```ts
export interface RateLimiter {
  <A, E, R>(task: Effect<A, E, R>): Effect<A, E, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RateLimiter.ts#L20)

Since v2.0.0
RateLimiter-make.md
Package: `effect`<br />
Module: `RateLimiter`<br />

## RateLimiter.make

Constructs a new `RateLimiter` which will utilize the specified algorithm
to limit requests (defaults to `token-bucket`).

Notes
- Only the moment of starting the effect is rate limited. The number of concurrent executions is not bounded.
- Instances of `RateLimiter` can be composed.
- The "cost" per effect can be changed. See `withCost`

**Example**

```ts
import { Effect, RateLimiter } from "effect";
import { compose } from "effect/Function"

const program = Effect.scoped(
  Effect.gen(function* ($) {
    const perMinuteRL = yield* $(RateLimiter.make({ limit: 30, interval: "1 minutes" }))
    const perSecondRL = yield* $(RateLimiter.make({ limit: 2, interval: "1 seconds" }))

    // This rate limiter respects both the 30 calls per minute
    // and the 2 calls per second constraints.
     const rateLimit = compose(perMinuteRL, perSecondRL)

    // simulate repeated calls
    for (let n = 0; n < 100; n++) {
      // wrap the effect we want to limit with rateLimit
      yield* $(rateLimit(Effect.log("Calling RateLimited Effect")));
    }
  })
);
```

**Signature**

```ts
declare const make: (options: RateLimiter.Options) => Effect<RateLimiter, never, Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RateLimiter.ts#L98)

Since v2.0.0
RateLimiter-withCost.md
Package: `effect`<br />
Module: `RateLimiter`<br />

## RateLimiter.withCost

Alters the per-effect cost of the rate-limiter.

This can be used for "credit" based rate-limiting where different API endpoints
cost a different number of credits within a time window.
Eg: 1000 credits / hour, where a query costs 1 credit and a mutation costs 5 credits.

**Example**

```ts
import { Effect, RateLimiter } from "effect";
import { compose } from "effect/Function";

const program = Effect.scoped(
  Effect.gen(function* ($) {
    // Create a rate limiter that has an hourly limit of 1000 credits
    const rateLimiter = yield* $(RateLimiter.make({ limit: 1000, interval: "1 hours" }));
    // Query API costs 1 credit per call ( 1 is the default cost )
    const queryAPIRL = compose(rateLimiter, RateLimiter.withCost(1));
    // Mutation API costs 5 credits per call
    const mutationAPIRL = compose(rateLimiter, RateLimiter.withCost(5));

    // Use the pre-defined rate limiters
    yield* $(queryAPIRL(Effect.log("Sample Query")));
    yield* $(mutationAPIRL(Effect.log("Sample Mutation")));

    // Or set a cost on-the-fly
    yield* $(
      rateLimiter(Effect.log("Another query with a different cost")).pipe(
        RateLimiter.withCost(3)
      )
    );
  })
);
```

**Signature**

```ts
declare const withCost: (cost: number) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RateLimiter.ts#L138)

Since v2.0.0
RcMap-make.md
Package: `effect`<br />
Module: `RcMap`<br />

## RcMap.make

An `RcMap` can contain multiple reference counted resources that can be indexed
by a key. The resources are lazily acquired on the first call to `get` and
released when the last reference is released.

Complex keys can extend `Equal` and `Hash` to allow lookups by value.

**Options**

- `capacity`: The maximum number of resources that can be held in the map.
- `idleTimeToLive`: When the reference count reaches zero, the resource will be released after this duration.

**Example**

```ts
import { Effect, RcMap } from "effect"

Effect.gen(function*() {
  const map = yield* RcMap.make({
    lookup: (key: string) =>
      Effect.acquireRelease(
        Effect.succeed(`acquired ${key}`),
        () => Effect.log(`releasing ${key}`)
      )
  })

  // Get "foo" from the map twice, which will only acquire it once.
  // It will then be released once the scope closes.
  yield* RcMap.get(map, "foo").pipe(
    Effect.andThen(RcMap.get(map, "foo")),
    Effect.scoped
  )
})
```

**Signature**

```ts
declare const make: { <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity?: undefined; }): Effect.Effect<RcMap<K, A, E>, never, Scope.Scope | R>; <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity: number; }): Effect.Effect<RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L84)

Since v3.5.0
RcRef-make.md
Package: `effect`<br />
Module: `RcRef`<br />

## RcRef.make

Create an `RcRef` from an acquire `Effect`.

An RcRef wraps a reference counted resource that can be acquired and released
multiple times.

The resource is lazily acquired on the first call to `get` and released when
the last reference is released.

**Example**

```ts
import { Effect, RcRef } from "effect"

Effect.gen(function*() {
  const ref = yield* RcRef.make({
    acquire: Effect.acquireRelease(
      Effect.succeed("foo"),
      () => Effect.log("release foo")
    )
  })

  // will only acquire the resource once, and release it
  // when the scope is closed
  yield* RcRef.get(ref).pipe(
    Effect.andThen(RcRef.get(ref)),
    Effect.scoped
  )
})
```

**Signature**

```ts
declare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; }) => Effect.Effect<RcRef<A, E>, never, R | Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L100)

Since v3.5.0
Record-collect.md
Package: `effect`<br />
Module: `Record`<br />

## Record.collect

Transforms the values of a record into an `Array` with a custom mapping function.

**Example**

```ts
import * as assert from "node:assert"
import { collect } from "effect/Record"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [["a", 1], ["b", 2], ["c", 3]])
```

**Signature**

```ts
declare const collect: { <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L214)

Since v2.0.0
Record-difference.md
Package: `effect`<br />
Module: `Record`<br />

## Record.difference

Merge two records, preserving only the entries that are unique to each record.

**Signature**

```ts
declare const difference: { <K1 extends string, B>(that: ReadonlyRecord<K1, B>): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>; <K0 extends string, A, K1 extends string, B>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>): Record<K0 | K1, A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1176)

Since v2.0.0
Record-empty.md
Package: `effect`<br />
Module: `Record`<br />

## Record.empty

Creates a new, empty record.

**Signature**

```ts
declare const empty: <K extends string | symbol = never, V = never>() => Record<ReadonlyRecord.NonLiteralKey<K>, V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L61)

Since v2.0.0
Record-every.md
Package: `effect`<br />
Module: `Record`<br />

## Record.every

Check if all entries in a record meet a specific condition.

**Signature**

```ts
declare const every: { <A, K extends string, B extends A>(refinement: (value: A, key: K) => value is B): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>; <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <A, K extends string, B extends A>(self: ReadonlyRecord<K, A>, refinement: (value: A, key: K) => value is B): self is ReadonlyRecord<K, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1046)

Since v2.0.0
Record-filter.md
Package: `effect`<br />
Module: `Record`<br />

## Record.filter

Selects properties from a record whose values match the given predicate.

**Example**

```ts
import * as assert from "node:assert"
import { filter } from "effect/Record"

const x = { a: 1, b: 2, c: 3, d: 4 }
assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })
```

**Signature**

```ts
declare const filter: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(predicate: (A: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): Record<ReadonlyRecord.NonLiteralKey<K>, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L664)

Since v2.0.0
Record-filterMap.md
Package: `effect`<br />
Module: `Record`<br />

## Record.filterMap

Transforms a record into a record by applying the function `f` to each key and value in the original record.
If the function returns `Some`, the key-value pair is included in the output record.

**Example**

```ts
import * as assert from "node:assert"
import { Record, Option } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()
assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })
```

**Signature**

```ts
declare const filterMap: { <K extends string, A, B>(f: (a: A, key: K) => Option.Option<B>): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Option.Option<B>): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L624)

Since v2.0.0
Record-findFirst.md
Package: `effect`<br />
Module: `Record`<br />

## Record.findFirst

Returns the first entry that satisfies the specified
predicate, or `None` if no such entry exists.

**Example**

```ts
import { Record, Option } from "effect"

const record = { a: 1, b: 2, c: 3 }
const result = Record.findFirst(record, (value, key) => value > 1 && key !== "b")
console.log(result) // Option.Some(["c", 3])
```

**Signature**

```ts
declare const findFirst: { <K extends string | symbol, V, V2 extends V>(refinement: (value: NoInfer<V>, key: NoInfer<K>) => value is V2): (self: ReadonlyRecord<K, V>) => Option.Option<[K, V2]>; <K extends string | symbol, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: ReadonlyRecord<K, V>) => Option.Option<[K, V]>; <K extends string | symbol, V, V2 extends V>(self: ReadonlyRecord<K, V>, refinement: (value: NoInfer<V>, key: NoInfer<K>) => value is V2): Option.Option<[K, V2]>; <K extends string | symbol, V>(self: ReadonlyRecord<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): Option.Option<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1247)

Since v3.14.0
Record-fromEntries.md
Package: `effect`<br />
Module: `Record`<br />

## Record.fromEntries

Builds a record from an iterable of key-value pairs.

If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the
previous ones. So the resulting record will only have the value of the last occurrence of each key.

**Example**

```ts
import * as assert from "node:assert"
import { fromEntries } from "effect/Record"

const input: Array<[string, number]> = [["a", 1], ["b", 2]]

assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })
```

**Signature**

```ts
declare const fromEntries: <Entry extends readonly [string | symbol, any]>(entries: Iterable<Entry>) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L195)

Since v2.0.0
Record-fromIterableBy.md
Package: `effect`<br />
Module: `Record`<br />

## Record.fromIterableBy

Creates a new record from an iterable, utilizing the provided function to determine the key for each element.

**Example**

```ts
import * as assert from "node:assert"
import { fromIterableBy } from "effect/Record"

const users = [
  { id: "2", name: "name2" },
  { id: "1", name: "name1" }
]

assert.deepStrictEqual(
  fromIterableBy(users, user => user.id),
  {
    "2": { id: "2", name: "name2" },
    "1": { id: "1", name: "name1" }
  }
)
```

**Signature**

```ts
declare const fromIterableBy: <A, K extends string | symbol>(items: Iterable<A>, f: (a: A) => K) => Record<ReadonlyRecord.NonLiteralKey<K>, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L171)

Since v2.0.0
Record-fromIterableWith.md
Package: `effect`<br />
Module: `Record`<br />

## Record.fromIterableWith

Takes an iterable and a projection function and returns a record.
The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.

**Example**

```ts
import * as assert from "node:assert"
import { fromIterableWith } from "effect/Record"

const input = [1, 2, 3, 4]

assert.deepStrictEqual(
  fromIterableWith(input, a => [String(a), a * 2]),
  { '1': 2, '2': 4, '3': 6, '4': 8 }
)
```

**Signature**

```ts
declare const fromIterableWith: { <A, K extends string | symbol, B>(f: (a: A) => readonly [K, B]): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <A, K extends string | symbol, B>(self: Iterable<A>, f: (a: A) => readonly [K, B]): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L123)

Since v2.0.0
Record-get.md
Package: `effect`<br />
Module: `Record`<br />

## Record.get

Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.

**Example**

```ts
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

const person: Record<string, unknown> = { name: "John Doe", age: 35 }

assert.deepStrictEqual(R.get(person, "name"), Option.some("John Doe"))
assert.deepStrictEqual(R.get(person, "email"), Option.none())
```

**Signature**

```ts
declare const get: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L309)

Since v2.0.0
Record-getEquivalence.md
Package: `effect`<br />
Module: `Record`<br />

## Record.getEquivalence

Create an `Equivalence` for records using the provided `Equivalence` for values.

**Signature**

```ts
declare const getEquivalence: <K extends string, A>(equivalence: Equivalence<A>) => Equivalence<ReadonlyRecord<K, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1214)

Since v2.0.0
Record-getLefts.md
Package: `effect`<br />
Module: `Record`<br />

## Record.getLefts

Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.

**Example**

```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.getLefts({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
  { b: "err" }
)
```

**Signature**

```ts
declare const getLefts: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<ReadonlyRecord.NonLiteralKey<K>, L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L735)

Since v2.0.0
Record-getRights.md
Package: `effect`<br />
Module: `Record`<br />

## Record.getRights

Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.

**Example**

```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.getRights({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
  { a: 1, c: 2 }
)
```

**Signature**

```ts
declare const getRights: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<string, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L766)

Since v2.0.0
Record-getSomes.md
Package: `effect`<br />
Module: `Record`<br />

## Record.getSomes

Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.

**Example**

```ts
import * as assert from "node:assert"
import { Record, Option } from "effect"

assert.deepStrictEqual(
  Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),
  { a: 1, c: 2 }
)
```

**Signature**

```ts
declare const getSomes: <K extends string, A>(self: ReadonlyRecord<K, Option.Option<A>>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L712)

Since v2.0.0
Record-has.md
Package: `effect`<br />
Module: `Record`<br />

## Record.has

Check if a given `key` exists in a record.

**Example**

```ts
import * as assert from "node:assert"
import { empty, has } from "effect/Record"

assert.deepStrictEqual(has({ a: 1, b: 2 }, "a"), true);
assert.deepStrictEqual(has(empty<string>(), "c"), false);
```

**Signature**

```ts
declare const has: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => boolean; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L277)

Since v2.0.0
Record-intersection.md
Package: `effect`<br />
Module: `Record`<br />

## Record.intersection

Merge two records, retaining only the entries that exist in both records.

**Signature**

```ts
declare const intersection: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1141)

Since v2.0.0
Record-isEmptyReadonlyRecord.md
Package: `effect`<br />
Module: `Record`<br />

## Record.isEmptyReadonlyRecord

Determine if a record is empty.

**Example**

```ts
import * as assert from "node:assert"
import { isEmptyReadonlyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);
assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);
```

**Signature**

```ts
declare const isEmptyReadonlyRecord: <K extends string, A>(self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L99)

Since v2.0.0
Record-isEmptyRecord.md
Package: `effect`<br />
Module: `Record`<br />

## Record.isEmptyRecord

Determine if a record is empty.

**Example**

```ts
import * as assert from "node:assert"
import { isEmptyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyRecord({}), true);
assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);
```

**Signature**

```ts
declare const isEmptyRecord: <K extends string, A>(self: Record<K, A>) => self is Record<K, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L81)

Since v2.0.0
Record-isSubrecord.md
Package: `effect`<br />
Module: `Record`<br />

## Record.isSubrecord

Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.
This comparison uses default equality checks (`Equal.equivalence()`).

**Signature**

```ts
declare const isSubrecord: { <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1009)

Since v2.0.0
Record-isSubrecordBy.md
Package: `effect`<br />
Module: `Record`<br />

## Record.isSubrecordBy

Check if all the keys and values in one record are also found in another record.

**Signature**

```ts
declare const isSubrecordBy: <A>(equivalence: Equivalence<A>) => { <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L990)

Since v2.0.0
Record-keys.md
Package: `effect`<br />
Module: `Record`<br />

## Record.keys

Retrieve the keys of a given record as an array.

**Signature**

```ts
declare const keys: <K extends string | symbol, A>(self: ReadonlyRecord<K, A>) => Array<K & string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L912)

Since v2.0.0
Record-map.md
Package: `effect`<br />
Module: `Record`<br />

## Record.map

Maps a record into another record by applying a transformation function to each of its values.

**Example**

```ts
import * as assert from "node:assert"
import { map } from "effect/Record"

const f = (n: number) => `-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: "-3", b: "-5" })

const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: "A-3", b: "B-5" })
```

**Signature**

```ts
declare const map: { <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L520)

Since v2.0.0
Record-mapEntries.md
Package: `effect`<br />
Module: `Record`<br />

## Record.mapEntries

Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.

**Example**

```ts
import * as assert from "node:assert"
import { mapEntries } from "effect/Record"

assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })
```

**Signature**

```ts
declare const mapEntries: { <K extends string, A, K2 extends string, B>(f: (a: A, key: K) => readonly [K2, B]): (self: ReadonlyRecord<K, A>) => Record<K2, B>; <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L585)

Since v2.0.0
Record-mapKeys.md
Package: `effect`<br />
Module: `Record`<br />

## Record.mapKeys

Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.

**Example**

```ts
import * as assert from "node:assert"
import { mapKeys } from "effect/Record"

assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })
```

**Signature**

```ts
declare const mapKeys: { <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>; <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L548)

Since v2.0.0
Record-modify.md
Package: `effect`<br />
Module: `Record`<br />

## Record.modify

Apply a function to the element at the specified key, creating a new record.
If the key does not exist, the record is returned unchanged.

**Example**

```ts
import * as assert from "node:assert"
import { Record as R } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(
 R.modify({ a: 3 }, 'a', f),
 { a: 6 }
)
assert.deepStrictEqual(
 R.modify({ a: 3 } as Record<string, number>, 'b', f),
 { a: 3 }
)
```

**Signature**

```ts
declare const modify: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L341)

Since v2.0.0
Record-modifyOption.md
Package: `effect`<br />
Module: `Record`<br />

## Record.modifyOption

Apply a function to the element at the specified key, creating a new record,
or return `None` if the key doesn't exist.

**Example**

```ts
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(
 R.modifyOption({ a: 3 }, 'a', f),
 Option.some({ a: 6 })
)
assert.deepStrictEqual(
 R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),
 Option.none()
)
```

**Signature**

```ts
declare const modifyOption: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Option.Option<Record<K, A | B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L380)

Since v2.0.0
Record-partition.md
Package: `effect`<br />
Module: `Record`<br />

## Record.partition

Partitions a record into two separate records based on the result of a predicate function.

**Example**

```ts
import * as assert from "node:assert"
import { partition } from "effect/Record"

assert.deepStrictEqual(
  partition({ a: 1, b: 3 }, (n) => n > 2),
  [{ a: 1 }, { b: 3 }]
)
```

**Signature**

```ts
declare const partition: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(predicate: (a: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L865)

Since v2.0.0
Record-partitionMap.md
Package: `effect`<br />
Module: `Record`<br />

## Record.partitionMap

Partitions the elements of a record into two groups: those that match a predicate, and those that don't.

**Example**

```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))
assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])
```

**Signature**

```ts
declare const partitionMap: { <K extends string, A, B, C>(f: (a: A, key: K) => Either<C, B>): (self: ReadonlyRecord<K, A>) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; <K extends string, A, B, C>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Either<C, B>): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L796)

Since v2.0.0
Record-pop.md
Package: `effect`<br />
Module: `Record`<br />

## Record.pop

Retrieves the value of the property with the given `key` from a record and returns an `Option`
of a tuple with the value and the record with the removed property.
If the key is not present, returns `O.none`.

**Example**

```ts
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, "a"), Option.some([1, { b: 2 }]))
assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, "c"), Option.none())
```

**Signature**

```ts
declare const pop: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Option.Option<[A, Record<Exclude<K, X>, A>]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L486)

Since v2.0.0
Record-reduce.md
Package: `effect`<br />
Module: `Record`<br />

## Record.reduce

Reduce a record to a single value by combining its entries with a specified function.

**Signature**

```ts
declare const reduce: { <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z; <K extends string, V, Z>(self: ReadonlyRecord<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1020)

Since v2.0.0
Record-remove.md
Package: `effect`<br />
Module: `Record`<br />

## Record.remove

If the given key exists in the record, returns a new record with the key removed,
otherwise returns a copy of the original record.

**Example**

```ts
import * as assert from "node:assert"
import { remove } from "effect/Record"

assert.deepStrictEqual(remove({ a: 1, b: 2 }, "a"), { b: 2 })
```

**Signature**

```ts
declare const remove: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L454)

Since v2.0.0
Record-replace.md
Package: `effect`<br />
Module: `Record`<br />

## Record.replace

Replace a key's value in a record and return the updated record.
If the key does not exist in the record, a copy of the original record is returned.

**Example**

```ts
import * as assert from "node:assert"
import { Record } from "effect"

assert.deepStrictEqual(Record.replace("a", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });
assert.deepStrictEqual(Record.replace("c", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });
```

**Signature**

```ts
declare const replace: { <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L972)

Since v2.0.0
Record-replaceOption.md
Package: `effect`<br />
Module: `Record`<br />

## Record.replaceOption

Replaces a value in the record with the new value passed as parameter.

**Example**

```ts
import * as assert from "node:assert"
import { Record, Option } from "effect"

assert.deepStrictEqual(
  Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),
  Option.some({ a: 10, b: 2, c: 3 })
)
assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())
```

**Signature**

```ts
declare const replaceOption: { <K extends string | symbol, B>(key: NoInfer<K>, b: B): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L421)

Since v2.0.0
Record-separate.md
Package: `effect`<br />
Module: `Record`<br />

## Record.separate

Partitions a record of `Either` values into two separate records,
one with the `Left` values and one with the `Right` values.

**Example**

```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.separate({ a: Either.left("e"), b: Either.right(1) }),
  [{ a: "e" }, { b: 1 }]
)
```

**Signature**

```ts
declare const separate: <K extends string, A, B>(self: ReadonlyRecord<K, Either<B, A>>) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L844)

Since v2.0.0
Record-set.md
Package: `effect`<br />
Module: `Record`<br />

## Record.set

Add a new key-value pair or update an existing key's value in a record.

**Example**

```ts
import * as assert from "node:assert"
import { set } from "effect/Record"

assert.deepStrictEqual(set("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
assert.deepStrictEqual(set("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
```

**Signature**

```ts
declare const set: { <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(key: K1, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>; <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(self: ReadonlyRecord<K, A>, key: K1, value: B): Record<K | K1, A | B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L936)

Since v2.0.0
Record-singleton.md
Package: `effect`<br />
Module: `Record`<br />

## Record.singleton

Create a non-empty record from a single element.

**Signature**

```ts
declare const singleton: <K extends string | symbol, A>(key: K, value: A) => Record<K, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1227)

Since v2.0.0
Record-size.md
Package: `effect`<br />
Module: `Record`<br />

## Record.size

Returns the number of key/value pairs in a record.

**Example**

```ts
import * as assert from "node:assert"
import { size } from "effect/Record";

assert.deepStrictEqual(size({ a: "a", b: 1, c: true }), 3);
```

**Signature**

```ts
declare const size: <K extends string, A>(self: ReadonlyRecord<K, A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L261)

Since v2.0.0
Record-some.md
Package: `effect`<br />
Module: `Record`<br />

## Record.some

Check if any entry in a record meets a specific condition.

**Signature**

```ts
declare const some: { <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1076)

Since v2.0.0
Record-toEntries.md
Package: `effect`<br />
Module: `Record`<br />

## Record.toEntries

Takes a record and returns an array of tuples containing its keys and values.

**Example**

```ts
import * as assert from "node:assert"
import { toEntries } from "effect/Record"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(toEntries(x), [["a", 1], ["b", 2], ["c", 3]])
```

**Signature**

```ts
declare const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L243)

Since v2.0.0
Record-union.md
Package: `effect`<br />
Module: `Record`<br />

## Record.union

Merge two records, preserving entries that exist in either of the records.

**Signature**

```ts
declare const union: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<K0 | K1, A | B | C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1096)

Since v2.0.0
Record-values.md
Package: `effect`<br />
Module: `Record`<br />

## Record.values

Retrieve the values of a given record as an array.

**Signature**

```ts
declare const values: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L920)

Since v2.0.0
RedBlackTree-RedBlackTree.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.RedBlackTree

A Red-Black Tree.

**Signature**

```ts
export interface RedBlackTree<in out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {
  readonly [TypeId]: {
    readonly _Key: Types.Invariant<Key>
    readonly _Value: Types.Covariant<Value>
  }
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L34)

Since v2.0.0
RedBlackTree-at.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.at

Returns an iterator that points to the element at the specified index of the
tree.

**Note**: The iterator will run through elements in order.

**Signature**

```ts
declare const at: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L102)

Since v2.0.0
RedBlackTree-atReversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.atReversed

Returns an iterator that points to the element at the specified index of the
tree.

**Note**: The iterator will run through elements in reverse order.

**Signature**

```ts
declare const atReversed: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L116)

Since v2.0.0
RedBlackTree-empty.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.empty

Creates an empty `RedBlackTree`.

**Signature**

```ts
declare const empty: <K, V = never>(ord: Order<K>) => RedBlackTree<K, V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L68)

Since v2.0.0
RedBlackTree-findAll.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.findAll

Finds all values in the tree associated with the specified key.

**Signature**

```ts
declare const findAll: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Chunk<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Chunk<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L127)

Since v2.0.0
RedBlackTree-findFirst.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.findFirst

Finds the first value in the tree associated with the specified key, if it exists.

**Signature**

```ts
declare const findFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Option<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Option<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L138)

Since v2.0.0
RedBlackTree-first.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.first

Returns the first entry in the tree, if it exists.

**Signature**

```ts
declare const first: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L149)

Since v2.0.0
RedBlackTree-forEach.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.forEach

Execute the specified function for each node of the tree, in order.

**Signature**

```ts
declare const forEach: { <K, V>(f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, f: (key: K, value: V) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L318)

Since v2.0.0
RedBlackTree-forEachBetween.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.forEachBetween

Visit each node of the tree in order with key lower than max and greater
than or equal to min.

**Signature**

```ts
declare const forEachBetween: { <K, V>(options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L352)

Since v2.0.0
RedBlackTree-forEachGreaterThanEqual.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.forEachGreaterThanEqual

Visit each node of the tree in order with key greater then or equal to max.

**Signature**

```ts
declare const forEachGreaterThanEqual: { <K, V>(min: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L329)

Since v2.0.0
RedBlackTree-forEachLessThan.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.forEachLessThan

Visit each node of the tree in order with key lower then max.

**Signature**

```ts
declare const forEachLessThan: { <K, V>(max: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L340)

Since v2.0.0
RedBlackTree-fromIterable.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.fromIterable

Creates a new `RedBlackTree` from an iterable collection of key/value pairs.

**Signature**

```ts
declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(entries: Iterable<readonly [K, V]>) => RedBlackTree<K, V>; <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order<B>): RedBlackTree<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L76)

Since v2.0.0
RedBlackTree-getAt.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.getAt

Returns the element at the specified index within the tree or `None` if the
specified index does not exist.

**Signature**

```ts
declare const getAt: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Option<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L158)

Since v2.0.0
RedBlackTree-getOrder.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.getOrder

Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.

**Signature**

```ts
declare const getOrder: <K, V>(self: RedBlackTree<K, V>) => Order<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L169)

Since v2.0.0
RedBlackTree-greaterThan.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.greaterThan

Returns an iterator that traverse entries in order with keys greater than the
specified key.

**Signature**

```ts
declare const greaterThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L178)

Since v2.0.0
RedBlackTree-greaterThanEqual.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.greaterThanEqual

Returns an iterator that traverse entries in order with keys greater than or
equal to the specified key.

**Signature**

```ts
declare const greaterThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L202)

Since v2.0.0
RedBlackTree-greaterThanEqualReversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.greaterThanEqualReversed

Returns an iterator that traverse entries in reverse order with keys greater
than or equal to the specified key.

**Signature**

```ts
declare const greaterThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L214)

Since v2.0.0
RedBlackTree-greaterThanReversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.greaterThanReversed

Returns an iterator that traverse entries in reverse order with keys greater
than the specified key.

**Signature**

```ts
declare const greaterThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L190)

Since v2.0.0
RedBlackTree-has.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.has

Finds the item with key, if it exists.

**Signature**

```ts
declare const has: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => boolean; <K, V>(self: RedBlackTree<K, V>, key: K): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L225)

Since v2.0.0
RedBlackTree-insert.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.insert

Insert a new item into the tree.

**Signature**

```ts
declare const insert: { <K, V>(key: K, value: V): (self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K, value: V): RedBlackTree<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L235)

Since v2.0.0
RedBlackTree-keys.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.keys

Get all the keys present in the tree in order.

**Signature**

```ts
declare const keys: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L246)

Since v2.0.0
RedBlackTree-keysReversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.keysReversed

Get all the keys present in the tree in reverse order.

**Signature**

```ts
declare const keysReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L254)

Since v2.0.0
RedBlackTree-last.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.last

Returns the last entry in the tree, if it exists.

**Signature**

```ts
declare const last: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L262)

Since v2.0.0
RedBlackTree-lessThan.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.lessThan

Returns an iterator that traverse entries in order with keys less than the
specified key.

**Signature**

```ts
declare const lessThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L271)

Since v2.0.0
RedBlackTree-lessThanEqual.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.lessThanEqual

Returns an iterator that traverse entries in order with keys less than or
equal to the specified key.

**Signature**

```ts
declare const lessThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L295)

Since v2.0.0
RedBlackTree-lessThanEqualReversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.lessThanEqualReversed

Returns an iterator that traverse entries in reverse order with keys less
than or equal to the specified key.

**Signature**

```ts
declare const lessThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L307)

Since v2.0.0
RedBlackTree-lessThanReversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.lessThanReversed

Returns an iterator that traverse entries in reverse order with keys less
than the specified key.

**Signature**

```ts
declare const lessThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L283)

Since v2.0.0
RedBlackTree-make.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.make

Constructs a new `RedBlackTree` from the specified entries.

**Signature**

```ts
declare const make: <K>(ord: Order<K>) => <Entries extends Array<readonly [K, any]>>(...entries: Entries) => RedBlackTree<K, Entries[number] extends readonly [any, infer V] ? V : never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L87)

Since v2.0.0
RedBlackTree-reduce.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.reduce

Reduce a state over the entries of the tree.

**Signature**

```ts
declare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: RedBlackTree<K, V>) => Z; <Z, V, K>(self: RedBlackTree<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L376)

Since v2.0.0
RedBlackTree-removeFirst.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.removeFirst

Removes the entry with the specified key, if it exists.

**Signature**

```ts
declare const removeFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K): RedBlackTree<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L386)

Since v2.0.0
RedBlackTree-reversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.reversed

Traverse the tree in reverse order.

**Signature**

```ts
declare const reversed: <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L397)

Since v2.0.0
RedBlackTree-size.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.size

Returns the size of the tree.

**Signature**

```ts
declare const size: <K, V>(self: RedBlackTree<K, V>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L405)

Since v2.0.0
RedBlackTree-values.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.values

Get all values present in the tree in order.

**Signature**

```ts
declare const values: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L413)

Since v2.0.0
RedBlackTree-valuesReversed.md
Package: `effect`<br />
Module: `RedBlackTree`<br />

## RedBlackTree.valuesReversed

Get all values present in the tree in reverse order.

**Signature**

```ts
declare const valuesReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L421)

Since v2.0.0
Redacted-getEquivalence.md
Package: `effect`<br />
Module: `Redacted`<br />

## Redacted.getEquivalence

Generates an equivalence relation for `Redacted<A>` values based on an
equivalence relation for the underlying values `A`. This function is useful
for comparing `Redacted` instances without exposing their contents.

**Example**

```ts
import * as assert from "node:assert"
import { Redacted, Equivalence } from "effect"

const API_KEY1 = Redacted.make("1234567890")
const API_KEY2 = Redacted.make("1-34567890")
const API_KEY3 = Redacted.make("1234567890")

const equivalence = Redacted.getEquivalence(Equivalence.string)

assert.equal(equivalence(API_KEY1, API_KEY2), false)
assert.equal(equivalence(API_KEY1, API_KEY3), true)
```

**Signature**

```ts
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Redacted<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L143)

Since v3.3.0
Redacted-make.md
Package: `effect`<br />
Module: `Redacted`<br />

## Redacted.make

This function creates a `Redacted<A>` instance from a given value `A`,
securely hiding its content.

**Example**

```ts
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")
```

**Signature**

```ts
declare const make: <A>(value: A) => Redacted<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L75)

Since v3.3.0
Redacted-unsafeWipe.md
Package: `effect`<br />
Module: `Redacted`<br />

## Redacted.unsafeWipe

Erases the underlying value of a `Redacted` instance, rendering it unusable.
This function is intended to ensure that sensitive data does not remain in
memory longer than necessary.

**Example**

```ts
import * as assert from "node:assert"
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")

assert.equal(Redacted.value(API_KEY), "1234567890")

Redacted.unsafeWipe(API_KEY)

assert.throws(() => Redacted.value(API_KEY), new Error("Unable to get redacted value"))
```

**Signature**

```ts
declare const unsafeWipe: <A>(self: Redacted<A>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L118)

Since v3.3.0
Redacted-value.md
Package: `effect`<br />
Module: `Redacted`<br />

## Redacted.value

Retrieves the original value from a `Redacted` instance. Use this function
with caution, as it exposes the sensitive data.

**Example**

```ts
import * as assert from "node:assert"
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")

assert.equal(Redacted.value(API_KEY), "1234567890")
```

**Signature**

```ts
declare const value: <A>(self: Redacted<A>) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L94)

Since v3.3.0
RegExp-escape.md
Package: `effect`<br />
Module: `RegExp`<br />

## RegExp.escape

Escapes special characters in a regular expression pattern.

**Example**

```ts
import * as assert from "node:assert"
import { RegExp } from "effect"

assert.deepStrictEqual(RegExp.escape("a*b"), "a\\*b")
```

**Signature**

```ts
declare const escape: (string: string) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RegExp.ts#L38)

Since v2.0.0
RegExp-isRegExp.md
Package: `effect`<br />
Module: `RegExp`<br />

## RegExp.isRegExp

Tests if a value is a `RegExp`.

**Example**

```ts
import * as assert from "node:assert"
import { RegExp } from "effect"

assert.deepStrictEqual(RegExp.isRegExp(/a/), true)
assert.deepStrictEqual(RegExp.isRegExp("a"), false)
```

**Signature**

```ts
declare const isRegExp: (input: unknown) => input is RegExp
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RegExp.ts#L23)

Since v3.9.0
Reloadable-auto.md
Package: `effect`<br />
Module: `Reloadable`<br />

## Reloadable.auto

Makes a new reloadable service from a layer that describes the construction
of a static service. The service is automatically reloaded according to the
provided schedule.

**Signature**

```ts
declare const auto: <I, S, E, In, R>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; readonly schedule: Schedule.Schedule<unknown, unknown, R>; }) => Layer.Layer<Reloadable<I>, E, R | In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L65)

Since v2.0.0
Reloadable-autoFromConfig.md
Package: `effect`<br />
Module: `Reloadable`<br />

## Reloadable.autoFromConfig

Makes a new reloadable service from a layer that describes the construction
of a static service. The service is automatically reloaded according to a
schedule, which is extracted from the input to the layer.

**Signature**

```ts
declare const autoFromConfig: <I, S, E, In, R>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; readonly scheduleFromConfig: (context: Context.Context<In>) => Schedule.Schedule<unknown, unknown, R>; }) => Layer.Layer<Reloadable<I>, E, R | In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L78)

Since v2.0.0
Reloadable-get.md
Package: `effect`<br />
Module: `Reloadable`<br />

## Reloadable.get

Retrieves the current version of the reloadable service.

**Signature**

```ts
declare const get: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<S, never, Reloadable<I>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L92)

Since v2.0.0
Reloadable-manual.md
Package: `effect`<br />
Module: `Reloadable`<br />

## Reloadable.manual

Makes a new reloadable service from a layer that describes the construction
of a static service.

**Signature**

```ts
declare const manual: <I, S, In, E>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; }) => Layer.Layer<Reloadable<I>, E, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L101)

Since v2.0.0
Reloadable-Reloadable.md
Package: `effect`<br />
Module: `Reloadable`<br />

## Reloadable.Reloadable

A `Reloadable` is an implementation of some service that can be dynamically
reloaded, or swapped out for another implementation on-the-fly.

**Signature**

```ts
export interface Reloadable<in out A> extends Reloadable.Variance<A> {
  /**
   * @internal
   */
  readonly scopedRef: ScopedRef.ScopedRef<A>
  /**
   * @internal
   */
  readonly reload: Effect.Effect<void, unknown>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L31)

Since v2.0.0
Reloadable-reload.md
Package: `effect`<br />
Module: `Reloadable`<br />

## Reloadable.reload

Reloads the specified service.

**Signature**

```ts
declare const reload: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L112)

Since v2.0.0
Reloadable-reloadFork.md
Package: `effect`<br />
Module: `Reloadable`<br />

## Reloadable.reloadFork

Forks the reload of the service in the background, ignoring any errors.

**Signature**

```ts
declare const reloadFork: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L126)

Since v2.0.0
Request-Class.md
Package: `effect`<br />
Module: `Request`<br />

## Request.Class

Provides a constructor for a Request Class.

**Example**

```ts
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.Class<Success, Error, {
  readonly id: string
}> {}
```

**Signature**

```ts
declare const Class: new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L142)

Since v2.0.0
Request-Entry.md
Package: `effect`<br />
Module: `Request`<br />

## Request.Entry

A `Entry<A>` keeps track of a request of type `A` along with a
`Ref` containing the result of the request, existentially hiding the result
type. This is used internally by the library to support data sources that
return different result types for different requests while guaranteeing that
results will be of the type requested.

**Signature**

```ts
export interface Entry<out R> extends Entry.Variance<R> {
  readonly request: R
  readonly result: Deferred<
    [R] extends [Request<infer _A, infer _E>] ? _A : never,
    [R] extends [Request<infer _A, infer _E>] ? _E : never
  >
  readonly listeners: Listeners
  readonly ownerId: FiberId
  readonly state: {
    completed: boolean
  }
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L308)

Since v2.0.0
Request-Request.Error.md
Package: `effect`<br />
Module: `Request`<br />

## Request.Request.Error

A utility type to extract the error type from a `Request`.

**Signature**

```ts
type Error<T> = [T] extends [Request<infer _A, infer _E>] ? _E : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L69)

Since v2.0.0
Request-Request.OptionalResult.md
Package: `effect`<br />
Module: `Request`<br />

## Request.Request.OptionalResult

A utility type to extract the optional result type from a `Request`.

**Signature**

```ts
type OptionalResult<T> = T extends Request<infer A, infer E>
    ? Exit.Exit<Option.Option<A>, E>
    : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L93)

Since v2.0.0
Request-Request.Result.md
Package: `effect`<br />
Module: `Request`<br />

## Request.Request.Result

A utility type to extract the result type from a `Request`.

**Signature**

```ts
type Result<T> = T extends Request<infer A, infer E> ? Exit.Exit<A, E> : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L85)

Since v2.0.0
Request-Request.Success.md
Package: `effect`<br />
Module: `Request`<br />

## Request.Request.Success

A utility type to extract the value type from a `Request`.

**Signature**

```ts
type Success<T> = [T] extends [Request<infer _A, infer _E>] ? _A : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L77)

Since v2.0.0
Request-Request.md
Package: `effect`<br />
Module: `Request`<br />

## Request.Request

A `Request<A, E>` is a request from a data source for a value of type `A`
that may fail with an `E`.

**Signature**

```ts
export interface Request<out A, out E = never> extends Request.Variance<A, E> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L38)

Since v2.0.0
Request-TaggedClass.md
Package: `effect`<br />
Module: `Request`<br />

## Request.TaggedClass

Provides a Tagged constructor for a Request Class.

**Example**

```ts
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.TaggedClass("MyRequest")<Success, Error, {
  readonly name: string
}> {}
```

**Signature**

```ts
declare const TaggedClass: <Tag extends string>(tag: Tag) => new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" | keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A> & { readonly _tag: Tag; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L165)

Since v2.0.0
Request-complete.md
Package: `effect`<br />
Module: `Request`<br />

## Request.complete

Complete a `Request` with the specified result.

**Signature**

```ts
declare const complete: { <A extends Request<any, any>>(result: Request.Result<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, result: Request.Result<A>): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L178)

Since v2.0.0
Request-completeEffect.md
Package: `effect`<br />
Module: `Request`<br />

## Request.completeEffect

Complete a `Request` with the specified effectful computation, failing the
request with the error from the effect workflow if it fails, and completing
the request with the value of the effect workflow if it succeeds.

**Signature**

```ts
declare const completeEffect: { <A extends Request<any, any>, R>(effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): (self: A) => Effect.Effect<void, never, R>; <A extends Request<any, any>, R>(self: A, effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): Effect.Effect<void, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L202)

Since v2.0.0
Request-fail.md
Package: `effect`<br />
Module: `Request`<br />

## Request.fail

Complete a `Request` with the specified error.

**Signature**

```ts
declare const fail: { <A extends Request<any, any>>(error: Request.Error<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, error: Request.Error<A>): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L218)

Since v2.0.0
Request-failCause.md
Package: `effect`<br />
Module: `Request`<br />

## Request.failCause

Complete a `Request` with the specified cause.

**Signature**

```ts
declare const failCause: { <A extends Request<any, any>>(cause: Cause<Request.Error<A>>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, cause: Cause<Request.Error<A>>): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L229)

Since v2.0.0
Request-interruptWhenPossible.md
Package: `effect`<br />
Module: `Request`<br />

## Request.interruptWhenPossible

Interrupts the child effect when requests are no longer needed

**Signature**

```ts
declare const interruptWhenPossible: { (all: Iterable<Request<any, any>>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, all: Iterable<Request<any, any>>): Effect.Effect<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L189)

Since v2.0.0
Request-isRequest.md
Package: `effect`<br />
Module: `Request`<br />

## Request.isRequest

Returns `true` if the specified value is a `Request`, `false` otherwise.

**Signature**

```ts
declare const isRequest: (u: unknown) => u is Request<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L104)

Since v2.0.0
Request-of.md
Package: `effect`<br />
Module: `Request`<br />

## Request.of

Constructs a new `Request`.

**Signature**

```ts
declare const of: <R extends Request<any, any>>() => Request.Constructor<R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L112)

Since v2.0.0
Request-succeed.md
Package: `effect`<br />
Module: `Request`<br />

## Request.succeed

Complete a `Request` with the specified value.

**Signature**

```ts
declare const succeed: { <A extends Request<any, any>>(value: Request.Success<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, value: Request.Success<A>): Effect.Effect<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L240)

Since v2.0.0
Request-tagged.md
Package: `effect`<br />
Module: `Request`<br />

## Request.tagged

Constructs a new `Request`.

**Signature**

```ts
declare const tagged: <R extends Request<any, any> & { _tag: string; }>(tag: R["_tag"]) => Request.Constructor<R, "_tag">
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L120)

Since v2.0.0
RequestBlock-RequestBlock.md
Package: `effect`<br />
Module: `RequestBlock`<br />

## RequestBlock.RequestBlock

`RequestBlock` captures a collection of blocked requests as a data
structure. By doing this the library is able to preserve information about
which requests must be performed sequentially and which can be performed in
parallel, allowing for maximum possible batching and pipelining while
preserving ordering guarantees.

**Signature**

```ts
type RequestBlock = Empty | Par | Seq | Single
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L18)

Since v2.0.0
RequestResolver-RequestResolver.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.RequestResolver

The `RequestResolver<A, R>` interface requires an environment `R` and handles
the execution of requests of type `A`.

Implementations must provide a `runAll` method, which processes a collection
of requests and produces an effect that fulfills these requests. Requests are
organized into a `Array<Array<A>>`, where the outer `Array` groups requests
into batches that are executed sequentially, and each inner `Array` contains
requests that can be executed in parallel. This structure allows
implementations to analyze all incoming requests collectively and optimize
query execution accordingly.

Implementations are typically specialized for a subtype of `Request<A, E>`.
However, they are not strictly limited to these subtypes as long as they can
map any given request type to `Request<A, E>`. Implementations should inspect
the collection of requests to identify the needed information and execute the
corresponding queries. It is imperative that implementations resolve all the
requests they receive. Failing to do so will lead to a `QueryFailure` error
during query execution.

**Signature**

```ts
export interface RequestResolver<in A, out R = never> extends RequestResolver.Variance<A, R>, Equal.Equal, Pipeable {
  /**
   * Execute a collection of requests. The outer `Array` represents batches
   * of requests that must be performed sequentially. The inner `Array`
   * represents a batch of requests that can be performed in parallel.
   */
  runAll(requests: Array<Array<Request.Entry<A>>>): Effect.Effect<void, never, R>

  /**
   * Identify the data source using the specific identifier
   */
  identified(...identifiers: Array<unknown>): RequestResolver<A, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L52)

Since v2.0.0
RequestResolver-around.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.around

A data source aspect that executes requests between two effects, `before`
and `after`, where the result of `before` can be used by `after`.

**Signature**

```ts
declare const around: { <A2, R2, X, R3>(before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L150)

Since v2.0.0
RequestResolver-aroundRequests.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.aroundRequests

A data source aspect that executes requests between two effects, `before`
and `after`, where the result of `before` can be used by `after`.

The `before` and `after` effects are provided with the requests being executed.

**Example**

```ts
import { Effect, Request, RequestResolver } from "effect"

interface GetUserById extends Request.Request<unknown> {
  readonly id: number
}

const resolver = RequestResolver.fromFunction(
  (request: GetUserById) => ({ id: request.id, name: "John" })
)

RequestResolver.aroundRequests(
  resolver,
  (requests) => Effect.log(`got ${requests.length} requests`),
  (requests, _) => Effect.log(`finised running ${requests.length} requests`)
)
```

**Signature**

```ts
declare const aroundRequests: { <A, A2, R2, X, R3>(before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): <R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L189)

Since v2.0.0
RequestResolver-batchN.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.batchN

Returns a data source that executes at most `n` requests in parallel.

**Signature**

```ts
declare const batchN: { (n: number): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R>; <A, R>(self: RequestResolver<A, R>, n: number): RequestResolver<A, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L207)

Since v2.0.0
RequestResolver-eitherWith.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.eitherWith

Returns a new data source that executes requests of type `C` using the
specified function to transform `C` requests into requests that either this
data source or that data source can execute.

**Signature**

```ts
declare const eitherWith: { <A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): <R>(self: RequestResolver<A, R>) => RequestResolver<C, R2 | R>; <R, A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(self: RequestResolver<A, R>, that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): RequestResolver<C, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L236)

Since v2.0.0
RequestResolver-fromEffect.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.fromEffect

Constructs a data source from an effectual function.

**Signature**

```ts
declare const fromEffect: <R, A extends Request.Request<any, any>>(f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>) => RequestResolver<A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L282)

Since v2.0.0
RequestResolver-fromEffectTagged.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.fromEffectTagged

Constructs a data source from a list of tags paired to functions, that takes
a list of requests and returns a list of results of the same size. Each item
in the result list must correspond to the item at the same index in the
request list.

**Signature**

```ts
declare const fromEffectTagged: <A extends Request.Request<any, any> & { readonly _tag: string; }>() => <Fns extends { readonly [Tag in A["_tag"]]: [Extract<A, { readonly _tag: Tag; }>] extends [infer Req] ? Req extends Request.Request<infer ReqA, infer ReqE> ? (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any> : never : never; }>(fns: Fns) => RequestResolver<A, ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L295)

Since v2.0.0
RequestResolver-fromFunction.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.fromFunction

Constructs a data source from a pure function.

**Signature**

```ts
declare const fromFunction: <A extends Request.Request<any>>(f: (request: A) => Request.Request.Success<A>) => RequestResolver<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L260)

Since v2.0.0
RequestResolver-fromFunctionBatched.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.fromFunctionBatched

Constructs a data source from a pure function that takes a list of requests
and returns a list of results of the same size. Each item in the result
list must correspond to the item at the same index in the request list.

**Signature**

```ts
declare const fromFunctionBatched: <A extends Request.Request<any>>(f: (chunk: NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>) => RequestResolver<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L272)

Since v2.0.0
RequestResolver-isRequestResolver.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.isRequestResolver

Returns `true` if the specified value is a `RequestResolver`, `false` otherwise.

**Signature**

```ts
declare const isRequestResolver: (u: unknown) => u is RequestResolver<unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L109)

Since v2.0.0
RequestResolver-locally.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.locally

Returns a new data source with a localized FiberRef

**Signature**

```ts
declare const locally: { <A>(self: FiberRef<A>, value: A): <R, B extends Request.Request<any, any>>(use: RequestResolver<B, R>) => RequestResolver<B, R>; <R, B extends Request.Request<any, any>, A>(use: RequestResolver<B, R>, self: FiberRef<A>, value: A): RequestResolver<B, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L356)

Since v2.0.0
RequestResolver-make.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.make

Constructs a data source with the specified identifier and method to run
requests.

**Signature**

```ts
declare const make: <A, R>(runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L118)

Since v2.0.0
RequestResolver-makeBatched.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.makeBatched

Constructs a data source from a function taking a collection of requests.

**Signature**

```ts
declare const makeBatched: <A extends Request.Request<any, any>, R>(run: (requests: NonEmptyArray<A>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L139)

Since v2.0.0
RequestResolver-makeWithEntry.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.makeWithEntry

Constructs a data source with the specified identifier and method to run
requests.

**Signature**

```ts
declare const makeWithEntry: <A, R>(runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L129)

Since v2.0.0
RequestResolver-mapInputContext.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.mapInputContext

Provides this data source with part of its required context.

**Signature**

```ts
declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A, R0>; <R, A extends Request.Request<any, any>, R0>(self: RequestResolver<A, R>, f: (context: Context.Context<R0>) => Context.Context<R>): RequestResolver<A, R0>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L218)

Since v2.0.0
RequestResolver-never.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.never

A data source that never executes requests.

**Signature**

```ts
declare const never: RequestResolver<never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L314)

Since v2.0.0
RequestResolver-provideContext.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.provideContext

Provides this data source with its required context.

**Signature**

```ts
declare const provideContext: { <R>(context: Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A>; <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>, context: Context.Context<R>): RequestResolver<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L322)

Since v2.0.0
RequestResolver-race.md
Package: `effect`<br />
Module: `RequestResolver`<br />

## RequestResolver.race

Returns a new data source that executes requests by sending them to this
data source and that data source, returning the results from the first data
source to complete and safely interrupting the loser.

**Signature**

```ts
declare const race: { <A2 extends Request.Request<any, any>, R2>(that: RequestResolver<A2, R2>): <A extends Request.Request<any, any>, R>(self: RequestResolver<A, R>) => RequestResolver<A2 | A, R2 | R>; <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>(self: RequestResolver<A, R>, that: RequestResolver<A2, R2>): RequestResolver<A | A2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L340)

Since v2.0.0
Resource-Resource.md
Package: `effect`<br />
Module: `Resource`<br />

## Resource.Resource

A `Resource` is a possibly resourceful value that is loaded into memory, and
which can be refreshed either manually or automatically.

**Signature**

```ts
export interface Resource<in out A, in out E = never> extends Effect.Effect<A, E>, Resource.Variance<A, E> {
  /** @internal */
  readonly scopedRef: ScopedRef.ScopedRef<Exit.Exit<A, E>>
  /** @internal */
  readonly acquire: Effect.Effect<A, E, Scope.Scope>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: ResourceUnify<this>
  readonly [Unify.ignoreSymbol]?: ResourceUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L32)

Since v2.0.0
Resource-auto.md
Package: `effect`<br />
Module: `Resource`<br />

## Resource.auto

Creates a new `Resource` value that is automatically refreshed according to
the specified policy. Note that error retrying is not performed
automatically, so if you want to retry on errors, you should first apply
retry policies to the acquisition effect before passing it to this
constructor.

**Signature**

```ts
declare const auto: <A, E, R, Out, R2>(acquire: Effect.Effect<A, E, R>, policy: Schedule.Schedule<Out, unknown, R2>) => Effect.Effect<Resource<A, E>, never, R | R2 | Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L85)

Since v2.0.0
Resource-get.md
Package: `effect`<br />
Module: `Resource`<br />

## Resource.get

Retrieves the current value stored in the cache.

**Signature**

```ts
declare const get: <A, E>(self: Resource<A, E>) => Effect.Effect<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L96)

Since v2.0.0
Resource-manual.md
Package: `effect`<br />
Module: `Resource`<br />

## Resource.manual

Creates a new `Resource` value that must be manually refreshed by calling
the refresh method. Note that error retrying is not performed
automatically, so if you want to retry on errors, you should first apply
retry policies to the acquisition effect before passing it to this
constructor.

**Signature**

```ts
declare const manual: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<Resource<A, E>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L108)

Since v2.0.0
Resource-refresh.md
Package: `effect`<br />
Module: `Resource`<br />

## Resource.refresh

Refreshes the cache. This method will not return until either the refresh
is successful, or the refresh operation fails.

**Signature**

```ts
declare const refresh: <A, E>(self: Resource<A, E>) => Effect.Effect<void, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L119)

Since v2.0.0
Rpc-Handler.md
Package: `@effect/rpc`<br />
Module: `Rpc`<br />

## Rpc.Handler

Represents an implemented rpc.

**Signature**

```ts
export interface Handler<Tag extends string> {
  readonly _: unique symbol
  readonly tag: Tag
  readonly handler: (request: any, headers: Headers) => Effect<any, any> | Stream<any, any>
  readonly context: Context<never>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/Rpc.ts#L132)

Since v1.0.0
Rpc-Rpc.md
Package: `@effect/rpc`<br />
Module: `Rpc`<br />

## Rpc.Rpc

Represents an API endpoint. An API endpoint is mapped to a single route on
the underlying `HttpRouter`.

**Signature**

```ts
export interface Rpc<
  in out Tag extends string,
  out Payload extends AnySchema = typeof Schema.Void,
  out Success extends Schema.Schema.Any = typeof Schema.Void,
  out Error extends Schema.Schema.All = typeof Schema.Never,
  out Middleware extends RpcMiddleware.TagClassAny = never
> extends Pipeable {
  new(_: never): {}

  readonly [TypeId]: TypeId
  readonly _tag: Tag
  readonly key: string
  readonly payloadSchema: Payload
  readonly successSchema: Success
  readonly errorSchema: Error
  readonly annotations: Context_.Context<never>
  readonly middlewares: ReadonlySet<Middleware>

  /**
   * Set the schema for the success response of the rpc.
   */
  setSuccess<S extends Schema.Schema.Any>(schema: S): Rpc<
    Tag,
    Payload,
    S,
    Error,
    Middleware
  >

  /**
   * Set the schema for the error response of the rpc.
   */
  setError<E extends Schema.Schema.Any>(schema: E): Rpc<
    Tag,
    Payload,
    Success,
    E,
    Middleware
  >

  /**
   * Set the schema for the payload of the rpc.
   */
  setPayload<P extends Schema.Struct<any> | Schema.Struct.Fields>(
    schema: P
  ): Rpc<
    Tag,
    P extends Schema.Struct<infer _> ? P : P extends Schema.Struct.Fields ? Schema.Struct<P> : never,
    Success,
    Error,
    Middleware
  >

  /**
   * Add an `RpcMiddleware` to this procedure.
   */
  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): Rpc<
    Tag,
    Payload,
    Success,
    Error,
    Middleware | M
  >

  /**
   * Add an annotation on the rpc.
   */
  annotate<I, S>(
    tag: Context_.Tag<I, S>,
    value: S
  ): Rpc<Tag, Payload, Success, Error, Middleware>

  /**
   * Merge the annotations of the rpc with the provided context.
   */
  annotateContext<I>(
    context: Context_.Context<I>
  ): Rpc<Tag, Payload, Success, Error, Middleware>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/Rpc.ts#L46)

Since v1.0.0
Rpc-fork.md
Package: `@effect/rpc`<br />
Module: `Rpc`<br />

## Rpc.fork

You can use `fork` to wrap a response Effect or Stream, to ensure that the
response is executed concurrently regardless of the RpcServer concurrency
setting.

**Signature**

```ts
declare const fork: <A>(value: A) => Fork<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/Rpc.ts#L722)

Since v1.0.0
RpcSerialization-layerJson.md
Package: `@effect/rpc`<br />
Module: `RpcSerialization`<br />

## RpcSerialization.layerJson

A rpc serialization layer that uses JSON for serialization.

Use this if your protocol supports framing for messages, otherwise use
`layerNdjson`.

**Signature**

```ts
declare const layerJson: Layer.Layer<RpcSerialization, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcSerialization.ts#L362)

Since v1.0.0
RpcSerialization-layerJsonRpc.md
Package: `@effect/rpc`<br />
Module: `RpcSerialization`<br />

## RpcSerialization.layerJsonRpc

A rpc serialization layer that uses JSON-RPC for serialization.

**Signature**

```ts
declare const layerJsonRpc: (options?: { readonly contentType?: string | undefined; }) => Layer.Layer<RpcSerialization>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcSerialization.ts#L381)

Since v1.0.0
RpcSerialization-layerMsgPack.md
Package: `@effect/rpc`<br />
Module: `RpcSerialization`<br />

## RpcSerialization.layerMsgPack

A rpc serialization layer that uses MessagePack for serialization.

MessagePack has a more compact binary format compared to JSON and NDJSON. It
also has better support for binary data.

**Signature**

```ts
declare const layerMsgPack: Layer.Layer<RpcSerialization, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcSerialization.ts#L405)

Since v1.0.0
RpcSerialization-layerNdJsonRpc.md
Package: `@effect/rpc`<br />
Module: `RpcSerialization`<br />

## RpcSerialization.layerNdJsonRpc

A rpc serialization layer that uses JSON-RPC for serialization seperated by
new lines.

**Signature**

```ts
declare const layerNdJsonRpc: (options?: { readonly contentType?: string | undefined; }) => Layer.Layer<RpcSerialization>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcSerialization.ts#L392)

Since v1.0.0
RpcSerialization-layerNdjson.md
Package: `@effect/rpc`<br />
Module: `RpcSerialization`<br />

## RpcSerialization.layerNdjson

A rpc serialization layer that uses NDJSON for serialization.

Use this if your protocol does not support framing for messages, otherwise
use `layerJson`.

**Signature**

```ts
declare const layerNdjson: Layer.Layer<RpcSerialization, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcSerialization.ts#L373)

Since v1.0.0
RpcServer-layerProtocolHttp.md
Package: `@effect/rpc`<br />
Module: `RpcServer`<br />

## RpcServer.layerProtocolHttp

A rpc protocol that uses streaming http for communication.

**Signature**

```ts
declare const layerProtocolHttp: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; }) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcServer.ts#L1042)

Since v1.0.0
RpcServer-layerProtocolSocketServer.md
Package: `@effect/rpc`<br />
Module: `RpcServer`<br />

## RpcServer.layerProtocolSocketServer

A rpc protocol that uses `SocketServer` for communication.

**Signature**

```ts
declare const layerProtocolSocketServer: Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | SocketServer.SocketServer>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcServer.ts#L767)

Since v1.0.0
RpcServer-layerProtocolStdio.md
Package: `@effect/rpc`<br />
Module: `RpcServer`<br />

## RpcServer.layerProtocolStdio

Create a protocol that uses the provided `Stream` and `Sink` for communication.

**Signature**

```ts
declare const layerProtocolStdio: <EIn, EOut, RIn, ROut>(options: { readonly stdin: Stream.Stream<Uint8Array, EIn, RIn>; readonly stdout: Sink.Sink<void, Uint8Array | string, never, EOut, ROut>; }) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | Exclude<RIn | ROut, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcServer.ts#L1239)

Since v1.0.0
RpcServer-layerProtocolWebsocket.md
Package: `@effect/rpc`<br />
Module: `RpcServer`<br />

## RpcServer.layerProtocolWebsocket

A rpc protocol that uses websockets for communication.

**Signature**

```ts
declare const layerProtocolWebsocket: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; }) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcServer.ts#L827)

Since v1.0.0
RpcServer-makeProtocolStdio.md
Package: `@effect/rpc`<br />
Module: `RpcServer`<br />

## RpcServer.makeProtocolStdio

Create a protocol that uses the provided `Stream` and `Sink` for communication.

**Signature**

```ts
declare const makeProtocolStdio: <EIn, EOut, RIn, ROut>(options: { readonly stdin: Stream.Stream<Uint8Array, EIn, RIn>; readonly stdout: Sink.Sink<void, Uint8Array | string, never, EOut, ROut>; }) => Effect.Effect<{ readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>; readonly disconnects: Mailbox.ReadonlyMailbox<number>; readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>; readonly end: (clientId: number) => Effect.Effect<void>; readonly initialMessage: Effect.Effect<Option.Option<unknown>>; readonly supportsAck: boolean; readonly supportsTransferables: boolean; readonly supportsSpanPropagation: boolean; }, never, Scope.Scope | RpcSerialization.RpcSerialization | RIn | Exclude<ROut, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcServer.ts#L1180)

Since v1.0.0
RpcServer-toWebHandler.md
Package: `@effect/rpc`<br />
Module: `RpcServer`<br />

## RpcServer.toWebHandler

Construct an http web handler from an `RpcGroup`.

**Signature**

```ts
declare const toWebHandler: <Rpcs extends Rpc.Any, LE>(group: RpcGroup.RpcGroup<Rpcs>, options: { readonly layer: Layer.Layer<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | RpcSerialization.RpcSerialization | HttpRouter.HttpRouter.DefaultServices, LE>; readonly disableTracing?: boolean | undefined; readonly spanPrefix?: string | undefined; readonly spanAttributes?: Record<string, unknown> | undefined; readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>; readonly memoMap?: Layer.MemoMap; }) => { readonly handler: (request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>; readonly dispose: () => Promise<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/rpc/src/RpcServer.ts#L1129)

Since v1.0.0
Runner-Runner.md
Package: `@effect/cluster`<br />
Module: `Runner`<br />

## Runner.Runner

A `Runner` represents a physical application server that is capable of running
entities.

Because a Runner represents a physical application server, a Runner must have a
unique `address` which can be used to communicate with the server.

The version of a Runner is used during rebalancing to give priority to newer
application servers and slowly decommission older ones.

**Signature**

```ts
declare class Runner
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Runner.ts#L38)

Since v1.0.0
Runner-make.md
Package: `@effect/cluster`<br />
Module: `Runner`<br />

## Runner.make

A `Runner` represents a physical application server that is capable of running
entities.

Because a Runner represents a physical application server, a Runner must have a
unique `address` which can be used to communicate with the server.

The version of a Runner is used during rebalancing to give priority to newer
application servers and slowly decommission older ones.

**Signature**

```ts
declare const make: (props: { readonly address: RunnerAddress; readonly groups: ReadonlyArray<string>; readonly version: number; }) => Runner
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Runner.ts#L98)

Since v1.0.0
RunnerHealth-RunnerHealth.md
Package: `@effect/cluster`<br />
Module: `RunnerHealth`<br />

## RunnerHealth.RunnerHealth

Represents the service used to check if a Runner is healthy.

If a Runner is responsive, shards will not be re-assigned because the Runner may
still be processing messages. If a Runner is not responsive, then its
associated shards can and will be re-assigned to a different Runner.

**Signature**

```ts
declare class RunnerHealth
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/RunnerHealth.ts#L22)

Since v1.0.0
RunnerHealth-layer.md
Package: `@effect/cluster`<br />
Module: `RunnerHealth`<br />

## RunnerHealth.layer

A layer which will ping a Runner directly to check if it is healthy.

**Signature**

```ts
declare const layer: Layer.Layer<RunnerHealth, never, Runners.Runners>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/RunnerHealth.ts#L68)

Since v1.0.0
RunnerHealth-layerNoop.md
Package: `@effect/cluster`<br />
Module: `RunnerHealth`<br />

## RunnerHealth.layerNoop

A layer which will **always** consider a Runner healthy.

This is useful for testing.

**Signature**

```ts
declare const layerNoop: Layer.Layer<RunnerHealth, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/RunnerHealth.ts#L37)

Since v1.0.0
RunnerHealth-layerRpc.md
Package: `@effect/cluster`<br />
Module: `RunnerHealth`<br />

## RunnerHealth.layerRpc

A layer which will ping a Runner directly to check if it is healthy.

**Signature**

```ts
declare const layerRpc: Layer.Layer<RunnerHealth, never, ShardingConfig | Runners.RpcClientProtocol>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/RunnerHealth.ts#L80)

Since v1.0.0
RunnerServer-layer.md
Package: `@effect/cluster`<br />
Module: `RunnerServer`<br />

## RunnerServer.layer

The `RunnerServer` recieves messages from other Runners and forwards them to the
`Sharding` layer.

It also responds to `Ping` requests.

**Signature**

```ts
declare const layer: Layer.Layer<never, never, MessageStorage.MessageStorage | Sharding.Sharding | RpcServer.Protocol>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/RunnerServer.ts#L113)

Since v1.0.0
RunnerServer-layerClientOnly.md
Package: `@effect/cluster`<br />
Module: `RunnerServer`<br />

## RunnerServer.layerClientOnly

A `Runners` layer that is client only.

It will not register with the ShardManager and recieve shard assignments,
so this layer can be used to embed a cluster client inside another effect
application.

**Signature**

```ts
declare const layerClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, MessageStorage.MessageStorage | ShardingConfig | Runners.RpcClientProtocol>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/RunnerServer.ts#L153)

Since v1.0.0
RunnerServer-layerWithClients.md
Package: `@effect/cluster`<br />
Module: `RunnerServer`<br />

## RunnerServer.layerWithClients

A `RunnerServer` layer that includes the `Runners` & `Sharding` clients.

**Signature**

```ts
declare const layerWithClients: Layer.Layer<Sharding.Sharding | Runners.Runners, never, ShardStorage.ShardStorage | MessageStorage.MessageStorage | ShardingConfig | Runners.RpcClientProtocol | RpcServer.Protocol>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/RunnerServer.ts#L128)

Since v1.0.0
Runtime-runCallback.md
Package: `effect`<br />
Module: `Runtime`<br />

## Runtime.runCallback

Executes the effect asynchronously, eventually passing the exit value to
the specified callback.

This method is effectful and should only be invoked at the edges of your
program.

**Signature**

```ts
declare const runCallback: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined) => (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined): (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L141)

Since v2.0.0
Runtime-runFork.md
Package: `effect`<br />
Module: `Runtime`<br />

## Runtime.runFork

Executes the effect using the provided Scheduler or using the global
Scheduler if not provided

**Signature**

```ts
declare const runFork: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined) => Fiber.RuntimeFiber<A, E>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined): Fiber.RuntimeFiber<A, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L84)

Since v2.0.0
Runtime-runPromise.md
Package: `effect`<br />
Module: `Runtime`<br />

## Runtime.runPromise

Runs the `Effect`, returning a JavaScript `Promise` that will be resolved
with the value of the effect once the effect has been executed, or will be
rejected with the first error or exception throw by the effect.

This method is effectful and should only be used at the edges of your
program.

**Signature**

```ts
declare const runPromise: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L166)

Since v2.0.0
Runtime-runPromiseExit.md
Package: `effect`<br />
Module: `Runtime`<br />

## Runtime.runPromiseExit

Runs the `Effect`, returning a JavaScript `Promise` that will be resolved
with the `Exit` state of the effect once the effect has been executed.

This method is effectful and should only be used at the edges of your
program.

**Signature**

```ts
declare const runPromiseExit: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<Exit.Exit<A, E>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L187)

Since v2.0.0
Runtime-runSync.md
Package: `effect`<br />
Module: `Runtime`<br />

## Runtime.runSync

Executes the effect synchronously throwing in case of errors or async boundaries.

This method is effectful and should only be invoked at the edges of your
program.

**Signature**

```ts
declare const runSync: { <A, E, R>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>): A; <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => A; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L118)

Since v2.0.0
Runtime-runSyncExit.md
Package: `effect`<br />
Module: `Runtime`<br />

## Runtime.runSyncExit

Executes the effect synchronously returning the exit.

This method is effectful and should only be invoked at the edges of your
program.

**Signature**

```ts
declare const runSyncExit: { <A, E, R>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>): Exit.Exit<A, E>; <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L104)

Since v2.0.0
RuntimeFlags-CooperativeYielding.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.CooperativeYielding

The cooperative yielding flag determines whether the Effect runtime will
yield to another fiber.

**Signature**

```ts
declare const CooperativeYielding: RuntimeFlag
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L92)

Since v2.0.0
RuntimeFlags-Interruption.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.Interruption

The interruption flag determines whether or not the Effect runtime system will
interrupt a fiber.

**Signature**

```ts
declare const Interruption: RuntimeFlag
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L49)

Since v2.0.0
RuntimeFlags-None.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.None

No runtime flags.

**Signature**

```ts
declare const None: RuntimeFlag
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L40)

Since v2.0.0
RuntimeFlags-OpSupervision.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.OpSupervision

The op supervision flag determines whether or not the Effect runtime system
will supervise all operations of the Effect runtime. Use of this flag will
negatively impact performance, but is required for some operations, such as
profiling.

**Signature**

```ts
declare const OpSupervision: RuntimeFlag
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L60)

Since v2.0.0
RuntimeFlags-RuntimeFlag.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.RuntimeFlag

Represents a flag that can be set to enable or disable a particular feature
of the Effect runtime.

**Signature**

```ts
type RuntimeFlag = number & {
  readonly RuntimeFlag: unique symbol
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L30)

Since v2.0.0
RuntimeFlags-RuntimeFlags.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.RuntimeFlags

Represents a set of `RuntimeFlag`s. `RuntimeFlag`s affect the operation of
the Effect runtime system. They are exposed to application-level code because
they affect the behavior and performance of application code.

**Signature**

```ts
type RuntimeFlags = number & {
  readonly RuntimeFlags: unique symbol
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L19)

Since v2.0.0
RuntimeFlags-RuntimeMetrics.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.RuntimeMetrics

The runtime metrics flag determines whether or not the Effect runtime system
will collect metrics about the Effect runtime. Use of this flag will have a
very small negative impact on performance, but generates very helpful
operational insight into running Effect applications that can be exported to
Prometheus or other tools via Effect Metrics.

**Signature**

```ts
declare const RuntimeMetrics: RuntimeFlag
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L72)

Since v2.0.0
RuntimeFlags-WindDown.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.WindDown

The wind down flag determines whether the Effect runtime system will execute
effects in wind-down mode. In wind-down mode, even if interruption is
enabled and a fiber has been interrupted, the fiber will continue its
execution uninterrupted.

**Signature**

```ts
declare const WindDown: RuntimeFlag
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L83)

Since v2.0.0
RuntimeFlags-cooperativeYielding.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.cooperativeYielding

Returns `true` if the `CooperativeYielding` `RuntimeFlag` is enabled, `false`
otherwise.

**Signature**

```ts
declare const cooperativeYielding: (self: RuntimeFlags) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L101)

Since v2.0.0
RuntimeFlags-diff.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.diff

Creates a `RuntimeFlagsPatch` which describes the difference between `self`
and `that`.

**Signature**

```ts
declare const diff: { (that: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch; (self: RuntimeFlags, that: RuntimeFlags): RuntimeFlagsPatch.RuntimeFlagsPatch; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L110)

Since v2.0.0
RuntimeFlags-differ.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.differ

Constructs a differ that knows how to diff `RuntimeFlags` values.

**Signature**

```ts
declare const differ: Differ.Differ<RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L121)

Since v2.0.0
RuntimeFlags-disable.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.disable

Disables the specified `RuntimeFlag`.

**Signature**

```ts
declare const disable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L129)

Since v2.0.0
RuntimeFlags-disableAll.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.disableAll

Disables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.

**Signature**

```ts
declare const disableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L140)

Since v2.0.0
RuntimeFlags-enable.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.enable

Enables the specified `RuntimeFlag`.

**Signature**

```ts
declare const enable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L181)

Since v2.0.0
RuntimeFlags-enableAll.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.enableAll

Enables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.

**Signature**

```ts
declare const enableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L192)

Since v2.0.0
RuntimeFlags-interruptible.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.interruptible

Returns true only if the `Interruption` flag is **enabled** and the
`WindDown` flag is **disabled**.

A fiber is said to be interruptible if interruption is enabled and the fiber
is not in its wind-down phase, in which it takes care of cleanup activities
related to fiber shutdown.

**Signature**

```ts
declare const interruptible: (self: RuntimeFlags) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L238)

Since v2.0.0
RuntimeFlags-interruption.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.interruption

Returns `true` if the `Interruption` `RuntimeFlag` is enabled, `false`
otherwise.

**Signature**

```ts
declare const interruption: (self: RuntimeFlags) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L247)

Since v2.0.0
RuntimeFlags-isDisabled.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.isDisabled

Returns `true` if the specified `RuntimeFlag` is disabled, `false` otherwise.

**Signature**

```ts
declare const isDisabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L266)

Since v2.0.0
RuntimeFlags-isEnabled.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.isEnabled

Returns `true` if the specified `RuntimeFlag` is enabled, `false` otherwise.

**Signature**

```ts
declare const isEnabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L255)

Since v2.0.0
RuntimeFlags-opSupervision.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.opSupervision

Returns `true` if the `OpSupervision` `RuntimeFlag` is enabled, `false`
otherwise.

**Signature**

```ts
declare const opSupervision: (self: RuntimeFlags) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L290)

Since v2.0.0
RuntimeFlags-patch.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.patch

Patches a set of `RuntimeFlag`s with a `RuntimeFlagsPatch`, returning the
patched set of `RuntimeFlag`s.

**Signature**

```ts
declare const patch: { (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlags; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L299)

Since v2.0.0
RuntimeFlags-render.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.render

Converts the provided `RuntimeFlags` into a `string`.

**Signature**

```ts
declare const render: (self: RuntimeFlags) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L310)

Since v2.0.0
RuntimeFlags-runtimeMetrics.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.runtimeMetrics

Returns `true` if the `RuntimeMetrics` `RuntimeFlag` is enabled, `false`
otherwise.

**Signature**

```ts
declare const runtimeMetrics: (self: RuntimeFlags) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L319)

Since v2.0.0
RuntimeFlags-toSet.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.toSet

Converts the provided `RuntimeFlags` into a `ReadonlySet<number>`.

**Signature**

```ts
declare const toSet: (self: RuntimeFlags) => ReadonlySet<RuntimeFlag>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L327)

Since v2.0.0
RuntimeFlags-windDown.md
Package: `effect`<br />
Module: `RuntimeFlags`<br />

## RuntimeFlags.windDown

Returns `true` if the `WindDown` `RuntimeFlag` is enabled, `false`
otherwise.

**Signature**

```ts
declare const windDown: (self: RuntimeFlags) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L336)

Since v2.0.0
RuntimeFlagsPatch-andThen.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.andThen

Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,
followed by `that` patch.

**Signature**

```ts
declare const andThen: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L109)

Since v2.0.0
RuntimeFlagsPatch-both.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.both

Creates a `RuntimeFlagsPatch` describing application of both the `self` patch
and `that` patch.

**Signature**

```ts
declare const both: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L121)

Since v2.0.0
RuntimeFlagsPatch-disable.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.disable

Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.

**Signature**

```ts
declare const disable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L44)

Since v2.0.0
RuntimeFlagsPatch-disabledSet.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.disabledSet

Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
disabled by the specified `RuntimeFlagsPatch`.

**Signature**

```ts
declare const disabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L175)

Since v2.0.0
RuntimeFlagsPatch-either.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.either

Creates a `RuntimeFlagsPatch` describing application of either the `self`
patch or `that` patch.

**Signature**

```ts
declare const either: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L133)

Since v2.0.0
RuntimeFlagsPatch-empty.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.empty

The empty `RuntimeFlagsPatch`.

**Signature**

```ts
declare const empty: RuntimeFlagsPatch
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L22)

Since v2.0.0
RuntimeFlagsPatch-enable.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.enable

Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.

**Signature**

```ts
declare const enable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L36)

Since v2.0.0
RuntimeFlagsPatch-enabledSet.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.enabledSet

Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
enabled by the specified `RuntimeFlagsPatch`.

**Signature**

```ts
declare const enabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L166)

Since v2.0.0
RuntimeFlagsPatch-exclude.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.exclude

Creates a `RuntimeFlagsPatch` which describes exclusion of the specified
`RuntimeFlag` from the set of `RuntimeFlags`.

**Signature**

```ts
declare const exclude: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L145)

Since v2.0.0
RuntimeFlagsPatch-includes.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.includes

Returns `true` if the `RuntimeFlagsPatch` includes the specified
`RuntimeFlag`, `false` otherwise.

**Signature**

```ts
declare const includes: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L97)

Since v2.0.0
RuntimeFlagsPatch-inverse.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.inverse

Creates a `RuntimeFlagsPatch` which describes the inverse of the patch
specified by the provided `RuntimeFlagsPatch`.

**Signature**

```ts
declare const inverse: (patch: RuntimeFlagsPatch) => RuntimeFlagsPatch
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L157)

Since v2.0.0
RuntimeFlagsPatch-isActive.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.isActive

Returns `true` if the `RuntimeFlagsPatch` describes the specified
`RuntimeFlag` as active.

**Signature**

```ts
declare const isActive: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L61)

Since v2.0.0
RuntimeFlagsPatch-isDisabled.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.isDisabled

Returns `true` if the `RuntimeFlagsPatch` describes the specified
`RuntimeFlag` as disabled.

**Signature**

```ts
declare const isDisabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L85)

Since v2.0.0
RuntimeFlagsPatch-isEmpty.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.isEmpty

Returns `true` if the specified `RuntimeFlagsPatch` is empty.

**Signature**

```ts
declare const isEmpty: (patch: RuntimeFlagsPatch) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L52)

Since v2.0.0
RuntimeFlagsPatch-isEnabled.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.isEnabled

Returns `true` if the `RuntimeFlagsPatch` describes the specified
`RuntimeFlag` as enabled.

**Signature**

```ts
declare const isEnabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L73)

Since v2.0.0
RuntimeFlagsPatch-render.md
Package: `effect`<br />
Module: `RuntimeFlagsPatch`<br />

## RuntimeFlagsPatch.render

Renders the provided `RuntimeFlagsPatch` to a string.

**Signature**

```ts
declare const render: (self: RuntimeFlagsPatch) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L183)

Since v2.0.0
Schedule-addDelay.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.addDelay

Adds a delay to every interval in a schedule.

**Details**

This function modifies a given schedule by applying an additional delay to
every interval it defines. The delay is determined by the provided function,
which takes the schedule's output and returns a delay duration.

**See**

- `addDelayEffect` If you need to compute the delay using an effectful function.

**Signature**

```ts
declare const addDelay: { <Out>(f: (out: Out) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => Duration.DurationInput): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L199)

Since v2.0.0
Schedule-addDelayEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.addDelayEffect

Adds an effectfully computed delay to every interval in a schedule.

**Details**

This function modifies a given schedule by applying an additional delay to
each interval, where the delay is determined by an effectful function. The
function takes the schedules output and returns an effect that produces a
delay duration.

**See**

- `addDelay` If you need to compute the delay using a pure function.

**Signature**

```ts
declare const addDelayEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L219)

Since v2.0.0
Schedule-andThen.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.andThen

Runs two schedules sequentially, merging their outputs.

**Details**

This function executes two schedules one after the other. The first schedule
runs to completion, and then the second schedule begins execution. Unlike
`andThenEither`, this function merges the outputs instead of wrapping
them in `Either`, allowing both schedules to contribute their results
directly.

This is useful when a workflow consists of two phases where the second phase
should start only after the first one has fully completed.

**See**

- `andThenEither` If you need to keep track of which schedule
produced each result.

**Signature**

```ts
declare const andThen: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out | Out2, In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L249)

Since v2.0.0
Schedule-andThenEither.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.andThenEither

Runs two schedules sequentially, collecting results in an `Either`.

**Details**

This function combines two schedules in sequence. The first schedule runs to
completion, and then the second schedule starts and runs to completion as
well. The outputs of both schedules are collected into an `Either` structure:
- `Either.Left` contains the output of the second schedule.
- `Either.Right` contains the output of the first schedule.

This is useful when you need to switch from one schedule to another after the
first one finishes, while still keeping track of which schedule produced each
result.

**See**

- `andThen` If you need to merge the outputs of both schedules.

**Signature**

```ts
declare const andThenEither: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either.Either<Out2, Out>, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Either.Either<Out2, Out>, In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L279)

Since v2.0.0
Schedule-as.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.as

Transforms a schedule to always produce a constant output.

**Details**

This function modifies a given schedule so that instead of returning its
computed outputs, it always returns a constant value.

This is useful when you need a schedule for timing but dont care about its
actual output, or when you want to standardize results across different
scheduling strategies.

**Signature**

```ts
declare const as: { <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L304)

Since v2.0.0
Schedule-asVoid.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.asVoid

Transforms a schedule to always return `void` instead of its output.

**Details**

This function modifies a given schedule so that it no longer returns
meaningful outputeach execution produces `void`. This is useful when the
schedule is used only for timing purposes and the actual output of the
schedule is irrelevant.

The schedule still determines when executions should occur, but the results
are discarded.

**Signature**

```ts
declare const asVoid: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L325)

Since v2.0.0
Schedule-bothInOut.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.bothInOut

Combines two schedules, preserving both their inputs and outputs.

**Details**

This function merges two schedules so that both their input types and output
types are retained. When executed, the resulting schedule will take inputs
from both original schedules and produce a tuple containing both outputs.

It recurs if either schedule wants to continue, using the shorter delay.

This is useful when you want to track multiple schedules simultaneously,
ensuring that both receive the same inputs and produce combined results.

**Signature**

```ts
declare const bothInOut: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], readonly [In, In2], R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L345)

Since v2.0.0
Schedule-check.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.check

Filters schedule executions based on a custom condition.

**Details**

This function modifies a schedule by applying a custom test function to each
input-output pair. The test function determines whether the schedule should
continue or stop. If the function returns `true`, the schedule proceeds as
usual; if it returns `false`, the schedule terminates.

This is useful for conditional retries, custom stop conditions, or
dynamically controlling execution based on observed inputs and outputs.

**See**

- `checkEffect` If you need to use an effectful test function.

**Signature**

```ts
declare const check: { <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L373)

Since v2.0.0
Schedule-checkEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.checkEffect

Conditionally filters schedule executions using an effectful function.

**Details**

This function modifies a schedule by applying a custom effectful test
function to each input-output pair. The test function determines whether the
schedule should continue (`true`) or stop (`false`).

This is useful when the decision to continue depends on external factors such
as database lookups, API calls, or other asynchronous computations.

**See**

- `check` If you need to use a pure test function.

**Signature**

```ts
declare const checkEffect: { <In, Out, R2>(test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L395)

Since v2.0.0
Schedule-collectAllInputs.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.collectAllInputs

A schedule that collects all inputs into a `Chunk`.

**Details**

This function creates a schedule that never terminates and continuously
collects every input it receives into a `Chunk`. Each time the schedule runs,
it appends the new input to the collected list.

This is useful when you need to track all received inputs over time, such as
logging user actions, recording retry attempts, or accumulating data for
later processing.

**See**

- `collectAllOutputs` If you need to collect outputs instead of
inputs.

**Signature**

```ts
declare const collectAllInputs: <A>() => Schedule<Chunk.Chunk<A>, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L424)

Since v2.0.0
Schedule-collectAllOutputs.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.collectAllOutputs

Collects all outputs of a schedule into a `Chunk`.

**Details**

This function modifies a given schedule so that instead of returning
individual outputs, it accumulates them into a `Chunk`. The schedule
continues to run, appending each output to the collected list.

This is useful when you need to track all results over time, such as logging
outputs, aggregating data, or keeping a history of previous values.

**See**

- `collectAllInputs` If you need to collect inputs instead of
outputs.

**Signature**

```ts
declare const collectAllOutputs: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk.Chunk<Out>, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L444)

Since v2.0.0
Schedule-collectUntil.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.collectUntil

Collects all inputs into a `Chunk` until a condition fails.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` until the given predicate function `f` evaluates to `false`. Once the
condition fails, the schedule stops.

**Signature**

```ts
declare const collectUntil: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L459)

Since v2.0.0
Schedule-collectUntilEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.collectUntilEffect

Collects all inputs into a `Chunk` until an effectful condition fails.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` until the given effectful predicate `f` returns `false`. The
predicate runs as an effect, meaning it can involve asynchronous computations
like API calls, database lookups, or randomness.

**Signature**

```ts
declare const collectUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L474)

Since v2.0.0
Schedule-collectWhile.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.collectWhile

Collects all inputs into a `Chunk` while a condition holds.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` while the given predicate function `f` evaluates to `true`. As soon
as the condition fails, the schedule stops.

**Signature**

```ts
declare const collectWhile: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L490)

Since v2.0.0
Schedule-collectWhileEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.collectWhileEffect

Collects all inputs into a `Chunk` while an effectful condition holds.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` while the given effectful predicate `f` returns `true`. The predicate
returns an effect, meaning it can depend on external state, such as database
queries, API responses, or real-time user conditions.

As soon as the effectful condition returns `false`, the schedule stops. This
is useful for dynamically controlled data collection, where stopping depends
on an external or asynchronous factor.

**Signature**

```ts
declare const collectWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L509)

Since v2.0.0
Schedule-compose.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.compose

Chains two schedules, passing the output of the first as the input to the
second, while selecting the shorter delay between them.

**Details**

This function composes two schedules so that the output of the first schedule
becomes the input of the second schedule. The first schedule executes first,
and once it produces a result, the second schedule receives that result and
continues execution based on it.

This is useful for building complex scheduling workflows where one schedule's
behavior determines how the next schedule behaves.

**Signature**

```ts
declare const compose: { <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L530)

Since v2.0.0
Schedule-count.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.count

A schedule that recurs indefinitely, counting the number of recurrences.

**Details**

This schedule never stops and simply counts how many times it has executed.
Each recurrence increases the count, starting from `0`.

This is useful when tracking the number of attempts in retry policies,
measuring execution loops, or implementing infinite polling scenarios.

**Signature**

```ts
declare const count: Schedule<number, unknown, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L624)

Since v2.0.0
Schedule-cron.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.cron

Creates a schedule that recurs based on a cron expression.

**Details**

This schedule automatically executes at intervals defined by a cron
expression. It triggers at the beginning of each matched interval and
produces timestamps representing the start and end of the cron window.

The cron `expression` is validated lazily, meaning errors may only be
detected when the schedule is executed.

**Signature**

```ts
declare const cron: { (cron: Cron.Cron): Schedule<[number, number]>; (expression: string, tz?: DateTime.TimeZone | string): Schedule<[number, number]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L641)

Since v2.0.0
Schedule-dayOfMonth.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.dayOfMonth

Creates a schedule that recurs on a specific day of the month.

**Details**

This schedule triggers at midnight on the specified day of each month. It
will not execute in months that have fewer days than the given day. For
example, if the schedule is set to run on the 31st, it will not execute in
months with only 30 days.

The schedule produces a count of executions, starting at 0 and incrementing
with each recurrence.

The `day` parameter is validated lazily, meaning errors may only be detected
when the schedule is executed.

**Signature**

```ts
declare const dayOfMonth: (day: number) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L719)

Since v2.0.0
Schedule-dayOfWeek.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.dayOfWeek

Creates a schedule that recurs on a specific day of the week.

**Details**

This schedule triggers at midnight on the specified day of the week. The
`day` parameter follows the standard convention where `Monday = 1` and
`Sunday = 7`. The schedule produces a count of executions, starting at 0 and
incrementing with each recurrence.

The `day` parameter is validated lazily, meaning errors may only be detected
when the schedule is executed.

**Signature**

```ts
declare const dayOfWeek: (day: number) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L737)

Since v2.0.0
Schedule-delayed.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.delayed

Modifies a schedule by adding a computed delay before each execution.

**Details**

This function adjusts an existing schedule by applying a transformation to
its delays. Instead of using the default interval, each delay is modified
using the provided function `f`, which takes the current delay and returns a
new delay.

This is useful for dynamically adjusting wait times between executions, such
as introducing jitter, exponential backoff, or custom delay logic.

**See**

- `delayedEffect` If you need to compute the delay using an effectful function.

**Signature**

```ts
declare const delayed: { (f: (duration: Duration.Duration) => Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L757)

Since v2.0.0
Schedule-delayedEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.delayedEffect

Modifies a schedule by adding an effectfully computed delay before each
execution.

**Details**

This function adjusts an existing schedule by introducing a delay that is
computed via an effect. Instead of using a fixed delay, each interval is
dynamically adjusted based on an effectful function `f`, which takes the
current delay and returns a new delay wrapped in an `Effect`.

This is useful for adaptive scheduling where delays depend on external
factors, such as API calls, database queries, or dynamic system conditions.

**See**

- `delayed` If you need to compute the delay using a pure function.

**Signature**

```ts
declare const delayedEffect: { <R2>(f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L786)

Since v2.0.0
Schedule-delayedSchedule.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.delayedSchedule

Uses the delays produced by a schedule to further delay its intervals.

**Details**

This function modifies a schedule by using its own output delays to control
its execution timing. Instead of executing immediately at each interval, the
schedule will be delayed by the duration it produces.

**Signature**

```ts
declare const delayedSchedule: <In, R>(schedule: Schedule<Duration.Duration, In, R>) => Schedule<Duration.Duration, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L808)

Since v2.0.0
Schedule-delays.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.delays

Transforms a schedule to output the delay between each occurrence.

**Details**

This function modifies an existing schedule so that instead of producing its
original output, it now returns the delay between each scheduled execution.

**Signature**

```ts
declare const delays: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration.Duration, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L823)

Since v2.0.0
Schedule-driver.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.driver

Creates a driver to manually control the execution of a schedule.

**Details**

This function returns a `ScheduleDriver`, which allows stepping through a
schedule manually while handling delays and sleeping appropriately. A driver
is useful when you need fine-grained control over how a schedule progresses,
rather than relying on automatic execution.

The returned driver exposes methods for retrieving the current state,
executing the next step, and resetting the schedule when needed.

**Signature**

```ts
declare const driver: <Out, In, R>(self: Schedule<Out, In, R>) => Effect.Effect<ScheduleDriver<Out, In, R>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L899)

Since v2.0.0
Schedule-duration.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.duration

Alias of `fromDelay`.

**Signature**

```ts
declare const duration: (duration: Duration.DurationInput) => Schedule<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L910)

Since v2.0.0
Schedule-either.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.either

Alias of `union`.

**Signature**

```ts
declare const either: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L919)

Since v2.0.0
Schedule-eitherWith.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.eitherWith

Alias of `unionWith`.

**Signature**

```ts
declare const eitherWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L936)

Since v2.0.0
Schedule-elapsed.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.elapsed

Creates a schedule that tracks the total elapsed duration since it started.

**Details**

This schedule executes continuously and returns the total time that has
passed since the first execution. The duration keeps increasing with each
step, providing a way to measure elapsed time.

This is useful for tracking execution time, monitoring delays, or
implementing logic based on how long a process has been running.

**Signature**

```ts
declare const elapsed: Schedule<Duration.Duration, unknown, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L963)

Since v2.0.0
Schedule-ensuring.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.ensuring

Attaches a finalizer to a schedule that runs when the schedule completes.

**Details**

This function returns a new schedule that executes a given finalizer when the
schedule reaches completion. Unlike `Effect.ensuring`, this method does not
guarantee the finalizer will run in all cases. If the schedule never
initializes or is not driven to completion, the finalizer may not execute.
However, if the schedule decides not to continue, the finalizer will be
invoked.

This is useful for cleaning up resources, logging, or executing other side
effects when a schedule completes.

**Signature**

```ts
declare const ensuring: { <X>(finalizer: Effect.Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect.Effect<X, never, never>): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L983)

Since v2.0.0
Schedule-exponential.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.exponential

Creates a schedule that recurs indefinitely with exponentially increasing
delays.

**Details**

This schedule starts with an initial delay of `base` and increases the delay
exponentially on each repetition using the formula `base * factor^n`, where
`n` is the number of times the schedule has executed so far. If no `factor`
is provided, it defaults to `2`, causing the delay to double after each
execution.

**Signature**

```ts
declare const exponential: (base: Duration.DurationInput, factor?: number) => Schedule<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1003)

Since v2.0.0
Schedule-fibonacci.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.fibonacci

Creates a schedule that recurs indefinitely with Fibonacci-based increasing
delays.

**Details**

This schedule starts with an initial delay of `one` and increases subsequent
delays by summing the two previous delays, following the Fibonacci sequence.
The delay pattern follows: `one, one, one + one, (one + one) + one, ...`,
resulting in `1s, 1s, 2s, 3s, 5s, 8s, 13s, ...` if `one = 1s`.

This is useful for progressive backoff strategies, where delays grow
naturally over time without increasing as aggressively as an exponential
schedule.

**Signature**

```ts
declare const fibonacci: (one: Duration.DurationInput) => Schedule<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1026)

Since v2.0.0
Schedule-fixed.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.fixed

Creates a schedule that recurs at a fixed interval.

**Details**

This schedule executes at regular, evenly spaced intervals, returning the
number of times it has run so far. If the action being executed takes longer
than the interval, the next execution will happen immediately to prevent
"pile-ups," ensuring that the schedule remains consistent without overlapping
executions.

```text
|-----interval-----|-----interval-----|-----interval-----|
|---------action--------||action|-----|action|-----------|
```

**See**

- `spaced` If you need to run from the end of the last execution.

**Signature**

```ts
declare const fixed: (interval: Duration.DurationInput) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1049)

Since v2.0.0
Schedule-forever.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.forever

Creates a schedule that recurs indefinitely, producing a count of
repetitions.

**Details**

This schedule runs indefinitely, returning an increasing count of executions
(`0, 1, 2, 3, ...`). Each step increments the count by one, allowing tracking
of how many times it has executed.

**Signature**

```ts
declare const forever: Schedule<number, unknown, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1064)

Since v2.0.0
Schedule-fromDelay.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.fromDelay

Creates a schedule that recurs once after a specified duration.

**Details**

This schedule executes a single time after waiting for the given duration.
Once it has executed, it does not repeat.

**See**

- `fromDelays` If you need to create a schedule with multiple delays.

**Signature**

```ts
declare const fromDelay: (delay: Duration.DurationInput) => Schedule<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1079)

Since v2.0.0
Schedule-fromDelays.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.fromDelays

Creates a schedule that recurs once for each specified duration, applying the
given delays sequentially.

**Details**

This schedule executes multiple times, each time waiting for the
corresponding duration from the provided list of delays. The first execution
waits for `delay`, the next for the second value in `delays`, and so on. Once
all delays have been used, the schedule stops executing.

This is useful for defining a custom delay sequence that does not follow a
fixed pattern like exponential or Fibonacci backoff.

**Signature**

```ts
declare const fromDelays: (delay: Duration.DurationInput, ...delays: Array<Duration.DurationInput>) => Schedule<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1098)

Since v2.0.0
Schedule-Schedule.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.Schedule

A `Schedule<Out, In, R>` defines a recurring schedule, which consumes values
of type `In`, and which returns values of type `Out`.

The `Schedule` type is structured as follows:

```ts
//         The type of output produced by the schedule
//            The type of input consumed by the schedule
//                 Additional requirements for the schedule
//                
Schedule<Out, In, Requirements>
```

A schedule operates by consuming values of type `In` (such as errors in the
case of `Effect.retry`, or values in the case of `Effect.repeat`) and
producing values of type `Out`. It determines when to halt or continue the
execution based on input values and its internal state.

The inclusion of a `Requirements` parameter allows the schedule to leverage
additional services or resources as needed.

Schedules are defined as a possibly infinite set of intervals spread out over
time. Each interval defines a window in which recurrence is possible.

When schedules are used to repeat or retry effects, the starting boundary of
each interval produced by a schedule is used as the moment when the effect
will be executed again.

Schedules can be composed in different ways:

- Union: Combines two schedules and recurs if either schedule wants to
  continue, using the shorter delay.
- Intersection: Combines two schedules and recurs only if both schedules want
  to continue, using the longer delay.
- Sequencing: Combines two schedules by running the first one fully, then
  switching to the second.

In addition, schedule inputs and outputs can be transformed, filtered (to
terminate a schedule early in response to some input or output), and so
forth.

A variety of other operators exist for transforming and combining schedules,
and the companion object for `Schedule` contains all common types of
schedules, both for performing retrying, as well as performing repetition.

**Signature**

```ts
export interface Schedule<out Out, in In = unknown, out R = never> extends Schedule.Variance<Out, In, R>, Pipeable {
  /**
   * Initial State
   */
  readonly initial: any
  /**
   * Schedule Step
   */
  step(
    now: number,
    input: In,
    state: any
  ): Effect.Effect<readonly [any, Out, ScheduleDecision.ScheduleDecision], never, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L95)

Since v2.0.0
Schedule-fromFunction.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.fromFunction

Creates a schedule that always recurs, transforming input values using the
specified function.

**Details**

This schedule continuously executes and applies the given function `f` to
each input value, producing a transformed output. The schedule itself does
not control delays or stopping conditions; it simply transforms the input
values as they are processed.

This is useful when defining schedules that map inputs to outputs, allowing
dynamic transformations of incoming data.

**Signature**

```ts
declare const fromFunction: <A, B>(f: (a: A) => B) => Schedule<B, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1120)

Since v2.0.0
Schedule-hourOfDay.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.hourOfDay

Creates a schedule that recurs at a specific hour of each day.

**Details**

This schedule triggers once per day at the specified `hour`, starting at zero
minutes of that hour. The schedule produces a count of executions (`0, 1, 2,
...`), indicating how many times it has been triggered.

The `hour` parameter must be between `0` (midnight) and `23` (11 PM). It is
validated lazily, meaning an invalid value will cause errors only when the
schedule is executed.

This is useful for scheduling daily recurring tasks at a fixed time, such as
running batch jobs or refreshing data.

**Signature**

```ts
declare const hourOfDay: (hour: number) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L698)

Since v2.0.0
Schedule-identity.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.identity

Creates a schedule that always recurs, passing inputs directly as outputs.

**Details**

This schedule runs indefinitely, returning each input value as its output
without modification. It effectively acts as a pass-through that simply
echoes its input values at each step.

**Signature**

```ts
declare const identity: <A>() => Schedule<A, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1134)

Since v2.0.0
Schedule-intersect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.intersect

Combines two schedules, continuing only if both schedules want to continue,
using the longer delay.

**Details**

This function takes two schedules and creates a new schedule that only
continues execution if both schedules allow it. The interval between
recurrences is determined by the longer delay between the two schedules.

The output of the resulting schedule is a tuple containing the outputs of
both schedules. The input type is the intersection of both schedules' input
types.

This is useful when coordinating multiple scheduling conditions where
execution should proceed only when both schedules permit it.

**See**

- `intersectWith` If you need to use a custom merge function.

**Signature**

```ts
declare const intersect: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1171)

Since v2.0.0
Schedule-intersectWith.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.intersectWith

Combines two schedules, continuing only if both want to continue, merging
intervals using a custom function.

**Details**

This function takes two schedules and creates a new schedule that only
continues execution if both schedules allow it. Instead of automatically
using the longer delay (like `intersect`), this function applies a
user-provided merge function `f` to determine the next interval between
executions.

The output of the resulting schedule is a tuple containing the outputs of
both schedules, and the input type is the intersection of both schedules'
input types.

**Signature**

```ts
declare const intersectWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1200)

Since v2.0.0
Schedule-isSchedule.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.isSchedule

Checks whether a given value is a `Schedule`.

**Signature**

```ts
declare const isSchedule: (u: unknown) => u is Schedule<unknown, never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L183)

Since v2.0.0
Schedule-jittered.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.jittered

Returns a new schedule that randomly adjusts the interval size within a
range.

**Details**

This function modifies a schedule so that its delay between executions is
randomly varied within a range. By default, the delay is adjusted between
`80%` (`0.8 * interval`) and `120%` (`1.2 * interval`) of the original
interval size.

This is useful for adding randomness to repeated executions, reducing
contention in distributed systems, and avoiding synchronized execution
patterns that can cause bottlenecks.

**See**

- `jitteredWith` If you need to specify custom min/max values.

**Signature**

```ts
declare const jittered: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1232)

Since v2.0.0
Schedule-jitteredWith.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.jitteredWith

Returns a new schedule that randomly adjusts the interval size within a
user-defined range.

**Details**

This function modifies a schedule so that its delay between executions is
randomly varied within a specified range. Instead of using the default `0.8 -
1.2` range like `jittered`, this function allows customizing the `min`
and `max` multipliers.

The delay for each step will be adjusted within `min * original_interval` and
`max * original_interval`. If `min` and `max` are not provided, the defaults
are `0.8` and `1.2`, respectively.

This is useful for introducing randomness into scheduling behavior while
having precise control over the jitter range.

**Signature**

```ts
declare const jitteredWith: { (options: { min?: number | undefined; max?: number | undefined; }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, options: { min?: number | undefined; max?: number | undefined; }): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1255)

Since v2.0.0
Schedule-linear.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.linear

Creates a schedule that recurs indefinitely, increasing the delay linearly.

**Details**

This schedule starts with an initial delay of `base` and increases the delay
on each recurrence in a linear fashion, following the formula:

`delay = base * n`

where `n` is the number of times the schedule has executed so far. This
results in increasing intervals between executions.

This is useful for implementing linear backoff strategies where the wait time
between retries increases at a steady rate.

**Signature**

```ts
declare const linear: (base: Duration.DurationInput) => Schedule<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1284)

Since v2.0.0
Schedule-makeWithState.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.makeWithState

Creates a new schedule with a custom state and step function.

**Details**

This function constructs a `Schedule` by defining its initial state and a
step function, which determines how the schedule progresses over time. The
step function is called on each iteration with the current time, an input
value, and the schedule's current state. It returns the next state, an output
value, and a decision on whether the schedule should continue or stop.

This function is useful for creating custom scheduling logic that goes beyond
predefined schedules like fixed intervals or exponential backoff. It allows
full control over how the schedule behaves at each step.

**Signature**

```ts
declare const makeWithState: <S, In, Out, R = never>(initial: S, step: (now: number, input: In, state: S) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>) => Schedule<Out, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L168)

Since v2.0.0
Schedule-map.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.map

Returns a new schedule that transforms its output using the specified
function.

**Details**

This function modifies an existing schedule so that its outputs are
transformed by the provided function `f`. The timing and recurrence behavior
of the schedule remain unchanged, but the values it produces are mapped to
new values.

This is useful when composing schedules where you need to adjust the output
format or apply additional processing.

**See**

- `mapEffect` If you need to use an effectful transformation
function.

**Signature**

```ts
declare const map: { <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1306)

Since v2.0.0
Schedule-mapBoth.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.mapBoth

Transforms both the input and output of a schedule.

**Details**

This function modifies an existing schedule by applying a transformation to
both its input values and its output values. The provided transformation
functions `onInput` and `onOutput` allow you to map the schedule to work with
a different input type while modifying its outputs as well.

**See**

- `mapBothEffect` If you need to use effectful transformation functions.

**Signature**

```ts
declare const mapBoth: { <In2, In, Out, Out2>(options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>; <Out, In, R, In2, Out2>(self: Schedule<Out, In, R>, options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): Schedule<Out2, In2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L840)

Since v2.0.0
Schedule-mapBothEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.mapBothEffect

Transforms both the input and output of a schedule using effectful
computations.

**Details**

This function modifies an existing schedule by applying effectful
transformations to both its input values and its output values. The provided
effectful functions `onInput` and `onOutput` allow you to transform inputs
and outputs using computations that may involve additional logic, resource
access, or side effects.

**See**

- `mapBoth` If you need to use pure transformation functions.

**Signature**

```ts
declare const mapBothEffect: { <In2, In, R2, Out, R3, Out2>(options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>; <Out, In, R, In2, R2, Out2, R3>(self: Schedule<Out, In, R>, options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): Schedule<Out2, In2, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L867)

Since v2.0.0
Schedule-mapEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.mapEffect

Returns a new schedule that applies an effectful transformation to its
output.

**Details**

This function modifies an existing schedule by applying an effectful function
`f` to its output values. The timing and recurrence behavior of the schedule
remain unchanged, but each output is mapped to a new value within an
`Effect`.

This is useful when you need to perform side effects or asynchronous
transformations before passing the output forward.

**See**

- `map` If you need to use a pure transformation function.

**Signature**

```ts
declare const mapEffect: { <Out, Out2, R2>(f: (out: Out) => Effect.Effect<Out2, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Out2, never, R2>): Schedule<Out2, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1330)

Since v2.0.0
Schedule-mapInput.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.mapInput

Transforms the input type of a schedule.

**Details**

This function modifies a given schedule by applying a transformation function
to its inputs. Instead of directly receiving values of type `In`, the
schedule will now accept values of type `In2`, which are converted to `In`
using the provided mapping function `f`.

This is useful when you have a schedule that expects a specific input type
but you need to adapt it to work with a different type.

**See**

- `mapInputEffect` If you need to use an effectful transformation function.

**Signature**

```ts
declare const mapInput: { <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>; <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L553)

Since v2.0.0
Schedule-mapInputContext.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.mapInputContext

Transforms the required context of a schedule.

**Details**

This function modifies a schedule by mapping its required context (`R`) into
a new context (`R0`) using the provided function `f`.

This is useful when you need to adapt a schedule to work with a different
dependency environment without changing its core logic.

**Signature**

```ts
declare const mapInputContext: { <R0, R>(f: (env0: Context.Context<R0>) => Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>; <Out, In, R, R0>(self: Schedule<Out, In, R>, f: (env0: Context.Context<R0>) => Context.Context<R>): Schedule<Out, In, R0>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L600)

Since v2.0.0
Schedule-mapInputEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.mapInputEffect

Transforms the input type of a schedule using an effectful function.

**Details**

This function modifies a schedule by applying an effectful transformation to
its inputs. Instead of directly receiving values of type `In`, the schedule
will now accept values of type `In2`, which are converted to `In` via an
effectful function `f`.

This is useful when the input transformation involves external dependencies,
such as API calls, database lookups, or other asynchronous computations.

**See**

- `mapInput` If you need to use a pure transformation function.

**Signature**

```ts
declare const mapInputEffect: { <In2, In, R2>(f: (in2: In2) => Effect.Effect<In, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>; <Out, In, R, In2, R2>(self: Schedule<Out, In, R>, f: (in2: In2) => Effect.Effect<In, never, R2>): Schedule<Out, In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L576)

Since v2.0.0
Schedule-minuteOfHour.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.minuteOfHour

Creates a schedule that recurs every specified minute of each hour.

**Details**

This schedule triggers once per hour at the specified `minute`, starting
exactly at `minute:00` (zero seconds). The schedule produces a count of
executions (`0, 1, 2, ...`), representing how many times it has run.

The `minute` parameter must be between `0` and `59`. It is validated lazily,
meaning an invalid value will cause errors only when the schedule is
executed.

**Signature**

```ts
declare const minuteOfHour: (minute: number) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L677)

Since v2.0.0
Schedule-modifyDelay.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.modifyDelay

Returns a new schedule that modifies the delay between executions using a
custom function.

**Details**

This function transforms an existing schedule by applying `f` to modify the
delay before each execution. The function receives both the schedule's output
(`out`) and the originally computed delay (`duration`), and returns a new
adjusted delay.

**See**

- `modifyDelayEffect` If you need to use an effectful function.

**Signature**

```ts
declare const modifyDelay: { <Out>(f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1356)

Since v2.0.0
Schedule-modifyDelayEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.modifyDelayEffect

Returns a new schedule that modifies the delay before execution using an
effectful function.

**Details**

This function takes an existing schedule and applies an effectful function
`f` to dynamically adjust the delay before each execution. The function
receives both the schedule's output (`out`) and the originally computed delay
(`duration`), returning a new adjusted delay wrapped in an `Effect`.

**See**

- `modifyDelay` If you need to use a pure function.

**Signature**

```ts
declare const modifyDelayEffect: { <Out, R2>(f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1382)

Since v2.0.0
Schedule-onDecision.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.onDecision

Returns a new schedule that executes an effect every time the schedule makes
a decision.

**Details**

This function enhances an existing schedule by running an effectful function
`f` whenever a scheduling decision is made. The function receives the current
schedule output (`out`) and the decision (`ScheduleDecision`), allowing
additional logic to be executed, such as logging, monitoring, or side
effects.

**Signature**

```ts
declare const onDecision: { <Out, X, R2>(f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1406)

Since v2.0.0
Schedule-once.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.once

A schedule that executes only once and then stops.

**Details**

This schedule triggers a single execution and then terminates. It does not
repeat or apply any additional logic.

**Signature**

```ts
declare const once: Schedule<void, unknown, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1427)

Since v2.0.0
Schedule-passthrough.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.passthrough

Transforms a schedule to pass through its inputs as outputs.

**Details**

This function modifies an existing schedule so that it returns its input
values instead of its original output values. The schedule's timing remains
unchanged, but its outputs are replaced with whatever inputs it receives.

**Signature**

```ts
declare const passthrough: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1147)

Since v2.0.0
Schedule-provideContext.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.provideContext

Returns a new schedule with a provided context, eliminating the need for
external dependencies.

**Details**

This function supplies a required `context` to a schedule, allowing it to run
without requiring external dependencies. After calling this function, the
schedule can be used freely without needing to pass a context at execution
time.

This is useful when working with schedules that rely on contextual
information, such as logging services, database connections, or configuration
settings.

**Signature**

```ts
declare const provideContext: { <R>(context: Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>; <Out, In, R>(self: Schedule<Out, In, R>, context: Context.Context<R>): Schedule<Out, In, never>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1447)

Since v2.0.0
Schedule-provideService.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.provideService

Returns a new schedule with a single required service provided, eliminating
the need for external dependencies.

**Details**

This function supplies a single service dependency to a schedule, allowing it
to run without requiring that service externally. If a schedule depends on
multiple services, consider using `provideContext` instead.

This is useful when working with schedules that require a specific service,
such as logging, metrics, or configuration retrieval.

**Signature**

```ts
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>; <Out, In, R, I, S>(self: Schedule<Out, In, R>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Schedule<Out, In, Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1468)

Since v2.0.0
Schedule-recurUntil.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.recurUntil

A schedule that recurs until the given predicate evaluates to true.

**Details**

This schedule will continue executing as long as the provided predicate `f`
returns `false` for the input value. Once `f` evaluates to `true`, the
schedule stops recurring.

This is useful for defining schedules that should stop when a certain
condition is met, such as detecting a success state, reaching a threshold, or
avoiding unnecessary retries.

**See**

- `recurUntilEffect` If you need to use an effectful predicate.

**Signature**

```ts
declare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1498)

Since v2.0.0
Schedule-recurUntilEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.recurUntilEffect

A schedule that recurs until the given effectful predicate evaluates to true.

**Details**

This schedule continues executing as long as the provided effectful predicate
`f` returns `false`. Once `f` evaluates to `true`, the schedule stops
recurring. Unlike `recurUntil`, this function allows the stopping
condition to be computed asynchronously or based on external dependencies.

This is useful when the stopping condition depends on an effectful
computation, such as checking a database, making an API call, or retrieving
system state dynamically.

**See**

- `recurUntil` If you need to use a pure predicate.

**Signature**

```ts
declare const recurUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1519)

Since v2.0.0
Schedule-recurUntilOption.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.recurUntilOption

A schedule that recurs until the input value matches a partial function, then
maps the value.

**Details**

This schedule continues executing until the provided partial function `pf`
returns `Some(value)`. At that point, it stops and maps the resulting value
to an `Option<B>`. If `pf` returns `None`, the schedule continues.

This is useful when defining schedules that should stop once a certain
condition is met and transform the final value before completion.

**Signature**

```ts
declare const recurUntilOption: <A, B>(pf: (a: A) => Option.Option<B>) => Schedule<Option.Option<B>, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1538)

Since v2.0.0
Schedule-recurUpTo.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.recurUpTo

A schedule that recurs until the specified duration has elapsed.

**Details**

This schedule continues executing for the given `duration`, after which it
stops. The schedule outputs the elapsed time on each recurrence.

This is useful for limiting the duration of retries, enforcing time-based
constraints, or ensuring that an operation does not run indefinitely.

**Signature**

```ts
declare const recurUpTo: (duration: Duration.DurationInput) => Schedule<Duration.Duration>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1555)

Since v2.0.0
Schedule-recurWhile.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.recurWhile

A schedule that recurs as long as the given predicate evaluates to true.

**Details*

This schedule continues executing as long as the provided predicate `f`
returns `true` for the input value. Once `f` evaluates to `false`, the
schedule stops recurring.

**See**

- `recurWhileEffect` If you need to use an effectful predicate.

**Signature**

```ts
declare const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1571)

Since v2.0.0
Schedule-recurWhileEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.recurWhileEffect

A schedule that recurs as long as the given effectful predicate evaluates to
true.

**Details**

This schedule continues executing as long as the provided effectful predicate
`f` returns `true`. Once `f` evaluates to `false`, the schedule stops
recurring. Unlike `recurWhile`, this function allows the condition to
be computed dynamically using an effectful computation.

**See**

- `recurWhile` If you need to use a pure predicate.

**Signature**

```ts
declare const recurWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1589)

Since v2.0.0
Schedule-recurs.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.recurs

A schedule that recurs a fixed number of times before terminating.

**Details**

This schedule will continue executing until it has been stepped `n` times,
after which it will stop. The output of the schedule is the current count of
recurrences.

**Signature**

```ts
declare const recurs: (n: number) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1604)

Since v2.0.0
Schedule-reduce.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.reduce

Returns a new schedule that folds over the outputs of this one.

**Details**

This schedule transforms the output by accumulating values over time using a
reducer function `f`. It starts with an initial value `zero` and updates it
each time the schedule produces an output.

This is useful for tracking statistics, aggregating results, or summarizing
data across multiple executions.

**See**

- `reduceEffect` If you need to use an effectful reducer function.

**Signature**

```ts
declare const reduce: { <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>; <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1623)

Since v2.0.0
Schedule-reduceEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.reduceEffect

Returns a new schedule that effectfully folds over the outputs of this one.

**Details**

This schedule accumulates outputs over time using an effectful reducer
function `f`. It starts with an initial value `zero` and updates it
asynchronously or based on external dependencies.

This is useful for asynchronous state tracking, logging, external metrics
aggregation, or any scenario where accumulation needs to involve an effectful
computation.

**See**

- `reduce` If you need to use a pure reducer function.

**Signature**

```ts
declare const reduceEffect: { <Z, Out, R2>(zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>; <Out, In, R, Z, R2>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): Schedule<Z, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1646)

Since v2.0.0
Schedule-repeatForever.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.repeatForever

Alias of `forever`.

**Signature**

```ts
declare const repeatForever: Schedule<number, unknown, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1665)

Since v2.0.0
Schedule-repetitions.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.repetitions

Returns a new schedule that outputs the number of repetitions of this one.

**Details**

This schedule tracks how many times the given schedule has executed and
outputs the count instead of the original values. The first execution starts
at `0`, and the count increases with each recurrence.

**Signature**

```ts
declare const repetitions: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1679)

Since v2.0.0
Schedule-resetAfter.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.resetAfter

Returns a new schedule that automatically resets to its initial state after a
period of inactivity defined by `duration`.

**Details**

This function modifies a schedule so that if no inputs are received for the
specified `duration`, the schedule resets as if it were new.

**See**

- `resetWhen` If you need to reset based on output values.

**Signature**

```ts
declare const resetAfter: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1695)

Since v2.0.0
Schedule-resetWhen.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.resetWhen

Resets the schedule when the specified predicate on the schedule output
evaluates to `true`.

**Details**

This function modifies a schedule so that it resets to its initial state
whenever the provided predicate `f` returns `true` for an output value.

**See**

- `resetAfter` If you need to reset based on inactivity.

**Signature**

```ts
declare const resetWhen: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1714)

Since v2.0.0
Schedule-run.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.run

Runs a schedule using the provided inputs and collects all outputs.

**Details**

This function executes a given schedule with a sequence of input values and
accumulates all outputs into a `Chunk`. The schedule starts execution at the
specified `now` timestamp and proceeds according to its defined behavior.

This is useful for batch processing, simulating execution, or testing
schedules with predefined input sequences.

**Signature**

```ts
declare const run: { <In>(now: number, input: Iterable<In>): <Out, R>(self: Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>; <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect.Effect<Chunk.Chunk<Out>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1734)

Since v2.0.0
Schedule-secondOfMinute.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.secondOfMinute

Cron-like schedule that recurs at a specific second of each minute.

**Details**

This schedule triggers at the specified `second` of each minute,
starting at zero nanoseconds. It produces a count of executions
(0, 1, 2, ...). The `second` parameter is validated lazily, meaning
invalid values will only be caught at runtime.

**Signature**

```ts
declare const secondOfMinute: (second: number) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L659)

Since v2.0.0
Schedule-spaced.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.spaced

Returns a schedule that recurs continuously, with each repetition
spaced by the specified `duration` from the last run.

**Details**

This schedule ensures that executions occur at a fixed interval,
maintaining a consistent delay between repetitions. The delay starts
from the end of the last execution, not from the schedule start time.

**See**

- `fixed` If you need to run at a fixed interval from the start.

**Signature**

```ts
declare const spaced: (duration: Duration.DurationInput) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1757)

Since v2.0.0
Schedule-stop.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.stop

A schedule that does not recur and stops immediately.

**Signature**

```ts
declare const stop: Schedule<void, unknown, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1765)

Since v2.0.0
Schedule-succeed.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.succeed

Returns a schedule that recurs indefinitely, always producing the specified
constant value.

**Signature**

```ts
declare const succeed: <A>(value: A) => Schedule<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1774)

Since v2.0.0
Schedule-sync.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.sync

Returns a schedule that recurs indefinitely, evaluating the given function to
produce a constant value.

**Signature**

```ts
declare const sync: <A>(evaluate: LazyArg<A>) => Schedule<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1783)

Since v2.0.0
Schedule-tapInput.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.tapInput

Returns a new schedule that runs the given effectful function for each input
before continuing execution.

**Details**

This function allows side effects to be performed on each input processed by
the schedule. It does not modify the schedules behavior but ensures that the
provided function `f` runs before each step.

**Signature**

```ts
declare const tapInput: { <In2, X, R2>(f: (input: In2) => Effect.Effect<X, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, In2, X, R2>(self: Schedule<Out, In, R>, f: (input: In2) => Effect.Effect<X, never, R2>): Schedule<Out, In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1798)

Since v2.0.0
Schedule-tapOutput.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.tapOutput

Returns a new schedule that runs the given effectful function for each output
before continuing execution.

**Details**

This function allows side effects to be performed on each output produced by
the schedule. It does not modify the schedules behavior but ensures that the
provided function `f` runs after each step.

**Signature**

```ts
declare const tapOutput: { <X, R2, Out>(f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1821)

Since v2.0.0
Schedule-unfold.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.unfold

Creates a schedule that repeatedly applies a function to transform a state
value, producing a sequence of values.

**Details**

This function starts with an `initial` value and applies `f` recursively to
generate the next state at each step. The schedule continues indefinitely,
producing a stream of values by unfolding the state over time.

**Signature**

```ts
declare const unfold: <A>(initial: A, f: (a: A) => A) => Schedule<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1844)

Since v2.0.0
Schedule-union.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.union

Combines two schedules, continuing execution as long as at least one of them
allows it, using the shorter delay.

**Details**

This function combines two schedules into a single schedule that executes in
parallel. If either schedule allows continuation, the merged schedule
continues. When both schedules produce delays, the schedule selects the
shorter delay to determine the next step.

The output of the new schedule is a tuple containing the outputs of both
schedules. The input type is the intersection of both schedules' input types.

This is useful for scenarios where multiple scheduling conditions should be
considered, ensuring execution proceeds if at least one schedule permits it.

**See**

- `unionWith` If you need to use a custom merge function.

**Signature**

```ts
declare const union: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1868)

Since v2.0.0
Schedule-unionWith.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.unionWith

Combines two schedules, continuing execution as long as at least one of them
wants to continue, merging their intervals using a custom merge function.

**Details**

This function allows you to combine two schedules while defining how their
intervals should be merged. Unlike `union`, which simply selects the
shorter delay, this function lets you specify a custom merging strategy for
the schedules intervals.

The merged schedule continues execution as long as at least one of the input
schedules allows it. The next interval is determined by applying the provided
merge function to the intervals of both schedules.

The output of the resulting schedule is a tuple containing the outputs of
both schedules. The input type is the intersection of both schedules' input
types.

**See**

- `union` If you need to use the shorter delay.

**Signature**

```ts
declare const unionWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1902)

Since v2.0.0
Schedule-untilInput.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.untilInput

Returns a new schedule that stops execution when the given predicate on the
input evaluates to `true`.

**Details**

This function modifies an existing schedule so that it continues executing
only while the provided predicate returns `false` for incoming inputs. Once
an input satisfies the condition, the schedule terminates immediately.

**See**

- `untilInputEffect` If you need to use an effectful predicate.

**Signature**

```ts
declare const untilInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1929)

Since v2.0.0
Schedule-untilInputEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.untilInputEffect

Returns a new schedule that stops execution when the given effectful
predicate on the input evaluates to `true`.

**Details**

This function modifies an existing schedule so that it continues executing
only while the provided effectful predicate returns `false` for incoming
inputs. The predicate is an `Effect`, meaning it can involve asynchronous
computations or dependency-based logic.

**See**

- `untilInput` If you need to use a pure predicate.

**Signature**

```ts
declare const untilInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1950)

Since v2.0.0
Schedule-untilOutput.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.untilOutput

Returns a new schedule that stops execution when the given predicate on the
output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
executing while the given predicate returns false for its output values. Once
the predicate evaluates to `true`, execution stops.

The output of the resulting schedule remains the same, but its duration is
now constrained by a stopping condition based on its own output.

**See**

- `untilOutputEffect` If you need to use an effectful predicate.

**Signature**

```ts
declare const untilOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1978)

Since v2.0.0
Schedule-untilOutputEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.untilOutputEffect

Returns a new schedule that stops execution when the given effectful
predicate on the output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
executing while the provided effectful predicate returns `false` for its
output values. Once the predicate returns `true`, execution stops.

**See**

- `untilOutput` If you need to use a pure predicate.

**Signature**

```ts
declare const untilOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1998)

Since v2.0.0
Schedule-upTo.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.upTo

Returns a new schedule that limits execution to a fixed duration.

**Details**

This function modifies an existing schedule to stop execution after a
specified duration has passed. The schedule continues as normal until the
duration is reached, at which point it stops automatically.

**Signature**

```ts
declare const upTo: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2020)

Since v2.0.0
Schedule-whileInput.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.whileInput

Returns a new schedule that continues execution as long as the given
predicate on the input is true.

**Details**

This function modifies an existing schedule so that it only continues
execution while a specified predicate holds true for its input. If the
predicate evaluates to `false` at any step, the schedule stops.

**See**

- `whileInputEffect` If you need to use an effectful predicate.

**Signature**

```ts
declare const whileInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2040)

Since v2.0.0
Schedule-whileInputEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.whileInputEffect

Returns a new schedule that continues execution for as long as the given
effectful predicate on the input evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
execution while an effectful predicate holds true for its input. If the
predicate evaluates to `false` at any step, the schedule stops.

**See**

- `whileInput` If you need to use a pure predicate.

**Signature**

```ts
declare const whileInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2060)

Since v2.0.0
Schedule-whileOutput.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.whileOutput

Returns a new schedule that continues execution for as long as the given
predicate on the output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
execution while a provided condition holds true for its output. If the
predicate returns `false`, the schedule stops.

**See**

- `whileOutputEffect` If you need to use an effectful predicate.

**Signature**

```ts
declare const whileOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2085)

Since v2.0.0
Schedule-whileOutputEffect.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.whileOutputEffect

Returns a new schedule that continues execution for as long as the given
effectful predicate on the output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
execution while an effectful condition holds true for its output. If the
effectful predicate returns `false`, the schedule stops.

**See**

- `whileOutput` If you need to use a pure predicate.

**Signature**

```ts
declare const whileOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2105)

Since v2.0.0
Schedule-windowed.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.windowed

Creates a schedule that divides time into fixed `interval`-long windows,
triggering execution at the start of each new window.

**Details**

This function produces a schedule that waits until the next time window
boundary before executing. Each window spans a fixed duration specified by
`interval`. If an action completes midway through a window, the schedule
waits until the next full window starts before proceeding.

For example, `windowed(Duration.seconds(10))` would produce a schedule as
follows:

```text
     10s        10s        10s       10s
|----------|----------|----------|----------|
|action------|sleep---|act|-sleep|action----|
```

**Signature**

```ts
declare const windowed: (interval: Duration.DurationInput) => Schedule<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2138)

Since v2.0.0
Schedule-zipLeft.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.zipLeft

The same as `intersect` but ignores the right output.

**Signature**

```ts
declare const zipLeft: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out, In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2146)

Since v2.0.0
Schedule-zipRight.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.zipRight

The same as `intersect` but ignores the left output.

**Signature**

```ts
declare const zipRight: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out2, In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2162)

Since v2.0.0
Schedule-zipWith.md
Package: `effect`<br />
Module: `Schedule`<br />

## Schedule.zipWith

Equivalent to `intersect` followed by `map`.

**Signature**

```ts
declare const zipWith: { <Out2, In2, R2, Out, Out3>(that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2, Out3>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): Schedule<Out3, In & In2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2178)

Since v2.0.0
ScheduleInterval-Interval.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.Interval

An `Interval` represents an interval of time. Intervals can encompass all
time, or no time at all.

**Signature**

```ts
export interface Interval {
  readonly [IntervalTypeId]: IntervalTypeId
  readonly startMillis: number
  readonly endMillis: number
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L27)

Since v2.0.0
ScheduleInterval-after.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.after

Construct an `Interval` that includes all time equal to and after the
specified start time.

**Signature**

```ts
declare const after: (startMilliseconds: number) => Interval
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L142)

Since v2.0.0
ScheduleInterval-before.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.before

Construct an `Interval` that includes all time equal to and before the
specified end time.

**Signature**

```ts
declare const before: (endMilliseconds: number) => Interval
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L151)

Since v2.0.0
ScheduleInterval-empty.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.empty

An `Interval` of zero-width.

**Signature**

```ts
declare const empty: Interval
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L49)

Since v2.0.0
ScheduleInterval-intersect.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.intersect

Computes a new `Interval` which is the intersection of this `Interval` and
that `Interval`.

**Signature**

```ts
declare const intersect: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L108)

Since v2.0.0
ScheduleInterval-isEmpty.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.isEmpty

Returns `true` if the specified `Interval` is empty, `false` otherwise.

**Signature**

```ts
declare const isEmpty: (self: Interval) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L91)

Since v2.0.0
ScheduleInterval-isNonEmpty.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.isNonEmpty

Returns `true` if the specified `Interval` is non-empty, `false` otherwise.

**Signature**

```ts
declare const isNonEmpty: (self: Interval) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L99)

Since v2.0.0
ScheduleInterval-lessThan.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.lessThan

Returns `true` if this `Interval` is less than `that` interval, `false`
otherwise.

**Signature**

```ts
declare const lessThan: { (that: Interval): (self: Interval) => boolean; (self: Interval, that: Interval): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L58)

Since v2.0.0
ScheduleInterval-make.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.make

Constructs a new interval from the two specified endpoints. If the start
endpoint greater than the end endpoint, then a zero size interval will be
returned.

**Signature**

```ts
declare const make: (startMillis: number, endMillis: number) => Interval
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L41)

Since v2.0.0
ScheduleInterval-max.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.max

Returns the maximum of two `Interval`s.

**Signature**

```ts
declare const max: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L80)

Since v2.0.0
ScheduleInterval-min.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.min

Returns the minimum of two `Interval`s.

**Signature**

```ts
declare const min: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L69)

Since v2.0.0
ScheduleInterval-size.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.size

Calculates the size of the `Interval` as the `Duration` from the start of the
interval to the end of the interval.

**Signature**

```ts
declare const size: (self: Interval) => Duration.Duration
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L120)

Since v2.0.0
ScheduleInterval-union.md
Package: `effect`<br />
Module: `ScheduleInterval`<br />

## ScheduleInterval.union

Computes a new `Interval` which is the union of this `Interval` and that
`Interval` as a `Some`, otherwise returns `None` if the two intervals cannot
form a union.

**Signature**

```ts
declare const union: { (that: Interval): (self: Interval) => Option.Option<Interval>; (self: Interval, that: Interval): Option.Option<Interval>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L130)

Since v2.0.0
ScheduleIntervals-Intervals.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.Intervals

An `Intervals` represents a list of several `Interval`s.

**Signature**

```ts
export interface Intervals {
  readonly [IntervalsTypeId]: IntervalsTypeId
  readonly intervals: Check.Chunk<Interval.Interval>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L26)

Since v2.0.0
ScheduleIntervals-empty.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.empty

Constructs an empty list of `Interval`s.

**Signature**

```ts
declare const empty: Intervals
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L45)

Since v2.0.0
ScheduleIntervals-end.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.end

The end of the latest interval in the specified `Intervals`.

**Signature**

```ts
declare const end: (self: Intervals) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L91)

Since v2.0.0
ScheduleIntervals-fromIterable.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.fromIterable

Creates `Intervals` from the specified `Iterable<Interval>`.

**Signature**

```ts
declare const fromIterable: (intervals: Iterable<Interval.Interval>) => Intervals
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L53)

Since v2.0.0
ScheduleIntervals-intersect.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.intersect

Produces the intersection of this `Intervals` and that `Intervals`.

**Signature**

```ts
declare const intersect: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L72)

Since v2.0.0
ScheduleIntervals-isNonEmpty.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.isNonEmpty

Returns `true` if this `Intervals` is non-empty, `false` otherwise.

**Signature**

```ts
declare const isNonEmpty: (self: Intervals) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L111)

Since v2.0.0
ScheduleIntervals-lessThan.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.lessThan

Returns `true` if the start of this `Intervals` is before the start of that
`Intervals`, `false` otherwise.

**Signature**

```ts
declare const lessThan: { (that: Intervals): (self: Intervals) => boolean; (self: Intervals, that: Intervals): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L100)

Since v2.0.0
ScheduleIntervals-make.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.make

Creates a new `Intervals` from a `List` of `Interval`s.

**Signature**

```ts
declare const make: (intervals: Check.Chunk<Interval.Interval>) => Intervals
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L37)

Since v2.0.0
ScheduleIntervals-max.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.max

Returns the maximum of the two `Intervals` (i.e. which has the latest start).

**Signature**

```ts
declare const max: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L119)

Since v2.0.0
ScheduleIntervals-start.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.start

The start of the earliest interval in the specified `Intervals`.

**Signature**

```ts
declare const start: (self: Intervals) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L83)

Since v2.0.0
ScheduleIntervals-union.md
Package: `effect`<br />
Module: `ScheduleIntervals`<br />

## ScheduleIntervals.union

Computes the union of this `Intervals` and  that `Intervals`

**Signature**

```ts
declare const union: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L61)

Since v2.0.0
Schema-BigDecimalFromNumber.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.BigDecimalFromNumber

A schema that transforms a `number` into a `BigDecimal`.
When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.

**Signature**

```ts
declare class BigDecimalFromNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7927)

Since v3.10.0
Schema-BigInt.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.BigInt

This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

**Signature**

```ts
declare const BigInt: typeof BigInt$
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5710)

Since v3.10.0
Schema-BigIntFromNumber.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.BigIntFromNumber

This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.

It returns an error if the value can't be safely encoded as a `number` due to being out of range.

**Signature**

```ts
declare class BigIntFromNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5785)

Since v3.10.0
Schema-BooleanFromString.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.BooleanFromString

Converts an `string` value into its corresponding `boolean`
("true" as `true` and "false" as `false`).

**Signature**

```ts
declare class BooleanFromString
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10100)

Since v3.11.0
Schema-BooleanFromUnknown.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.BooleanFromUnknown

Converts an arbitrary value to a `boolean` by testing whether it is truthy.
Uses `!!val` to coerce the value to a `boolean`.

**See**

- https://developer.mozilla.org/docs/Glossary/Truthy

**Signature**

```ts
declare class BooleanFromUnknown
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10083)

Since v3.10.0
Schema-Capitalize.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Capitalize

This schema converts a string to capitalized one.

**Signature**

```ts
declare class Capitalize
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4700)

Since v3.10.0
Schema-Char.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Char

A schema representing a single character.

**Signature**

```ts
declare class Char
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4647)

Since v3.10.0
Schema-annotations.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.annotations

Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

**Signature**

```ts
declare const annotations: { <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>; <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4185)

Since v3.10.0
Schema-asserts.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.asserts

By default the option `exact` is set to `true`.

**Throws**

`ParseError`

**Signature**

```ts
declare const asserts: <A, I, R>(schema: Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L424)

Since v3.10.0
Schema-attachPropertySignature.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.attachPropertySignature

Attaches a property signature with the specified key and value to the schema.
This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
but rather maps to another schema, for example when you want to add a discriminant to a simple union.

**Example**

```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})
```

**Signature**

```ts
declare const attachPropertySignature: { <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): <I, R>(schema: SchemaClass<A, I, R>) => SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(schema: Schema<A, I, R>, key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4082)

Since v3.10.0
Schema-between.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.between

This filter checks whether the provided number falls within the specified minimum and maximum values.

**Signature**

```ts
declare const between: <S extends Schema.Any>(minimum: number, maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5194)

Since v3.10.0
Schema-brand.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.brand

Returns a nominal branded schema by applying a brand to a given schema.

```
Schema<A> + B -> Schema<A & Brand<B>>
```

**Example**

```ts
import * as Schema from "effect/Schema"

const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
```

**Signature**

```ts
declare const brand: <S extends Schema.Any, B extends string | symbol>(brand: B, annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>) => (self: S) => brand<S, B>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3193)

Since v3.10.0
Schema-capitalized.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.capitalized

Verifies that a string is capitalized.

**Signature**

```ts
declare const capitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4587)

Since v3.10.0
Schema-Data.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Data

Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

**Signature**

```ts
declare const Data: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => Data<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8441)

Since v3.10.0
Schema-DataFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DataFromSelf

Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

**Signature**

```ts
declare const DataFromSelf: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => DataFromSelf<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8407)

Since v3.10.0
Schema-Date.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Date

This schema converts a `string` into a `Date` object using the `new Date`
constructor. It ensures that only valid date strings are accepted,
rejecting any strings that would result in an invalid date, such as `new
Date("Invalid Date")`.

**Signature**

```ts
declare const Date: typeof Date$
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6842)

Since v3.10.0
Schema-DateFromNumber.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateFromNumber

Defines a schema that converts a `number` into a `Date` object using the `new
Date` constructor. This schema does not validate the numerical input,
allowing potentially invalid values such as `NaN`, `Infinity`, and
`-Infinity` to be converted into `Date` objects. During the encoding process,
any invalid `Date` object will be encoded to `NaN`.

**Signature**

```ts
declare class DateFromNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6855)

Since v3.10.0
Schema-DateFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateFromSelf

Describes a schema that accommodates potentially invalid `Date` instances,
such as `new Date("Invalid Date")`, without rejection.

**Signature**

```ts
declare class DateFromSelf
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6778)

Since v3.10.0
Schema-DateFromString.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateFromString

Defines a schema that attempts to convert a `string` to a `Date` object using
the `new Date` constructor. This conversion is lenient, meaning it does not
reject strings that do not form valid dates (e.g., using `new Date("Invalid
Date")` results in a `Date` object, despite being invalid).

**Signature**

```ts
declare class DateFromString
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6817)

Since v3.10.0
Schema-DateTimeUtc.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateTimeUtc

Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

**Signature**

```ts
declare class DateTimeUtc
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6927)

Since v3.10.0
Schema-DateTimeUtcFromDate.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateTimeUtcFromDate

Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

**Signature**

```ts
declare class DateTimeUtcFromDate
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6911)

Since v3.12.0
Schema-DateTimeUtcFromNumber.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateTimeUtcFromNumber

Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

**Signature**

```ts
declare class DateTimeUtcFromNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6895)

Since v3.10.0
Schema-DateTimeUtcFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateTimeUtcFromSelf

Describes a schema that represents a `DateTime.Utc` instance.

**Signature**

```ts
declare class DateTimeUtcFromSelf
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6871)

Since v3.10.0
Schema-DateTimeZoned.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateTimeZoned

Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.

**Signature**

```ts
declare class DateTimeZoned
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7075)

Since v3.10.0
Schema-DateTimeZonedFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DateTimeZonedFromSelf

Describes a schema that represents a `DateTime.Zoned` instance.

**Signature**

```ts
declare class DateTimeZonedFromSelf
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7050)

Since v3.10.0
Schema-Defect.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Defect

Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.
It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),
or converts other values to their string representations.

When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,
or other values into their string forms.

This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.

**Signature**

```ts
declare class Defect
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9500)

Since v3.10.0
Schema-Duration.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Duration

A schema that converts a JSON-compatible tagged union into a `Duration`.

**Signature**

```ts
declare class Duration
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6004)

Since v3.10.0
Schema-DurationFromMillis.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DurationFromMillis

A schema that transforms a (possibly Infinite) non negative number into a
`Duration`. Treats the value as the number of milliseconds.

**Signature**

```ts
declare class DurationFromMillis
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5939)

Since v3.10.0
Schema-DurationFromNanos.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.DurationFromNanos

A schema that transforms a non negative `bigint` into a `Duration`. Treats
the value as the number of nanoseconds.

**Signature**

```ts
declare class DurationFromNanos
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5910)

Since v3.10.0
Schema-JsonNumber.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.JsonNumber

The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
format.

**Example**

```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

const is = Schema.is(S.JsonNumber)

assert.deepStrictEqual(is(42), true)
assert.deepStrictEqual(is(Number.NaN), false)
assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
```

**Signature**

```ts
declare class JsonNumber
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5423)

Since v3.10.0
Schema-Lowercase.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Lowercase

This schema converts a string to lowercase.

**Signature**

```ts
declare class Lowercase
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4668)

Since v3.10.0
Schema-NonEmptyTrimmedString.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.NonEmptyTrimmedString

Useful for validating strings that must contain meaningful characters without
leading or trailing whitespace.

**Example**

```ts
import { Schema } from "effect"

console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(" a ")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("a")) // Option.some("a")
```

**Signature**

```ts
declare class NonEmptyTrimmedString
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4750)

Since v3.10.0
Schema-NonNegativeInt.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.NonNegativeInt

A non-negative integer. +Infinity is excluded.

**Signature**

```ts
declare const NonNegativeInt: refine<number, typeof NonNegative>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5930)

Since v3.11.10
Schema-NumberFromString.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.NumberFromString

This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity", "-Infinity".

**Signature**

```ts
declare class NumberFromString
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5336)

Since v3.10.0
Schema-OptionFromNonEmptyTrimmedString.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.OptionFromNonEmptyTrimmedString

Transforms strings into an Option type, effectively filtering out empty or
whitespace-only strings by trimming them and checking their length. Returns
`none` for invalid inputs and `some` for valid non-empty strings.

**Example**

```ts
import { Schema } from "effect"

console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(" a ")) // Option.some("a")
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("a")) // Option.some("a")
```

**Signature**

```ts
declare class OptionFromNonEmptyTrimmedString
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7311)

Since v3.10.0
Schema-clamp.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.clamp

Clamps a number between a minimum and a maximum value.

**Signature**

```ts
declare const clamp: (minimum: number, maximum: number) => <S extends Schema.Any, A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5280)

Since v3.10.0
Schema-clampBigDecimal.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.clampBigDecimal

Clamps a `BigDecimal` between a minimum and a maximum value.

**Signature**

```ts
declare const clampBigDecimal: (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) => <S extends Schema.Any, A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8204)

Since v3.10.0
Schema-clampBigInt.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.clampBigInt

Clamps a bigint between a minimum and a maximum value.

**Signature**

```ts
declare const clampBigInt: (minimum: bigint, maximum: bigint) => <S extends Schema.Any, A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5672)

Since v3.10.0
Schema-clampDuration.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.clampDuration

Clamps a `Duration` between a minimum and a maximum value.

**Signature**

```ts
declare const clampDuration: (minimum: duration_.DurationInput, maximum: duration_.DurationInput) => <S extends Schema.Any, A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6042)

Since v3.10.0
Schema-declare.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.declare

The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.

**Signature**

```ts
declare const declare: { <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>; <A, I, const P extends ReadonlyArray<Schema.All>>(typeParameters: P, options: { readonly decode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, never>; readonly encode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, never>; }, annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]>; }>): declare<A, I, P>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1064)

Since v3.10.0
Schema-encodedBoundSchema.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.encodedBoundSchema

The `encodedBoundSchema` function is similar to `encodedSchema` but preserves
the refinements up to the first transformation point in the original schema.

**Signature**

```ts
declare const encodedBoundSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L402)

Since v3.10.0
Schema-encodedSchema.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.encodedSchema

The `encodedSchema` function allows you to extract the `Encoded` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without retaining any refinements or transformations that
were applied previously.

**Signature**

```ts
declare const encodedSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L394)

Since v3.10.0
Schema-equivalence.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.equivalence

Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.

**Signature**

```ts
declare const equivalence: <A, I, R>(schema: Schema<A, I, R>) => Equivalence.Equivalence<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10648)

Since v3.10.0
Schema-extend.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.extend

Extends a schema with another schema.

Not all extensions are supported, and their support depends on the nature of
the involved schemas.

Possible extensions include:
- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean
  literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema
- A transformation between structs where the from and to sides have no
  overlapping fields with the target struct

**Example**

```ts
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(schema.pipe(
  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
))
```

**Signature**

```ts
declare const extend: { <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>; <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3502)

Since v3.10.0
Schema-finite.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.finite

Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).

**Signature**

```ts
declare const finite: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4975)

Since v3.10.0
Schema-fromKey.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.fromKey

Enhances a property signature by specifying a different key for it in the Encoded type.

**Signature**

```ts
declare const fromKey: { <Key extends PropertyKey>(key: Key): <TypeToken extends PropertySignature.Token, Type, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean, R>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, HasDefault extends boolean, R, Key extends PropertyKey>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>, key: Key): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2167)

Since v3.10.0
Schema-greaterThan.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.greaterThan

This filter checks whether the provided number is greater than the specified minimum.

**Signature**

```ts
declare const greaterThan: <S extends Schema.Any>(exclusiveMinimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5006)

Since v3.10.0
Schema-greaterThanOrEqualTo.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.greaterThanOrEqualTo

This filter checks whether the provided number is greater than or equal to the specified minimum.

**Signature**

```ts
declare const greaterThanOrEqualTo: <S extends Schema.Any>(minimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5039)

Since v3.10.0
Schema-head.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.head

Get the first element of a `ReadonlyArray`, or `None` if the array is empty.

**Signature**

```ts
declare const head: <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, OptionFromSelf<SchemaClass<A[number]>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6523)

Since v3.10.0
Schema-headNonEmpty.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.headNonEmpty

Get the first element of a `NonEmptyReadonlyArray`.

**Signature**

```ts
declare const headNonEmpty: <S extends Schema.Any, A extends array_.NonEmptyReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6547)

Since v3.12.0
Schema-headOrElse.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.headOrElse

Retrieves the first element of a `ReadonlyArray`.

If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.

**Signature**

```ts
declare const headOrElse: { <S extends Schema.Any, A extends ReadonlyArray<unknown>>(fallback?: LazyArg<A[number]>): (self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>; <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>, fallback?: LazyArg<A[number]>): transform<S, SchemaClass<A[number]>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6569)

Since v3.10.0
Schema-int.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.int

Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).

**Signature**

```ts
declare const int: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5099)

Since v3.10.0
Schema-is.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.is

By default the option `exact` is set to `true`.

**Signature**

```ts
declare const is: <A, I, R>(schema: Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions | number) => u is A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L475)

Since v3.10.0
Schema-isSchema.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.isSchema

Tests if a value is a `Schema`.

**Signature**

```ts
declare const isSchema: (u: unknown) => u is Schema.Any
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L664)

Since v3.10.0
Schema-lessThan.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.lessThan

This filter checks whether the provided number is less than the specified maximum.

**Signature**

```ts
declare const lessThan: <S extends Schema.Any>(exclusiveMaximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5130)

Since v3.10.0
Schema-lessThanOrEqualTo.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.lessThanOrEqualTo

This schema checks whether the provided number is less than or equal to the specified maximum.

**Signature**

```ts
declare const lessThanOrEqualTo: <S extends Schema.Any>(maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5161)

Since v3.10.0
Schema-lowercased.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.lowercased

Verifies that a string is lowercased.

**Signature**

```ts
declare const lowercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4521)

Since v3.10.0
Schema-mutable.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.mutable

Creates a new schema with shallow mutability applied to its properties.

**Signature**

```ts
declare const mutable: <S extends Schema.Any>(schema: S) => mutable<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3265)

Since v3.10.0
Schema-optionalToOptional.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.optionalToOptional

Converts an optional property to another optional property through a transformation `Option -> Option`.

- `decode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.
- `encode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.

**Signature**

```ts
declare const optionalToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (o: option_.Option<FA>) => option_.Option<TI>; readonly encode: (o: option_.Option<TI>) => option_.Option<FA>; }) => PropertySignature<"?:", TA, never, "?:", FI, false, FR | TR>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2303)

Since v3.10.0
Schema-optionalToRequired.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.optionalToRequired

Converts an optional property to a required one through a transformation `Option -> Type`.

- `decode`: `none` as argument means the value is missing in the input.
- `encode`: `none` as return value means the value will be missing in the output.

**Signature**

```ts
declare const optionalToRequired: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (o: option_.Option<FA>) => TI; readonly encode: (ti: TI) => option_.Option<FA>; }) => PropertySignature<":", TA, never, "?:", FI, false, FR | TR>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2247)

Since v3.10.0
Schema-parseJson.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.parseJson

The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.

You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.

Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.

**Example**

```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`), { a: 1 })
```

**Signature**

```ts
declare const parseJson: { <S extends Schema.Any>(schema: S, options?: ParseJsonOptions): transform<SchemaClass<unknown, string>, S>; (options?: ParseJsonOptions): SchemaClass<unknown, string>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4840)

Since v3.10.0
Schema-parseNumber.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.parseNumber

Transforms a `string` into a `number` by parsing the string using the `parse`
function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when
non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity",
"-Infinity".

**Signature**

```ts
declare const parseNumber: <S extends Schema.Any, A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transformOrFail<S, typeof Number$>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5308)

Since v3.10.0
Schema-pickLiteral.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.pickLiteral

Creates a new `Schema` from a literal schema.

**Example**

```ts
import * as assert from "node:assert"
import { Either, Schema } from "effect"

const schema = Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b"))

assert.deepStrictEqual(Schema.decodeSync(schema)("a"), "a")
assert.deepStrictEqual(Schema.decodeSync(schema)("b"), "b")
assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)("c")), true)
```

**Signature**

```ts
declare const pickLiteral: <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) => <I, R>(_schema: Schema<A, I, R>) => Literal<[...L]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L732)

Since v3.10.0
Schema-Redacted.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Redacted

A transformation that transform a `Schema<A, I, R>` into a
`RedactedFromSelf<A>`.

**Signature**

```ts
declare const Redacted: <Value extends Schema.Any>(value: Value) => Redacted<Value>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5872)

Since v3.10.0
Schema-Schema.All.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Schema.All

Any schema, including `never`.

**Signature**

```ts
type All = | Any
    | Schema<any, never, unknown>
    | Schema<never, any, unknown>
    | Schema<never, never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L372)

Since v3.10.0
Schema-Schema.Any.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Schema.Any

Any schema, except for `never`.

**Signature**

```ts
type Any = Schema<any, any, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L358)

Since v3.10.0
Schema-Schema.AnyNoContext.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Schema.AnyNoContext

Any schema with `Context = never`, except for `never`.

**Signature**

```ts
type AnyNoContext = Schema<any, any, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L365)

Since v3.10.0
Schema-Schema.AsSchema.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Schema.AsSchema

Type-level counterpart of `Schema.asSchema` function.

**Signature**

```ts
type AsSchema<S> = Schema<Type<S>, Encoded<S>, Context<S>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L383)

Since v3.10.0
Schema-Serializable.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Serializable

The `Serializable` trait allows objects to define their own schema for
serialization.

**Signature**

```ts
export interface Serializable<A, I, R> {
  readonly [symbolSerializable]: Schema<A, I, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10144)

Since v3.10.0
Schema-SerializableWithResult.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.SerializableWithResult

The `SerializableWithResult` trait is specifically designed to model remote
procedures that require serialization of their input and output, managing
both successful and failed outcomes.

This trait combines functionality from both the `Serializable` and `WithResult`
traits to handle data serialization and the bifurcation of operation results
into success or failure categories.

**Signature**

```ts
export interface SerializableWithResult<
  A,
  I,
  R,
  Success,
  SuccessEncoded,
  Failure,
  FailureEncoded,
  ResultR
> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10449)

Since v3.10.0
Schema-StringFromBase64.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.StringFromBase64

Decodes a base64 (RFC4648) encoded string into a UTF-8 string.

**Signature**

```ts
declare const StringFromBase64: Schema<string, string, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6317)

Since v3.10.0
Schema-StringFromBase64Url.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.StringFromBase64Url

Decodes a base64 (URL) encoded string into a UTF-8 string.

**Signature**

```ts
declare const StringFromBase64Url: Schema<string, string, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6329)

Since v3.10.0
Schema-StringFromHex.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.StringFromHex

Decodes a hex encoded string into a UTF-8 string.

**Signature**

```ts
declare const StringFromHex: Schema<string, string, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6341)

Since v3.10.0
Schema-StringFromUriComponent.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.StringFromUriComponent

Decodes a URI component encoded string into a UTF-8 string.
Can be used to store data in a URL.

**Example**

```ts
import { Schema } from "effect"

const PaginationSchema = Schema.Struct({
  maxItemPerPage: Schema.Number,
  page: Schema.Number
})

const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))

console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))
// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D
```

**Signature**

```ts
declare const StringFromUriComponent: transformOrFail<SchemaClass<string, string, never>, typeof String$, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6369)

Since v3.12.0
Schema-Struct.Field.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Struct.Field

Useful for creating a type that can be used to add custom constraints to the fields of a struct.

```ts
import { Schema } from "effect"

const f = <Fields extends Record<"a" | "b", Schema.Struct.Field>>(
  schema: Schema.Struct<Fields>
) => {
  return schema.omit("a")
}

//       Schema.Struct<{ b: typeof Schema.Number; }>
//      
const result = f(Schema.Struct({ a: Schema.String, b: Schema.Number }))
```

**Signature**

```ts
type Field = | Schema.All
    | PropertySignature.All
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2583)

Since v3.13.11
Schema-Symbol.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Symbol

Converts a string key into a globally shared symbol.

**Signature**

```ts
declare const Symbol: typeof Symbol$
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5469)

Since v3.10.0
Schema-TaggedStruct.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.TaggedStruct

A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.

The tag is optional when using the `make` method.

**Example**

```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.TaggedStruct("User", {
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

**Signature**

```ts
declare const TaggedStruct: <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(value: Tag, fields: Fields) => TaggedStruct<Tag, Fields>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3005)

Since v3.10.0
Schema-TimeZone.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.TimeZone

Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.

**Signature**

```ts
declare class TimeZone
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7023)

Since v3.10.0
Schema-TimeZoneNamed.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.TimeZoneNamed

Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.

**Signature**

```ts
declare class TimeZoneNamed
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6997)

Since v3.10.0
Schema-TimeZoneNamedFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.TimeZoneNamedFromSelf

Describes a schema that represents a `TimeZone.Named` instance.

**Signature**

```ts
declare class TimeZoneNamedFromSelf
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6981)

Since v3.10.0
Schema-TimeZoneOffset.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.TimeZoneOffset

Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.

**Signature**

```ts
declare class TimeZoneOffset
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6962)

Since v3.10.0
Schema-TimeZoneOffsetFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.TimeZoneOffsetFromSelf

Describes a schema that represents a `TimeZone.Offset` instance.

**Signature**

```ts
declare class TimeZoneOffsetFromSelf
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6946)

Since v3.10.0
Schema-Trim.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Trim

This schema allows removing whitespaces from the beginning and end of a string.

**Signature**

```ts
declare class Trim
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4760)

Since v3.10.0
Schema-ULID.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.ULID

Represents a Universally Unique Lexicographically Sortable Identifier (ULID).

ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
This schema ensures that the provided string adheres to the standard ULID format.

**Signature**

```ts
declare class ULID
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4902)

Since v3.10.0
Schema-URL.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.URL

Defines a schema that attempts to convert a `string` to a `URL` object using
the `new URL` constructor.

**Signature**

```ts
declare const URL: typeof URL$
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4954)

Since v3.11.0
Schema-URLFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.URLFromSelf

Defines a schema that represents a `URL` object.

**Signature**

```ts
declare class URLFromSelf
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4917)

Since v3.11.0
Schema-UUID.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.UUID

Represents a Universally Unique Identifier (UUID).

This schema ensures that the provided string adheres to the standard UUID format.

**Signature**

```ts
declare class UUID
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4872)

Since v3.10.0
Schema-Uint8Array.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Uint8Array

A schema that transforms an array of numbers into a `Uint8Array`.

**Signature**

```ts
declare const Uint8Array: typeof Uint8Array$
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6232)

Since v3.10.0
Schema-Uint8ArrayFromBase64.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Uint8ArrayFromBase64

Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.

**Signature**

```ts
declare const Uint8ArrayFromBase64: Schema<Uint8Array<ArrayBufferLike>, string, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6260)

Since v3.10.0
Schema-Uint8ArrayFromBase64Url.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Uint8ArrayFromBase64Url

Decodes a base64 (URL) encoded string into a `Uint8Array`.

**Signature**

```ts
declare const Uint8ArrayFromBase64Url: Schema<Uint8Array<ArrayBufferLike>, string, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6272)

Since v3.10.0
Schema-Uint8ArrayFromHex.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Uint8ArrayFromHex

Decodes a hex encoded string into a `Uint8Array`.

**Signature**

```ts
declare const Uint8ArrayFromHex: Schema<Uint8Array<ArrayBufferLike>, string, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6284)

Since v3.10.0
Schema-Uncapitalize.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Uncapitalize

This schema converts a string to uncapitalized one.

**Signature**

```ts
declare class Uncapitalize
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4716)

Since v3.10.0
Schema-Uppercase.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.Uppercase

This schema converts a string to uppercase.

**Signature**

```ts
declare class Uppercase
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4684)

Since v3.10.0
Schema-ValidDateFromSelf.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.ValidDateFromSelf

Defines a schema that ensures only valid dates are accepted. This schema
rejects values like `new Date("Invalid Date")`, which, despite being a `Date`
instance, represents an invalid date. Such stringent validation ensures that
all date objects processed through this schema are properly formed and
represent real dates.

**Signature**

```ts
declare class ValidDateFromSelf
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6801)

Since v3.10.0
Schema-WithResult.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.WithResult

The `WithResult` trait is designed to encapsulate the outcome of an
operation, distinguishing between success and failure cases. Each case is
associated with a schema that defines the structure and types of the success
or failure data.

**Signature**

```ts
export interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {
  readonly [symbolWithResult]: {
    readonly success: Schema<Success, SuccessEncoded, ResultR>
    readonly failure: Schema<Failure, FailureEncoded, ResultR>
  }
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10229)

Since v3.10.0
Schema-pluck.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.pluck

Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

**Example**

```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

**Signature**

```ts
declare const pluck: { <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>; <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3108)

Since v3.10.0
Schema-propertySignature.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.propertySignature

Lifts a `Schema` into a `PropertySignature`.

**Signature**

```ts
declare const propertySignature: <S extends Schema.All>(self: S) => propertySignature<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1975)

Since v3.10.0
Schema-requiredToOptional.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.requiredToOptional

Converts an optional property to a required one through a transformation `Type -> Option`.

- `decode`: `none` as return value means the value will be missing in the output.
- `encode`: `none` as argument means the value is missing in the input.

**Signature**

```ts
declare const requiredToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (fa: FA) => option_.Option<TI>; readonly encode: (o: option_.Option<TI>) => FA; }) => PropertySignature<"?:", TA, never, ":", FI, false, FR | TR>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2273)

Since v3.10.0
Schema-split.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.split

Returns a schema that allows splitting a string into an array of strings.

**Signature**

```ts
declare const split: (separator: string) => transform<SchemaClass<string>, Array$<typeof String$>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4776)

Since v3.10.0
Schema-standardSchemaV1.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.standardSchemaV1

Returns a "Standard Schema" object conforming to the [Standard Schema
v1](https://standardschema.dev/) specification.

This function creates a schema whose `validate` method attempts to decode and
validate the provided input synchronously. If the underlying `Schema`
includes any asynchronous components (e.g., asynchronous message resolutions
or checks), then validation will necessarily return a `Promise` instead.

Any detected defects will be reported via a single issue containing no
`path`.

**Example**

```ts
import { Schema } from "effect"

const schema = Schema.Struct({
  name: Schema.String
})

//       StandardSchemaV1<{ readonly name: string; }>
//      
const standardSchema = Schema.standardSchemaV1(schema)
```

**Signature**

```ts
declare const standardSchemaV1: <A, I>(schema: Schema<A, I, never>, overrideOptions?: AST.ParseOptions) => StandardSchemaV1<I, A> & SchemaClass<A, I, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L195)

Since v3.13.0
Schema-tag.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.tag

Returns a property signature that represents a tag.
A tag is a literal value that is used to distinguish between different types of objects.
The tag is optional when using the `make` method.

**Example**

```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.Struct({
  _tag: Schema.tag("User"),
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

**See**

- `TaggedStruct`

**Signature**

```ts
declare const tag: <Tag extends AST.LiteralValue>(tag: Tag) => tag<Tag>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2973)

Since v3.10.0
Schema-transform.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.transform

Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided mapping functions.

**Signature**

```ts
declare const transform: { <To extends Schema.Any, From extends Schema.Any>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): (from: From) => transform<From, To>; <To extends Schema.Any, From extends Schema.Any>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): transform<From, To>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3936)

Since v3.10.0
Schema-transformLiteral.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.transformLiteral

Creates a new `Schema` which transforms literal values.

**Example**

```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"

const schema = S.transformLiteral(0, "a")

assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
```

**Signature**

```ts
declare const transformLiteral: <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(from: Encoded, to: Type) => transformLiteral<Type, Encoded>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4009)

Since v3.10.0
Schema-transformLiterals.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.transformLiterals

Creates a new `Schema` which maps between corresponding literal values.

**Example**

```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"

const Animal = S.transformLiterals(
  [0, "cat"],
  [1, "dog"],
  [2, "cow"]
)

assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")
```

**Signature**

```ts
declare const transformLiterals: { <const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]>; }>; <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(pairs: [Encoded, Type]): transformLiteral<Type, Encoded>; <const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Schema<A[number][1], A[number][0]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4049)

Since v3.10.0
Schema-transformOrFail.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.transformOrFail

Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided decoding functions.

**Signature**

```ts
declare const transformOrFail: { <To extends Schema.Any, From extends Schema.Any, RD, RE>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): (from: From) => transformOrFail<From, To, RD | RE>; <To extends Schema.Any, From extends Schema.Any, RD, RE>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): transformOrFail<From, To, RD | RE>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3827)

Since v3.10.0
Schema-trimmed.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.trimmed

Verifies that a string contains no leading or trailing whitespaces.

Note. This combinator does not make any transformations, it only validates.
If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.

**Signature**

```ts
declare const trimmed: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4256)

Since v3.10.0
Schema-typeSchema.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.typeSchema

The `typeSchema` function allows you to extract the `Type` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without considering the initial encoding or transformation
processes.

**Signature**

```ts
declare const typeSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L413)

Since v3.10.0
Schema-uncapitalized.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.uncapitalized

Verifies that a string is uncapitalized.

**Signature**

```ts
declare const uncapitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4620)

Since v3.10.0
Schema-uppercased.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.uppercased

Verifies that a string is uppercased.

**Signature**

```ts
declare const uppercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4554)

Since v3.10.0
Schema-validDate.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.validDate

Defines a filter that specifically rejects invalid dates, such as `new
Date("Invalid Date")`. This filter ensures that only properly formatted and
valid date objects are accepted, enhancing data integrity by preventing
erroneous date values from being processed.

**Signature**

```ts
declare const validDate: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6616)

Since v3.10.0
Schema-withConstructorDefault.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.withConstructorDefault

Enhances a property signature with a default constructor value.

**Signature**

```ts
declare const withConstructorDefault: { <Type>(defaultValue: () => Types.NoInfer<Type>): <TypeToken extends PropertySignature.Token, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>, defaultValue: () => Types.NoInfer<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1989)

Since v3.10.0
Schema-withDecodingDefault.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.withDecodingDefault

Enhances a property signature with a default decoding value.

**Signature**

```ts
declare const withDecodingDefault: { <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, false, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>, defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, false, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2059)

Since v3.10.0
Schema-withDefaults.md
Package: `effect`<br />
Module: `Schema`<br />

## Schema.withDefaults

Enhances a property signature with a default decoding value and a default constructor value.

**Signature**

```ts
declare const withDefaults: { <Type>(defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>, defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2124)

Since v3.10.0
SchemaAST-PropertySignatureTransformation.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.PropertySignatureTransformation

Represents a `PropertySignature -> PropertySignature` transformation

The semantic of `decode` is:
- `none()` represents the absence of the key/value pair
- `some(value)` represents the presence of the key/value pair

The semantic of `encode` is:
- `none()` you don't want to output the key/value pair
- `some(value)` you want to output the key/value pair

**Signature**

```ts
declare class PropertySignatureTransformation { constructor(
    readonly from: PropertyKey,
    readonly to: PropertyKey,
    readonly decode: (o: Option.Option<any>) => Option.Option<any>,
    readonly encode: (o: Option.Option<any>) => Option.Option<any>
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2022)

Since v3.10.0
SchemaAST-annotations.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.annotations

Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

**Signature**

```ts
declare const annotations: (ast: AST, overrides: Annotations) => AST
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2083)

Since v3.10.0
SchemaAST-getTemplateLiteralCapturingRegExp.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.getTemplateLiteralCapturingRegExp

Generates a regular expression that captures the pattern defined by the given `TemplateLiteral` AST.

**See**

- `getTemplateLiteralRegExp` for a variant that does not capture the pattern.

**Signature**

```ts
declare const getTemplateLiteralCapturingRegExp: (ast: TemplateLiteral) => RegExp
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2171)

Since v3.10.0
SchemaAST-getTemplateLiteralRegExp.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.getTemplateLiteralRegExp

Generates a regular expression from a `TemplateLiteral` AST node.

**See**

- `getTemplateLiteralCapturingRegExp` for a variant that captures the pattern.

**Signature**

```ts
declare const getTemplateLiteralRegExp: (ast: TemplateLiteral) => RegExp
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2161)

Since v3.10.0
SchemaAST-keyof.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.keyof

Equivalent at runtime to the TypeScript type-level `keyof` operator.

**Signature**

```ts
declare const keyof: (ast: AST) => AST
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2099)

Since v3.10.0
SchemaAST-mutable.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.mutable

Creates a new AST with shallow mutability applied to its properties.

**Signature**

```ts
declare const mutable: (ast: AST) => AST
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2549)

Since v3.10.0
SchemaAST-omit.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.omit

Equivalent at runtime to the built-in TypeScript utility type `Omit`.

**Signature**

```ts
declare const omit: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2448)

Since v3.10.0
SchemaAST-partial.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.partial

Equivalent at runtime to the built-in TypeScript utility type `Partial`.

**Signature**

```ts
declare const partial: (ast: AST, options?: { readonly exact: true; }) => AST
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2467)

Since v3.10.0
SchemaAST-pick.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.pick

Equivalent at runtime to the built-in TypeScript utility type `Pick`.

**Signature**

```ts
declare const pick: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2378)

Since v3.10.0
SchemaAST-required.md
Package: `effect`<br />
Module: `SchemaAST`<br />

## SchemaAST.required

Equivalent at runtime to the built-in TypeScript utility type `Required`.

**Signature**

```ts
declare const required: (ast: AST) => AST
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2511)

Since v3.10.0
Scope-CloseableScope.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.CloseableScope

A scope that can be explicitly closed with a specified exit value.

**Signature**

```ts
export interface CloseableScope extends Scope, Pipeable {
  readonly [CloseableScopeTypeId]: CloseableScopeTypeId

  /**
   * Closes this scope with the given exit value, running all finalizers.
   *
   * @internal
   */
  close(exit: Exit.Exit<unknown, unknown>): Effect.Effect<void>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L78)

Since v2.0.0
Scope-CloseableScopeTypeId.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.CloseableScopeTypeId

The type of the unique identifier for `CloseableScope`.

**Signature**

```ts
type CloseableScopeTypeId = typeof CloseableScopeTypeId
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L43)

Since v2.0.0
Scope-Scope.Closeable.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.Scope.Closeable

A closeable scope that can be explicitly closed.

**Signature**

```ts
type Closeable = CloseableScope
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L114)

Since v2.0.0
Scope-Scope.Finalizer.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.Scope.Finalizer

A finalizer function that takes an `Exit` value and returns an `Effect`.

**Signature**

```ts
type Finalizer = (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L107)

Since v2.0.0
Scope-Scope.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.Scope

Represents a scope that manages finalizers and can fork child scopes.

**Signature**

```ts
export interface Scope extends Pipeable {
  readonly [ScopeTypeId]: ScopeTypeId
  /**
   * The execution strategy for running finalizers in this scope.
   */
  readonly strategy: ExecutionStrategy.ExecutionStrategy
  /**
   * Forks a new child scope with the specified execution strategy. The child scope
   * will automatically be closed when this scope is closed.
   *
   * @internal
   */
  fork(strategy: ExecutionStrategy.ExecutionStrategy): Effect.Effect<Scope.Closeable>
  /**
   * Adds a finalizer to this scope. The finalizer will be run when the scope is closed.
   *
   * @internal
   */
  addFinalizer(finalizer: Scope.Finalizer): Effect.Effect<void>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L51)

Since v2.0.0
Scope-ScopeTypeId.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.ScopeTypeId

The type of the unique identifier for `Scope`.

**Signature**

```ts
type ScopeTypeId = typeof ScopeTypeId
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L27)

Since v2.0.0
Scope-addFinalizer.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.addFinalizer

Adds a finalizer to this scope. The finalizer is guaranteed to be run when
the scope is closed. Use this when the finalizer does not need to know the
`Exit` value that the scope is closed with.

**See**

- `addFinalizerExit`

**Signature**

```ts
declare const addFinalizer: (self: Scope, finalizer: Effect.Effect<unknown>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L127)

Since v2.0.0
Scope-addFinalizerExit.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.addFinalizerExit

Adds a finalizer to this scope. The finalizer receives the `Exit` value
when the scope is closed, allowing it to perform different actions based
on the exit status.

**See**

- `addFinalizer`

**Signature**

```ts
declare const addFinalizerExit: (self: Scope, finalizer: Scope.Finalizer) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L142)

Since v2.0.0
Scope-close.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.close

Closes this scope with the specified exit value, running all finalizers that
have been added to the scope.

**Signature**

```ts
declare const close: (self: CloseableScope, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L152)

Since v2.0.0
Scope-extend.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.extend

Extends the scope of an `Effect` that requires a scope into this scope.
It provides this scope to the effect but does not close the scope when the
effect completes execution. This allows extending a scoped value into a
larger scope.

**Signature**

```ts
declare const extend: { (scope: Scope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope): Effect.Effect<A, E, Exclude<R, Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L163)

Since v2.0.0
Scope-fork.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.fork

Forks a new child scope with the specified execution strategy. The child scope
will automatically be closed when this scope is closed.

**Signature**

```ts
declare const fork: (self: Scope, strategy: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L175)

Since v2.0.0
Scope-make.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.make

Creates a new closeable scope where finalizers will run according to the
specified `ExecutionStrategy`. If no execution strategy is provided, `sequential`
will be used by default.

**Signature**

```ts
declare const make: (executionStrategy?: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L202)

Since v2.0.0
Scope-use.md
Package: `effect`<br />
Module: `Scope`<br />

## Scope.use

Provides this closeable scope to an `Effect` that requires a scope,
guaranteeing that the scope is closed with the result of that effect as
soon as the effect completes execution, whether by success, failure, or
interruption.

**Signature**

```ts
declare const use: { (scope: CloseableScope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect.Effect<A, E, R>, scope: CloseableScope): Effect.Effect<A, E, Exclude<R, Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L189)

Since v2.0.0
ScopedCache-Lookup.md
Package: `effect`<br />
Module: `ScopedCache`<br />

## ScopedCache.Lookup

Similar to `Cache.Lookup`, but executes the lookup function within a `Scope`.

**Signature**

```ts
type Lookup<Key, Value, Error, Environment> = (
  key: Key
) => Effect.Effect<Value, Error, Environment | Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L149)

Since v2.0.0
ScopedCache-make.md
Package: `effect`<br />
Module: `ScopedCache`<br />

## ScopedCache.make

Constructs a new cache with the specified capacity, time to live, and
lookup function.

**Signature**

```ts
declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly lookup: Lookup<Key, Value, Error, Environment>; readonly capacity: number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L119)

Since v2.0.0
ScopedCache-makeWith.md
Package: `effect`<br />
Module: `ScopedCache`<br />

## ScopedCache.makeWith

Constructs a new cache with the specified capacity, time to live, and
lookup function, where the time to live can depend on the `Exit` value
returned by the lookup function.

**Signature**

```ts
declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L135)

Since v2.0.0
ScopedRef-ScopedRef.md
Package: `effect`<br />
Module: `ScopedRef`<br />

## ScopedRef.ScopedRef

A `ScopedRef` is a reference whose value is associated with resources,
which must be released properly. You can both get the current value of any
`ScopedRef`, as well as set it to a new value (which may require new
resources). The reference itself takes care of properly releasing resources
for the old value whenever a new value is obtained.

**Signature**

```ts
export interface ScopedRef<in out A> extends Effect.Effect<A>, ScopedRef.Variance<A>, Pipeable {
  /** @internal */
  readonly ref: Synchronized.SynchronizedRef<readonly [Scope.Scope.Closeable, A]>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: ScopedRefUnify<this>
  readonly [Unify.ignoreSymbol]?: ScopedRefUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L35)

Since v2.0.0
ScopedRef-fromAcquire.md
Package: `effect`<br />
Module: `ScopedRef`<br />

## ScopedRef.fromAcquire

Creates a new `ScopedRef` from an effect that resourcefully produces a
value.

**Signature**

```ts
declare const fromAcquire: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<ScopedRef<A>, E, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L82)

Since v2.0.0
ScopedRef-get.md
Package: `effect`<br />
Module: `ScopedRef`<br />

## ScopedRef.get

Retrieves the current value of the scoped reference.

**Signature**

```ts
declare const get: <A>(self: ScopedRef<A>) => Effect.Effect<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L92)

Since v2.0.0
ScopedRef-make.md
Package: `effect`<br />
Module: `ScopedRef`<br />

## ScopedRef.make

Creates a new `ScopedRef` from the specified value. This method should
not be used for values whose creation require the acquisition of resources.

**Signature**

```ts
declare const make: <A>(evaluate: LazyArg<A>) => Effect.Effect<ScopedRef<A>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L101)

Since v2.0.0
ScopedRef-set.md
Package: `effect`<br />
Module: `ScopedRef`<br />

## ScopedRef.set

Sets the value of this reference to the specified resourcefully-created
value. Any resources associated with the old value will be released.

This method will not return until either the reference is successfully
changed to the new value, with old resources released, or until the attempt
to acquire a new value fails.

**Signature**

```ts
declare const set: { <A, R, E>(acquire: Effect.Effect<A, E, R>): (self: ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>; <A, R, E>(self: ScopedRef<A>, acquire: Effect.Effect<A, E, R>): Effect.Effect<void, E, Exclude<R, Scope.Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L114)

Since v2.0.0
SemiApplicative-getSemigroup.md
Package: `@effect/typeclass`<br />
Module: `SemiApplicative`<br />

## SemiApplicative.getSemigroup

Lift a `Semigroup` into 'F', the inner values are combined using the provided `Semigroup`.

**Signature**

```ts
declare const getSemigroup: <F extends TypeLambda>(F: SemiApplicative<F>) => <A, R, O, E>(S: Semigroup<A>) => Semigroup<Kind<F, R, O, E, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/SemiApplicative.ts#L23)

Since v0.24.0
SemiApplicative-lift2.md
Package: `@effect/typeclass`<br />
Module: `SemiApplicative`<br />

## SemiApplicative.lift2

Lifts a binary function into `F`.

**Signature**

```ts
declare const lift2: <F extends TypeLambda>(F: SemiApplicative<F>) => <A, B, C>(f: (a: A, b: B) => C) => { <R2, O2, E2>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>; <R1, O1, E1, R2, O2, E2>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/SemiApplicative.ts#L114)

Since v0.24.0
SemiApplicative-zipWith.md
Package: `@effect/typeclass`<br />
Module: `SemiApplicative`<br />

## SemiApplicative.zipWith

Zips two `F` values together using a provided function, returning a new `F` of the result.

**Signature**

```ts
declare const zipWith: <F extends TypeLambda>(F: SemiApplicative<F>) => { <R2, O2, E2, B, A, C>(that: Kind<F, R2, O2, E2, B>, f: (a: A, b: B) => C): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>; <R1, O1, E1, A, R2, O2, E2, B, C>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>, f: (a: A, b: B) => C): Kind<F, R1 & R2, O1 | O2, E1 | E2, C>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/SemiApplicative.ts#L35)

Since v0.24.0
SemiProduct-appendElement.md
Package: `@effect/typeclass`<br />
Module: `SemiProduct`<br />

## SemiProduct.appendElement

Appends an element to the end of a tuple.

**Signature**

```ts
declare const appendElement: <F extends TypeLambda>(F: SemiProduct<F>) => { <R2, O2, E2, B>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1, A extends ReadonlyArray<any>>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, [...A, B]>; <R1, O1, E1, A extends ReadonlyArray<any>, R2, O2, E2, B>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, [...A, B]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/SemiProduct.ts#L118)

Since v0.24.0
SemiProduct-productComposition.md
Package: `@effect/typeclass`<br />
Module: `SemiProduct`<br />

## SemiProduct.productComposition

Returns a default `product` composition.

**Signature**

```ts
declare const productComposition: <F extends TypeLambda, G extends TypeLambda>(F: SemiApplicative<F>, G: SemiProduct<G>) => <FR1, FO1, FE1, GR1, GO1, GE1, A, FR2, FO2, FE2, GR2, GO2, GE2, B>(self: Kind<F, FR1, FO1, FE1, Kind<G, GR1, GO1, GE1, A>>, that: Kind<F, FR2, FO2, FE2, Kind<G, GR2, GO2, GE2, B>>) => Kind<F, FR1 & FR2, FO1 | FO2, FE1 | FE2, Kind<G, GR1 & GR2, GO1 | GO2, GE1 | GE2, [A, B]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/SemiProduct.ts#L55)

Since v0.24.0
SemiProduct-productMany.md
Package: `@effect/typeclass`<br />
Module: `SemiProduct`<br />

## SemiProduct.productMany

Returns a default `productMany` implementation.

**Signature**

```ts
declare const productMany: <F extends TypeLambda>(map: Covariant<F>["map"], product: SemiProduct<F>["product"]) => SemiProduct<F>["productMany"]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/SemiProduct.ts#L32)

Since v0.24.0
SemiProduct-productManyComposition.md
Package: `@effect/typeclass`<br />
Module: `SemiProduct`<br />

## SemiProduct.productManyComposition

Returns a default `productMany` composition.

**Signature**

```ts
declare const productManyComposition: <F extends TypeLambda, G extends TypeLambda>(F: SemiApplicative<F>, G: SemiProduct<G>) => <FR, FO, FE, GR, GO, GE, A>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, collection: Iterable<Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>>) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, [A, ...Array<A>]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/SemiProduct.ts#L75)

Since v0.24.0
Semigroup-array.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.array

Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.
The returned `Semigroup` combines two arrays by concatenating them.

**Signature**

```ts
declare const array: <A>() => Semigroup<ReadonlyArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L225)

Since v0.24.0
Semigroup-first.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.first

Always return the first argument.

**Signature**

```ts
declare const first: <A = never>() => Semigroup<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L109)

Since v0.24.0
Semigroup-intercalate.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.intercalate

The `intercalate` API returns a function that takes a `Semigroup` instance and a separator value, and returns a new
`Semigroup` instance that combines values with the given separator.

This API is useful when you want to combine values with a specific separator. For example, when you want to concatenate
an array of strings with a separator string in between.

It is interesting to note that there is no equivalent API in the `Monoid` module. This is because the value `empty`,
which is required for the `Monoid` interface, cannot exist.

**Signature**

```ts
declare const intercalate: { <A>(separator: A): (S: Semigroup<A>) => Semigroup<A>; <A>(S: Semigroup<A>, separator: A): Semigroup<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L95)

Since v0.24.0
Semigroup-last.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.last

Always return the last argument.

**Signature**

```ts
declare const last: <A = never>() => Semigroup<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L117)

Since v0.24.0
Semigroup-make.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.make

The `combineMany` parameter is optional and defaults to a standard
implementation. You can provide a custom implementation when performance
optimizations are possible.

**Signature**

```ts
declare const make: <A>(combine: Semigroup<A>["combine"], combineMany?: Semigroup<A>["combineMany"]) => Semigroup<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L37)

Since v0.24.0
Semigroup-max.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.max

`Semigroup` that returns last maximum of elements.

**Signature**

```ts
declare const max: <A>(O: Order<A>) => Semigroup<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L59)

Since v0.24.0
Semigroup-min.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.min

`Semigroup` that returns last minimum of elements.

**Signature**

```ts
declare const min: <A>(O: Order<A>) => Semigroup<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L51)

Since v0.24.0
Semigroup-reverse.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.reverse

The dual of a `Semigroup`, obtained by flipping the arguments of `combine`.

**Signature**

```ts
declare const reverse: <A>(S: Semigroup<A>) => Semigroup<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L72)

Since v0.24.0
Semigroup-struct.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.struct

This function creates and returns a new `Semigroup` for a struct of values based on the given `Semigroup`s for each property in the struct.
The returned `Semigroup` combines two structs of the same type by applying the corresponding `Semigroup` passed as arguments to each property in the struct.

It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.

**Signature**

```ts
declare const struct: <R extends { readonly [x: string]: Semigroup<any>; }>(fields: R) => Semigroup<{ readonly [K in keyof R]: [R[K]] extends [Semigroup<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L236)

Since v0.24.0
Semigroup-tuple.md
Package: `@effect/typeclass`<br />
Module: `Semigroup`<br />

## Semigroup.tuple

Similar to `Promise.all` but operates on `Semigroup`s.

```
[Semigroup<A>, Semigroup<B>, ...] -> Semigroup<[A, B, ...]>
```

This function creates and returns a new `Semigroup` for a tuple of values based on the given `Semigroup`s for each element in the tuple.
The returned `Semigroup` combines two tuples of the same type by applying the corresponding `Semigroup` passed as arguments to each element in the tuple.

It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.

**Signature**

```ts
declare const tuple: <T extends ReadonlyArray<Semigroup<any>>>(...elements: T) => Semigroup<{ readonly [I in keyof T]: [T[I]] extends [Semigroup<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Semigroup.ts#L214)

Since v0.24.0
ShardingConfig-ShardingConfig.md
Package: `@effect/cluster`<br />
Module: `ShardingConfig`<br />

## ShardingConfig.ShardingConfig

Represents the configuration for the `Sharding` service on a given runner.

**Signature**

```ts
declare class ShardingConfig
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ShardingConfig.ts#L21)

Since v1.0.0
ShardingRegistrationEvent-EntityRegistered.md
Package: `@effect/cluster`<br />
Module: `ShardingRegistrationEvent`<br />

## ShardingRegistrationEvent.EntityRegistered

Represents an event that occurs when a new entity is registered with a runner.

**Signature**

```ts
export interface EntityRegistered {
  readonly _tag: "EntityRegistered"
  readonly entity: Entity<any>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ShardingRegistrationEvent.ts#L24)

Since v1.0.0
ShardManager-Rpcs.md
Package: `@effect/cluster`<br />
Module: `ShardManager`<br />

## ShardManager.Rpcs

The messaging protocol for the `ShardManager`.

**Signature**

```ts
declare class Rpcs
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ShardManager.ts#L280)

Since v1.0.0
ShardManager-ShardManagerClient.md
Package: `@effect/cluster`<br />
Module: `ShardManager`<br />

## ShardManager.ShardManagerClient

Represents a client which can be used to communicate with the
`ShardManager`.

**Signature**

```ts
declare class ShardManagerClient
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ShardManager.ts#L221)

Since v1.0.0
ShardStorage-ShardStorage.md
Package: `@effect/cluster`<br />
Module: `ShardStorage`<br />

## ShardStorage.ShardStorage

Represents a generic interface to the persistent storage required by the
cluster.

**Signature**

```ts
declare class ShardStorage
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ShardStorage.ts#L22)

Since v1.0.0
ShardingRegistrationEvent-ShardingRegistrationEvent.md
Package: `@effect/cluster`<br />
Module: `ShardingRegistrationEvent`<br />

## ShardingRegistrationEvent.ShardingRegistrationEvent

Represents events that can occur when a runner registers entities or singletons.

**Signature**

```ts
type ShardingRegistrationEvent = | EntityRegistered
  | SingletonRegistered
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ShardingRegistrationEvent.ts#L14)

Since v1.0.0
ShardingRegistrationEvent-SingletonRegistered.md
Package: `@effect/cluster`<br />
Module: `ShardingRegistrationEvent`<br />

## ShardingRegistrationEvent.SingletonRegistered

Represents an event that occurs when a new singleton is registered with a
runner.

**Signature**

```ts
export interface SingletonRegistered {
  readonly _tag: "SingletonRegistered"
  readonly address: SingletonAddress
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/ShardingRegistrationEvent.ts#L36)

Since v1.0.0
SingleProducerAsyncInput-AsyncInputConsumer.md
Package: `effect`<br />
Module: `SingleProducerAsyncInput`<br />

## SingleProducerAsyncInput.AsyncInputConsumer

Consumer-side view of `SingleProducerAsyncInput` for variance purposes.

**Signature**

```ts
export interface AsyncInputConsumer<out Err, out Elem, out Done> {
  takeWith<A>(
    onError: (cause: Cause.Cause<Err>) => A,
    onElement: (element: Elem) => A,
    onDone: (value: Done) => A
  ): Effect.Effect<A>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SingleProducerAsyncInput.ts#L55)

Since v2.0.0
SingleProducerAsyncInput-AsyncInputProducer.md
Package: `effect`<br />
Module: `SingleProducerAsyncInput`<br />

## SingleProducerAsyncInput.AsyncInputProducer

Producer-side view of `SingleProducerAsyncInput` for variance purposes.

**Signature**

```ts
export interface AsyncInputProducer<in Err, in Elem, in Done> {
  awaitRead(): Effect.Effect<unknown>
  done(value: Done): Effect.Effect<unknown>
  emit(element: Elem): Effect.Effect<unknown>
  error(cause: Cause.Cause<Err>): Effect.Effect<unknown>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SingleProducerAsyncInput.ts#L42)

Since v2.0.0
SingleProducerAsyncInput-SingleProducerAsyncInput.md
Package: `effect`<br />
Module: `SingleProducerAsyncInput`<br />

## SingleProducerAsyncInput.SingleProducerAsyncInput

An MVar-like abstraction for sending data to channels asynchronously which is
designed for one producer and multiple consumers.

Features the following semantics:
  - Buffer of size 1.
  - When emitting, the producer waits for a consumer to pick up the value to
    prevent "reading ahead" too much.
  - Once an emitted element is read by a consumer, it is cleared from the
    buffer, so that at most one consumer sees every emitted element.
  - When sending a done or error signal, the producer does not wait for a
    consumer to pick up the signal. The signal stays in the buffer after
    being read by a consumer, so it can be propagated to multiple consumers.
  - Trying to publish another emit/error/done after an error/done have
    already been published results in an interruption.

**Signature**

```ts
export interface SingleProducerAsyncInput<in out Err, in out Elem, in out Done>
  extends AsyncInputProducer<Err, Elem, Done>, AsyncInputConsumer<Err, Elem, Done>
{
  readonly close: Effect.Effect<unknown>
  readonly take: Effect.Effect<Exit.Exit<Elem, Either.Either<Done, Err>>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SingleProducerAsyncInput.ts#L29)

Since v2.0.0
SingletonAddress-SingletonAddress.md
Package: `@effect/cluster`<br />
Module: `SingletonAddress`<br />

## SingletonAddress.SingletonAddress

Represents the unique address of an singleton within the cluster.

**Signature**

```ts
declare class SingletonAddress
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/SingletonAddress.ts#L27)

Since v1.0.0
Sink-as.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.as

Replaces this sink's result with the provided value.

**Signature**

```ts
declare const as: { <A2>(a: A2): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, a: A2): Sink<A2, In, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L118)

Since v2.0.0
Sink-collectAll.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAll

A sink that collects all elements into a `Chunk`.

**Signature**

```ts
declare const collectAll: <In>() => Sink<Chunk.Chunk<In>, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L129)

Since v2.0.0
Sink-collectAllFrom.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllFrom

Repeatedly runs the sink and accumulates its results into a `Chunk`.

**Signature**

```ts
declare const collectAllFrom: <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Chunk.Chunk<A>, In, L, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L145)

Since v2.0.0
Sink-collectAllN.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllN

A sink that collects first `n` elements into a chunk.

**Signature**

```ts
declare const collectAllN: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L137)

Since v2.0.0
Sink-collectAllToMap.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllToMap

A sink that collects all of its inputs into a map. The keys are extracted
from inputs using the keying function `key`; if multiple inputs use the
same key, they are merged using the `merge` function.

**Signature**

```ts
declare const collectAllToMap: <In, K>(key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L157)

Since v2.0.0
Sink-collectAllToMapN.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllToMapN

A sink that collects first `n` keys into a map. The keys are calculated
from inputs using the keying function `key`; if multiple inputs use the the
same key, they are merged using the `merge` function.

**Signature**

```ts
declare const collectAllToMapN: <In, K>(n: number, key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L170)

Since v2.0.0
Sink-collectAllToSet.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllToSet

A sink that collects all of its inputs into a set.

**Signature**

```ts
declare const collectAllToSet: <In>() => Sink<HashSet.HashSet<In>, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L182)

Since v2.0.0
Sink-collectAllToSetN.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllToSetN

A sink that collects first `n` distinct inputs into a set.

**Signature**

```ts
declare const collectAllToSetN: <In>(n: number) => Sink<HashSet.HashSet<In>, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L190)

Since v2.0.0
Sink-collectAllUntil.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllUntil

Accumulates incoming elements into a chunk until predicate `p` is
satisfied.

**Signature**

```ts
declare const collectAllUntil: <In>(p: Predicate<In>) => Sink<Chunk.Chunk<In>, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L199)

Since v2.0.0
Sink-collectAllUntilEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllUntilEffect

Accumulates incoming elements into a chunk until effectful predicate `p` is
satisfied.

**Signature**

```ts
declare const collectAllUntilEffect: <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L208)

Since v2.0.0
Sink-collectAllWhile.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllWhile

Accumulates incoming elements into a chunk as long as they verify predicate
`p`.

**Signature**

```ts
declare const collectAllWhile: { <In, Out extends In>(refinement: Refinement<In, Out>): Sink<Chunk.Chunk<Out>, In, In>; <In>(predicate: Predicate<In>): Sink<Chunk.Chunk<In>, In, In>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L219)

Since v2.0.0
Sink-collectAllWhileEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllWhileEffect

Accumulates incoming elements into a chunk as long as they verify effectful
predicate `p`.

**Signature**

```ts
declare const collectAllWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L231)

Since v2.0.0
Sink-collectAllWhileWith.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectAllWhileWith

Repeatedly runs the sink for as long as its results satisfy the predicate
`p`. The sink's results will be accumulated using the stepping function `f`.

**Signature**

```ts
declare const collectAllWhileWith: { <A, S>(options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<S, In, L, E, R>; <A, In, L extends In, E, R, S>(self: Sink<A, In, L, E, R>, options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): Sink<S, In, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L242)

Since v2.0.0
Sink-collectLeftover.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.collectLeftover

Collects the leftovers from the stream when the sink succeeds and returns
them as part of the sink's result.

**Signature**

```ts
declare const collectLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Chunk.Chunk<L>], In, never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L259)

Since v2.0.0
Sink-context.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.context

Accesses the whole context of the sink.

**Signature**

```ts
declare const context: <R>() => Sink<Context.Context<R>, unknown, never, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L527)

Since v2.0.0
Sink-contextWith.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.contextWith

Accesses the context of the sink.

**Signature**

```ts
declare const contextWith: <R, Z>(f: (context: Context.Context<R>) => Z) => Sink<Z, unknown, never, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L535)

Since v2.0.0
Sink-contextWithEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.contextWithEffect

Accesses the context of the sink in the context of an effect.

**Signature**

```ts
declare const contextWithEffect: <R0, A, E, R>(f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R0 | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L544)

Since v2.0.0
Sink-contextWithSink.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.contextWithSink

Accesses the context of the sink in the context of a sink.

**Signature**

```ts
declare const contextWithSink: <R0, A, In, L, E, R>(f: (context: Context.Context<R0>) => Sink<A, In, L, E, R>) => Sink<A, In, L, E, R0 | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L554)

Since v2.0.0
Sink-count.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.count

A sink that counts the number of elements fed to it.

**Signature**

```ts
declare const count: Sink<number, unknown, never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L329)

Since v2.0.0
Sink-die.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.die

Creates a sink halting with the specified defect.

**Signature**

```ts
declare const die: (defect: unknown) => Sink<never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L337)

Since v2.0.0
Sink-dieMessage.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dieMessage

Creates a sink halting with the specified message, wrapped in a
`RuntimeException`.

**Signature**

```ts
declare const dieMessage: (message: string) => Sink<never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L346)

Since v2.0.0
Sink-dieSync.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dieSync

Creates a sink halting with the specified defect.

**Signature**

```ts
declare const dieSync: (evaluate: LazyArg<unknown>) => Sink<never, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L354)

Since v2.0.0
Sink-dimap.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dimap

Transforms both inputs and result of this sink using the provided
functions.

**Signature**

```ts
declare const dimap: { <In0, In, A, A2>(options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L363)

Since v2.0.0
Sink-dimapChunks.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dimapChunks

Transforms both input chunks and result of this sink using the provided
functions.

**Signature**

```ts
declare const dimapChunks: { <In0, In, A, A2>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L403)

Since v2.0.0
Sink-dimapChunksEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dimapChunksEffect

Effectfully transforms both input chunks and result of this sink using the
provided functions. `f` and `g` must preserve chunking-invariance.

**Signature**

```ts
declare const dimapChunksEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L420)

Since v2.0.0
Sink-dimapEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dimapEffect

Effectfully transforms both inputs and result of this sink using the
provided functions.

**Signature**

```ts
declare const dimapEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L380)

Since v2.0.0
Sink-drain.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.drain

A sink that ignores its inputs.

**Signature**

```ts
declare const drain: Sink<void, unknown, never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L442)

Since v2.0.0
Sink-drop.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.drop

Creates a sink that drops `n` elements.

**Signature**

```ts
declare const drop: <In>(n: number) => Sink<unknown, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L450)

Since v2.0.0
Sink-dropUntil.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dropUntil

Drops incoming elements until the predicate is satisfied.

**Signature**

```ts
declare const dropUntil: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L458)

Since v2.0.0
Sink-dropUntilEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dropUntilEffect

Drops incoming elements until the effectful predicate is satisfied.

**Signature**

```ts
declare const dropUntilEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L466)

Since v2.0.0
Sink-dropWhile.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dropWhile

Drops incoming elements as long as the predicate is satisfied.

**Signature**

```ts
declare const dropWhile: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L476)

Since v2.0.0
Sink-dropWhileEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.dropWhileEffect

Drops incoming elements as long as the effectful predicate is satisfied.

**Signature**

```ts
declare const dropWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L484)

Since v2.0.0
Sink-ensuring.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.ensuring

Returns a new sink with an attached finalizer. The finalizer is guaranteed
to be executed so long as the sink begins execution (and regardless of
whether or not it completes).

**Signature**

```ts
declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L496)

Since v2.0.0
Sink-ensuringWith.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.ensuringWith

Returns a new sink with an attached finalizer. The finalizer is guaranteed
to be executed so long as the sink begins execution (and regardless of
whether or not it completes).

**Signature**

```ts
declare const ensuringWith: { <A, E, X, R2>(finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L511)

Since v2.0.0
Sink-every.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.every

A sink that returns whether all elements satisfy the specified predicate.

**Signature**

```ts
declare const every: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L564)

Since v2.0.0
Sink-fail.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.fail

A sink that always fails with the specified error.

**Signature**

```ts
declare const fail: <E>(e: E) => Sink<never, unknown, never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L572)

Since v2.0.0
Sink-failCause.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.failCause

Creates a sink halting with a specified `Cause`.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Sink<never, unknown, never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L588)

Since v2.0.0
Sink-failCauseSync.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.failCauseSync

Creates a sink halting with a specified lazily evaluated `Cause`.

**Signature**

```ts
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Sink<never, unknown, never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L596)

Since v2.0.0
Sink-failSync.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.failSync

A sink that always fails with the specified lazily evaluated error.

**Signature**

```ts
declare const failSync: <E>(evaluate: LazyArg<E>) => Sink<never, unknown, never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L580)

Since v2.0.0
Sink-filterInput.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.filterInput

Filters the sink's input with the given predicate.

**Signature**

```ts
declare const filterInput: { <In, In1 extends In, In2 extends In1>(f: Refinement<In1, In2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In2, L, E, R>; <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L605)

Since v2.0.0
Sink-filterInputEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.filterInputEffect

Effectfully filter the input of this sink using the specified predicate.

**Signature**

```ts
declare const filterInputEffect: { <In, In1 extends In, E2, R2>(f: (input: In1) => Effect.Effect<boolean, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E2 | E, R2 | R>; <A, In, L, E, R, In1 extends In, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In1) => Effect.Effect<boolean, E2, R2>): Sink<A, In1, L, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L618)

Since v2.0.0
Sink-Sink.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.Sink

A `Sink<A, In, L, E, R>` is used to consume elements produced by a `Stream`.
You can think of a sink as a function that will consume a variable amount of
`In` elements (could be 0, 1, or many), might fail with an error of type `E`,
and will eventually yield a value of type `A` together with a remainder of
type `L` (i.e. any leftovers).

**Signature**

```ts
export interface Sink<out A, in In = unknown, out L = never, out E = never, out R = never>
  extends Sink.Variance<A, In, L, E, R>, Pipeable
{}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L48)

Since v2.0.0
Sink-findEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.findEffect

Creates a sink that produces values until one verifies the predicate `f`.

**Signature**

```ts
declare const findEffect: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Option.Option<A>, In, L, E2 | E, R2 | R>; <A, In, L extends In, E, R, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Sink<Option.Option<A>, In, L, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L634)

Since v2.0.0
Sink-flatMap.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.flatMap

Runs this sink until it yields a result, then uses that result to create
another sink from the provided function which will continue to run until it
yields a result.

This function essentially runs sinks in sequence.

**Signature**

```ts
declare const flatMap: { <A, A1, In, In1 extends In, L1, E1, R1>(f: (a: A) => Sink<A1, In1, L1, E1, R1>): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(self: Sink<A, In, L, E, R>, f: (a: A) => Sink<A1, In1, L1, E1, R1>): Sink<A1, In & In1, L | L1, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L956)

Since v2.0.0
Sink-fold.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.fold

A sink that folds its inputs with the provided function, termination
predicate and initial state.

**Signature**

```ts
declare const fold: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => S) => Sink<S, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L651)

Since v2.0.0
Sink-foldChunks.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldChunks

A sink that folds its input chunks with the provided function, termination
predicate and initial state. `contFn` condition is checked only for the
initial value and at the end of processing of each chunk. `f` and `contFn`
must preserve chunking-invariance.

**Signature**

```ts
declare const foldChunks: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L684)

Since v2.0.0
Sink-foldChunksEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldChunksEffect

A sink that effectfully folds its input chunks with the provided function,
termination predicate and initial state. `contFn` condition is checked only
for the initial value and at the end of processing of each chunk. `f` and
`contFn` must preserve chunking-invariance.

**Signature**

```ts
declare const foldChunksEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L699)

Since v2.0.0
Sink-foldEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldEffect

A sink that effectfully folds its inputs with the provided function,
termination predicate and initial state.

**Signature**

```ts
declare const foldEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L712)

Since v2.0.0
Sink-foldLeft.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldLeft

A sink that folds its inputs with the provided function and initial state.

**Signature**

```ts
declare const foldLeft: <S, In>(s: S, f: (s: S, input: In) => S) => Sink<S, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L724)

Since v2.0.0
Sink-foldLeftChunks.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldLeftChunks

A sink that folds its input chunks with the provided function and initial
state. `f` must preserve chunking-invariance.

**Signature**

```ts
declare const foldLeftChunks: <S, In>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L733)

Since v2.0.0
Sink-foldLeftChunksEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldLeftChunksEffect

A sink that effectfully folds its input chunks with the provided function
and initial state. `f` must preserve chunking-invariance.

**Signature**

```ts
declare const foldLeftChunksEffect: <S, In, E, R>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L743)

Since v2.0.0
Sink-foldLeftEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldLeftEffect

A sink that effectfully folds its inputs with the provided function and
initial state.

**Signature**

```ts
declare const foldLeftEffect: <S, In, E, R>(s: S, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L755)

Since v2.0.0
Sink-foldSink.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldSink

Folds over the result of the sink

**Signature**

```ts
declare const foldSink: { <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): <L, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L659)

Since v2.0.0
Sink-foldUntil.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldUntil

Creates a sink that folds elements of type `In` into a structure of type
`S` until `max` elements have been folded.

Like `Sink.foldWeighted`, but with a constant cost function of `1`.

**Signature**

```ts
declare const foldUntil: <In, S>(s: S, max: number, f: (s: S, input: In) => S) => Sink<S, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L769)

Since v2.0.0
Sink-foldUntilEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldUntilEffect

Creates a sink that effectfully folds elements of type `In` into a
structure of type `S` until `max` elements have been folded.

Like `Sink.foldWeightedEffect` but with a constant cost function of `1`.

**Signature**

```ts
declare const foldUntilEffect: <S, In, E, R>(s: S, max: number, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L780)

Since v2.0.0
Sink-foldWeighted.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldWeighted

Creates a sink that folds elements of type `In` into a structure of type `S`,
until `max` worth of elements (determined by the `costFn`) have been folded.

**Note**

Elements that have an individual cost larger than `max` will force the sink
to cross the `max` cost. See `Sink.foldWeightedDecompose` for a variant
that can handle these cases.

**Signature**

```ts
declare const foldWeighted: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L799)

Since v2.0.0
Sink-foldWeightedDecompose.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldWeightedDecompose

Creates a sink that folds elements of type `In` into a structure of type
`S`, until `max` worth of elements (determined by the `costFn`) have been
folded.

The `decompose` function will be used for decomposing elements that cause
an `S` aggregate to cross `max` into smaller elements. For example:

```ts
pipe(
  Stream.make(1, 5, 1),
  Stream.transduce(
    Sink.foldWeightedDecompose(
      Chunk.empty<number>(),
      4,
      (n: number) => n,
      (n: number) => Chunk.make(n - 1, 1),
      (acc, el) => pipe(acc, Chunk.append(el))
    )
  ),
  Stream.runCollect
)
```

The stream would emit the elements `Chunk(1), Chunk(4), Chunk(1, 1)`.

Be vigilant with this function, it has to generate "simpler" values or the
fold may never end. A value is considered indivisible if `decompose` yields
the empty chunk or a single-valued chunk. In these cases, there is no other
choice than to yield a value that will cross the threshold.

`Sink.foldWeightedDecomposeEffect` allows the decompose function to return an
effect value, and consequently it allows the sink to fail.

**Signature**

```ts
declare const foldWeightedDecompose: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly decompose: (input: In) => Chunk.Chunk<In>; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L845)

Since v2.0.0
Sink-foldWeightedDecomposeEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldWeightedDecomposeEffect

Creates a sink that effectfully folds elements of type `In` into a
structure of type `S`, until `max` worth of elements (determined by the
`costFn`) have been folded.

The `decompose` function will be used for decomposing elements that cause
an `S` aggregate to cross `max` into smaller elements. Be vigilant with
this function, it has to generate "simpler" values or the fold may never
end. A value is considered indivisible if `decompose` yields the empty
chunk or a single-valued chunk. In these cases, there is no other choice
than to yield a value that will cross the threshold.

See `Sink.foldWeightedDecompose` for an example.

**Signature**

```ts
declare const foldWeightedDecomposeEffect: <S, In, E, R, E2, R2, E3, R3>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>; }) => Sink<S, In, In, E | E2 | E3, R | R2 | R3>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L872)

Since v2.0.0
Sink-foldWeightedEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.foldWeightedEffect

Creates a sink that effectfully folds elements of type `In` into a
structure of type `S`, until `max` worth of elements (determined by the
`costFn`) have been folded.

**Signature**

```ts
declare const foldWeightedEffect: <S, In, E, R, E2, R2>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>; }) => Sink<S, In, In, E | E2, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L895)

Since v2.0.0
Sink-forEach.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.forEach

A sink that executes the provided effectful function for every element fed
to it.

**Signature**

```ts
declare const forEach: <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L911)

Since v2.0.0
Sink-forEachChunk.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.forEachChunk

A sink that executes the provided effectful function for every chunk fed to
it.

**Signature**

```ts
declare const forEachChunk: <In, X, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L921)

Since v2.0.0
Sink-forEachChunkWhile.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.forEachChunkWhile

A sink that executes the provided effectful function for every chunk fed to
it until `f` evaluates to `false`.

**Signature**

```ts
declare const forEachChunkWhile: <In, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L932)

Since v2.0.0
Sink-forEachWhile.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.forEachWhile

A sink that executes the provided effectful function for every element fed
to it until `f` evaluates to `false`.

**Signature**

```ts
declare const forEachWhile: <In, E, R>(f: (input: In) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L943)

Since v2.0.0
Sink-fromChannel.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.fromChannel

Creates a sink from a `Channel`.

**Signature**

```ts
declare const fromChannel: <L, In, E, A, R>(channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>) => Sink<A, In, L, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L972)

Since v2.0.0
Sink-fromEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.fromEffect

Creates a single-value sink produced from an effect.

**Signature**

```ts
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L992)

Since v2.0.0
Sink-fromPubSub.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.fromPubSub

Create a sink which publishes each element to the specified `PubSub`.

If the `shutdown` parameter is `true`, the `PubSub` will be shutdown after
the sink is evaluated (defaults to `false`).

**Signature**

```ts
declare const fromPubSub: <In>(pubsub: PubSub.PubSub<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1004)

Since v2.0.0
Sink-fromPush.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.fromPush

Creates a sink from a chunk processing function.

**Signature**

```ts
declare const fromPush: <In, L0, R0, L, R>(push: Effect.Effect<(_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>, never, R>) => Sink<R0, In, L, L0, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1017)

Since v2.0.0
Sink-fromQueue.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.fromQueue

Create a sink which enqueues each element into the specified queue.

If the `shutdown` parameter is `true`, the queue will be shutdown after the
sink is evaluated (defaults to `false`).

**Signature**

```ts
declare const fromQueue: <In>(queue: Queue.Enqueue<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1034)

Since v2.0.0
Sink-head.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.head

Creates a sink containing the first value.

**Signature**

```ts
declare const head: <In>() => Sink<Option.Option<In>, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1047)

Since v2.0.0
Sink-ignoreLeftover.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.ignoreLeftover

Drains the remaining elements from the stream after the sink finishes

**Signature**

```ts
declare const ignoreLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1055)

Since v2.0.0
Sink-last.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.last

Creates a sink containing the last value.

**Signature**

```ts
declare const last: <In>() => Sink<Option.Option<In>, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1064)

Since v2.0.0
Sink-leftover.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.leftover

Creates a sink that does not consume any input but provides the given chunk
as its leftovers

**Signature**

```ts
declare const leftover: <L>(chunk: Chunk.Chunk<L>) => Sink<void, unknown, L>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1073)

Since v2.0.0
Sink-map.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.map

Transforms this sink's result.

**Signature**

```ts
declare const map: { <A, A2>(f: (a: A) => A2): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, f: (a: A) => A2): Sink<A2, In, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1081)

Since v2.0.0
Sink-mapEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mapEffect

Effectfully transforms this sink's result.

**Signature**

```ts
declare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>): Sink<A2, In, L, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1092)

Since v2.0.0
Sink-mapError.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mapError

Transforms the errors emitted by this sink using `f`.

**Signature**

```ts
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, f: (error: E) => E2): Sink<A, In, L, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1108)

Since v2.0.0
Sink-mapInput.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mapInput

Transforms this sink's input elements.

**Signature**

```ts
declare const mapInput: { <In0, In>(f: (input: In0) => In): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (input: In0) => In): Sink<A, In0, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L269)

Since v2.0.0
Sink-mapInputChunks.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mapInputChunks

Transforms this sink's input chunks. `f` must preserve chunking-invariance.

**Signature**

```ts
declare const mapInputChunks: { <In0, In>(f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): Sink<A, In0, L, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L296)

Since v2.0.0
Sink-mapInputChunksEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mapInputChunksEffect

Effectfully transforms this sink's input chunks. `f` must preserve
chunking-invariance.

**Signature**

```ts
declare const mapInputChunksEffect: { <In0, In, E2, R2>(f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L313)

Since v2.0.0
Sink-mapInputEffect.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mapInputEffect

Effectfully transforms this sink's input elements.

**Signature**

```ts
declare const mapInputEffect: { <In0, In, E2, R2>(f: (input: In0) => Effect.Effect<In, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In0) => Effect.Effect<In, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L280)

Since v2.0.0
Sink-mapLeftover.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mapLeftover

Transforms the leftovers emitted by this sink using `f`.

**Signature**

```ts
declare const mapLeftover: { <L, L2>(f: (leftover: L) => L2): <A, In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L2, E, R>; <A, In, L, E, R, L2>(self: Sink<A, In, L, E, R>, f: (leftover: L) => L2): Sink<A, In, L2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1119)

Since v2.0.0
Sink-mkString.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.mkString

Creates a sink which transforms it's inputs into a string.

**Signature**

```ts
declare const mkString: Sink<string, unknown, never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1130)

Since v2.0.0
Sink-never.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.never

Creates a sink which never terminates.

**Signature**

```ts
declare const never: Sink<never, unknown, never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1138)

Since v2.0.0
Sink-orElse.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.orElse

Switch to another sink in case of failure

**Signature**

```ts
declare const orElse: { <A2, In2, L2, E2, R2>(that: LazyArg<Sink<A2, In2, L2, E2, R2>>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: LazyArg<Sink<A2, In2, L2, E2, R2>>): Sink<A | A2, In & In2, L | L2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1146)

Since v2.0.0
Sink-provideContext.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.provideContext

Provides the sink with its required context, which eliminates its
dependency on `R`.

**Signature**

```ts
declare const provideContext: { <R>(context: Context.Context<R>): <A, In, L, E>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, never>; <A, In, L, E, R>(self: Sink<A, In, L, E, R>, context: Context.Context<R>): Sink<A, In, L, E, never>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1163)

Since v2.0.0
Sink-race.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.race

Runs both sinks in parallel on the input, , returning the result or the
error from the one that finishes first.

**Signature**

```ts
declare const race: { <R1, E1, In1, L1, A1>(that: Sink<A1, In1, L1, E1, R1>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>): Sink<A | A1, In & In1, L | L1, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1175)

Since v2.0.0
Sink-raceBoth.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.raceBoth

Runs both sinks in parallel on the input, returning the result or the error
from the one that finishes first.

**Signature**

```ts
declare const raceBoth: { <A1, In1, L1, E1, R1>(that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): Sink<Either.Either<A1, A>, In & In1, L | L1, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1192)

Since v2.0.0
Sink-raceWith.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.raceWith

Runs both sinks in parallel on the input, using the specified merge
function as soon as one result or the other has been computed.

**Signature**

```ts
declare const raceWith: { <A2, In2, L2, E2, R2, A, E, A3, A4>(options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>; readonly capacity?: number | undefined; }): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(self: Sink<A, In, L, E, R>, options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E | E2, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E | E2, A4>; readonly capacity?: number | undefined; }): Sink<A3 | A4, In & In2, L | L2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1211)

Since v2.0.0
Sink-some.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.some

A sink that returns whether an element satisfies the specified predicate.

**Signature**

```ts
declare const some: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1262)

Since v2.0.0
Sink-splitWhere.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.splitWhere

Splits the sink on the specified predicate, returning a new sink that
consumes elements until an element after the first satisfies the specified
predicate.

**Signature**

```ts
declare const splitWhere: { <In>(f: Predicate<In>): <A, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, In, E, R>; <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>, f: Predicate<In>): Sink<A, In, In, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1272)

Since v2.0.0
Sink-succeed.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.succeed

A sink that immediately ends with the specified value.

**Signature**

```ts
declare const succeed: <A>(a: A) => Sink<A, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1283)

Since v2.0.0
Sink-sum.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.sum

A sink that sums incoming numeric values.

**Signature**

```ts
declare const sum: Sink<number, number, never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1291)

Since v2.0.0
STM-acquireUseRelease.md
Package: `effect`<br />
Module: `STM`<br />

## STM.acquireUseRelease

Treats the specified `acquire` transaction as the acquisition of a
resource. The `acquire` transaction will be executed interruptibly. If it
is a success and is committed the specified `release` workflow will be
executed uninterruptibly as soon as the `use` workflow completes execution.

**Signature**

```ts
declare const acquireUseRelease: { <A, A2, E2, R2, A3, E3, R3>(use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): <E, R>(acquire: STM<A, E, R>) => Effect.Effect<A2, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(acquire: STM<A, E, R>, use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): Effect.Effect<A2, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L173)

Since v2.0.0
STM-all.md
Package: `effect`<br />
Module: `STM`<br />

## STM.all

Runs all the provided transactional effects in sequence respecting the
structure provided in input.

Supports multiple arguments, a single argument tuple / array or record /
struct.

**Signature**

```ts
declare const all: All.Signature
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L256)

Since v2.0.0
STM-as.md
Package: `effect`<br />
Module: `STM`<br />

## STM.as

Maps the success value of this effect to the specified constant value.

**Signature**

```ts
declare const as: { <A2>(value: A2): <A, E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, value: A2): STM<A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L264)

Since v2.0.0
STM-asSome.md
Package: `effect`<br />
Module: `STM`<br />

## STM.asSome

Maps the success value of this effect to an optional value.

**Signature**

```ts
declare const asSome: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L275)

Since v2.0.0
STM-asSomeError.md
Package: `effect`<br />
Module: `STM`<br />

## STM.asSomeError

Maps the error value of this effect to an optional value.

**Signature**

```ts
declare const asSomeError: <A, E, R>(self: STM<A, E, R>) => STM<A, Option.Option<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L283)

Since v2.0.0
STM-asVoid.md
Package: `effect`<br />
Module: `STM`<br />

## STM.asVoid

This function maps the success value of an `STM` to `void`. If the original
`STM` succeeds, the returned `STM` will also succeed. If the original `STM`
fails, the returned `STM` will fail with the same error.

**Signature**

```ts
declare const asVoid: <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L293)

Since v2.0.0
STM-attempt.md
Package: `effect`<br />
Module: `STM`<br />

## STM.attempt

Creates an `STM` value from a partial (but pure) function.

**Signature**

```ts
declare const attempt: <A>(evaluate: LazyArg<A>) => STM<A, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L301)

Since v2.0.0
STM-catchAll.md
Package: `effect`<br />
Module: `STM`<br />

## STM.catchAll

Recovers from all errors.

**Signature**

```ts
declare const catchAll: { <E, B, E1, R1>(f: (e: E) => STM<B, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<B | A, E1, R1 | R>; <A, E, R, B, E1, R1>(self: STM<A, E, R>, f: (e: E) => STM<B, E1, R1>): STM<A | B, E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L309)

Since v2.0.0
STM-catchSome.md
Package: `effect`<br />
Module: `STM`<br />

## STM.catchSome

Recovers from some or all of the error cases.

**Signature**

```ts
declare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<STM<A2, E2, R2>>): <A, R>(self: STM<A, E, R>) => STM<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<STM<A2, E2, R2>>): STM<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L320)

Since v2.0.0
STM-catchTag.md
Package: `effect`<br />
Module: `STM`<br />

## STM.catchTag

Recovers from the specified tagged error.

**Signature**

```ts
declare const catchTag: { <K extends E["_tag"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E["_tag"] & string, A1, E1, R1>(self: STM<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): STM<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L336)

Since v2.0.0
STM-catchTags.md
Package: `effect`<br />
Module: `STM`<br />

## STM.catchTags

Recovers from multiple tagged errors.

**Signature**

```ts
declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(cases: Cases): <A, R>(self: STM<A, E, R>) => STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E extends { _tag: string; }, A, Cases extends { [K in E["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(self: STM<A, E, R>, cases: Cases): STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L354)

Since v2.0.0
STM-check.md
Package: `effect`<br />
Module: `STM`<br />

## STM.check

Checks the condition, and if it's true, returns unit, otherwise, retries.

**Signature**

```ts
declare const check: (predicate: LazyArg<boolean>) => STM<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L394)

Since v2.0.0
STM-collect.md
Package: `effect`<br />
Module: `STM`<br />

## STM.collect

Simultaneously filters and maps the value produced by this effect.

**Signature**

```ts
declare const collect: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<A2>): STM<A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L402)

Since v2.0.0
STM-collectSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.collectSTM

Simultaneously filters and maps the value produced by this effect.

**Signature**

```ts
declare const collectSTM: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<STM<A2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<A2, E2, R2>>): STM<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L413)

Since v2.0.0
STM-commit.md
Package: `effect`<br />
Module: `STM`<br />

## STM.commit

Commits this transaction atomically.

**Signature**

```ts
declare const commit: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L424)

Since v2.0.0
STM-commitEither.md
Package: `effect`<br />
Module: `STM`<br />

## STM.commitEither

Commits this transaction atomically, regardless of whether the transaction
is a success or a failure.

**Signature**

```ts
declare const commitEither: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L433)

Since v2.0.0
STM-cond.md
Package: `effect`<br />
Module: `STM`<br />

## STM.cond

Similar to Either.cond, evaluate the predicate, return the given A as
success if predicate returns true, and the given E as error otherwise

**Signature**

```ts
declare const cond: <A, E>(predicate: LazyArg<boolean>, error: LazyArg<E>, result: LazyArg<A>) => STM<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L442)

Since v2.0.0
STM-context.md
Package: `effect`<br />
Module: `STM`<br />

## STM.context

Retrieves the environment inside an stm.

**Signature**

```ts
declare const context: <R>() => STM<Context.Context<R>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L450)

Since v2.0.0
STM-contextWith.md
Package: `effect`<br />
Module: `STM`<br />

## STM.contextWith

Accesses the environment of the transaction to perform a transaction.

**Signature**

```ts
declare const contextWith: <R0, R>(f: (environment: Context.Context<R0>) => R) => STM<R, never, R0>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L458)

Since v2.0.0
STM-contextWithSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.contextWithSTM

Accesses the environment of the transaction to perform a transaction.

**Signature**

```ts
declare const contextWithSTM: <R0, A, E, R>(f: (environment: Context.Context<R0>) => STM<A, E, R>) => STM<A, E, R0 | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L466)

Since v2.0.0
STM-die.md
Package: `effect`<br />
Module: `STM`<br />

## STM.die

Fails the transactional effect with the specified defect.

**Signature**

```ts
declare const die: (defect: unknown) => STM<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L488)

Since v2.0.0
STM-dieMessage.md
Package: `effect`<br />
Module: `STM`<br />

## STM.dieMessage

Kills the fiber running the effect with a `Cause.RuntimeException` that
contains the specified message.

**Signature**

```ts
declare const dieMessage: (message: string) => STM<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L497)

Since v2.0.0
STM-dieSync.md
Package: `effect`<br />
Module: `STM`<br />

## STM.dieSync

Fails the transactional effect with the specified lazily evaluated defect.

**Signature**

```ts
declare const dieSync: (evaluate: LazyArg<unknown>) => STM<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L505)

Since v2.0.0
Sink-summarized.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.summarized

Summarize a sink by running an effect when the sink starts and again when
it completes.

**Signature**

```ts
declare const summarized: { <A2, E2, R2, A3>(summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A3], In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2, A3>(self: Sink<A, In, L, E, R>, summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): Sink<[A, A3], In, L, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1300)

Since v2.0.0
Sink-suspend.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.suspend

Returns a lazily constructed sink that may require effects for its
creation.

**Signature**

```ts
declare const suspend: <A, In, L, E, R>(evaluate: LazyArg<Sink<A, In, L, E, R>>) => Sink<A, In, L, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1319)

Since v2.0.0
Sink-sync.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.sync

A sink that immediately ends with the specified lazy value.

**Signature**

```ts
declare const sync: <A>(evaluate: LazyArg<A>) => Sink<A, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1328)

Since v2.0.0
Sink-take.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.take

A sink that takes the specified number of values.

**Signature**

```ts
declare const take: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1336)

Since v2.0.0
Sink-toChannel.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.toChannel

Creates a `Channel` from a Sink.

**Signature**

```ts
declare const toChannel: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L982)

Since v2.0.0
Sink-unwrap.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.unwrap

Creates a sink produced from an effect.

**Signature**

```ts
declare const unwrap: <A, In, L, E2, R2, E, R>(effect: Effect.Effect<Sink<A, In, L, E2, R2>, E, R>) => Sink<A, In, L, E2 | E, R2 | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1350)

Since v2.0.0
Sink-unwrapScoped.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.unwrapScoped

Creates a sink produced from a scoped effect.

**Signature**

```ts
declare const unwrapScoped: <A, In, L, E, R>(effect: Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1360)

Since v2.0.0
Sink-unwrapScopedWith.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.unwrapScopedWith

Constructs a `Sink` from a function which receives a `Scope` and returns
an effect that will result in a `Sink` if successful.

**Signature**

```ts
declare const unwrapScopedWith: <A, In, L, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1371)

Since v3.11.0
Sink-withDuration.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.withDuration

Returns the sink that executes this one and times its execution.

**Signature**

```ts
declare const withDuration: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Duration.Duration], In, L, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1381)

Since v2.0.0
Sink-zip.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.zip

Feeds inputs to this sink until it yields a result, then switches over to
the provided sink until it yields a result, finally combining the two
results into a tuple.

**Signature**

```ts
declare const zip: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A2], In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<[A, A2], In & In2, L | L2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1393)

Since v2.0.0
Sink-zipLeft.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.zipLeft

Like `Sink.zip` but keeps only the result from this sink.

**Signature**

```ts
declare const zipLeft: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A, In & In2, L | L2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1411)

Since v2.0.0
Sink-zipRight.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.zipRight

Like `Sink.zip` but keeps only the result from `that` sink.

**Signature**

```ts
declare const zipRight: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A2, In & In2, L | L2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1429)

Since v2.0.0
Sink-zipWith.md
Package: `effect`<br />
Module: `Sink`<br />

## Sink.zipWith

Feeds inputs to this sink until it yields a result, then switches over to
the provided sink until it yields a result, finally combining the two
results with `f`.

**Signature**

```ts
declare const zipWith: { <A2, In, In2 extends In, L2, E2, R2, A, A3>(that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A3, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A3, In & In2, L | L2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1449)

Since v2.0.0
SortedMap-fromIterable.md
Package: `effect`<br />
Module: `SortedMap`<br />

## SortedMap.fromIterable

Creates a new `SortedMap` from an iterable collection of key/value pairs.

**Signature**

```ts
declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>; <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L100)

Since v2.0.0
SortedMap-getOrder.md
Package: `effect`<br />
Module: `SortedMap`<br />

## SortedMap.getOrder

Gets the `Order<K>` that the `SortedMap<K, V>` is using.

**Signature**

```ts
declare const getOrder: <K, V>(self: SortedMap<K, V>) => Order<K>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L150)

Since v2.0.0
SortedSet-every.md
Package: `effect`<br />
Module: `SortedSet`<br />

## SortedSet.every

Check if a predicate holds true for every `SortedSet` element.

**Signature**

```ts
declare const every: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L155)

Since v2.0.0
SortedSet-fromIterable.md
Package: `effect`<br />
Module: `SortedSet`<br />

## SortedSet.fromIterable

Creates a new `SortedSet` from an iterable collection of values.

**Signature**

```ts
declare const fromIterable: { <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>; <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L100)

Since v2.0.0
SortedSet-some.md
Package: `effect`<br />
Module: `SortedSet`<br />

## SortedSet.some

Check if a predicate holds true for some `SortedSet` element.

**Signature**

```ts
declare const some: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L332)

Since v2.0.0
SqlResolver-findById.md
Package: `@effect/sql`<br />
Module: `SqlResolver`<br />

## SqlResolver.findById

Create a resolver that resolves results by id.

**Signature**

```ts
declare const findById: <T extends string, I, II, RI, A, IA, Row, E, RA = never, R = never>(tag: T, options: { readonly Id: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA>; readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E>; readonly withContext?: false; } | { readonly Id: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA, RA>; readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E, R>; readonly withContext: true; }) => Effect.Effect<SqlResolver<T, I, Option.Option<A>, E, RI>, never, RA | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlResolver.ts#L345)

Since v1.0.0
SqlResolver-grouped.md
Package: `@effect/sql`<br />
Module: `SqlResolver`<br />

## SqlResolver.grouped

Create a resolver the can return multiple results for a single request.

Results are grouped by a common key extracted from the request and result.

**Signature**

```ts
declare const grouped: <T extends string, I, II, K, RI, A, IA, Row, E, RA = never, R = never>(tag: T, options: { readonly Request: Schema.Schema<I, II, RI>; readonly RequestGroupKey: (request: Types.NoInfer<I>) => K; readonly Result: Schema.Schema<A, IA>; readonly ResultGroupKey: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => K; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E>; readonly withContext?: false; } | { readonly Request: Schema.Schema<I, II, RI>; readonly RequestGroupKey: (request: Types.NoInfer<I>) => K; readonly Result: Schema.Schema<A, IA, RA>; readonly ResultGroupKey: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => K; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E, R>; readonly withContext: true; }) => Effect.Effect<SqlResolver<T, I, Array<A>, E, RI>, never, RA | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlResolver.ts#L266)

Since v1.0.0
SqlResolver-ordered.md
Package: `@effect/sql`<br />
Module: `SqlResolver`<br />

## SqlResolver.ordered

Create a resolver for a sql query with a request schema and a result schema.

The request schema is used to validate the input of the query.
The result schema is used to validate the output of the query.

Results are mapped to the requests in order, so the length of the results must match the length of the requests.

**Signature**

```ts
declare const ordered: <T extends string, I, II, RI, A, IA, _, E, RA = never, R = never>(tag: T, options: { readonly Request: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E>; readonly withContext?: false; } | { readonly Request: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA, RA>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E, R>; readonly withContext: true; }) => Effect.Effect<SqlResolver<T, I, A, E | ResultLengthMismatch, RI>, never, RA | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlResolver.ts#L196)

Since v1.0.0
SqlResolver-void.md
Package: `@effect/sql`<br />
Module: `SqlResolver`<br />

## SqlResolver.void

Create a resolver that performs side effects.

**Signature**

```ts
declare const void: <T extends string, I, II, RI, E, R = never>(tag: T, options: { readonly Request: Schema.Schema<I, II, RI>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<unknown>, E>; readonly withContext?: false; } | { readonly Request: Schema.Schema<I, II, RI>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<unknown>, E, R>; readonly withContext: true; }) => Effect.Effect<SqlResolver<T, I, void, E, RI>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlResolver.ts#L472)

Since v1.0.0
SqlSchema-findAll.md
Package: `@effect/sql`<br />
Module: `SqlSchema`<br />

## SqlSchema.findAll

Run a sql query with a request schema and a result schema.

**Signature**

```ts
declare const findAll: <IR, II, IA, AR, AI, A, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly Result: Schema.Schema<A, AI, AR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<ReadonlyArray<A>, E | ParseError, R | IR | AR>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlSchema.ts#L16)

Since v1.0.0
SqlSchema-findOne.md
Package: `@effect/sql`<br />
Module: `SqlSchema`<br />

## SqlSchema.findOne

Run a sql query with a request schema and a result schema and return the first result.

**Signature**

```ts
declare const findOne: <IR, II, IA, AR, AI, A, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly Result: Schema.Schema<A, AI, AR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<Option.Option<A>, E | ParseError, R | IR | AR>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlSchema.ts#L60)

Since v1.0.0
SqlSchema-single.md
Package: `@effect/sql`<br />
Module: `SqlSchema`<br />

## SqlSchema.single

Run a sql query with a request schema and a result schema and return the first result.

**Signature**

```ts
declare const single: <IR, II, IA, AR, AI, A, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly Result: Schema.Schema<A, AI, AR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<A, E | ParseError | Cause.NoSuchElementException, R | IR | AR>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlSchema.ts#L82)

Since v1.0.0
SqlSchema-void.md
Package: `@effect/sql`<br />
Module: `SqlSchema`<br />

## SqlSchema.void

Run a sql query with a request schema and discard the result.

**Signature**

```ts
declare const void: <IR, II, IA, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<void, E | ParseError, R | IR>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/sql/src/SqlSchema.ts#L51)

Since v1.0.0
Sse-makeParser.md
Package: `@effect/experimental`<br />
Module: `Sse`<br />

## Sse.makeParser

Create a SSE parser.

Adapted from https://github.com/rexxars/eventsource-parser under MIT license.

**Signature**

```ts
declare const makeParser: (onParse: (event: AnyEvent) => void) => Parser
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/experimental/src/Sse.ts#L93)

Since v1.0.0
STM-either.md
Package: `effect`<br />
Module: `STM`<br />

## STM.either

Converts the failure channel into an `Either`.

**Signature**

```ts
declare const either: <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L513)

Since v2.0.0
STM-ensuring.md
Package: `effect`<br />
Module: `STM`<br />

## STM.ensuring

Executes the specified finalization transaction whether or not this effect
succeeds. Note that as with all STM transactions, if the full transaction
fails, everything will be rolled back.

**Signature**

```ts
declare const ensuring: { <R1, B>(finalizer: STM<B, never, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, R1 | R>; <A, E, R, R1, B>(self: STM<A, E, R>, finalizer: STM<B, never, R1>): STM<A, E, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L523)

Since v2.0.0
STM-eventually.md
Package: `effect`<br />
Module: `STM`<br />

## STM.eventually

Returns an effect that ignores errors and runs repeatedly until it
eventually succeeds.

**Signature**

```ts
declare const eventually: <A, E, R>(self: STM<A, E, R>) => STM<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L535)

Since v2.0.0
STM-every.md
Package: `effect`<br />
Module: `STM`<br />

## STM.every

Determines whether all elements of the `Iterable<A>` satisfy the effectual
predicate.

**Signature**

```ts
declare const every: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L544)

Since v2.0.0
STM-exists.md
Package: `effect`<br />
Module: `STM`<br />

## STM.exists

Determines whether any element of the `Iterable[A]` satisfies the effectual
predicate `f`.

**Signature**

```ts
declare const exists: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L556)

Since v2.0.0
STM-fail.md
Package: `effect`<br />
Module: `STM`<br />

## STM.fail

Fails the transactional effect with the specified error.

**Signature**

```ts
declare const fail: <E>(error: E) => STM<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L567)

Since v2.0.0
STM-failSync.md
Package: `effect`<br />
Module: `STM`<br />

## STM.failSync

Fails the transactional effect with the specified lazily evaluated error.

**Signature**

```ts
declare const failSync: <E>(evaluate: LazyArg<E>) => STM<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L575)

Since v2.0.0
STM-fiberId.md
Package: `effect`<br />
Module: `STM`<br />

## STM.fiberId

Returns the fiber id of the fiber committing the transaction.

**Signature**

```ts
declare const fiberId: STM<FiberId.FiberId, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L583)

Since v2.0.0
STM-filter.md
Package: `effect`<br />
Module: `STM`<br />

## STM.filter

Filters the collection using the specified effectual predicate.

**Signature**

```ts
declare const filter: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L591)

Since v2.0.0
STM-filterNot.md
Package: `effect`<br />
Module: `STM`<br />

## STM.filterNot

Filters the collection using the specified effectual predicate, removing
all elements that satisfy the predicate.

**Signature**

```ts
declare const filterNot: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L603)

Since v2.0.0
STM-filterOrDie.md
Package: `effect`<br />
Module: `STM`<br />

## STM.filterOrDie

Dies with specified defect if the predicate fails.

**Signature**

```ts
declare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, defect: LazyArg<unknown>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, defect: LazyArg<unknown>): STM<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L614)

Since v2.0.0
STM-filterOrDieMessage.md
Package: `effect`<br />
Module: `STM`<br />

## STM.filterOrDieMessage

Dies with a `Cause.RuntimeException` having the specified  message if the
predicate fails.

**Signature**

```ts
declare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, message: string): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, message: string): STM<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L631)

Since v2.0.0
STM-filterOrElse.md
Package: `effect`<br />
Module: `STM`<br />

## STM.filterOrElse

Supplies `orElse` if the predicate fails.

**Signature**

```ts
declare const filterOrElse: { <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => STM<C, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<B | C, E2 | E, R2 | R>; <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => STM<B, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A | B, E2 | E, R2 | R>; <A, E, R, B extends A, C, E2, R2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => STM<C, E2, R2>): STM<B | C, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: STM<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => STM<B, E2, R2>): STM<A | B, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L644)

Since v2.0.0
STM-filterOrFail.md
Package: `effect`<br />
Module: `STM`<br />

## STM.filterOrFail

Fails with the specified error if the predicate fails.

**Signature**

```ts
declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): STM<B, E | E2, R>; <A, E, R, E2>(self: STM<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): STM<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L671)

Since v2.0.0
STM-firstSuccessOf.md
Package: `effect`<br />
Module: `STM`<br />

## STM.firstSuccessOf

This function takes an iterable of `STM` values and returns a new
`STM` value that represents the first `STM` value in the iterable
that succeeds. If all of the `Effect` values in the iterable fail, then
the resulting `STM` value will fail as well.

This function is sequential, meaning that the `STM` values in the
iterable will be executed in sequence, and the first one that succeeds
will determine the outcome of the resulting `STM` value.

Returns a new `STM` value that represents the first successful
`STM` value in the iterable, or a failed `STM` value if all of the
`STM` values in the iterable fail.

**Signature**

```ts
declare const firstSuccessOf: <A, E, R>(effects: Iterable<STM<A, E, R>>) => STM<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1983)

Since v2.0.0
STM-flatMap.md
Package: `effect`<br />
Module: `STM`<br />

## STM.flatMap

Feeds the value produced by this effect to the specified function, and then
runs the returned effect as well to produce its results.

**Signature**

```ts
declare const flatMap: { <A, A2, E1, R1>(f: (a: A) => STM<A2, E1, R1>): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A2, E1, R1>(self: STM<A, E, R>, f: (a: A) => STM<A2, E1, R1>): STM<A2, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L695)

Since v2.0.0
STM-flatten.md
Package: `effect`<br />
Module: `STM`<br />

## STM.flatten

Flattens out a nested `STM` effect.

**Signature**

```ts
declare const flatten: <A, E2, R2, E, R>(self: STM<STM<A, E2, R2>, E, R>) => STM<A, E2 | E, R2 | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L706)

Since v2.0.0
STM-flip.md
Package: `effect`<br />
Module: `STM`<br />

## STM.flip

Flips the success and failure channels of this transactional effect. This
allows you to use all methods on the error channel, possibly before
flipping back.

**Signature**

```ts
declare const flip: <A, E, R>(self: STM<A, E, R>) => STM<E, A, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L716)

Since v2.0.0
STM-flipWith.md
Package: `effect`<br />
Module: `STM`<br />

## STM.flipWith

Swaps the error/value parameters, applies the function `f` and flips the
parameters back

**Signature**

```ts
declare const flipWith: { <E, A, R, E2, A2, R2>(f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): (self: STM<A, E, R>) => STM<A | A2, E | E2, R | R2>; <A, E, R, E2, A2, R2>(self: STM<A, E, R>, f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): STM<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L725)

Since v2.0.0
STM-forEach.md
Package: `effect`<br />
Module: `STM`<br />

## STM.forEach

Applies the function `f` to each element of the `Iterable<A>` and returns
a transactional effect that produces a new `Chunk<A2>`.

**Signature**

```ts
declare const forEach: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): (elements: Iterable<A>) => STM<Array<A2>, E, R>; <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): (elements: Iterable<A>) => STM<void, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): STM<Array<A2>, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L770)

Since v2.0.0
STM-fromEither.md
Package: `effect`<br />
Module: `STM`<br />

## STM.fromEither

Lifts an `Either` into a `STM`.

**Signature**

```ts
declare const fromEither: <A, E>(either: Either.Either<A, E>) => STM<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L793)

Since v2.0.0
STM-fromOption.md
Package: `effect`<br />
Module: `STM`<br />

## STM.fromOption

Lifts an `Option` into a `STM`.

**Signature**

```ts
declare const fromOption: <A>(option: Option.Option<A>) => STM<A, Option.Option<never>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L801)

Since v2.0.0
STM-head.md
Package: `effect`<br />
Module: `STM`<br />

## STM.head

Returns a successful effect with the head of the list if the list is
non-empty or fails with the error `None` if the list is empty.

**Signature**

```ts
declare const head: <A, E, R>(self: STM<Iterable<A>, E, R>) => STM<A, Option.Option<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1093)

Since v2.0.0
STM-if.md
Package: `effect`<br />
Module: `STM`<br />

## STM.if

Runs `onTrue` if the result of `b` is `true` and `onFalse` otherwise.

**Signature**

```ts
declare const if: { <A, E1, R1, A2, E2, R2>(options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2>; }): <E = never, R = never>(self: boolean | STM<boolean, E, R>) => STM<A | A2, E1 | E2 | E, R1 | R2 | R>; <A, E1, R1, A2, E2, R2, E = never, R = never>(self: boolean, options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2>; }): STM<A | A2, E1 | E2 | E, R1 | R2 | R>; <E, R, A, E1, R1, A2, E2, R2>(self: STM<boolean, E, R>, options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2>; }): STM<A | A2, E | E1 | E2, R | R1 | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1122)

Since v2.0.0
STM-ignore.md
Package: `effect`<br />
Module: `STM`<br />

## STM.ignore

Returns a new effect that ignores the success or failure of this effect.

**Signature**

```ts
declare const ignore: <A, E, R>(self: STM<A, E, R>) => STM<void, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1131)

Since v2.0.0
STM-interrupt.md
Package: `effect`<br />
Module: `STM`<br />

## STM.interrupt

Interrupts the fiber running the effect.

**Signature**

```ts
declare const interrupt: STM<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1139)

Since v2.0.0
STM-interruptAs.md
Package: `effect`<br />
Module: `STM`<br />

## STM.interruptAs

Interrupts the fiber running the effect with the specified `FiberId`.

**Signature**

```ts
declare const interruptAs: (fiberId: FiberId.FiberId) => STM<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1147)

Since v2.0.0
STM-isFailure.md
Package: `effect`<br />
Module: `STM`<br />

## STM.isFailure

Returns whether this transactional effect is a failure.

**Signature**

```ts
declare const isFailure: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1155)

Since v2.0.0
STM-isSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.isSTM

Returns `true` if the provided value is an `STM`, `false` otherwise.

**Signature**

```ts
declare const isSTM: (u: unknown) => u is STM<unknown, unknown, unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L162)

Since v2.0.0
STM-isSuccess.md
Package: `effect`<br />
Module: `STM`<br />

## STM.isSuccess

Returns whether this transactional effect is a success.

**Signature**

```ts
declare const isSuccess: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1163)

Since v2.0.0
STM-iterate.md
Package: `effect`<br />
Module: `STM`<br />

## STM.iterate

Iterates with the specified transactional function. The moral equivalent
of:

```ts
const s = initial

while (cont(s)) {
  s = body(s)
}

return s
```

**Signature**

```ts
declare const iterate: <Z, E, R>(initial: Z, options: { readonly while: Predicate<Z>; readonly body: (z: Z) => STM<Z, E, R>; }) => STM<Z, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1182)

Since v2.0.0
STM-loop.md
Package: `effect`<br />
Module: `STM`<br />

## STM.loop

Loops with the specified transactional function, collecting the results
into a list. The moral equivalent of:

```ts
const as = []
let s  = initial

while (cont(s)) {
  as.push(body(s))
  s  = inc(s)
}

return as
```

**Signature**

```ts
declare const loop: { <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard?: false | undefined; }): STM<Array<A>, E, R>; <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard: true; }): STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1209)

Since v2.0.0
STM-map.md
Package: `effect`<br />
Module: `STM`<br />

## STM.map

Maps the value produced by the effect.

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1236)

Since v2.0.0
STM-mapAttempt.md
Package: `effect`<br />
Module: `STM`<br />

## STM.mapAttempt

Maps the value produced by the effect with the specified function that may
throw exceptions but is otherwise pure, translating any thrown exceptions
into typed failed effects.

**Signature**

```ts
declare const mapAttempt: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, unknown, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, unknown, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1249)

Since v2.0.0
STM-mapBoth.md
Package: `effect`<br />
Module: `STM`<br />

## STM.mapBoth

Returns an `STM` effect whose failure and success channels have been mapped
by the specified pair of functions, `f` and `g`.

**Signature**

```ts
declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): <R>(self: STM<A, E, R>) => STM<A2, E2, R>; <A, E, R, E2, A2>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): STM<A2, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1261)

Since v2.0.0
STM-mapError.md
Package: `effect`<br />
Module: `STM`<br />

## STM.mapError

Maps from one error type to another.

**Signature**

```ts
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, f: (error: E) => E2): STM<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1277)

Since v2.0.0
STM-mapInputContext.md
Package: `effect`<br />
Module: `STM`<br />

## STM.mapInputContext

Transforms the environment being provided to this effect with the specified
function.

**Signature**

```ts
declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E, R0>; <A, E, R0, R>(self: STM<A, E, R>, f: (context: Context.Context<R0>) => Context.Context<R>): STM<A, E, R0>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L477)

Since v2.0.0
STM-match.md
Package: `effect`<br />
Module: `STM`<br />

## STM.match

Folds over the `STM` effect, handling both failure and success, but not
retry.

**Signature**

```ts
declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: STM<A, E, R>) => STM<A2 | A3, never, R>; <A, E, R, A2, A3>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): STM<A2 | A3, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L737)

Since v2.0.0
STM-matchSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.matchSTM

Effectfully folds over the `STM` effect, handling both failure and success.

**Signature**

```ts
declare const matchSTM: { <E, A1, E1, R1, A, A2, E2, R2>(options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): <R>(self: STM<A, E, R>) => STM<A1 | A2, E1 | E2, R1 | R2 | R>; <A, E, R, A1, E1, R1, A2, E2, R2>(self: STM<A, E, R>, options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): STM<A1 | A2, E1 | E2, R | R1 | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L753)

Since v2.0.0
STM-merge.md
Package: `effect`<br />
Module: `STM`<br />

## STM.merge

Returns a new effect where the error channel has been merged into the
success channel to their common combined type.

**Signature**

```ts
declare const merge: <A, E, R>(self: STM<A, E, R>) => STM<E | A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1289)

Since v2.0.0
STM-mergeAll.md
Package: `effect`<br />
Module: `STM`<br />

## STM.mergeAll

Merges an `Iterable<STM>` to a single `STM`, working sequentially.

**Signature**

```ts
declare const mergeAll: { <A2, A>(zero: A2, f: (a2: A2, a: A) => A2): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A2, E, R>; <A, E, R, A2>(iterable: Iterable<STM<A, E, R>>, zero: A2, f: (a2: A2, a: A) => A2): STM<A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1297)

Since v2.0.0
STM-negate.md
Package: `effect`<br />
Module: `STM`<br />

## STM.negate

Returns a new effect where boolean value of this effect is negated.

**Signature**

```ts
declare const negate: <E, R>(self: STM<boolean, E, R>) => STM<boolean, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1308)

Since v2.0.0
STM-none.md
Package: `effect`<br />
Module: `STM`<br />

## STM.none

Requires the option produced by this value to be `None`.

**Signature**

```ts
declare const none: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<void, Option.Option<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1316)

Since v2.0.0
STM-option.md
Package: `effect`<br />
Module: `STM`<br />

## STM.option

Converts the failure channel into an `Option`.

**Signature**

```ts
declare const option: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1324)

Since v2.0.0
STM-orDie.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orDie

Translates `STM` effect failure into death of the fiber, making all
failures unchecked and not a part of the type of the effect.

**Signature**

```ts
declare const orDie: <A, E, R>(self: STM<A, E, R>) => STM<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1333)

Since v2.0.0
STM-orDieWith.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orDieWith

Keeps none of the errors, and terminates the fiber running the `STM` effect
with them, using the specified function to convert the `E` into a defect.

**Signature**

```ts
declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, never, R>; <A, E, R>(self: STM<A, E, R>, f: (error: E) => unknown): STM<A, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1342)

Since v2.0.0
STM-orElse.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orElse

Tries this effect first, and if it fails or retries, tries the other
effect.

**Signature**

```ts
declare const orElse: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<A | A2, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1354)

Since v2.0.0
STM-orElseEither.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orElseEither

Returns a transactional effect that will produce the value of this effect
in left side, unless it fails or retries, in which case, it will produce
the value of the specified effect in right side.

**Signature**

```ts
declare const orElseEither: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<Either.Either<A2, A>, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1367)

Since v2.0.0
STM-orElseFail.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orElseFail

Tries this effect first, and if it fails or retries, fails with the
specified error.

**Signature**

```ts
declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, error: LazyArg<E2>): STM<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1379)

Since v2.0.0
STM-orElseOptional.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orElseOptional

Returns an effect that will produce the value of this effect, unless it
fails with the `None` value, in which case it will produce the value of the
specified effect.

**Signature**

```ts
declare const orElseOptional: { <A2, E2, R2>(that: LazyArg<STM<A2, Option.Option<E2>, R2>>): <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<A2 | A, Option.Option<E2 | E>, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, Option.Option<E>, R>, that: LazyArg<STM<A2, Option.Option<E2>, R2>>): STM<A | A2, Option.Option<E | E2>, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1392)

Since v2.0.0
STM-STM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.STM

`STM<A, E, R>` represents an effect that can be performed transactionally,
 resulting in a failure `E` or a value `A` that may require an environment
 `R` to execute.

Software Transactional Memory is a technique which allows composition of
arbitrary atomic operations.  It is the software analog of transactions in
database systems.

The API is lifted directly from the Haskell package Control.Concurrent.STM
although the implementation does not resemble the Haskell one at all.

See http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM.html

STM in Haskell was introduced in:

Composable memory transactions, by Tim Harris, Simon Marlow, Simon Peyton
Jones, and Maurice Herlihy, in ACM Conference on Principles and Practice of
Parallel Programming 2005.

See https://www.microsoft.com/en-us/research/publication/composable-memory-transactions/

See also:
 Lock Free Data Structures using STMs in Haskell, by Anthony Discolo, Tim
 Harris, Simon Marlow, Simon Peyton Jones, Satnam Singh) FLOPS 2006: Eighth
 International Symposium on Functional and Logic Programming, Fuji Susono,
 JAPAN, April 2006

 https://www.microsoft.com/en-us/research/publication/lock-free-data-structures-using-stms-in-haskell/

The implemtation is based on the ZIO STM module, while JS environments have
no race conditions from multiple threads STM provides greater benefits for
synchronization of Fibers and transactional data-types can be quite useful.

**Signature**

```ts
export interface STM<out A, out E = never, out R = never>
  extends Effect.Effect<A, E, R>, STM.Variance<A, E, R>, Pipeable
{
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: STMUnify<this>
  [Unify.ignoreSymbol]?: STMUnifyIgnore
  [Symbol.iterator](): Effect.EffectGenerator<STM<A, E, R>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L70)

Since v2.0.0
STM-orElseSucceed.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orElseSucceed

Tries this effect first, and if it fails or retries, succeeds with the
specified value.

**Signature**

```ts
declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, never, R>; <A, E, R, A2>(self: STM<A, E, R>, value: LazyArg<A2>): STM<A | A2, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1409)

Since v2.0.0
STM-orTry.md
Package: `effect`<br />
Module: `STM`<br />

## STM.orTry

Tries this effect first, and if it enters retry, then it tries the other
effect. This is an equivalent of Haskell's orElse.

**Signature**

```ts
declare const orTry: { <A1, E1, R1>(that: LazyArg<STM<A1, E1, R1>>): <A, E, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: LazyArg<STM<A1, E1, R1>>): STM<A | A1, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1421)

Since v2.0.0
STM-partition.md
Package: `effect`<br />
Module: `STM`<br />

## STM.partition

Feeds elements of type `A` to a function `f` that returns an effect.
Collects all successes and failures in a tupled fashion.

**Signature**

```ts
declare const partition: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>): (elements: Iterable<A>) => STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>): STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1433)

Since v2.0.0
STM-provideContext.md
Package: `effect`<br />
Module: `STM`<br />

## STM.provideContext

Provides the transaction its required environment, which eliminates its
dependency on `R`.

**Signature**

```ts
declare const provideContext: { <R>(env: Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E>; <A, E, R>(self: STM<A, E, R>, env: Context.Context<R>): STM<A, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1450)

Since v2.0.0
STM-provideService.md
Package: `effect`<br />
Module: `STM`<br />

## STM.provideService

Provides the effect with the single service it requires. If the transactional
effect requires more than one service use `provideEnvironment` instead.

**Signature**

```ts
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: STM<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): STM<A, E, Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1474)

Since v2.0.0
STM-provideServiceSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.provideServiceSTM

Provides the effect with the single service it requires. If the transactional
effect requires more than one service use `provideEnvironment` instead.

**Signature**

```ts
declare const provideServiceSTM: { <I, S, E1, R1>(tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: STM<A, E, R>, tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): STM<A, E1 | E, R1 | Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1486)

Since v2.0.0
STM-provideSomeContext.md
Package: `effect`<br />
Module: `STM`<br />

## STM.provideSomeContext

Splits the context into two parts, providing one part using the
specified layer and leaving the remainder `R0`.

**Signature**

```ts
declare const provideSomeContext: { <R>(context: Context.Context<R>): <R1, E, A>(self: STM<A, E, R1>) => STM<A, E, Exclude<R1, R>>; <R, R1, E, A>(self: STM<A, E, R1>, context: Context.Context<R>): STM<A, E, Exclude<R1, R>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1462)

Since v2.0.0
STM-reduce.md
Package: `effect`<br />
Module: `STM`<br />

## STM.reduce

Folds an `Iterable<A>` using an effectual function f, working sequentially
from left to right.

**Signature**

```ts
declare const reduce: { <S, A, E, R>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, E, R>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1505)

Since v2.0.0
STM-reduceAll.md
Package: `effect`<br />
Module: `STM`<br />

## STM.reduceAll

Reduces an `Iterable<STM>` to a single `STM`, working sequentially.

**Signature**

```ts
declare const reduceAll: { <A, E2, R2>(initial: STM<A, E2, R2>, f: (x: A, y: A) => A): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(iterable: Iterable<STM<A, E, R>>, initial: STM<A, E2, R2>, f: (x: A, y: A) => A): STM<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1516)

Since v2.0.0
STM-reduceRight.md
Package: `effect`<br />
Module: `STM`<br />

## STM.reduceRight

Folds an `Iterable<A>` using an effectual function f, working sequentially
from right to left.

**Signature**

```ts
declare const reduceRight: { <S, A, R, E>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, R, E>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1535)

Since v2.0.0
STM-refineOrDie.md
Package: `effect`<br />
Module: `STM`<br />

## STM.refineOrDie

Keeps some of the errors, and terminates the fiber with the rest.

**Signature**

```ts
declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>): STM<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1546)

Since v2.0.0
STM-refineOrDieWith.md
Package: `effect`<br />
Module: `STM`<br />

## STM.refineOrDieWith

Keeps some of the errors, and terminates the fiber with the rest, using the
specified function to convert the `E` into a `Throwable`.

**Signature**

```ts
declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): STM<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1558)

Since v2.0.0
STM-reject.md
Package: `effect`<br />
Module: `STM`<br />

## STM.reject

Fail with the returned value if the `PartialFunction` matches, otherwise
continue with our held value.

**Signature**

```ts
declare const reject: { <A, E2>(pf: (a: A) => Option.Option<E2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<E2>): STM<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1570)

Since v2.0.0
STM-rejectSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.rejectSTM

Continue with the returned computation if the specified partial function
matches, translating the successful match into a failure, otherwise continue
with our held value.

**Signature**

```ts
declare const rejectSTM: { <A, E2, R2>(pf: (a: A) => Option.Option<STM<E2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<E2, E2, R2>>): STM<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1583)

Since v2.0.0
STM-repeatUntil.md
Package: `effect`<br />
Module: `STM`<br />

## STM.repeatUntil

Repeats this `STM` effect until its result satisfies the specified
predicate.

**WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will
consume a thread until it completes (it cannot yield). This is because STM
describes a single atomic transaction which must either complete, retry or
fail a transaction before yielding back to the Effect runtime.
  - Use `retryUntil` instead if you don't need to maintain transaction
    state for repeats.
  - Ensure repeating the STM effect will eventually satisfy the predicate.

**Signature**

```ts
declare const repeatUntil: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1603)

Since v2.0.0
STM-repeatWhile.md
Package: `effect`<br />
Module: `STM`<br />

## STM.repeatWhile

Repeats this `STM` effect while its result satisfies the specified
predicate.

**WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will
consume a thread until it completes (it cannot yield). This is because STM
describes a single atomic transaction which must either complete, retry or
fail a transaction before yielding back to the Effect runtime.
  - Use `retryWhile` instead if you don't need to maintain transaction
    state for repeats.
  - Ensure repeating the STM effect will eventually not satisfy the
    predicate.

**Signature**

```ts
declare const repeatWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1624)

Since v2.0.0
STM-replicate.md
Package: `effect`<br />
Module: `STM`<br />

## STM.replicate

Replicates the given effect n times. If 0 or negative numbers are given, an
empty `Chunk` will be returned.

**Signature**

```ts
declare const replicate: { (n: number): <A, E, R>(self: STM<A, E, R>) => Array<STM<A, E, R>>; <A, E, R>(self: STM<A, E, R>, n: number): Array<STM<A, E, R>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1636)

Since v2.0.0
STM-replicateSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.replicateSTM

Performs this transaction the specified number of times and collects the
results.

**Signature**

```ts
declare const replicateSTM: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<Array<A>, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1648)

Since v2.0.0
STM-replicateSTMDiscard.md
Package: `effect`<br />
Module: `STM`<br />

## STM.replicateSTMDiscard

Performs this transaction the specified number of times, discarding the
results.

**Signature**

```ts
declare const replicateSTMDiscard: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1660)

Since v2.0.0
STM-retry.md
Package: `effect`<br />
Module: `STM`<br />

## STM.retry

Abort and retry the whole transaction when any of the underlying
transactional variables have changed.

**Signature**

```ts
declare const retry: STM<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1672)

Since v2.0.0
STM-retryUntil.md
Package: `effect`<br />
Module: `STM`<br />

## STM.retryUntil

Filters the value produced by this effect, retrying the transaction until
the predicate returns `true` for the value.

**Signature**

```ts
declare const retryUntil: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1681)

Since v2.0.0
STM-retryWhile.md
Package: `effect`<br />
Module: `STM`<br />

## STM.retryWhile

Filters the value produced by this effect, retrying the transaction while
the predicate returns `true` for the value.

**Signature**

```ts
declare const retryWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1695)

Since v2.0.0
STM-some.md
Package: `effect`<br />
Module: `STM`<br />

## STM.some

Converts an option on values into an option on errors.

**Signature**

```ts
declare const some: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<A, Option.Option<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1706)

Since v2.0.0
STM-succeed.md
Package: `effect`<br />
Module: `STM`<br />

## STM.succeed

Returns an `STM` effect that succeeds with the specified value.

**Signature**

```ts
declare const succeed: <A>(value: A) => STM<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1714)

Since v2.0.0
STM-succeedNone.md
Package: `effect`<br />
Module: `STM`<br />

## STM.succeedNone

Returns an effect with the empty value.

**Signature**

```ts
declare const succeedNone: STM<Option.Option<never>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1722)

Since v2.0.0
STM-succeedSome.md
Package: `effect`<br />
Module: `STM`<br />

## STM.succeedSome

Returns an effect with the optional value.

**Signature**

```ts
declare const succeedSome: <A>(value: A) => STM<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1730)

Since v2.0.0
STM-summarized.md
Package: `effect`<br />
Module: `STM`<br />

## STM.summarized

Summarizes a `STM` effect by computing a provided value before and after
execution, and then combining the values to produce a summary, together
with the result of execution.

**Signature**

```ts
declare const summarized: { <A2, E2, R2, A3>(summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): <A, E, R>(self: STM<A, E, R>) => STM<[A3, A], E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: STM<A, E, R>, summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): STM<[A3, A], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1740)

Since v2.0.0
STM-suspend.md
Package: `effect`<br />
Module: `STM`<br />

## STM.suspend

Suspends creation of the specified transaction lazily.

**Signature**

```ts
declare const suspend: <A, E, R>(evaluate: LazyArg<STM<A, E, R>>) => STM<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1758)

Since v2.0.0
STM-sync.md
Package: `effect`<br />
Module: `STM`<br />

## STM.sync

Returns an `STM` effect that succeeds with the specified lazily evaluated
value.

**Signature**

```ts
declare const sync: <A>(evaluate: () => A) => STM<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1767)

Since v2.0.0
STM-tap.md
Package: `effect`<br />
Module: `STM`<br />

## STM.tap

"Peeks" at the success of transactional effect.

**Signature**

```ts
declare const tap: { <A, X, E2, R2>(f: (a: A) => STM<X, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (a: A) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1775)

Since v2.0.0
STM-tapBoth.md
Package: `effect`<br />
Module: `STM`<br />

## STM.tapBoth

"Peeks" at both sides of an transactional effect.

**Signature**

```ts
declare const tapBoth: { <XE extends E, A2, E2, R2, XA extends A, A3, E3, R3, A, E>(options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): <R>(self: STM<A, E, R>) => STM<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, XE extends E, A2, E2, R2, XA extends A, A3, E3, R3>(self: STM<A, E, R>, options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): STM<A, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1786)

Since v2.0.0
STM-tapError.md
Package: `effect`<br />
Module: `STM`<br />

## STM.tapError

"Peeks" at the error of the transactional effect.

**Signature**

```ts
declare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => STM<X, E2, R2>): <A, R>(self: STM<A, E, R>) => STM<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (error: E) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1802)

Since v2.0.0
STM-try.md
Package: `effect`<br />
Module: `STM`<br />

## STM.try

Imports a synchronous side-effect into a pure value, translating any thrown
exceptions into typed failed effects.

**Signature**

```ts
declare const try: { <A, E>(options: { readonly try: LazyArg<A>; readonly catch: (u: unknown) => E; }): STM<A, E>; <A>(try_: LazyArg<A>): STM<A, unknown>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1823)

Since v2.0.0
STM-unless.md
Package: `effect`<br />
Module: `STM`<br />

## STM.unless

The moral equivalent of `if (!p) exp`

**Signature**

```ts
declare const unless: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1832)

Since v2.0.0
STM-unlessSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.unlessSTM

The moral equivalent of `if (!p) exp` when `p` has side-effects

**Signature**

```ts
declare const unlessSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1843)

Since v2.0.0
STM-unsome.md
Package: `effect`<br />
Module: `STM`<br />

## STM.unsome

Converts an option on errors into an option on values.

**Signature**

```ts
declare const unsome: <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<Option.Option<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1854)

Since v2.0.0
STM-validateAll.md
Package: `effect`<br />
Module: `STM`<br />

## STM.validateAll

Feeds elements of type `A` to `f` and accumulates all errors in error
channel or successes in success channel.

This combinator is lossy meaning that if there are errors all successes
will be lost. To retain all information please use `STM.partition`.

**Signature**

```ts
declare const validateAll: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<Array<B>, [E, ...Array<E>], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<Array<B>, [E, ...Array<E>], R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1877)

Since v2.0.0
STM-validateFirst.md
Package: `effect`<br />
Module: `STM`<br />

## STM.validateFirst

Feeds elements of type `A` to `f` until it succeeds. Returns first success
or the accumulation of all errors.

**Signature**

```ts
declare const validateFirst: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<B, Array<E>, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1889)

Since v2.0.0
STM-void.md
Package: `effect`<br />
Module: `STM`<br />

## STM.void

Returns an `STM` effect that succeeds with `void`.

**Signature**

```ts
declare const void: STM<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1864)

Since v2.0.0
STM-when.md
Package: `effect`<br />
Module: `STM`<br />

## STM.when

The moral equivalent of `if (p) exp`.

**Signature**

```ts
declare const when: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1900)

Since v2.0.0
STM-whenSTM.md
Package: `effect`<br />
Module: `STM`<br />

## STM.whenSTM

The moral equivalent of `if (p) exp` when `p` has side-effects.

**Signature**

```ts
declare const whenSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1911)

Since v2.0.0
STM-zip.md
Package: `effect`<br />
Module: `STM`<br />

## STM.zip

Sequentially zips this value with the specified one.

**Signature**

```ts
declare const zip: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<[A, A1], E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<[A, A1], E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1922)

Since v2.0.0
STM-zipLeft.md
Package: `effect`<br />
Module: `STM`<br />

## STM.zipLeft

Sequentially zips this value with the specified one, discarding the second
element of the tuple.

**Signature**

```ts
declare const zipLeft: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1934)

Since v2.0.0
STM-zipRight.md
Package: `effect`<br />
Module: `STM`<br />

## STM.zipRight

Sequentially zips this value with the specified one, discarding the first
element of the tuple.

**Signature**

```ts
declare const zipRight: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A1, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A1, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1946)

Since v2.0.0
STM-zipWith.md
Package: `effect`<br />
Module: `STM`<br />

## STM.zipWith

Sequentially zips this value with the specified one, combining the values
using the specified combiner function.

**Signature**

```ts
declare const zipWith: { <A1, E1, R1, A, A2>(that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A1, E1, R1, A2>(self: STM<A, E, R>, that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): STM<A2, E | E1, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1958)

Since v2.0.0
Stream-accumulate.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.accumulate

Collects each underlying Chunk of the stream into a new chunk, and emits it
on each pull.

**Signature**

```ts
declare const accumulate: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L182)

Since v2.0.0
Stream-accumulateChunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.accumulateChunks

Re-chunks the elements of the stream by accumulating each underlying chunk.

**Signature**

```ts
declare const accumulateChunks: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L190)

Since v2.0.0
Stream-acquireRelease.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.acquireRelease

Creates a stream from a single value that will get cleaned up after the
stream is consumed.

**Example**

```ts
import { Console, Effect, Stream } from "effect"

// Simulating File operations
const open = (filename: string) =>
  Effect.gen(function*() {
    yield* Console.log(`Opening ${filename}`)
    return {
      getLines: Effect.succeed(["Line 1", "Line 2", "Line 3"]),
      close: Console.log(`Closing ${filename}`)
    }
  })

const stream = Stream.acquireRelease(
  open("file.txt"),
  (file) => file.close
).pipe(Stream.flatMap((file) => file.getLines))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Opening file.txt
// Closing file.txt
// { _id: 'Chunk', values: [ [ 'Line 1', 'Line 2', 'Line 3' ] ] }
```

**Signature**

```ts
declare const acquireRelease: <A, E, R, R2, X>(acquire: Effect.Effect<A, E, R>, release: (resource: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>) => Stream<A, E, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L224)

Since v2.0.0
Stream-aggregate.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.aggregate

Aggregates elements of this stream using the provided sink for as long as
the downstream operators on the stream are busy.

This operator divides the stream into two asynchronous "islands". Operators
upstream of this operator run on one fiber, while downstream operators run
on another. Whenever the downstream fiber is busy processing elements, the
upstream fiber will feed elements into the sink until it signals
completion.

Any sink can be used here, but see `Sink.foldWeightedEffect` and
`Sink.foldUntilEffect` for sinks that cover the common usecases.

**Signature**

```ts
declare const aggregate: { <B, A, A2, E2, R2>(sink: Sink.Sink<B, A | A2, A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>): Stream<B, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L245)

Since v2.0.0
Stream-DefaultChunkSize.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.DefaultChunkSize

The default chunk size used by the various combinators and constructors of
`Stream`.

**Signature**

```ts
declare const DefaultChunkSize: number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L173)

Since v2.0.0
Stream-Do.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```

**See**

- `bindTo`
- `bind`
- `bindEffect`
- `let`

**Signature**

```ts
declare const Do: Stream<{}, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6234)

Since v2.0.0
Stream-aggregateWithin.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.aggregateWithin

Like `aggregateWithinEither`, but only returns the `Right` results.

**Signature**

```ts
declare const aggregateWithin: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<B, E | E2, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L256)

Since v2.0.0
Stream-aggregateWithinEither.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.aggregateWithinEither

Aggregates elements using the provided sink until it completes, or until
the delay signalled by the schedule has passed.

This operator divides the stream into two asynchronous islands. Operators
upstream of this operator run on one fiber, while downstream operators run
on another. Elements will be aggregated by the sink until the downstream
fiber pulls the aggregated value, or until the schedule's delay has passed.

Aggregated elements will be fed into the schedule to determine the delays
between pulls.

**Signature**

```ts
declare const aggregateWithinEither: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<Either.Either<B, C>, E | E2, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L283)

Since v2.0.0
Stream-as.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.as

Maps the success values of this stream to the specified constant value.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 5).pipe(Stream.as(null))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ null, null, null, null, null ] }
```

**Signature**

```ts
declare const as: { <B>(value: B): <A, E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, value: B): Stream<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L311)

Since v2.0.0
Stream-async.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.async

Creates a stream from an asynchronous callback that can be called multiple
times. The optionality of the error type `E` in `Emit` can be used to
signal the end of the stream by setting it to `None`.

The registration function can optionally return an `Effect`, which will be
executed if the `Fiber` executing this Effect is interrupted.

**Example**

```ts
import type { StreamEmit } from "effect"
import { Chunk, Effect, Option, Stream } from "effect"

const events = [1, 2, 3, 4]

const stream = Stream.async(
  (emit: StreamEmit.Emit<never, never, number, void>) => {
    events.forEach((n) => {
      setTimeout(() => {
        if (n === 3) {
          emit(Effect.fail(Option.none())) // Terminate the stream
        } else {
          emit(Effect.succeed(Chunk.of(n))) // Add the current item to the stream
        }
      }, 100 * n)
    })
  }
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2 ] }

```

**Signature**

```ts
declare const async: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<void, never, R> | void, bufferSize?: number | "unbounded" | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; } | undefined) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L361)

Since v2.0.0
Stream-asyncEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.asyncEffect

Creates a stream from an asynchronous callback that can be called multiple
times The registration of the callback itself returns an effect. The
optionality of the error type `E` can be used to signal the end of the
stream, by setting it to `None`.

**Signature**

```ts
declare const asyncEffect: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R>, bufferSize?: number | "unbounded" | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; } | undefined) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L373)

Since v2.0.0
Stream-asyncPush.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.asyncPush

Creates a stream from an external push-based resource.

You can use the `emit` helper to emit values to the stream. The `emit` helper
returns a boolean indicating whether the value was emitted or not.

You can also use the `emit` helper to signal the end of the stream by
using apis such as `emit.end` or `emit.fail`.

By default it uses an "unbounded" buffer size.
You can customize the buffer size and strategy by passing an object as the
second argument with the `bufferSize` and `strategy` fields.

**Example**

```ts
import { Effect, Stream } from "effect"

Stream.asyncPush<string>((emit) =>
  Effect.acquireRelease(
    Effect.gen(function*() {
      yield* Effect.log("subscribing")
      return setInterval(() => emit.single("tick"), 1000)
    }),
    (handle) =>
      Effect.gen(function*() {
        yield* Effect.log("unsubscribing")
        clearInterval(handle)
      })
  ), { bufferSize: 16, strategy: "dropping" })
```

**Signature**

```ts
declare const asyncPush: <A, E = never, R = never>(register: (emit: Emit.EmitOpsPush<E, A>) => Effect.Effect<unknown, E, R | Scope.Scope>, options?: { readonly bufferSize: "unbounded"; } | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L415)

Since v3.6.0
Stream-asyncScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.asyncScoped

Creates a stream from an asynchronous callback that can be called multiple
times. The registration of the callback itself returns an a scoped
resource. The optionality of the error type `E` can be used to signal the
end of the stream, by setting it to `None`.

**Signature**

```ts
declare const asyncScoped: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R | Scope.Scope>, bufferSize?: number | "unbounded" | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L432)

Since v2.0.0
Stream-bind.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bindTo`
- `bindEffect`
- `let`

**Signature**

```ts
declare const bind: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E, R2 | R>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6268)

Since v2.0.0
Stream-bindEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.bindEffect

Binds an effectful value in a `do` scope

**See**

- `Do`
- `bindTo`
- `bind`
- `let`

**Signature**

```ts
declare const bindEffect: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; }): Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6297)

Since v2.0.0
Stream-bindTo.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bind`
- `bindEffect`
- `let`

**Signature**

```ts
declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Stream<A, E, R>) => Stream<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Stream<A, E, R>, name: N): Stream<{ [K in N]: A; }, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6343)

Since v2.0.0
Stream-branchAfter.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.branchAfter

Returns a `Stream` that first collects `n` elements from the input `Stream`,
and then creates a new `Stream` using the specified function, and sends all
the following elements through that.

**Signature**

```ts
declare const branchAfter: { <A, A2, E2, R2>(n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L448)

Since v2.0.0
Stream-broadcast.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.broadcast

Fan out the stream, producing a list of streams that have the same elements
as this stream. The driver stream will only ever advance the `maximumLag`
chunks before the slowest downstream stream.

**Example**

```ts
import { Console, Effect, Fiber, Schedule, Stream } from "effect"

const numbers = Effect.scoped(
  Stream.range(1, 20).pipe(
    Stream.tap((n) => Console.log(`Emit ${n} element before broadcasting`)),
    Stream.broadcast(2, 5),
    Stream.flatMap(([first, second]) =>
      Effect.gen(function*() {
        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) => Math.max(acc, e)).pipe(
          Effect.andThen((max) => Console.log(`Maximum: ${max}`)),
          Effect.fork
        )
        const fiber2 = yield* second.pipe(
          Stream.schedule(Schedule.spaced("1 second")),
          Stream.runForEach((n) => Console.log(`Logging to the Console: ${n}`)),
          Effect.fork
        )
        yield* Fiber.join(fiber1).pipe(
          Effect.zip(Fiber.join(fiber2), { concurrent: true })
        )
      })
    ),
    Stream.runCollect
  )
)

Effect.runPromise(numbers).then(console.log)
// Emit 1 element before broadcasting
// Emit 2 element before broadcasting
// Emit 3 element before broadcasting
// Emit 4 element before broadcasting
// Emit 5 element before broadcasting
// Emit 6 element before broadcasting
// Emit 7 element before broadcasting
// Emit 8 element before broadcasting
// Emit 9 element before broadcasting
// Emit 10 element before broadcasting
// Emit 11 element before broadcasting
// Logging to the Console: 1
// Logging to the Console: 2
// Logging to the Console: 3
// Logging to the Console: 4
// Logging to the Console: 5
// Emit 12 element before broadcasting
// Emit 13 element before broadcasting
// Emit 14 element before broadcasting
// Emit 15 element before broadcasting
// Emit 16 element before broadcasting
// Logging to the Console: 6
// Logging to the Console: 7
// Logging to the Console: 8
// Logging to the Console: 9
// Logging to the Console: 10
// Emit 17 element before broadcasting
// Emit 18 element before broadcasting
// Emit 19 element before broadcasting
// Emit 20 element before broadcasting
// Logging to the Console: 11
// Logging to the Console: 12
// Logging to the Console: 13
// Logging to the Console: 14
// Logging to the Console: 15
// Maximum: 20
// Logging to the Console: 16
// Logging to the Console: 17
// Logging to the Console: 18
// Logging to the Console: 19
// Logging to the Console: 20
// { _id: 'Chunk', values: [ undefined ] }
```

**Signature**

```ts
declare const broadcast: { <N extends number>(n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L541)

Since v2.0.0
Stream-broadcastDynamic.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.broadcastDynamic

Fan out the stream, producing a dynamic number of streams that have the
same elements as this stream. The driver stream will only ever advance the
`maximumLag` chunks before the slowest downstream stream.

**Signature**

```ts
declare const broadcastDynamic: { (maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L605)

Since v2.0.0
Stream-broadcastedQueues.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.broadcastedQueues

Converts the stream to a scoped list of queues. Every value will be
replicated to every queue with the slowest queue being allowed to buffer
`maximumLag` chunks before the driver is back pressured.

Queues can unsubscribe from upstream by shutting down.

**Signature**

```ts
declare const broadcastedQueues: { <N extends number>(n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L633)

Since v2.0.0
Stream-broadcastedQueuesDynamic.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.broadcastedQueuesDynamic

Converts the stream to a scoped dynamic amount of queues. Every chunk will
be replicated to every queue with the slowest queue being allowed to buffer
`maximumLag` chunks before the driver is back pressured.

Queues can unsubscribe from upstream by shutting down.

**Signature**

```ts
declare const broadcastedQueuesDynamic: { (maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L665)

Since v2.0.0
Stream-buffer.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.buffer

Allows a faster producer to progress independently of a slower consumer by
buffering up to `capacity` elements in a queue.

Note: This combinator destroys the chunking structure. It's recommended to
      use rechunk afterwards. Additionally, prefer capacities that are powers
      of 2 for better performance.

**Example**

```ts
import { Console, Effect, Schedule, Stream } from "effect"

const stream = Stream.range(1, 10).pipe(
  Stream.tap((n) => Console.log(`before buffering: ${n}`)),
  Stream.buffer({ capacity: 4 }),
  Stream.tap((n) => Console.log(`after buffering: ${n}`)),
  Stream.schedule(Schedule.spaced("5 seconds"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// before buffering: 1
// before buffering: 2
// before buffering: 3
// before buffering: 4
// before buffering: 5
// before buffering: 6
// after buffering: 1
// after buffering: 2
// before buffering: 7
// after buffering: 3
// before buffering: 8
// after buffering: 4
// before buffering: 9
// after buffering: 5
// before buffering: 10
// ...
```

**Signature**

```ts
declare const buffer: { (options: { readonly capacity: "unbounded"; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: "unbounded"; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L726)

Since v2.0.0
Stream-bufferChunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.bufferChunks

Allows a faster producer to progress independently of a slower consumer by
buffering up to `capacity` chunks in a queue.

**Signature**

```ts
declare const bufferChunks: { (options: { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L750)

Since v2.0.0
Stream-catchAll.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.catchAll

Switches over to the stream produced by the provided function in case this
one fails with a typed error.

**Signature**

```ts
declare const catchAll: { <E, A2, E2, R2>(f: (error: E) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L767)

Since v2.0.0
Stream-catchAllCause.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.catchAllCause

Switches over to the stream produced by the provided function in case this
one fails. Allows recovery from all causes of failure, including
interruption if the stream is uninterruptible.

**Signature**

```ts
declare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L780)

Since v2.0.0
Stream-catchSome.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.catchSome

Switches over to the stream produced by the provided function in case this
one fails with some typed error.

**Signature**

```ts
declare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L797)

Since v2.0.0
Stream-catchSomeCause.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.catchSomeCause

Switches over to the stream produced by the provided function in case this
one fails with some errors. Allows recovery from all causes of failure,
including interruption if the stream is uninterruptible.

**Signature**

```ts
declare const catchSomeCause: { <E, A2, E2, R2>(pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L893)

Since v2.0.0
Stream-catchTag.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.catchTag

Switches over to the stream produced by the provided function in case this
one fails with an error matching the given `_tag`.

**Signature**

```ts
declare const catchTag: { <K extends E["_tag"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): <A, R>(self: Stream<A, E, R>) => Stream<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E["_tag"] & string, A1, E1, R1>(self: Stream<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): Stream<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L814)

Since v2.0.0
Stream-catchTags.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.catchTags

Switches over to the stream produced by one of the provided functions, in
case this one fails with an error matching one of the given `_tag`'s.

**Signature**

```ts
declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(cases: Cases): <A, R>(self: Stream<A, E, R>) => Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer A, infer _E, infer _R> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer E, infer _R> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer _E, infer R> ? R : never; }[keyof Cases]>; <A, E extends { _tag: string; }, R, Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(self: Stream<A, E, R>, cases: Cases): Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer _E, infer A> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer E, infer _A> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer R, infer _E, infer _A> ? R : never; }[keyof Cases]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L833)

Since v2.0.0
Stream-changes.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.changes

Returns a new stream that only emits elements that are not equal to the
previous element emitted, using natural equality to determine whether two
elements are equal.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4 ] }
```

**Signature**

```ts
declare const changes: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L921)

Since v2.0.0
Stream-changesWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.changesWith

Returns a new stream that only emits elements that are not equal to the
previous element emitted, using the specified function to determine whether
two elements are equal.

**Signature**

```ts
declare const changesWith: { <A>(f: (x: A, y: A) => boolean): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, f: (x: A, y: A) => boolean): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L931)

Since v2.0.0
Stream-changesWithEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.changesWithEffect

Returns a new stream that only emits elements that are not equal to the
previous element emitted, using the specified effectual function to
determine whether two elements are equal.

**Signature**

```ts
declare const changesWithEffect: { <A, E2, R2>(f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L944)

Since v2.0.0
Stream-chunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.chunks

Exposes the underlying chunks of the stream as a stream of chunks of
elements.

**Signature**

```ts
declare const chunks: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L958)

Since v2.0.0
Stream-chunksWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.chunksWith

Performs the specified stream transformation with the chunk structure of
the stream exposed.

**Signature**

```ts
declare const chunksWith: { <A, E, R, A2, E2, R2>(f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): (self: Stream<A, E, R>) => Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L967)

Since v2.0.0
Stream-combine.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.combine

Combines the elements from this stream and the specified stream by
repeatedly applying the function `f` to extract an element using both sides
and conceptually "offer" it to the destination stream. `f` can maintain
some internal state to control the combining process, with the initial
state being specified by `s`.

Where possible, prefer `Stream.combineChunks` for a more efficient
implementation.

**Signature**

```ts
declare const combine: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L990)

Since v2.0.0
Stream-combineChunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.combineChunks

Combines the chunks from this stream and the specified stream by repeatedly
applying the function `f` to extract a chunk using both sides and
conceptually "offer" it to the destination stream. `f` can maintain some
internal state to control the combining process, with the initial state
being specified by `s`.

**Signature**

```ts
declare const combineChunks: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1022)

Since v2.0.0
Stream-concat.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.concat

Concatenates the specified stream with this stream, resulting in a stream
that emits the elements from this stream and then the elements from the
specified stream.

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)

const stream = Stream.concat(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
declare const concat: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1065)

Since v2.0.0
Stream-concatAll.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.concatAll

Concatenates all of the streams in the chunk to one stream.

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)
const s3 = Stream.make(6, 7, 8)

const stream = Stream.concatAll(Chunk.make(s1, s2, s3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2, 3, 4,
//     5, 6, 7, 8
//   ]
// }
```

**Signature**

```ts
declare const concatAll: <A, E, R>(streams: Chunk.Chunk<Stream<A, E, R>>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1096)

Since v2.0.0
Stream-context.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.context

Accesses the whole context of the stream.

**Signature**

```ts
declare const context: <R>() => Stream<Context.Context<R>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1523)

Since v2.0.0
Stream-contextWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.contextWith

Accesses the context of the stream.

**Signature**

```ts
declare const contextWith: <R, A>(f: (env: Context.Context<R>) => A) => Stream<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1531)

Since v2.0.0
Stream-contextWithEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.contextWithEffect

Accesses the context of the stream in the context of an effect.

**Signature**

```ts
declare const contextWithEffect: <R0, A, E, R>(f: (env: Context.Context<R0>) => Effect.Effect<A, E, R>) => Stream<A, E, R0 | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1539)

Since v2.0.0
Stream-contextWithStream.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.contextWithStream

Accesses the context of the stream in the context of a stream.

**Signature**

```ts
declare const contextWithStream: <R0, A, E, R>(f: (env: Context.Context<R0>) => Stream<A, E, R>) => Stream<A, E, R0 | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1549)

Since v2.0.0
Stream-cross.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.cross

Composes this stream with the specified stream to create a cartesian
product of elements. The `right` stream would be run multiple times, for
every element in the `left` stream.

See also `Stream.zip` for the more common point-wise variant.

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make("a", "b")

const product = Stream.cross(s1, s2)

Effect.runPromise(Stream.runCollect(product)).then(console.log)
// {
//   _id: "Chunk",
//   values: [
//     [ 1, "a" ], [ 1, "b" ], [ 2, "a" ], [ 2, "b" ], [ 3, "a" ], [ 3, "b" ]
//   ]
// }
```

**Signature**

```ts
declare const cross: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, ER, RR, AR, EL, RL>(left: Stream<AL, ER, RR>, right: Stream<AR, EL, RL>): Stream<[AL, AR], EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1126)

Since v2.0.0
Stream-crossLeft.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.crossLeft

Composes this stream with the specified stream to create a cartesian
product of elements, but keeps only elements from `left` stream. The `right`
stream would be run multiple times, for every element in the `left` stream.

See also `Stream.zipLeft` for the more common point-wise variant.

**Signature**

```ts
declare const crossLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1141)

Since v2.0.0
Stream-crossRight.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.crossRight

Composes this stream with the specified stream to create a cartesian
product of elements, but keeps only elements from the `right` stream. The
`left` stream would be run multiple times, for every element in the `right`
stream.

See also `Stream.zipRight` for the more common point-wise variant.

**Signature**

```ts
declare const crossRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1157)

Since v2.0.0
Stream-crossWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.crossWith

Composes this stream with the specified stream to create a cartesian
product of elements with a specified function. The `right` stream would be
run multiple times, for every element in the `left` stream.

See also `Stream.zipWith` for the more common point-wise variant.

**Signature**

```ts
declare const crossWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1172)

Since v2.0.0
Stream-debounce.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.debounce

Delays the emission of values by holding new values for a set duration. If
no new values arrive during that time the value is emitted, however if a
new value is received during the holding period the previous value is
discarded and the process is repeated with the new value.

This operator is useful if you have a stream of "bursty" events which
eventually settle down and you only need the final event of the burst. For
example, a search engine may only want to initiate a search after a user
has paused typing so as to not prematurely recommend results.

**Example**

```ts
import { Effect, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.make(1, 2, 3).pipe(
  Stream.concat(
    Stream.fromEffect(Effect.sleep("200 millis").pipe(Effect.as(4))) // Emit 4 after 200 ms
  ),
  Stream.concat(Stream.make(5, 6)), // Continue with more rapid values
  Stream.concat(
    Stream.fromEffect(Effect.sleep("150 millis").pipe(Effect.as(7))) // Emit 7 after 150 ms
  ),
  Stream.concat(Stream.make(8)),
  Stream.tap((n) => log(`Received ${n}`)),
  Stream.debounce("100 millis"), // Only emit values after a pause of at least 100 milliseconds,
  Stream.tap((n) => log(`> Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Received 1 after 5ms
// Received 2 after 2ms
// Received 3 after 0ms
// > Emitted 3 after 104ms
// Received 4 after 99ms
// Received 5 after 1ms
// Received 6 after 0ms
// > Emitted 6 after 101ms
// Received 7 after 50ms
// Received 8 after 1ms
// > Emitted 8 after 101ms
// { _id: 'Chunk', values: [ 3, 6, 8 ] }
```

**Signature**

```ts
declare const debounce: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1239)

Since v2.0.0
Stream-decodeText.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.decodeText

Decode Uint8Array chunks into a stream of strings using the specified encoding.

**Signature**

```ts
declare const decodeText: { (encoding?: string | undefined): <E, R>(self: Stream<Uint8Array, E, R>) => Stream<string, E, R>; <E, R>(self: Stream<Uint8Array, E, R>, encoding?: string | undefined): Stream<string, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6406)

Since v2.0.0
Stream-die.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.die

The stream that dies with the specified defect.

**Signature**

```ts
declare const die: (defect: unknown) => Stream<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1250)

Since v2.0.0
Stream-dieMessage.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.dieMessage

The stream that dies with an exception described by `message`.

**Signature**

```ts
declare const dieMessage: (message: string) => Stream<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1266)

Since v2.0.0
Stream-dieSync.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.dieSync

The stream that dies with the specified lazily evaluated defect.

**Signature**

```ts
declare const dieSync: (evaluate: LazyArg<unknown>) => Stream<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1258)

Since v2.0.0
Stream-distributedWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.distributedWith

More powerful version of `Stream.broadcast`. Allows to provide a function
that determines what queues should receive which elements. The decide
function will receive the indices of the queues in the resulting list.

**Signature**

```ts
declare const distributedWith: { <N extends number, A>(options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1276)

Since v2.0.0
Stream-distributedWithDynamic.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.distributedWithDynamic

More powerful version of `Stream.distributedWith`. This returns a function
that will produce new queues and corresponding indices. You can also
provide a function that will be executed after the final events are
enqueued in all queues. Shutdown of the queues is handled by the driver.
Downstream users can also shutdown queues manually. In this case the driver
will continue but no longer backpressure on them.

**Signature**

```ts
declare const distributedWithDynamic: { <A>(options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1307)

Since v2.0.0
Stream-drain.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.drain

Converts this stream to a stream that executes its effects but emits no
elements. Useful for sequencing effects using streams:

**Example**

```ts
import { Effect, Stream } from "effect"

// We create a stream and immediately drain it.
const stream = Stream.range(1, 6).pipe(Stream.drain)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }
```

**Signature**

```ts
declare const drain: <A, E, R>(self: Stream<A, E, R>) => Stream<never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1345)

Since v2.0.0
Stream-drainFork.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.drainFork

Drains the provided stream in the background for as long as this stream is
running. If this stream ends before `other`, `other` will be interrupted.
If `other` fails, this stream will fail with that error.

**Signature**

```ts
declare const drainFork: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1355)

Since v2.0.0
Stream-drop.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.drop

Drops the specified number of elements from this stream.

**Signature**

```ts
declare const drop: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1366)

Since v2.0.0
Stream-dropRight.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.dropRight

Drops the last specified number of elements from this stream.

**Signature**

```ts
declare const dropRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1379)

Since v2.0.0
Stream-dropUntil.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.dropUntil

Drops all elements of the stream until the specified predicate evaluates to
`true`.

**Signature**

```ts
declare const dropUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1391)

Since v2.0.0
Stream-dropUntilEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.dropUntilEffect

Drops all elements of the stream until the specified effectful predicate
evaluates to `true`.

**Signature**

```ts
declare const dropUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1403)

Since v2.0.0
Stream-dropWhile.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.dropWhile

Drops all elements of the stream for as long as the specified predicate
evaluates to `true`.

**Signature**

```ts
declare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1420)

Since v2.0.0
Stream-dropWhileEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.dropWhileEffect

Drops all elements of the stream for as long as the specified predicate
produces an effect that evalutates to `true`

**Signature**

```ts
declare const dropWhileEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1432)

Since v2.0.0
Stream-either.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.either

Returns a stream whose failures and successes have been lifted into an
`Either`. The resulting stream cannot fail, because the failures have been
exposed as part of the `Either` success case.

**Signature**

```ts
declare const either: <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1452)

Since v2.0.0
Stream-empty.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.empty

The empty stream.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.empty

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }
```

**Signature**

```ts
declare const empty: Stream<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1470)

Since v2.0.0
Stream-encodeText.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.encodeText

Encode a stream of strings into a stream of Uint8Array chunks using the specified encoding.

**Signature**

```ts
declare const encodeText: <E, R>(self: Stream<string, E, R>) => Stream<Uint8Array, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6417)

Since v2.0.0
Stream-ensuring.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.ensuring

Executes the provided finalizer after this stream's finalizers run.

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const program = Stream.fromEffect(Console.log("Application Logic.")).pipe(
  Stream.concat(Stream.finalizer(Console.log("Finalizing the stream"))),
  Stream.ensuring(
    Console.log("Doing some other works after stream's finalization")
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
// Application Logic.
// Finalizing the stream
// Doing some other works after stream's finalization
// { _id: 'Chunk', values: [ undefined, undefined ] }
```

**Signature**

```ts
declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1496)

Since v2.0.0
Stream-ensuringWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.ensuringWith

Executes the provided finalizer after this stream's finalizers run.

**Signature**

```ts
declare const ensuringWith: { <E, R2>(finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, R2>(self: Stream<A, E, R>, finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): Stream<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1507)

Since v2.0.0
Stream-execute.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.execute

Creates a stream that executes the specified effect but emits no elements.

**Signature**

```ts
declare const execute: <X, E, R>(effect: Effect.Effect<X, E, R>) => Stream<never, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1559)

Since v2.0.0
Stream-fail.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fail

Terminates with the specified error.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.fail("Uh oh!")

Effect.runPromiseExit(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }
```

**Signature**

```ts
declare const fail: <E>(error: E) => Stream<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1581)

Since v2.0.0
Stream-failCause.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.failCause

The stream that always fails with the specified `Cause`.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Stream<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1597)

Since v2.0.0
Stream-failCauseSync.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.failCauseSync

The stream that always fails with the specified lazily evaluated `Cause`.

**Signature**

```ts
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Stream<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1605)

Since v2.0.0
Stream-failSync.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.failSync

Terminates with the specified lazily evaluated error.

**Signature**

```ts
declare const failSync: <E>(evaluate: LazyArg<E>) => Stream<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1589)

Since v2.0.0
Stream-filter.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.filter

Filters the elements emitted by this stream using the provided function.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 11).pipe(Stream.filter((n) => n % 2 === 0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 4, 6, 8, 10 ] }
```

**Signature**

```ts
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1623)

Since v2.0.0
Stream-filterEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.filterEffect

Effectfully filters the elements emitted by this stream.

**Signature**

```ts
declare const filterEffect: { <A, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1636)

Since v2.0.0
Stream-filterMap.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.filterMap

Performs a filter and map in a single step.

**Signature**

```ts
declare const filterMap: { <A, B>(pf: (a: A) => Option.Option<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<B>): Stream<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1649)

Since v2.0.0
Stream-filterMapEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.filterMapEffect

Performs an effectful filter and map in a single step.

**Signature**

```ts
declare const filterMapEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1660)

Since v2.0.0
Stream-filterMapWhile.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.filterMapWhile

Transforms all elements of the stream for as long as the specified partial
function is defined.

**Signature**

```ts
declare const filterMapWhile: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<A2>): Stream<A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1677)

Since v2.0.0
Stream-filterMapWhileEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.filterMapWhileEffect

Effectfully transforms all elements of the stream for as long as the
specified partial function is defined.

**Signature**

```ts
declare const filterMapWhileEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1689)

Since v2.0.0
Stream-finalizer.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.finalizer

Creates a one-element stream that never fails and executes the finalizer
when it ends.

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const application = Stream.fromEffect(Console.log("Application Logic."))

const deleteDir = (dir: string) => Console.log(`Deleting dir: ${dir}`)

const program = application.pipe(
  Stream.concat(
    Stream.finalizer(
      deleteDir("tmp").pipe(
        Effect.andThen(Console.log("Temporary directory was deleted."))
      )
    )
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
// Application Logic.
// Deleting dir: tmp
// Temporary directory was deleted.
// { _id: 'Chunk', values: [ undefined, undefined ] }
```

**Signature**

```ts
declare const finalizer: <R, X>(finalizer: Effect.Effect<X, never, R>) => Stream<void, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1731)

Since v2.0.0
Stream-find.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.find

Finds the first element emitted by this stream that satisfies the provided
predicate.

**Signature**

```ts
declare const find: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1740)

Since v2.0.0
Stream-findEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.findEffect

Finds the first element emitted by this stream that satisfies the provided
effectful predicate.

**Signature**

```ts
declare const findEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1754)

Since v2.0.0
Stream-flatMap.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.flatMap

Returns a stream made of the concatenation in strict order of all the
streams produced by passing each element of this stream to `f0`

**Signature**

```ts
declare const flatMap: { <A, A2, E2, R2>(f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1771)

Since v2.0.0
Stream-flatten.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.flatten

Flattens this stream-of-streams into a stream made of the concatenation in
strict order of all the streams.

**Signature**

```ts
declare const flatten: { (options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1798)

Since v2.0.0
Stream-flattenChunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.flattenChunks

Submerges the chunks carried by this stream into the stream's structure,
while still preserving them.

**Signature**

```ts
declare const flattenChunks: <A, E, R>(self: Stream<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1819)

Since v2.0.0
Stream-flattenEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.flattenEffect

Flattens `Effect` values into the stream's structure, preserving all
information about the effect.

**Signature**

```ts
declare const flattenEffect: { (options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1828)

Since v2.0.0
Stream-flattenExitOption.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.flattenExitOption

Unwraps `Exit` values that also signify end-of-stream by failing with `None`.

**Signature**

```ts
declare const flattenExitOption: <A, E2, E, R>(self: Stream<Exit.Exit<A, Option.Option<E2>>, E, R>) => Stream<A, E | E2, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1848)

Since v2.0.0
Stream-flattenIterables.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.flattenIterables

Submerges the iterables carried by this stream into the stream's structure,
while still preserving them.

**Signature**

```ts
declare const flattenIterables: <A, E, R>(self: Stream<Iterable<A>, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1859)

Since v2.0.0
Stream-flattenTake.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.flattenTake

Unwraps `Exit` values and flatten chunks that also signify end-of-stream
by failing with `None`.

**Signature**

```ts
declare const flattenTake: <A, E2, E, R>(self: Stream<Take.Take<A, E2>, E, R>) => Stream<A, E | E2, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1868)

Since v2.0.0
Stream-forever.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.forever

Repeats this stream forever.

**Signature**

```ts
declare const forever: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1877)

Since v2.0.0
Stream-fromAsyncIterable.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromAsyncIterable

Creates a stream from an `AsyncIterable`.

**Example**

```ts
import { Effect, Stream } from "effect"

const myAsyncIterable = async function*() {
  yield 1
  yield 2
}

const stream = Stream.fromAsyncIterable(
  myAsyncIterable(),
  (e) => new Error(String(e)) // Error Handling
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2 ] }
```

**Signature**

```ts
declare const fromAsyncIterable: <A, E>(iterable: AsyncIterable<A>, onError: (e: unknown) => E) => Stream<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1903)

Since v2.0.0
Stream-fromChannel.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromChannel

Creates a stream from a `Channel`.

**Signature**

```ts
declare const fromChannel: <A, E, R>(channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1912)

Since v2.0.0
Stream-fromChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromChunk

Creates a stream from a `Chunk` of values.

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from a single Chunk
const stream = Stream.fromChunk(Chunk.make(1, 2, 3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }
```

**Signature**

```ts
declare const fromChunk: <A>(chunk: Chunk.Chunk<A>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1943)

Since v2.0.0
Stream-fromChunkPubSub.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromChunkPubSub

Creates a stream from a subscription to a `PubSub`.

**Options**

- `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)

**Signature**

```ts
declare const fromChunkPubSub: { <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options: { readonly scoped: true; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options?: { readonly scoped?: false | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1955)

Since v2.0.0
Stream-fromChunkQueue.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromChunkQueue

Creates a stream from a `Queue` of values.

**Options**

- `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)

**Signature**

```ts
declare const fromChunkQueue: <A>(queue: Queue.Dequeue<Chunk.Chunk<A>>, options?: { readonly shutdown?: boolean | undefined; }) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1976)

Since v2.0.0
Stream-fromChunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromChunks

Creates a stream from an arbitrary number of chunks.

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from multiple Chunks
const stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }
```

**Signature**

```ts
declare const fromChunks: <A>(...chunks: Array<Chunk.Chunk<A>>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2000)

Since v2.0.0
Stream-fromEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromEffect

Either emits the success value of this effect or terminates the stream
with the failure value of this effect.

**Example**

```ts
import { Effect, Random, Stream } from "effect"

const stream = Stream.fromEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 922694024 ] }
```

**Signature**

```ts
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2019)

Since v2.0.0
Stream-fromEffectOption.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromEffectOption

Creates a stream from an effect producing a value of type `A` or an empty
`Stream`.

**Signature**

```ts
declare const fromEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2028)

Since v2.0.0
Stream-fromEventListener.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromEventListener

Creates a `Stream` using addEventListener.

**Signature**

```ts
declare const fromEventListener: <A = unknown>(target: EventListener<A>, type: string, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | "unbounded" | undefined; } | undefined) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6447)

Since v3.1.0
Stream-fromIterable.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromIterable

Creates a new `Stream` from an iterable collection of values.

**Example**

```ts
import { Effect, Stream } from "effect"

const numbers = [1, 2, 3]

const stream = Stream.fromIterable(numbers)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }
```

**Signature**

```ts
declare const fromIterable: <A>(iterable: Iterable<A>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2086)

Since v2.0.0
Stream-fromIterableEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromIterableEffect

Creates a stream from an effect producing a value of type `Iterable<A>`.

**Example**

```ts
import { Context, Effect, Stream } from "effect"

class Database extends Context.Tag("Database")<
  Database,
  { readonly getUsers: Effect.Effect<Array<string>> }
>() {}

const getUsers = Database.pipe(Effect.andThen((_) => _.getUsers))

const stream = Stream.fromIterableEffect(getUsers)

Effect.runPromise(
  Stream.runCollect(stream.pipe(Stream.provideService(Database, { getUsers: Effect.succeed(["user1", "user2"]) })))
).then(console.log)
// { _id: 'Chunk', values: [ 'user1', 'user2' ] }
```

**Signature**

```ts
declare const fromIterableEffect: <A, E, R>(effect: Effect.Effect<Iterable<A>, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2113)

Since v2.0.0
Stream-fromIteratorSucceed.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromIteratorSucceed

Creates a stream from an iterator

**Signature**

```ts
declare const fromIteratorSucceed: <A>(iterator: IterableIterator<A>, maxChunkSize?: number) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2122)

Since v2.0.0
Stream-fromPubSub.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromPubSub

Creates a stream from a subscription to a `PubSub`.

**Options**

- `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)

**Signature**

```ts
declare const fromPubSub: { <A>(pubsub: PubSub.PubSub<A>, options: { readonly scoped: true; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<A>, options?: { readonly scoped?: false | undefined; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2041)

Since v2.0.0
Stream-fromPull.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromPull

Creates a stream from an effect that pulls elements from another stream.

See `Stream.toPull` for reference.

**Signature**

```ts
declare const fromPull: <R, R2, E, A>(effect: Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R2>, never, Scope.Scope | R>) => Stream<A, E, R2 | Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2133)

Since v2.0.0
Stream-fromQueue.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromQueue

Creates a stream from a queue of values

**Options**

- `maxChunkSize`: The maximum number of queued elements to put in one chunk in the stream
- `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)

**Signature**

```ts
declare const fromQueue: <A>(queue: Queue.Dequeue<A>, options?: { readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2148)

Since v2.0.0
Stream-fromReadableStream.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromReadableStream

Creates a stream from a `ReadableStream`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

**Signature**

```ts
declare const fromReadableStream: { <A, E>(options: { readonly evaluate: LazyArg<ReadableStream<A>>; readonly onError: (error: unknown) => E; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<A, E>; <A, E>(evaluate: LazyArg<ReadableStream<A>>, onError: (error: unknown) => E): Stream<A, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2172)

Since v2.0.0
Stream-fromReadableStreamByob.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromReadableStreamByob

Creates a stream from a `ReadableStreamBYOBReader`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader.

**Signature**

```ts
declare const fromReadableStreamByob: { <E>(options: { readonly evaluate: LazyArg<ReadableStream<Uint8Array>>; readonly onError: (error: unknown) => E; readonly bufferSize?: number | undefined; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<Uint8Array, E>; <E>(evaluate: LazyArg<ReadableStream<Uint8Array>>, onError: (error: unknown) => E, allocSize?: number): Stream<Uint8Array, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2191)

Since v2.0.0
Stream-fromSchedule.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromSchedule

Creates a stream from a `Schedule` that does not require any further
input. The stream will emit an element for each value output from the
schedule, continuing for as long as the schedule continues.

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

// Emits values every 1 second for a total of 5 emissions
const schedule = Schedule.spaced("1 second").pipe(
  Schedule.compose(Schedule.recurs(5))
)

const stream = Stream.fromSchedule(schedule)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
declare const fromSchedule: <A, R>(schedule: Schedule.Schedule<A, unknown, R>) => Stream<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2231)

Since v2.0.0
Stream-fromTPubSub.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromTPubSub

Creates a stream from a subscription to a `TPubSub`.

**Signature**

```ts
declare const fromTPubSub: <A>(pubsub: TPubSub<A>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2066)

Since v3.10.0
Stream-fromTQueue.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.fromTQueue

Creates a stream from a TQueue of values

**Signature**

```ts
declare const fromTQueue: <A>(queue: TDequeue<A>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2162)

Since v3.10.0
Stream-groupAdjacentBy.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.groupAdjacentBy

Creates a pipeline that groups on adjacent keys, calculated by the
specified function.

**Signature**

```ts
declare const groupAdjacentBy: { <A, K>(f: (a: A) => K): <E, R>(self: Stream<A, E, R>) => Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K): Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2241)

Since v2.0.0
Stream-groupBy.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.groupBy

More powerful version of `Stream.groupByKey`.

**Example**

```ts
import { Chunk, Effect, GroupBy, Stream } from "effect"

const groupByKeyResult = Stream.fromIterable([
  "Mary",
  "James",
  "Robert",
  "Patricia",
  "John",
  "Jennifer",
  "Rebecca",
  "Peter"
]).pipe(
  Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name]))
)

const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>
  Stream.fromEffect(
    Stream.runCollect(stream).pipe(
      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)
    )
  ))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]
// }
```

**Signature**

```ts
declare const groupBy: { <A, K, V, E2, R2>(f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, V, E2 | E, R2 | R>; <A, E, R, K, V, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): GroupBy.GroupBy<K, V, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2283)

Since v2.0.0
Stream-groupByKey.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.groupByKey

Partition a stream using a function and process each stream individually.
This returns a data structure that can be used to further filter down which
groups shall be processed.

After calling apply on the GroupBy object, the remaining groups will be
processed in parallel and the resulting streams merged in a
nondeterministic fashion.

Up to `buffer` elements may be buffered in any group stream before the
producer is backpressured. Take care to consume from all streams in order
to prevent deadlocks.

For example, to collect the first 2 words for every starting letter from a
stream of words:

```ts
import { pipe, GroupBy, Stream } from "effect"

pipe(
  Stream.fromIterable(["hello", "world", "hi", "holla"]),
  Stream.groupByKey((word) => word[0]),
  GroupBy.evaluate((key, stream) =>
    pipe(
      stream,
      Stream.take(2),
      Stream.map((words) => [key, words] as const)
    )
  )
)
```

**Signature**

```ts
declare const groupByKey: { <A, K>(f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, A, E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): GroupBy.GroupBy<K, A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2330)

Since v2.0.0
Stream-grouped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.grouped

Partitions the stream with specified `chunkSize`.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(0, 8).pipe(Stream.grouped(3))

Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log("%o", chunks))
// {
//   _id: 'Chunk',
//   values: [
//     { _id: 'Chunk', values: [ 0, 1, 2, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 3, 4, 5, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 6, 7, 8, [length]: 3 ] },
//     [length]: 3
//   ]
// }
```

**Signature**

```ts
declare const grouped: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2370)

Since v2.0.0
Stream-groupedWithin.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.groupedWithin

Partitions the stream with the specified `chunkSize` or until the specified
`duration` has passed, whichever is satisfied first.

**Example**

```ts
import { Chunk, Effect, Schedule, Stream } from "effect"

const stream = Stream.range(0, 9).pipe(
  Stream.repeat(Schedule.spaced("1 second")),
  Stream.groupedWithin(18, "1.5 seconds"),
  Stream.take(3)
)

Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(Chunk.toArray(chunks)))
// [
//   {
//     _id: 'Chunk',
//     values: [
//       0, 1, 2, 3, 4, 5, 6,
//       7, 8, 9, 0, 1, 2, 3,
//       4, 5, 6, 7
//     ]
//   },
//   {
//     _id: 'Chunk',
//     values: [
//       8, 9, 0, 1, 2,
//       3, 4, 5, 6, 7,
//       8, 9
//     ]
//   },
//   {
//     _id: 'Chunk',
//     values: [
//       0, 1, 2, 3, 4, 5, 6,
//       7, 8, 9, 0, 1, 2, 3,
//       4, 5, 6, 7
//     ]
//   }
// ]
```

**Signature**

```ts
declare const groupedWithin: { (chunkSize: number, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, duration: Duration.DurationInput): Stream<Chunk.Chunk<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2421)

Since v2.0.0
Stream-haltAfter.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.haltAfter

Specialized version of haltWhen which halts the evaluation of this stream
after the given duration.

An element in the process of being pulled will not be interrupted when the
given duration completes. See `interruptAfter` for this behavior.

**Signature**

```ts
declare const haltAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2439)

Since v2.0.0
Stream-haltWhen.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.haltWhen

Halts the evaluation of this stream when the provided effect completes. The
given effect will be forked as part of the returned stream, and its success
will be discarded.

An element in the process of being pulled will not be interrupted when the
effect completes. See `interruptWhen` for this behavior.

If the effect completes with a failure, the stream will emit that failure.

**Signature**

```ts
declare const haltWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2457)

Since v2.0.0
Stream-haltWhenDeferred.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.haltWhenDeferred

Halts the evaluation of this stream when the provided promise resolves.

If the promise completes with a failure, the stream will emit that failure.

**Signature**

```ts
declare const haltWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2470)

Since v2.0.0
Stream-identity.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.identity

The identity pipeline, which does not modify streams in any way.

**Signature**

```ts
declare const identity: <A, E = never, R = never>() => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2481)

Since v2.0.0
Stream-interleave.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.interleave

Interleaves this stream and the specified stream deterministically by
alternating pulling values from this stream and the specified stream. When
one stream is exhausted all remaining values in the other stream will be
pulled.

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5, 6)

const stream = Stream.interleave(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 5, 3, 6 ] }
```

**Signature**

```ts
declare const interleave: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2504)

Since v2.0.0
Stream-interleaveWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.interleaveWith

Combines this stream and the specified stream deterministically using the
stream of boolean values `pull` to control which stream to pull from next.
A value of `true` indicates to pull from this stream and a value of `false`
indicates to pull from the specified stream. Only consumes as many elements
as requested by the `pull` stream. If either this stream or the specified
stream are exhausted further requests for values from that stream will be
ignored.

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 3, 5, 7, 9)
const s2 = Stream.make(2, 4, 6, 8, 10)

const booleanStream = Stream.make(true, false, false).pipe(Stream.forever)

const stream = Stream.interleaveWith(s1, s2, booleanStream)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2,  4, 3, 6,
//     8, 5, 10, 7, 9
//   ]
// }
```

**Signature**

```ts
declare const interleaveWith: { <A2, E2, R2, E3, R3>(that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, E3, R3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): Stream<A | A2, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2542)

Since v2.0.0
Stream-interruptAfter.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.interruptAfter

Specialized version of `Stream.interruptWhen` which interrupts the
evaluation of this stream after the given `Duration`.

**Signature**

```ts
declare const interruptAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2627)

Since v2.0.0
Stream-interruptWhen.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.interruptWhen

Interrupts the evaluation of this stream when the provided effect
completes. The given effect will be forked as part of this stream, and its
success will be discarded. This combinator will also interrupt any
in-progress element being pulled from upstream.

If the effect completes with a failure before the stream completes, the
returned stream will emit that failure.

**Signature**

```ts
declare const interruptWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2644)

Since v2.0.0
Stream-interruptWhenDeferred.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.interruptWhenDeferred

Interrupts the evaluation of this stream when the provided promise
resolves. This combinator will also interrupt any in-progress element being
pulled from upstream.

If the promise completes with a failure, the stream will emit that failure.

**Signature**

```ts
declare const interruptWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2659)

Since v2.0.0
Stream-intersperse.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.intersperse

Intersperse stream with provided `element`.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 0, 2, 0, 3,
//     0, 4, 0, 5
//   ]
// }
```

**Signature**

```ts
declare const intersperse: { <A2>(element: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: A2): Stream<A | A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2576)

Since v2.0.0
Stream-intersperseAffixes.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.intersperseAffixes

Intersperse the specified element, also adding a prefix and a suffix.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.intersperseAffixes({
    start: "[",
    middle: "-",
    end: "]"
  })
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     '[', 1,   '-', 2,   '-',
//     3,   '-', 4,   '-', 5,
//     ']'
//   ]
// }
```

**Signature**

```ts
declare const intersperseAffixes: { <A2, A3, A4>(options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A3 | A4 | A, E, R>; <A, E, R, A2, A3, A4>(self: Stream<A, E, R>, options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): Stream<A | A2 | A3 | A4, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2610)

Since v2.0.0
Stream-iterate.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.iterate

The infinite stream of iterative function application: a, f(a), f(f(a)),
f(f(f(a))), ...

**Example**

```ts
import { Effect, Stream } from "effect"

// An infinite Stream of numbers starting from 1 and incrementing
const stream = Stream.iterate(1, (n) => n + 1)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(10)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] }
```

**Signature**

```ts
declare const iterate: <A>(value: A, next: (value: A) => A) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2682)

Since v2.0.0
Stream-let.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```

**See**

- `Do`
- `bindTo`
- `bind`
- `bindEffect`

**Signature**

```ts
declare const let: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; <A extends object, E, R, N extends string, B>(self: Stream<A, E, R>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6393)

Since v2.0.0
Stream-make.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.make

Creates a stream from an sequence of values.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }
```

**Signature**

```ts
declare const make: <As extends Array<any>>(...as: As) => Stream<As[number]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2700)

Since v2.0.0
Stream-map.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.map

Transforms the elements of this stream using the supplied function.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(Stream.map((n) => n + 1))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 3, 4 ] }
```

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (a: A) => B): Stream<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2718)

Since v2.0.0
Stream-mapAccum.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapAccum

Statefully maps over the elements of this stream to produce new elements.

**Example**

```ts
import { Effect, Stream } from "effect"

const runningTotal = (stream: Stream.Stream<number>): Stream.Stream<number> =>
  stream.pipe(Stream.mapAccum(0, (s, a) => [s + a, s + a]))

// input:  0, 1, 2, 3, 4, 5, 6
Effect.runPromise(Stream.runCollect(runningTotal(Stream.range(0, 6)))).then(
  console.log
)
// { _id: "Chunk", values: [ 0, 1, 3, 6, 10, 15, 21 ] }
```

**Signature**

```ts
declare const mapAccum: { <S, A, A2>(s: S, f: (s: S, a: A) => readonly [S, A2]): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, S, A2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]): Stream<A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2743)

Since v2.0.0
Stream-mapAccumEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapAccumEffect

Statefully and effectfully maps over the elements of this stream to produce
new elements.

**Signature**

```ts
declare const mapAccumEffect: { <S, A, A2, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, S, A2, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2755)

Since v2.0.0
Stream-mapBoth.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapBoth

Returns a stream whose failure and success channels have been mapped by the
specified `onFailure` and `onSuccess` functions.

**Signature**

```ts
declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R>; <A, E, R, E2, A2>(self: Stream<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Stream<A2, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2774)

Since v2.0.0
Stream-mapChunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapChunks

Transforms the chunks emitted by this stream.

**Signature**

```ts
declare const mapChunks: { <A, B>(f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): Stream<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2790)

Since v2.0.0
Stream-mapChunksEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapChunksEffect

Effectfully transforms the chunks emitted by this stream.

**Signature**

```ts
declare const mapChunksEffect: { <A, B, E2, R2>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, E2, R2>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): Stream<B, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2801)

Since v2.0.0
Stream-mapConcat.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapConcat

Maps each element to an iterable, and flattens the iterables into the
output of this stream.

**Example**

```ts
import { Effect, Stream } from "effect"

const numbers = Stream.make("1-2-3", "4-5", "6").pipe(
  Stream.mapConcat((s) => s.split("-")),
  Stream.map((s) => parseInt(s))
)

Effect.runPromise(Stream.runCollect(numbers)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }
```

**Signature**

```ts
declare const mapConcat: { <A, A2>(f: (a: A) => Iterable<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Iterable<A2>): Stream<A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2831)

Since v2.0.0
Stream-mapConcatChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapConcatChunk

Maps each element to a chunk, and flattens the chunks into the output of
this stream.

**Signature**

```ts
declare const mapConcatChunk: { <A, A2>(f: (a: A) => Chunk.Chunk<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>): Stream<A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2843)

Since v2.0.0
Stream-mapConcatChunkEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapConcatChunkEffect

Effectfully maps each element to a chunk, and flattens the chunks into the
output of this stream.

**Signature**

```ts
declare const mapConcatChunkEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2855)

Since v2.0.0
Stream-mapConcatEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapConcatEffect

Effectfully maps each element to an iterable, and flattens the iterables
into the output of this stream.

**Signature**

```ts
declare const mapConcatEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2872)

Since v2.0.0
Stream-mapEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapEffect

Maps over elements of the stream with the specified effectful function.

**Example**

```ts
import { Effect, Random, Stream } from "effect"

const stream = Stream.make(10, 20, 30).pipe(
  Stream.mapEffect((n) => Random.nextIntBetween(0, n))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 7, 19, 8 ] }
```

**Signature**

```ts
declare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, A2, E2, R2, K>(f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2, K>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2900)

Since v2.0.0
Stream-mapError.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapError

Transforms the errors emitted by this stream using `f`.

**Signature**

```ts
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (error: E) => E2): Stream<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2931)

Since v2.0.0
Stream-mapErrorCause.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapErrorCause

Transforms the full causes of failures emitted by this stream.

**Signature**

```ts
declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Stream<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2942)

Since v2.0.0
Stream-mapInputContext.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mapInputContext

Transforms the context being provided to the stream with the specified
function.

**Signature**

```ts
declare const mapInputContext: { <R0, R>(f: (env: Context.Context<R0>) => Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E, R0>; <A, E, R0, R>(self: Stream<A, E, R>, f: (env: Context.Context<R0>) => Context.Context<R>): Stream<A, E, R0>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3700)

Since v2.0.0
Stream-merge.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.merge

Merges this stream and the specified stream together.

New produced stream will terminate when both specified stream terminate if
no termination strategy is specified.

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.make(4, 5, 6).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

const stream = Stream.merge(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }
```

**Signature**

```ts
declare const merge: { <A2, E2, R2>(that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2973)

Since v2.0.0
Stream-mergeAll.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mergeAll

Merges a variable list of streams in a non-deterministic fashion. Up to `n`
streams may be consumed in parallel and up to `outputBuffer` chunks may be
buffered by this operator.

**Signature**

```ts
declare const mergeAll: { (options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): <A, E, R>(streams: Iterable<Stream<A, E, R>>) => Stream<A, E, R>; <A, E, R>(streams: Iterable<Stream<A, E, R>>, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2993)

Since v2.0.0
Stream-mergeEither.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mergeEither

Merges this stream and the specified stream together to produce a stream of
eithers.

**Signature**

```ts
declare const mergeEither: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<Either.Either<A2, A>, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3103)

Since v2.0.0
Stream-mergeLeft.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mergeLeft

Merges this stream and the specified stream together, discarding the values
from the right stream.

**Signature**

```ts
declare const mergeLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3117)

Since v2.0.0
Stream-mergeRight.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mergeRight

Merges this stream and the specified stream together, discarding the values
from the left stream.

**Signature**

```ts
declare const mergeRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3129)

Since v2.0.0
Stream-mergeWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mergeWith

Merges this stream and the specified stream together to a common element
type with the specified mapping functions.

New produced stream will terminate when both specified stream terminate if
no termination strategy is specified.

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make("1", "2", "3").pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.make(4.1, 5.3, 6.2).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

const stream = Stream.mergeWith(s1, s2, {
  onSelf: (s) => parseInt(s),
  onOther: (n) => Math.floor(n)
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }
```

**Signature**

```ts
declare const mergeWith: { <A2, E2, R2, A, A3, A4>(other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A3 | A4, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3, A4>(self: Stream<A, E, R>, other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): Stream<A3 | A4, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3076)

Since v2.0.0
Stream-mergeWithTag.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mergeWithTag

Merges a struct of streams into a single stream of tagged values.

**Example**

```ts
import { Stream } from "effect"
// Stream.Stream<{ _tag: "a"; value: number; } | { _tag: "b"; value: string; }>
const res = Stream.mergeWithTag({
   a: Stream.make(0),
   b: Stream.make("")
}, { concurrency: "unbounded" })
```

**Signature**

```ts
declare const mergeWithTag: { <S extends { [k in string]: Stream<any, any, any>; }>(streams: S, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; (options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): <S extends { [k in string]: Stream<any, any, any>; }>(streams: S) => Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3024)

Since v3.8.5
Stream-mkString.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.mkString

Returns a combined string resulting from concatenating each of the values
from the stream.

**Signature**

```ts
declare const mkString: <E, R>(self: Stream<string, E, R>) => Effect.Effect<string, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3141)

Since v2.0.0
Stream-never.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.never

The stream that never produces any value or fails with any error.

**Signature**

```ts
declare const never: Stream<never, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3149)

Since v2.0.0
Stream-onDone.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.onDone

Runs the specified effect if this stream ends.

**Signature**

```ts
declare const onDone: { <X, R2>(cleanup: () => Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: () => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3211)

Since v2.0.0
Stream-onEnd.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.onEnd

Adds an effect to be executed at the end of the stream.

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`)),
  Stream.onEnd(Console.log("Stream ended"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// after mapping: 2
// after mapping: 4
// after mapping: 6
// Stream ended
// { _id: 'Chunk', values: [ 2, 4, 6 ] }
```

**Signature**

```ts
declare const onEnd: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3175)

Since v3.6.0
Stream-onError.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.onError

Runs the specified effect if this stream fails, providing the error to the
effect if it exists.

Note: Unlike `Effect.onError` there is no guarantee that the provided
effect will not be interrupted.

**Signature**

```ts
declare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3195)

Since v2.0.0
Stream-onStart.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.onStart

Adds an effect to be executed at the start of the stream.

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.onStart(Console.log("Stream started")),
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Stream started
// after mapping: 2
// after mapping: 4
// after mapping: 6
// { _id: 'Chunk', values: [ 2, 4, 6 ] }
```

**Signature**

```ts
declare const onStart: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3240)

Since v3.6.0
Stream-orDie.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orDie

Translates any failure into a stream termination, making the stream
infallible and all failures unchecked.

**Signature**

```ts
declare const orDie: <A, E, R>(self: Stream<A, E, R>) => Stream<A, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3257)

Since v2.0.0
Stream-orDieWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orDieWith

Keeps none of the errors, and terminates the stream with them, using the
specified function to convert the `E` into a defect.

**Signature**

```ts
declare const orDieWith: { <E>(f: (e: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, never, R>; <A, E, R>(self: Stream<A, E, R>, f: (e: E) => unknown): Stream<A, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3266)

Since v2.0.0
Stream-orElse.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orElse

Switches to the provided stream in case this one fails with a typed error.

See also `Stream.catchAll`.

**Signature**

```ts
declare const orElse: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3279)

Since v2.0.0
Stream-orElseEither.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orElseEither

Switches to the provided stream in case this one fails with a typed error.

See also `Stream.catchAll`.

**Signature**

```ts
declare const orElseEither: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<Either.Either<A2, A>, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3292)

Since v2.0.0
Stream-orElseFail.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orElseFail

Fails with given error in case this one fails with a typed error.

See also `Stream.catchAll`.

**Signature**

```ts
declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>): Stream<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3310)

Since v2.0.0
Stream-orElseIfEmpty.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orElseIfEmpty

Produces the specified element if this stream is empty.

**Signature**

```ts
declare const orElseIfEmpty: { <A2>(element: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: LazyArg<A2>): Stream<A | A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3321)

Since v2.0.0
Stream-orElseIfEmptyChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orElseIfEmptyChunk

Produces the specified chunk if this stream is empty.

**Signature**

```ts
declare const orElseIfEmptyChunk: { <A2>(chunk: LazyArg<Chunk.Chunk<A2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>): Stream<A | A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3332)

Since v2.0.0
Stream-orElseIfEmptyStream.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orElseIfEmptyStream

Switches to the provided stream in case this one is empty.

**Signature**

```ts
declare const orElseIfEmptyStream: { <A2, E2, R2>(stream: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, stream: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3343)

Since v2.0.0
Stream-orElseSucceed.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.orElseSucceed

Succeeds with the specified value if this one fails with a typed error.

**Signature**

```ts
declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, never, R>; <A, E, R, A2>(self: Stream<A, E, R>, value: LazyArg<A2>): Stream<A | A2, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3354)

Since v2.0.0
Stream-paginate.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.paginate

Like `Stream.unfold`, but allows the emission of values to end one step further
than the unfolding of the state. This is useful for embedding paginated
APIs, hence the name.

**Example**

```ts
import { Effect, Option, Stream } from "effect"

const stream = Stream.paginate(0, (n) => [
  n,
  n < 3 ? Option.some(n + 1) : Option.none()
])

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3 ] }
```

**Signature**

```ts
declare const paginate: <S, A>(s: S, f: (s: S) => readonly [A, Option.Option<S>]) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3380)

Since v2.0.0
Stream-paginateChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.paginateChunk

Like `Stream.unfoldChunk`, but allows the emission of values to end one step
further than the unfolding of the state. This is useful for embedding
paginated APIs, hence the name.

**Signature**

```ts
declare const paginateChunk: <S, A>(s: S, f: (s: S) => readonly [Chunk.Chunk<A>, Option.Option<S>]) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3390)

Since v2.0.0
Stream-paginateChunkEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.paginateChunkEffect

Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step
further than the unfolding of the state. This is useful for embedding
paginated APIs, hence the name.

**Signature**

```ts
declare const paginateChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [Chunk.Chunk<A>, Option.Option<S>], E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3403)

Since v2.0.0
Stream-paginateEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.paginateEffect

Like `Stream.unfoldEffect` but allows the emission of values to end one step
further than the unfolding of the state. This is useful for embedding
paginated APIs, hence the name.

**Signature**

```ts
declare const paginateEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [A, Option.Option<S>], E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3416)

Since v2.0.0
Stream-partition.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.partition

Splits a stream into two substreams based on a predicate.

**Details**

The `Stream.partition` function splits a stream into two parts: one for
elements that satisfy the predicate (evaluated to `true`) and another for
those that do not (evaluated to `false`).

The faster stream may advance up to `bufferSize` elements ahead of the slower
one.

**Example** (Partitioning a Stream into Even and Odd Numbers)

```ts
import { Effect, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(
  Stream.partition((n) => n % 2 === 0, { bufferSize: 5 })
)

const program = Effect.scoped(
  Effect.gen(function*() {
    const [odds, evens] = yield* partition
    console.log(yield* Stream.runCollect(odds))
    console.log(yield* Stream.runCollect(evens))
  })
)

Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }
```

**See**

- `partitionEither` for partitioning a stream based on effectful
conditions.

**Signature**

```ts
declare const partition: { <C extends A, B extends A, A = C>(refinement: Refinement<NoInfer<A>, B>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<C, E, R>) => Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A>(predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope.Scope | R>; <C extends A, E, R, B extends A, A = C>(self: Stream<C, E, R>, refinement: Refinement<A, B>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, R | Scope.Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3461)

Since v2.0.0
Stream-partitionEither.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.partitionEither

Splits a stream into two substreams based on an effectful condition.

**Details**

The `Stream.partitionEither` function is used to divide a stream into two
parts: one for elements that satisfy a condition producing `Either.left`
values, and another for those that produce `Either.right` values. This
function applies an effectful predicate to each element in the stream to
determine which substream it belongs to.

The faster stream may advance up to `bufferSize` elements ahead of the slower
one.

**Example** (Partitioning a Stream with an Effectful Predicate)

```ts
import { Effect, Either, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(
  Stream.partitionEither(
    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),
    { bufferSize: 5 }
  )
)

const program = Effect.scoped(
  Effect.gen(function*() {
    const [evens, odds] = yield* partition
    console.log(yield* Stream.runCollect(evens))
    console.log(yield* Stream.runCollect(odds))
  })
)

Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }
```

**See**

- `partition` for partitioning a stream based on simple conditions.

**Signature**

```ts
declare const partitionEither: { <A, A3, A2, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[left: Stream<A2, E2 | E, never>, right: Stream<A3, E2 | E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A3, A2, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Effect.Effect<[left: Stream<A2, E | E2, never>, right: Stream<A3, E | E2, never>], E | E2, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3530)

Since v2.0.0
Stream-peel.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.peel

Peels off enough material from the stream to construct a `Z` using the
provided `Sink` and then returns both the `Z` and the rest of the
`Stream` in a scope. Like all scoped values, the provided stream is
valid only within the scope.

**Signature**

```ts
declare const peel: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[A2, Stream<A, E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Effect.Effect<[A2, Stream<A, E, never>], E | E2, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3553)

Since v2.0.0
Stream-pipeThrough.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.pipeThrough

Pipes all of the values from this stream through the provided sink.

See also `Stream.transduce`.

**Signature**

```ts
declare const pipeThrough: { <A2, A, L, E2, R2>(sink: Sink.Sink<A2, A, L, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<L, E2 | E, R2 | R>; <A, E, R, A2, L, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, L, E2, R2>): Stream<L, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3571)

Since v2.0.0
Stream-pipeThroughChannel.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.pipeThroughChannel

Pipes all the values from this stream through the provided channel.

**Signature**

```ts
declare const pipeThroughChannel: { <R2, E, E2, A, A2>(channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3582)

Since v2.0.0
Stream-pipeThroughChannelOrFail.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.pipeThroughChannelOrFail

Pipes all values from this stream through the provided channel, passing
through any error emitted by this stream unchanged.

**Signature**

```ts
declare const pipeThroughChannelOrFail: { <R2, E, E2, A, A2>(chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E | E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3599)

Since v2.0.0
Stream-prepend.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.prepend

Emits the provided chunk before emitting any other value.

**Signature**

```ts
declare const prepend: { <B>(values: Chunk.Chunk<B>): <A, E, R>(self: Stream<A, E, R>) => Stream<B | A, E, R>; <A, E, R, B>(self: Stream<A, E, R>, values: Chunk.Chunk<B>): Stream<A | B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3615)

Since v2.0.0
Stream-provideContext.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.provideContext

Provides the stream with its required context, which eliminates its
dependency on `R`.

**Signature**

```ts
declare const provideContext: { <R>(context: Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E>; <A, E, R>(self: Stream<A, E, R>, context: Context.Context<R>): Stream<A, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3627)

Since v2.0.0
Stream-provideLayer.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.provideLayer

Provides a `Layer` to the stream, which translates it to another level.

**Signature**

```ts
declare const provideLayer: { <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E>(self: Stream<A, E, ROut>) => Stream<A, E2 | E, RIn>; <A, E, RIn, E2, ROut>(self: Stream<A, E, ROut>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3638)

Since v2.0.0
Stream-provideService.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.provideService

Provides the stream with the single service it requires. If the stream
requires more than one service use `Stream.provideContext` instead.

**Signature**

```ts
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): Stream<A, E, Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3650)

Since v2.0.0
Stream-provideServiceEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.provideServiceEffect

Provides the stream with the single service it requires. If the stream
requires more than one service use `Stream.provideContext` instead.

**Signature**

```ts
declare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3662)

Since v2.0.0
Stream-provideServiceStream.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.provideServiceStream

Provides the stream with the single service it requires. If the stream
requires more than one service use `Stream.provideContext` instead.

**Signature**

```ts
declare const provideServiceStream: { <I, S, E2, R2>(tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3681)

Since v2.0.0
Stream-provideSomeLayer.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.provideSomeLayer

Splits the context into two parts, providing one part using the
specified layer and leaving the remainder `R0`.

**Signature**

```ts
declare const provideSomeLayer: { <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, RIn | Exclude<R, ROut>>; <A, E, R, RIn, E2, ROut>(self: Stream<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn | Exclude<R, ROut>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3712)

Since v2.0.0
Stream-race.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.race

Returns a stream that mirrors the first upstream to emit an item.
As soon as one of the upstream emits a first value, the other is interrupted.
The resulting stream will forward all items from the "winning" source stream.
Any upstream failures will cause the returned stream to fail.

**Example**

```ts
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.fromSchedule(Schedule.spaced('2 millis')).pipe(
  Stream.race(Stream.fromSchedule(Schedule.spaced('1 millis'))),
  Stream.take(6),
  Stream.tap(Console.log)
)

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5
```

**Signature**

```ts
declare const race: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL | AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL | AR, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3750)

Since v3.7.0
Stream-raceAll.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.raceAll

Returns a stream that mirrors the first upstream to emit an item.
As soon as one of the upstream emits a first value, all the others are interrupted.
The resulting stream will forward all items from the "winning" source stream.
Any upstream failures will cause the returned stream to fail.

**Example**

```ts
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.raceAll(
  Stream.fromSchedule(Schedule.spaced('1 millis')),
  Stream.fromSchedule(Schedule.spaced('2 millis')),
  Stream.fromSchedule(Schedule.spaced('4 millis')),
).pipe(Stream.take(6), Stream.tap(Console.log))

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5
```

**Signature**

```ts
declare const raceAll: <S extends ReadonlyArray<Stream<any, any, any>>>(...streams: S) => Stream<Stream.Success<S[number]>, Stream.Error<S[number]>, Stream.Context<S[number]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3788)

Since v3.5.0
Stream-range.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.range

Constructs a stream from a range of integers, including both endpoints.

**Example**

```ts
import { Effect, Stream } from "effect"

// A Stream with a range of numbers from 1 to 5
const stream = Stream.range(1, 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
declare const range: (min: number, max: number, chunkSize?: number) => Stream<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3813)

Since v2.0.0
Stream-rechunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.rechunk

Re-chunks the elements of the stream into chunks of `n` elements each. The
last chunk might contain less than `n` elements.

**Signature**

```ts
declare const rechunk: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3822)

Since v2.0.0
Stream-refineOrDie.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.refineOrDie

Keeps some of the errors, and terminates the fiber with the rest

**Signature**

```ts
declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>): Stream<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3833)

Since v2.0.0
Stream-refineOrDieWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.refineOrDieWith

Keeps some of the errors, and terminates the fiber with the rest, using the
specified function to convert the `E` into a defect.

**Signature**

```ts
declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): Stream<A, E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3845)

Since v2.0.0
Stream-repeat.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeat

Repeats the entire stream using the specified schedule. The stream will
execute normally, and then repeat again according to the provided schedule.

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const stream = Stream.repeat(Stream.succeed(1), Schedule.forever)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }
```

**Signature**

```ts
declare const repeat: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3870)

Since v2.0.0
Stream-repeatEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatEffect

Creates a stream from an effect producing a value of type `A` which repeats
forever.

**Example**

```ts
import { Effect, Random, Stream } from "effect"

const stream = Stream.repeatEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 3891571149, 4239494205, 2352981603, 2339111046, 1488052210 ] }
```

**Signature**

```ts
declare const repeatEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3892)

Since v2.0.0
Stream-repeatEffectChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatEffectChunk

Creates a stream from an effect producing chunks of `A` values which
repeats forever.

**Signature**

```ts
declare const repeatEffectChunk: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3901)

Since v2.0.0
Stream-repeatEffectChunkOption.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatEffectChunkOption

Creates a stream from an effect producing chunks of `A` values until it
fails with `None`.

**Signature**

```ts
declare const repeatEffectChunkOption: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3911)

Since v2.0.0
Stream-repeatEffectOption.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatEffectOption

Creates a stream from an effect producing values of type `A` until it fails
with `None`.

**Example**

```ts
// In this example, we're draining an Iterator to create a stream from it
import { Stream, Effect, Option } from "effect"

const drainIterator = <A>(it: Iterator<A>): Stream.Stream<A> =>
  Stream.repeatEffectOption(
    Effect.sync(() => it.next()).pipe(
      Effect.andThen((res) => {
        if (res.done) {
          return Effect.fail(Option.none())
        }
        return Effect.succeed(res.value)
      })
    )
  )
```

**Signature**

```ts
declare const repeatEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3940)

Since v2.0.0
Stream-repeatEffectWithSchedule.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatEffectWithSchedule

Creates a stream from an effect producing a value of type `A`, which is
repeated using the specified schedule.

**Signature**

```ts
declare const repeatEffectWithSchedule: <A, E, R, X, A0 extends A, R2>(effect: Effect.Effect<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>) => Stream<A, E, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3950)

Since v2.0.0
Stream-repeatEither.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatEither

Repeats the entire stream using the specified schedule. The stream will
execute normally, and then repeat again according to the provided schedule.
The schedule output will be emitted at the end of each repetition.

**Signature**

```ts
declare const repeatEither: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, B>, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<Either.Either<A, B>, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3963)

Since v2.0.0
Stream-repeatElements.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatElements

Repeats each element of the stream using the provided schedule. Repetitions
are done in addition to the first execution, which means using
`Schedule.recurs(1)` actually results in the original effect, plus an
additional recurrence, for a total of two repetitions of each value in the
stream.

**Signature**

```ts
declare const repeatElements: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3983)

Since v2.0.0
Stream-repeatElementsWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatElementsWith

Repeats each element of the stream using the provided schedule. When the
schedule is finished, then the output of the schedule will be emitted into
the stream. Repetitions are done in addition to the first execution, which
means using `Schedule.recurs(1)` actually results in the original effect,
plus an additional recurrence, for a total of two repetitions of each value
in the stream.

This function accepts two conversion functions, which allow the output of
this stream and the output of the provided schedule to be unified into a
single type. For example, `Either` or similar data type.

**Signature**

```ts
declare const repeatElementsWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4003)

Since v2.0.0
Stream-repeatValue.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatValue

Repeats the provided value infinitely.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.repeatValue(0)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }
```

**Signature**

```ts
declare const repeatValue: <A>(value: A) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4031)

Since v2.0.0
Stream-repeatWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.repeatWith

Repeats the entire stream using the specified schedule. The stream will
execute normally, and then repeat again according to the provided schedule.
The schedule output will be emitted at the end of each repetition and can
be unified with the stream elements using the provided functions.

**Signature**

```ts
declare const repeatWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4042)

Since v2.0.0
Stream-retry.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.retry

When the stream fails, retry it according to the given schedule

This retries the entire stream, so will re-execute all of the stream's
acquire operations.

The schedule is reset as soon as the first element passes through the
stream again.

**Signature**

```ts
declare const retry: { <E, R2, X>(policy: Schedule.Schedule<X, NoInfer<E>, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, policy: Schedule.Schedule<X, NoInfer<E>, R2>): Stream<A, E, R2 | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4066)

Since v2.0.0
Stream-run.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.run

Runs the sink on the stream to produce either the sink's result or an error.

**Signature**

```ts
declare const run: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, unknown, E2, R2>): Effect.Effect<A2, E | E2, Exclude<R | R2, Scope.Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4101)

Since v2.0.0
Stream-runCollect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runCollect

Runs the stream and collects all of its elements to a chunk.

**Signature**

```ts
declare const runCollect: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Chunk.Chunk<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4117)

Since v2.0.0
Stream-runCount.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runCount

Runs the stream and emits the number of elements processed

**Signature**

```ts
declare const runCount: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<number, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4125)

Since v2.0.0
Stream-runDrain.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runDrain

Runs the stream only for its effects. The emitted elements are discarded.

**Signature**

```ts
declare const runDrain: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4133)

Since v2.0.0
Stream-runFold.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFold

Executes a pure fold over the stream of values - reduces all elements in
the stream to a value of type `S`.

**Signature**

```ts
declare const runFold: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4142)

Since v2.0.0
Stream-runFoldEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFoldEffect

Executes an effectful fold over the stream of values.

**Signature**

```ts
declare const runFoldEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4153)

Since v2.0.0
Stream-Stream.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.Stream

A `Stream<A, E, R>` is a description of a program that, when evaluated, may
emit zero or more values of type `A`, may fail with errors of type `E`, and
uses an context of type `R`. One way to think of `Stream` is as a
`Effect` program that could emit multiple values.

`Stream` is a purely functional *pull* based stream. Pull based streams offer
inherent laziness and backpressure, relieving users of the need to manage
buffers between operators. As an optimization, `Stream` does not emit
single values, but rather an array of values. This allows the cost of effect
evaluation to be amortized.

`Stream` forms a monad on its `A` type parameter, and has error management
facilities for its `E` type parameter, modeled similarly to `Effect` (with
some adjustments for the multiple-valued nature of `Stream`). These aspects
allow for rich and expressive composition of streams.

**Signature**

```ts
export interface Stream<out A, out E = never, out R = never> extends Stream.Variance<A, E, R>, Pipeable {
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: StreamUnify<this>
  [Unify.ignoreSymbol]?: StreamUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L71)

Since v2.0.0
Stream-runFoldScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFoldScoped

Executes a pure fold over the stream of values. Returns a scoped value that
represents the scope of the stream.

**Signature**

```ts
declare const runFoldScoped: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4172)

Since v2.0.0
Stream-runFoldScopedEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFoldScopedEffect

Executes an effectful fold over the stream of values. Returns a scoped
value that represents the scope of the stream.

**Signature**

```ts
declare const runFoldScopedEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4184)

Since v2.0.0
Stream-runFoldWhile.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFoldWhile

Reduces the elements in the stream to a value of type `S`. Stops the fold
early when the condition is not fulfilled. Example:

**Signature**

```ts
declare const runFoldWhile: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4203)

Since v2.0.0
Stream-runFoldWhileEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFoldWhileEffect

Executes an effectful fold over the stream of values. Stops the fold early
when the condition is not fulfilled.

**Signature**

```ts
declare const runFoldWhileEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4215)

Since v2.0.0
Stream-runFoldWhileScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFoldWhileScoped

Executes a pure fold over the stream of values. Returns a scoped value that
represents the scope of the stream. Stops the fold early when the condition
is not fulfilled.

**Signature**

```ts
declare const runFoldWhileScoped: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4237)

Since v2.0.0
Stream-runFoldWhileScopedEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runFoldWhileScopedEffect

Executes an effectful fold over the stream of values. Returns a scoped
value that represents the scope of the stream. Stops the fold early when
the condition is not fulfilled.

**Signature**

```ts
declare const runFoldWhileScopedEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, R2 | R | Scope.Scope>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4259)

Since v2.0.0
Stream-runForEach.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runForEach

Consumes all elements of the stream, passing them to the specified
callback.

**Signature**

```ts
declare const runForEach: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4280)

Since v2.0.0
Stream-runForEachChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runForEachChunk

Consumes all elements of the stream, passing them to the specified
callback.

**Signature**

```ts
declare const runForEachChunk: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4297)

Since v2.0.0
Stream-runForEachChunkScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runForEachChunkScoped

Like `Stream.runForEachChunk`, but returns a scoped effect so the
finalization order can be controlled.

**Signature**

```ts
declare const runForEachChunkScoped: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4314)

Since v2.0.0
Stream-runForEachScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runForEachScoped

Like `Stream.forEach`, but returns a scoped effect so the finalization
order can be controlled.

**Signature**

```ts
declare const runForEachScoped: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4331)

Since v2.0.0
Stream-runForEachWhile.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runForEachWhile

Consumes elements of the stream, passing them to the specified callback,
and terminating consumption when the callback returns `false`.

**Signature**

```ts
declare const runForEachWhile: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4348)

Since v2.0.0
Stream-runForEachWhileScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runForEachWhileScoped

Like `Stream.runForEachWhile`, but returns a scoped effect so the
finalization order can be controlled.

**Signature**

```ts
declare const runForEachWhileScoped: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4365)

Since v2.0.0
Stream-runHead.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runHead

Runs the stream to completion and yields the first value emitted by it,
discarding the rest of the elements.

**Signature**

```ts
declare const runHead: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4382)

Since v2.0.0
Stream-runIntoPubSub.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runIntoPubSub

Publishes elements of this stream to a `PubSub`. Stream failure and ending will
also be signalled.

**Signature**

```ts
declare const runIntoPubSub: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4391)

Since v2.0.0
Stream-runIntoPubSubScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runIntoPubSubScoped

Like `Stream.runIntoPubSub`, but provides the result as a scoped effect to
allow for scope composition.

**Signature**

```ts
declare const runIntoPubSubScoped: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4403)

Since v2.0.0
Stream-runIntoQueue.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runIntoQueue

Enqueues elements of this stream into a queue. Stream failure and ending
will also be signalled.

**Signature**

```ts
declare const runIntoQueue: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4417)

Since v2.0.0
Stream-runIntoQueueElementsScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runIntoQueueElementsScoped

Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]
to allow for scope composition.

**Signature**

```ts
declare const runIntoQueueElementsScoped: { <A, E>(queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): Effect.Effect<void, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4429)

Since v2.0.0
Stream-runIntoQueueScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runIntoQueueScoped

Like `Stream.runIntoQueue`, but provides the result as a scoped effect
to allow for scope composition.

**Signature**

```ts
declare const runIntoQueueScoped: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4446)

Since v2.0.0
Stream-runLast.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runLast

Runs the stream to completion and yields the last value emitted by it,
discarding the rest of the elements.

**Signature**

```ts
declare const runLast: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4460)

Since v2.0.0
Stream-runSum.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.runSum

Runs the stream to a sink which sums elements, provided they are Numeric.

**Signature**

```ts
declare const runSum: <E, R>(self: Stream<number, E, R>) => Effect.Effect<number, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4482)

Since v2.0.0
Stream-scan.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.scan

Statefully maps over the elements of this stream to produce all
intermediate results of type `S` given an initial S.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 6).pipe(Stream.scan(0, (a, b) => a + b))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0,  1,  3, 6, 10, 15, 21 ] }
```

**Signature**

```ts
declare const scan: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Stream<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream<S, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4501)

Since v2.0.0
Stream-scanEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.scanEffect

Statefully and effectfully maps over the elements of this stream to produce
all intermediate results of type `S` given an initial S.

**Signature**

```ts
declare const scanEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<S, E2 | E, R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Stream<S, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4513)

Since v2.0.0
Stream-scanReduce.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.scanReduce

Statefully maps over the elements of this stream to produce all
intermediate results.

See also `Stream.scan`.

**Signature**

```ts
declare const scanReduce: { <A2, A>(f: (a2: A2 | A, a: A) => A2): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream<A | A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4534)

Since v2.0.0
Stream-scanReduceEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.scanReduceEffect

Statefully and effectfully maps over the elements of this stream to produce
all intermediate results.

See also `Stream.scanEffect`.

**Signature**

```ts
declare const scanReduceEffect: { <A2, A, E2, R2>(f: (a2: A2 | A, a: A) => Effect.Effect<A2 | A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => Effect.Effect<A | A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4548)

Since v2.0.0
Stream-schedule.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.schedule

Schedules the output of the stream using the provided `schedule`.

**Signature**

```ts
declare const schedule: { <X, A0 extends A, R2, A>(schedule: Schedule.Schedule<X, A0, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, A0 extends A, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>): Stream<A, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4564)

Since v2.0.0
Stream-scheduleWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.scheduleWith

Schedules the output of the stream using the provided `schedule` and emits
its output at the end (if `schedule` is finite). Uses the provided function
to align the stream and schedule outputs on the same type.

**Signature**

```ts
declare const scheduleWith: { <B, A0 extends A, R2, A, C>(schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, A0 extends A, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4579)

Since v2.0.0
Stream-scoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.scoped

Creates a single-valued stream from a scoped resource.

**Example**

```ts
import { Console, Effect, Stream } from "effect"

// Creating a single-valued stream from a scoped resource
const stream = Stream.scoped(
 Effect.acquireRelease(
   Console.log("acquire"),
   () => Console.log("release")
 )
).pipe(
 Stream.flatMap(() => Console.log("use"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// acquire
// use
// release
// { _id: 'Chunk', values: [ undefined ] }
```

**Signature**

```ts
declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4618)

Since v2.0.0
Stream-scopedWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.scopedWith

Use a function that receives a scope and returns an effect to emit an output
element. The output element will be the result of the returned effect, if
successful.

**Signature**

```ts
declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4629)

Since v3.11.0
Stream-share.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.share

Returns a new Stream that multicasts the original Stream, subscribing to it as soon as the first consumer subscribes.
As long as there is at least one consumer, the upstream will continue running and emitting data.
When all consumers have exited, the upstream will be finalized.

**Signature**

```ts
declare const share: { <A, E>(config: { readonly capacity: "unbounded"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): <R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, config: { readonly capacity: "unbounded"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L569)

Since v3.8.0
Stream-sliding.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.sliding

Emits a sliding window of `n` elements.

```ts
import { pipe, Stream } from "effect"

pipe(
  Stream.make(1, 2, 3, 4),
  Stream.sliding(2),
  Stream.runCollect
)
// => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))
```

**Signature**

```ts
declare const sliding: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4649)

Since v2.0.0
Stream-slidingSize.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.slidingSize

Like `sliding`, but with a configurable `stepSize` parameter.

**Signature**

```ts
declare const slidingSize: { (chunkSize: number, stepSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, stepSize: number): Stream<Chunk.Chunk<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4660)

Since v2.0.0
Stream-some.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.some

Converts an option on values into an option on errors.

**Signature**

```ts
declare const some: <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, Option.Option<E>, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4671)

Since v2.0.0
Stream-someOrElse.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.someOrElse

Extracts the optional value, or returns the given 'default'.

**Signature**

```ts
declare const someOrElse: { <A2>(fallback: LazyArg<A2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<Option.Option<A>, E, R>, fallback: LazyArg<A2>): Stream<A | A2, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4679)

Since v2.0.0
Stream-someOrFail.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.someOrFail

Extracts the optional value, or fails with the given error 'e'.

**Signature**

```ts
declare const someOrFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<Option.Option<A>, E, R>, error: LazyArg<E2>): Stream<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4690)

Since v2.0.0
Stream-split.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.split

Splits elements based on a predicate or refinement.

```ts
import { pipe, Stream } from "effect"

pipe(
  Stream.range(1, 10),
  Stream.split((n) => n % 4 === 0),
  Stream.runCollect
)
// => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))
```

**Signature**

```ts
declare const split: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<Chunk.Chunk<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4712)

Since v2.0.0
Stream-splitLines.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.splitLines

Splits strings on newlines. Handles both Windows newlines (`\r\n`) and UNIX
newlines (`\n`).

**Signature**

```ts
declare const splitLines: <E, R>(self: Stream<string, E, R>) => Stream<string, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4739)

Since v2.0.0
Stream-splitOnChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.splitOnChunk

Splits elements on a delimiter and transforms the splits into desired output.

**Signature**

```ts
declare const splitOnChunk: { <A>(delimiter: Chunk.Chunk<A>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, delimiter: Chunk.Chunk<A>): Stream<Chunk.Chunk<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4727)

Since v2.0.0
Stream-succeed.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.succeed

Creates a single-valued pure stream.

**Example**

```ts
import { Effect, Stream } from "effect"

// A Stream with a single number
const stream = Stream.succeed(3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 3 ] }
```

**Signature**

```ts
declare const succeed: <A>(value: A) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4758)

Since v2.0.0
Stream-suspend.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.suspend

Returns a lazily constructed stream.

**Signature**

```ts
declare const suspend: <A, E, R>(stream: LazyArg<Stream<A, E, R>>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4774)

Since v2.0.0
Stream-sync.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.sync

Creates a single-valued pure stream.

**Signature**

```ts
declare const sync: <A>(evaluate: LazyArg<A>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4766)

Since v2.0.0
Stream-take.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.take

Takes the specified number of elements from this stream.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.take(Stream.iterate(0, (n) => n + 1), 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
declare const take: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4792)

Since v2.0.0
Stream-takeRight.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.takeRight

Takes the last specified number of elements from this stream.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.takeRight(Stream.make(1, 2, 3, 4, 5, 6), 3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 4, 5, 6 ] }
```

**Signature**

```ts
declare const takeRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4813)

Since v2.0.0
Stream-takeUntil.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.takeUntil

Takes all elements of the stream until the specified predicate evaluates to
`true`.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.takeUntil(Stream.iterate(0, (n) => n + 1), (n) => n === 4)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
declare const takeUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4835)

Since v2.0.0
Stream-takeUntilEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.takeUntilEffect

Takes all elements of the stream until the specified effectual predicate
evaluates to `true`.

**Signature**

```ts
declare const takeUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4847)

Since v2.0.0
Stream-takeWhile.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.takeWhile

Takes all elements of the stream for as long as the specified predicate
evaluates to `true`.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.takeWhile(Stream.iterate(0, (n) => n + 1), (n) => n < 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
declare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4874)

Since v2.0.0
Stream-tap.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.tap

Adds an effect to consumption of every element of the stream.

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.tap((n) => Console.log(`before mapping: ${n}`)),
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// before mapping: 1
// after mapping: 2
// before mapping: 2
// after mapping: 4
// before mapping: 3
// after mapping: 6
// { _id: 'Chunk', values: [ 2, 4, 6 ] }
```

**Signature**

```ts
declare const tap: { <A, X, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4907)

Since v2.0.0
Stream-tapBoth.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.tapBoth

Returns a stream that effectfully "peeks" at the failure or success of
the stream.

**Signature**

```ts
declare const tapBoth: { <E, X1, E2, R2, A, X2, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): <R>(self: Stream<A, E, R>) => Stream<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X1, E2, R2, X2, E3, R3>(self: Stream<A, E, R>, options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): Stream<A, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4921)

Since v2.0.0
Stream-tapError.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.tapError

Returns a stream that effectfully "peeks" at the failure of the stream.

**Signature**

```ts
declare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4943)

Since v2.0.0
Stream-tapErrorCause.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.tapErrorCause

Returns a stream that effectfully "peeks" at the cause of failure of the
stream.

**Signature**

```ts
declare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4957)

Since v2.0.0
Stream-tapSink.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.tapSink

Sends all elements emitted by this stream to the specified sink in addition
to emitting them.

**Signature**

```ts
declare const tapSink: { <A, E2, R2>(sink: Sink.Sink<unknown, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<unknown, A, unknown, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4974)

Since v2.0.0
Stream-throttle.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.throttle

Delays the chunks of this stream according to the given bandwidth
parameters using the token bucket algorithm. Allows for burst in the
processing of elements by allowing the token bucket to accumulate tokens up
to a `units + burst` threshold. The weight of each chunk is determined by
the `cost` function.

If using the "enforce" strategy, chunks that do not meet the bandwidth
constraints are dropped. If using the "shape" strategy, chunks are delayed
until they can be emitted without exceeding the bandwidth constraints.

Defaults to the "shape" strategy.

**Example**

```ts
import { Chunk, Effect, Schedule, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.fromSchedule(Schedule.spaced("50 millis")).pipe(
  Stream.take(6),
  Stream.tap((n) => log(`Received ${n}`)),
  Stream.throttle({
    cost: Chunk.size,
    duration: "100 millis",
    units: 1
  }),
  Stream.tap((n) => log(`> Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Received 0 after 56ms
// > Emitted 0 after 0ms
// Received 1 after 52ms
// > Emitted 1 after 48ms
// Received 2 after 52ms
// > Emitted 2 after 49ms
// Received 3 after 52ms
// > Emitted 3 after 48ms
// Received 4 after 52ms
// > Emitted 4 after 47ms
// Received 5 after 52ms
// > Emitted 5 after 49ms
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
declare const throttle: { <A>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5034)

Since v2.0.0
Stream-throttleEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.throttleEffect

Delays the chunks of this stream according to the given bandwidth
parameters using the token bucket algorithm. Allows for burst in the
processing of elements by allowing the token bucket to accumulate tokens up
to a `units + burst` threshold. The weight of each chunk is determined by
the effectful `costFn` function.

If using the "enforce" strategy, chunks that do not meet the bandwidth
constraints are dropped. If using the "shape" strategy, chunks are delayed
until they can be emitted without exceeding the bandwidth constraints.

Defaults to the "shape" strategy.

**Signature**

```ts
declare const throttleEffect: { <A, E2, R2>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5072)

Since v2.0.0
Stream-tick.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.tick

A stream that emits void values spaced by the specified duration.

**Example**

```ts
import { Effect, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.tick("1 seconds").pipe(Stream.tap(() => log("tick")))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// tick after 4ms
// tick after 1003ms
// tick after 1001ms
// tick after 1002ms
// tick after 1002ms
// { _id: 'Chunk', values: [ undefined, undefined, undefined, undefined, undefined ] }
```

**Signature**

```ts
declare const tick: (interval: Duration.DurationInput) => Stream<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5123)

Since v2.0.0
Stream-timeout.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.timeout

Ends the stream if it does not produce a value after the specified duration.

**Signature**

```ts
declare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5131)

Since v2.0.0
Stream-timeoutFail.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.timeoutFail

Fails the stream with given error if it does not produce a value after d
duration.

**Signature**

```ts
declare const timeoutFail: { <E2>(error: LazyArg<E2>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5143)

Since v2.0.0
Stream-timeoutFailCause.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.timeoutFailCause

Fails the stream with given cause if it does not produce a value after d
duration.

**Signature**

```ts
declare const timeoutFailCause: { <E2>(cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5155)

Since v2.0.0
Stream-timeoutTo.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.timeoutTo

Switches the stream if it does not produce a value after the specified
duration.

**Signature**

```ts
declare const timeoutTo: { <A2, E2, R2>(duration: Duration.DurationInput, that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, duration: Duration.DurationInput, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5174)

Since v2.0.0
Stream-toAsyncIterable.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toAsyncIterable

Converts the stream to a `AsyncIterable`.

**Signature**

```ts
declare const toAsyncIterable: <A, E>(self: Stream<A, E>) => AsyncIterable<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5384)

Since v3.15.0
Stream-toAsyncIterableEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toAsyncIterableEffect

Converts the stream to a `AsyncIterable` capturing the required dependencies.

**Signature**

```ts
declare const toAsyncIterableEffect: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<AsyncIterable<A>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5375)

Since v3.15.0
Stream-toAsyncIterableRuntime.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toAsyncIterableRuntime

Converts the stream to a `AsyncIterable` using the provided runtime.

**Signature**

```ts
declare const toAsyncIterableRuntime: { <A, XR>(runtime: Runtime<XR>): <E, R extends XR>(self: Stream<A, E, R>) => AsyncIterable<A>; <A, E, XR, R extends XR>(self: Stream<A, E, R>, runtime: Runtime<XR>): AsyncIterable<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5364)

Since v3.15.0
Stream-toChannel.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toChannel

Creates a channel from a `Stream`.

**Signature**

```ts
declare const toChannel: <A, E, R>(stream: Stream<A, E, R>) => Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1922)

Since v2.0.0
Stream-toPubSub.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toPubSub

Converts the stream to a scoped `PubSub` of chunks. After the scope is closed,
the `PubSub` will never again produce values and should be discarded.

**Signature**

```ts
declare const toPubSub: { (capacity: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, capacity: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5193)

Since v2.0.0
Stream-toPull.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toPull

Returns in a scope a ZIO effect that can be used to repeatedly pull chunks
from the stream. The pull effect fails with None when the stream is
finished, or with Some error if it fails, otherwise it returns a chunk of
the stream's output.

**Example**

```ts
import { Effect, Stream } from "effect"

// Simulate a chunked stream
const stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(Stream.rechunk(2))

const program = Effect.gen(function*() {
  // Create an effect to get data chunks from the stream
  const getChunk = yield* Stream.toPull(stream)

  // Continuously fetch and process chunks
  while (true) {
    const chunk = yield* getChunk
    console.log(chunk)
  }
})

Effect.runPromise(Effect.scoped(program)).then(console.log, console.error)
// { _id: 'Chunk', values: [ 1, 2 ] }
// { _id: 'Chunk', values: [ 3, 4 ] }
// { _id: 'Chunk', values: [ 5 ] }
// (FiberFailure) Error: {
//   "_id": "Option",
//   "_tag": "None"
// }
```

**Signature**

```ts
declare const toPull: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>, never, Scope.Scope | R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5248)

Since v2.0.0
Stream-toQueue.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toQueue

Converts the stream to a scoped queue of chunks. After the scope is closed,
the queue will never again produce values and should be discarded.

Defaults to the "suspend" back pressure strategy with a capacity of 2.

**Signature**

```ts
declare const toQueue: { (options?: { readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: "unbounded"; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: "unbounded"; } | undefined): Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5261)

Since v2.0.0
Stream-toQueueOfElements.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toQueueOfElements

Converts the stream to a scoped queue of elements. After the scope is
closed, the queue will never again produce values and should be discarded.

Defaults to a capacity of 2.

**Signature**

```ts
declare const toQueueOfElements: { (options?: { readonly capacity?: number | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; } | undefined): Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5286)

Since v2.0.0
Stream-toReadableStream.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toReadableStream

Converts the stream to a `ReadableStream`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

**Signature**

```ts
declare const toReadableStream: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E>(self: Stream<A, E>) => ReadableStream<A>; <A, E>(self: Stream<A, E>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5306)

Since v2.0.0
Stream-toReadableStreamEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toReadableStreamEffect

Converts the stream to a `Effect<ReadableStream>`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

**Signature**

```ts
declare const toReadableStreamEffect: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<ReadableStream<A>, never, R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): Effect.Effect<ReadableStream<A>, never, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5326)

Since v2.0.0
Stream-toReadableStreamRuntime.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.toReadableStreamRuntime

Converts the stream to a `ReadableStream` using the provided runtime.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

**Signature**

```ts
declare const toReadableStreamRuntime: { <A, XR>(runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R extends XR>(self: Stream<A, E, R>) => ReadableStream<A>; <A, E, XR, R extends XR>(self: Stream<A, E, R>, runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5346)

Since v2.0.0
Stream-transduce.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.transduce

Applies the transducer to the stream and emits its outputs.

**Signature**

```ts
declare const transduce: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5392)

Since v2.0.0
Stream-unfold.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.unfold

Creates a stream by peeling off the "layers" of a value of type `S`.

**Example**

```ts
import { Effect, Option, Stream } from "effect"

const stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
declare const unfold: <S, A>(s: S, f: (s: S) => Option.Option<readonly [A, S]>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5413)

Since v2.0.0
Stream-unfoldChunk.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.unfoldChunk

Creates a stream by peeling off the "layers" of a value of type `S`.

**Signature**

```ts
declare const unfoldChunk: <S, A>(s: S, f: (s: S) => Option.Option<readonly [Chunk.Chunk<A>, S]>) => Stream<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5421)

Since v2.0.0
Stream-unfoldChunkEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.unfoldChunkEffect

Creates a stream by effectfully peeling off the "layers" of a value of type
`S`.

**Signature**

```ts
declare const unfoldChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [Chunk.Chunk<A>, S]>, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5433)

Since v2.0.0
Stream-unfoldEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.unfoldEffect

Creates a stream by effectfully peeling off the "layers" of a value of type
`S`.

**Example**

```ts
import { Effect, Option, Random, Stream } from "effect"

const stream = Stream.unfoldEffect(1, (n) =>
  Random.nextBoolean.pipe(
    Effect.map((b) => (b ? Option.some([n, -n]) : Option.some([n, n])))
  ))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, -1, -1, -1, -1 ] }
```

**Signature**

```ts
declare const unfoldEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [A, S]>, E, R>) => Stream<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5458)

Since v2.0.0
Stream-unwrap.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.unwrap

Creates a stream produced from an `Effect`.

**Signature**

```ts
declare const unwrap: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5490)

Since v2.0.0
Stream-unwrapScoped.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.unwrapScoped

Creates a stream produced from a scoped `Effect`.

**Signature**

```ts
declare const unwrapScoped: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R2 | Exclude<R, Scope.Scope>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5499)

Since v2.0.0
Stream-unwrapScopedWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.unwrapScopedWith

Creates a stream produced from a function which receives a `Scope` and
returns an `Effect`. The resulting stream will emit a single element, which
will be the result of the returned effect, if successful.

**Signature**

```ts
declare const unwrapScopedWith: <A, E2, R2, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5511)

Since v3.11.0
Stream-updateService.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.updateService

Updates the specified service within the context of the `Stream`.

**Signature**

```ts
declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, I | R>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Stream<A, E, I | R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5521)

Since v2.0.0
Stream-void.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.void

A stream that contains a single `void` value.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.void

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ undefined ] }

```

**Signature**

```ts
declare const void: Stream<void, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5481)

Since v2.0.0
Stream-when.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.when

Returns the specified stream if the given condition is satisfied, otherwise
returns an empty stream.

**Signature**

```ts
declare const when: { (test: LazyArg<boolean>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, test: LazyArg<boolean>): Stream<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5540)

Since v2.0.0
Stream-whenCase.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.whenCase

Returns the resulting stream when the given `PartialFunction` is defined
for the given value, otherwise returns an empty stream.

**Signature**

```ts
declare const whenCase: <A, A2, E, R>(evaluate: LazyArg<A>, pf: (a: A) => Option.Option<Stream<A2, E, R>>) => Stream<A2, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5552)

Since v2.0.0
Stream-whenCaseEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.whenCaseEffect

Returns the stream when the given partial function is defined for the given
effectful value, otherwise returns an empty stream.

**Signature**

```ts
declare const whenCaseEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): <E, R>(self: Effect.Effect<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5564)

Since v2.0.0
Stream-whenEffect.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.whenEffect

Returns the stream if the given effectful condition is satisfied, otherwise
returns an empty stream.

**Signature**

```ts
declare const whenEffect: { <E2, R2>(effect: Effect.Effect<boolean, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5581)

Since v2.0.0
Stream-withExecutionPlan.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.withExecutionPlan

Apply an `ExecutionPlan` to the stream, which allows you to fallback to
different resources in case of failure.

If you have a stream that could fail with partial results, you can use
the `preventFallbackOnPartialStream` option to prevent contamination of
the final stream with partial results.

**Signature**

```ts
declare const withExecutionPlan: { <Input, R2, Provides, PolicyE>(policy: ExecutionPlan<{ provides: Provides; input: Input; error: PolicyE; requirements: R2; }>, options?: { readonly preventFallbackOnPartialStream?: boolean | undefined; }): <A, E extends Input, R>(self: Stream<A, E, R>) => Stream<A, E | PolicyE, R2 | Exclude<R, Provides>>; <A, E extends Input, R, R2, Input, Provides, PolicyE>(self: Stream<A, E, R>, policy: ExecutionPlan<{ provides: Provides; input: Input; error: PolicyE; requirements: R2; }>, options?: { readonly preventFallbackOnPartialStream?: boolean | undefined; }): Stream<A, E | PolicyE, R2 | Exclude<R, Provides>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4083)

Since v3.16.0
Stream-withSpan.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.withSpan

Wraps the stream with a new span for tracing.

**Signature**

```ts
declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Stream<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Stream<A, E, Exclude<R, Tracer.ParentSpan>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5592)

Since v2.0.0
Stream-zip.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zip

Zips this stream with another point-wise and emits tuples of elements from
both streams.

The new stream will end when one of the sides ends.

**Example**

```ts
import { Effect, Stream } from "effect"

// We create two streams and zip them together.
const stream = Stream.zip(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make("a", "b", "c")
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 1, 'a' ], [ 2, 'b' ], [ 3, 'c' ] ] }
```

**Signature**

```ts
declare const zip: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[A, A2], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5627)

Since v2.0.0
Stream-zipAll.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAll

Zips this stream with another point-wise, creating a new stream of pairs of
elements from both sides.

The defaults `defaultLeft` and `defaultRight` will be used if the streams
have different lengths and one of the streams has ended before the other.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.zipAll(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make("a", "b", "c"),
  defaultSelf: 0,
  defaultOther: "x"
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 1, "a" ], [ 2, "b" ], [ 3, "c" ], [ 4, "x" ], [ 5, "x" ], [ 6, "x" ] ] }
```

**Signature**

```ts
declare const zipAll: { <A2, E2, R2, A>(options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): <E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): Stream<[A, A2], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5675)

Since v2.0.0
Stream-zipAllLeft.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAllLeft

Zips this stream with another point-wise, and keeps only elements from this
stream.

The provided default value will be used if the other stream ends before
this one.

**Signature**

```ts
declare const zipAllLeft: { <A2, E2, R2, A>(that: Stream<A2, E2, R2>, defaultLeft: A): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultLeft: A): Stream<A, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5695)

Since v2.0.0
Stream-zipAllRight.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAllRight

Zips this stream with another point-wise, and keeps only elements from the
other stream.

The provided default value will be used if this stream ends before the
other one.

**Signature**

```ts
declare const zipAllRight: { <A2, E2, R2>(that: Stream<A2, E2, R2>, defaultRight: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultRight: A2): Stream<A2, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5710)

Since v2.0.0
Stream-zipAllSortedByKey.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAllSortedByKey

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Combines values associated with each key into a tuple,
using the specified values `defaultLeft` and `defaultRight` to fill in
missing values.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

**Signature**

```ts
declare const zipAllSortedByKey: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, [A, A2]], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order.Order<K>; }): Stream<[K, [A, A2]], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5732)

Since v2.0.0
Stream-zipAllSortedByKeyLeft.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAllSortedByKeyLeft

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Keeps only values from this stream, using the specified
value `default` to fill in missing values.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

**Signature**

```ts
declare const zipAllSortedByKeyLeft: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): Stream<[K, A], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5765)

Since v2.0.0
Stream-zipAllSortedByKeyRight.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAllSortedByKeyRight

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Keeps only values from that stream, using the specified
value `default` to fill in missing values.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

**Signature**

```ts
declare const zipAllSortedByKeyRight: { <K, A2, E2, R2>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): <A, E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A2], E2 | E, R2 | R>; <A, E, R, K, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): Stream<[K, A2], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5796)

Since v2.0.0
Stream-zipAllSortedByKeyWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAllSortedByKeyWith

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Uses the functions `left`, `right`, and `both` to handle
the cases where a key and value exist in this stream, that stream, or
both streams.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

**Signature**

```ts
declare const zipAllSortedByKeyWith: { <K, A2, E2, R2, A, A3>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A3], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2, A3>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): Stream<[K, A3], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5828)

Since v2.0.0
Stream-zipAllWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipAllWith

Zips this stream with another point-wise. The provided functions will be
used to create elements for the composed stream.

The functions `left` and `right` will be used if the streams have different
lengths and one of the streams has ended before the other.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make("a", "b", "c"),
  onSelf: (n) => [n, "x"],
  onOther: (s) => [0, s],
  onBoth: (n, s) => [n - s.length, s]
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 0, "a" ], [ 1, "b" ], [ 2, "c" ], [ 4, "x" ], [ 5, "x" ], [ 6, "x" ] ] }
```

**Signature**

```ts
declare const zipAllWith: { <A2, E2, R2, A, A3>(options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): Stream<A3, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5875)

Since v2.0.0
Stream-zipFlatten.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipFlatten

Zips this stream with another point-wise and emits tuples of elements from
both streams.

The new stream will end when one of the sides ends.

**Signature**

```ts
declare const zipFlatten: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A extends ReadonlyArray<any>, E, R>(self: Stream<A, E, R>) => Stream<[...A, A2], E2 | E, R2 | R>; <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[...A, A2], E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5641)

Since v2.0.0
Stream-zipLatest.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipLatest

Zips the two streams so that when a value is emitted by either of the two
streams, it is combined with the latest value from the other stream to
produce a result.

Note: tracking the latest value is done on a per-chunk basis. That means
that emitted elements that are not the last value in chunks will never be
used for zipping.

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced("1 second"))
)

const s2 = Stream.make("a", "b", "c", "d").pipe(
  Stream.schedule(Schedule.spaced("500 millis"))
)

const stream = Stream.zipLatest(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 1, "a" ], [ 1, "b" ], [ 2, "b" ], [ 2, "c" ], [ 2, "d" ], [ 3, "d" ] ] }
```

**Signature**

```ts
declare const zipLatest: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<[AL, AR], EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5925)

Since v2.0.0
Stream-zipLatestAll.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipLatestAll

Zips multiple streams so that when a value is emitted by any of the streams,
it is combined with the latest values from the other streams to produce a result.

Note: tracking the latest value is done on a per-chunk basis. That means
that emitted elements that are not the last value in chunks will never be
used for zipping.

**Example**

```ts
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.zipLatestAll(
    Stream.fromSchedule(Schedule.spaced('1 millis')),
    Stream.fromSchedule(Schedule.spaced('2 millis')),
    Stream.fromSchedule(Schedule.spaced('4 millis')),
).pipe(Stream.take(6), Stream.tap(Console.log))

Effect.runPromise(Stream.runDrain(stream))
// Output:
// [ 0, 0, 0 ]
// [ 1, 0, 0 ]
// [ 1, 1, 0 ]
// [ 2, 1, 0 ]
// [ 3, 1, 0 ]
// [ 3, 1, 1 ]
// .....
```

**Signature**

```ts
declare const zipLatestAll: <T extends ReadonlyArray<Stream<any, any, any>>>(...streams: T) => Stream<[T[number]] extends [never] ? never : { [K in keyof T]: T[K] extends Stream<infer A, infer _E, infer _R> ? A : never; }, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _E : never, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _R : never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5962)

Since v3.3.0
Stream-zipLatestWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipLatestWith

Zips the two streams so that when a value is emitted by either of the two
streams, it is combined with the latest value from the other stream to
produce a result.

Note: tracking the latest value is done on a per-chunk basis. That means
that emitted elements that are not the last value in chunks will never be
used for zipping.

**Signature**

```ts
declare const zipLatestWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5983)

Since v2.0.0
Stream-zipLeft.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipLeft

Zips this stream with another point-wise, but keeps only the outputs of
`left` stream.

The new stream will end when one of the sides ends.

**Signature**

```ts
declare const zipLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6004)

Since v2.0.0
Stream-zipRight.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipRight

Zips this stream with another point-wise, but keeps only the outputs of the
`right` stream.

The new stream will end when one of the sides ends.

**Signature**

```ts
declare const zipRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6018)

Since v2.0.0
Stream-zipWith.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipWith

Zips this stream with another point-wise and applies the function to the
paired elements.

The new stream will end when one of the sides ends.

**Example**

```ts
import { Effect, Stream } from "effect"

// We create two streams and zip them with custom logic.
const stream = Stream.zipWith(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make("a", "b", "c"),
  (n, s) => [n - s.length, s]
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 0, 'a' ], [ 1, 'b' ], [ 2, 'c' ] ] }
```

**Signature**

```ts
declare const zipWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6047)

Since v2.0.0
Stream-zipWithChunks.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipWithChunks

Zips this stream with another point-wise and applies the function to the
paired elements.

The new stream will end when one of the sides ends.

**Signature**

```ts
declare const zipWithChunks: { <A2, E2, R2, A, A3>(that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): Stream<A3, E | E2, R | R2>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6068)

Since v2.0.0
Stream-zipWithIndex.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipWithIndex

Zips this stream together with the index of elements.

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make("Mary", "James", "Robert", "Patricia")

const indexedStream = Stream.zipWithIndex(stream)

Effect.runPromise(Stream.runCollect(indexedStream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'Mary', 0 ], [ 'James', 1 ], [ 'Robert', 2 ], [ 'Patricia', 3 ] ]
// }
```

**Signature**

```ts
declare const zipWithIndex: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, number], E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6196)

Since v2.0.0
Stream-zipWithNext.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipWithNext

Zips each element with the next element if present.

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ 1, { _id: 'Option', _tag: 'Some', value: 2 } ],
//   [ 2, { _id: 'Option', _tag: 'Some', value: 3 } ],
//   [ 3, { _id: 'Option', _tag: 'Some', value: 4 } ],
//   [ 4, { _id: 'Option', _tag: 'None' } ]
// ]
```

**Signature**

```ts
declare const zipWithNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, Option.Option<A>], E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6107)

Since v2.0.0
Stream-zipWithPrevious.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipWithPrevious

Zips each element with the previous element. Initially accompanied by
`None`.

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPrevious(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ { _id: 'Option', _tag: 'None' }, 1 ],
//   [ { _id: 'Option', _tag: 'Some', value: 1 }, 2 ],
//   [ { _id: 'Option', _tag: 'Some', value: 2 }, 3 ],
//   [ { _id: 'Option', _tag: 'Some', value: 3 }, 4 ]
// ]
```

**Signature**

```ts
declare const zipWithPrevious: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A], E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6131)

Since v2.0.0
Stream-zipWithPreviousAndNext.md
Package: `effect`<br />
Module: `Stream`<br />

## Stream.zipWithPreviousAndNext

Zips each element with both the previous and next element.

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPreviousAndNext(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [
//     { _id: 'Option', _tag: 'None' },
//     1,
//     { _id: 'Option', _tag: 'Some', value: 2 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 1 },
//     2,
//     { _id: 'Option', _tag: 'Some', value: 3 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 2 },
//     3,
//     { _id: 'Option', _tag: 'Some', value: 4 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 3 },
//     4,
//     { _id: 'Option', _tag: 'None' }
//   ]
// ]
```

**Signature**

```ts
declare const zipWithPreviousAndNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A, Option.Option<A>], E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6171)

Since v2.0.0
StreamEmit-Emit.md
Package: `effect`<br />
Module: `StreamEmit`<br />

## StreamEmit.Emit

An `Emit<R, E, A, B>` represents an asynchronous callback that can be
called multiple times. The callback can be called with a value of type
`Effect<Chunk<A>, Option<E>, R>`, where succeeding with a `Chunk<A>`
indicates to emit those elements, failing with `Some<E>` indicates to
terminate with that error, and failing with `None` indicates to terminate
with an end of stream signal.

**Signature**

```ts
export interface Emit<in R, in E, in A, out B> extends EmitOps<R, E, A, B> {
  (f: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>): Promise<B>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamEmit.ts#L21)

Since v2.0.0
StreamHaltStrategy-match.md
Package: `effect`<br />
Module: `StreamHaltStrategy`<br />

## StreamHaltStrategy.match

Folds over the specified `HaltStrategy` using the provided case functions.

**Signature**

```ts
declare const match: { <Z>(options: { readonly onLeft: () => Z; readonly onRight: () => Z; readonly onBoth: () => Z; readonly onEither: () => Z; }): (self: HaltStrategy) => Z; <Z>(self: HaltStrategy, options: { readonly onLeft: () => Z; readonly onRight: () => Z; readonly onBoth: () => Z; readonly onEither: () => Z; }): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L110)

Since v2.0.0
String-Concat.md
Package: `effect`<br />
Module: `String`<br />

## String.Concat

Concatenates two strings at the type level.

**Signature**

```ts
type `${A}${B}` = `${A}${B}`
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L61)

Since v2.0.0
String-concat.md
Package: `effect`<br />
Module: `String`<br />

## String.concat

Concatenates two strings at runtime.

**Signature**

```ts
declare const concat: { <B extends string>(that: B): <A extends string>(self: A) => Concat<A, B>; <A extends string, B extends string>(self: A, that: B): Concat<A, B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L68)

Since v2.0.0
String-empty.md
Package: `effect`<br />
Module: `String`<br />

## String.empty

The empty string `""`.

**Signature**

```ts
declare const empty: ""
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L54)

Since v2.0.0
String-includes.md
Package: `effect`<br />
Module: `String`<br />

## String.includes

Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are
greater than or equal to `position`; otherwise, returns `false`.

**Signature**

```ts
declare const includes: (searchString: string, position?: number) => (self: string) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L278)

Since v2.0.0
String-isEmpty.md
Package: `effect`<br />
Module: `String`<br />

## String.isEmpty

Test whether a `string` is empty.

**Example**

```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.isEmpty(''), true)
assert.deepStrictEqual(String.isEmpty('a'), false)
```

**Signature**

```ts
declare const isEmpty: (self: string) => self is ""
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L228)

Since v2.0.0
String-isNonEmpty.md
Package: `effect`<br />
Module: `String`<br />

## String.isNonEmpty

Test whether a `string` is non empty.

**Signature**

```ts
declare const isNonEmpty: (self: string) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L235)

Since v2.0.0
String-isString.md
Package: `effect`<br />
Module: `String`<br />

## String.isString

Tests if a value is a `string`.

**Example**

```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.isString("a"), true)
assert.deepStrictEqual(String.isString(1), false)
```

**Signature**

```ts
declare const isString: Refinement<unknown, string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L35)

Since v2.0.0
String-length.md
Package: `effect`<br />
Module: `String`<br />

## String.length

Calculate the number of characters in a `string`.

**Example**

```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.length('abc'), 3)
```

**Signature**

```ts
declare const length: (self: string) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L250)

Since v2.0.0
String-linesIterator.md
Package: `effect`<br />
Module: `String`<br />

## String.linesIterator

Returns an `IterableIterator` which yields each line contained within the
string, trimming off the trailing newline character.

**Signature**

```ts
declare const linesIterator: (self: string) => LinesIterator
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L632)

Since v2.0.0
String-linesWithSeparators.md
Package: `effect`<br />
Module: `String`<br />

## String.linesWithSeparators

Returns an `IterableIterator` which yields each line contained within the
string as well as the trailing newline character.

**Signature**

```ts
declare const linesWithSeparators: (s: string) => LinesIterator
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L640)

Since v2.0.0
String-match.md
Package: `effect`<br />
Module: `String`<br />

## String.match

It is the `pipe`-able version of the native `match` method.

**Signature**

```ts
declare const match: (regexp: RegExp | string) => (self: string) => Option.Option<RegExpMatchArray>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L432)

Since v2.0.0
String-matchAll.md
Package: `effect`<br />
Module: `String`<br />

## String.matchAll

It is the `pipe`-able version of the native `matchAll` method.

**Signature**

```ts
declare const matchAll: (regexp: RegExp) => (self: string) => IterableIterator<RegExpMatchArray>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L440)

Since v2.0.0
String-stripMargin.md
Package: `effect`<br />
Module: `String`<br />

## String.stripMargin

For every line in this string, strip a leading prefix consisting of blanks
or control characters followed by the `"|"` character from the line.

**Signature**

```ts
declare const stripMargin: (self: string) => string
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L678)

Since v2.0.0
String-stripMarginWith.md
Package: `effect`<br />
Module: `String`<br />

## String.stripMarginWith

For every line in this string, strip a leading prefix consisting of blanks
or control characters followed by the character specified by `marginChar`
from the line.

**Signature**

```ts
declare const stripMarginWith: { (marginChar: string): (self: string) => string; (self: string, marginChar: string): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L649)

Since v2.0.0
String-takeLeft.md
Package: `effect`<br />
Module: `String`<br />

## String.takeLeft

Keep the specified number of characters from the start of a string.

If `n` is larger than the available number of characters, the string will
be returned whole.

If `n` is not a positive number, an empty string will be returned.

If `n` is a float, it will be rounded down to the nearest integer.

**Example**

```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.takeLeft("Hello World", 5), "Hello")
```

**Signature**

```ts
declare const takeLeft: { (n: number): (self: string) => string; (self: string, n: number): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L590)

Since v2.0.0
String-takeRight.md
Package: `effect`<br />
Module: `String`<br />

## String.takeRight

Keep the specified number of characters from the end of a string.

If `n` is larger than the available number of characters, the string will
be returned whole.

If `n` is not a positive number, an empty string will be returned.

If `n` is a float, it will be rounded down to the nearest integer.

**Example**

```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.takeRight("Hello World", 5), "World")
```

**Signature**

```ts
declare const takeRight: { (n: number): (self: string) => string; (self: string, n: number): string; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L615)

Since v2.0.0
Struct-evolve.md
Package: `effect`<br />
Module: `Struct`<br />

## Struct.evolve

Transforms the values of a Struct provided a transformation function for each key.
If no transformation function is provided for a key, it will return the origional value for that key.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(
  pipe(
    { a: 'a', b: 1, c: 3 },
    Struct.evolve({
      a: (a) => a.length,
      b: (b) => b * 2
    })
  ),
  { a: 1, b: 2, c: 3 }
)
```

**Signature**

```ts
declare const evolve: { <O, T>(t: PartialTransform<O, T>): (obj: O) => Transformed<O, T>; <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L162)

Since v2.0.0
Struct-get.md
Package: `effect`<br />
Module: `Struct`<br />

## Struct.get

Retrieves the value associated with the specified key from a struct.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

const value = pipe({ a: 1, b: 2 }, Struct.get("a"))

assert.deepStrictEqual(value, 1)
```

**Signature**

```ts
declare const get: <K extends PropertyKey>(key: K) => <S extends { [P in K]?: any; }>(s: S) => MatchRecord<S, S[K] | undefined, S[K]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L194)

Since v2.0.0
Struct-getEquivalence.md
Package: `effect`<br />
Module: `Struct`<br />

## Struct.getEquivalence

Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
by applying each `Equivalence` to the corresponding property of the struct.

Alias of `Equivalence.struct`.

**Example**

```ts
import * as assert from "node:assert"
import { Struct, String, Number } from "effect"

const PersonEquivalence = Struct.getEquivalence({
  name: String.Equivalence,
  age: Number.Equivalence
})

assert.deepStrictEqual(
  PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 25 }),
  true
)
assert.deepStrictEqual(
  PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 40 }),
  false
)
```

**Signature**

```ts
declare const getEquivalence: <R extends Record<string, Equivalence.Equivalence<any>>>(isEquivalents: R) => Equivalence.Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L112)

Since v2.0.0
Struct-getOrder.md
Package: `effect`<br />
Module: `Struct`<br />

## Struct.getOrder

This function creates and returns a new `Order` for a struct of values based on the given `Order`s
for each property in the struct.

Alias of `order.struct`.

**Signature**

```ts
declare const getOrder: <R extends { readonly [x: string]: order.Order<any>; }>(fields: R) => order.Order<{ [K in keyof R]: [R[K]] extends [order.Order<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L127)

Since v2.0.0
Struct-keys.md
Package: `effect`<br />
Module: `Struct`<br />

## Struct.keys

Retrieves the object keys that are strings in a typed manner

**Example**

```ts
import * as assert from "node:assert"
import { Struct } from "effect"

const symbol: unique symbol = Symbol()

const value = {
  a: 1,
  b: 2,
  [symbol]: 3
}

const keys: Array<"a" | "b"> = Struct.keys(value)

assert.deepStrictEqual(keys, ["a", "b"])
```

**Signature**

```ts
declare const keys: <T extends {}>(o: T) => Array<(keyof T) & string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L221)

Since v3.6.0
Struct-omit.md
Package: `effect`<br />
Module: `Struct`<br />

## Struct.omit

Create a new object by omitting properties of an existing object.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.omit("c")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.omit({ a: "a", b: 1, c: true }, "c"), { a: "a", b: 1 })
```

**Signature**

```ts
declare const omit: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => Simplify<Omit<S, Keys[number]>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): Simplify<Omit<S, Keys[number]>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L64)

Since v2.0.0
Struct-pick.md
Package: `effect`<br />
Module: `Struct`<br />

## Struct.pick

Create a new object by picking properties of an existing object.

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.pick("a", "b")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.pick({ a: "a", b: 1, c: true }, "a", "b"), { a: "a", b: 1 })
```

**Signature**

```ts
declare const pick: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L27)

Since v2.0.0
SubscriptionRef-SubscriptionRef.md
Package: `effect`<br />
Module: `SubscriptionRef`<br />

## SubscriptionRef.SubscriptionRef

A `SubscriptionRef<A>` is a `Ref` that can be subscribed to in order to
receive the current value as well as all changes to the value.

**Signature**

```ts
export interface SubscriptionRef<in out A>
  extends SubscriptionRef.Variance<A>, Synchronized.SynchronizedRef<A>, Subscribable<A>
{
  /** @internal */
  readonly ref: Ref.Ref<A>
  /** @internal */
  readonly pubsub: PubSub.PubSub<A>
  /** @internal */
  readonly semaphore: Effect.Semaphore
  /**
   * A stream containing the current value of the `Ref` as well as all changes
   * to that value.
   */
  readonly changes: Stream.Stream<A>
  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: SubscriptionRefUnify<this>
  readonly [Unify.ignoreSymbol]?: SubscriptionRefUnifyIgnore
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L34)

Since v2.0.0
SubscriptionRef-make.md
Package: `effect`<br />
Module: `SubscriptionRef`<br />

## SubscriptionRef.make

Creates a new `SubscriptionRef` with the specified value.

**Signature**

```ts
declare const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L148)

Since v2.0.0
Supervisor-fibersIn.md
Package: `effect`<br />
Module: `Supervisor`<br />

## Supervisor.fibersIn

Creates a new supervisor that tracks children in a set.

**Signature**

```ts
declare const fibersIn: (ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>) => Effect.Effect<Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L115)

Since v2.0.0
Supervisor-fromEffect.md
Package: `effect`<br />
Module: `Supervisor`<br />

## Supervisor.fromEffect

Creates a new supervisor that constantly yields effect when polled

**Signature**

```ts
declare const fromEffect: <A>(effect: Effect.Effect<A>) => Supervisor<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L125)

Since v2.0.0
Supervisor-none.md
Package: `effect`<br />
Module: `Supervisor`<br />

## Supervisor.none

A supervisor that doesn't do anything in response to supervision events.

**Signature**

```ts
declare const none: Supervisor<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L133)

Since v2.0.0
Supervisor-track.md
Package: `effect`<br />
Module: `Supervisor`<br />

## Supervisor.track

Creates a new supervisor that tracks children in a set.

**Signature**

```ts
declare const track: Effect.Effect<Supervisor<Array<Fiber.RuntimeFiber<any, any>>>, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L141)

Since v2.0.0
Supervisor-unsafeTrack.md
Package: `effect`<br />
Module: `Supervisor`<br />

## Supervisor.unsafeTrack

Unsafely creates a new supervisor that tracks children in a set.

**Signature**

```ts
declare const unsafeTrack: () => Supervisor<Array<Fiber.RuntimeFiber<any, any>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L149)

Since v2.0.0
Symbol-isSymbol.md
Package: `effect`<br />
Module: `Symbol`<br />

## Symbol.isSymbol

Tests if a value is a `symbol`.

**Example**

```ts
import * as assert from "node:assert"
import { Predicate } from "effect"

assert.deepStrictEqual(Predicate.isSymbol(Symbol.for("a")), true)
assert.deepStrictEqual(Predicate.isSymbol("a"), false)
```

**Signature**

```ts
declare const isSymbol: (u: unknown) => u is symbol
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Symbol.ts#L23)

Since v2.0.0
Take-chunk.md
Package: `effect`<br />
Module: `Take`<br />

## Take.chunk

Creates a `Take` with the specified chunk.

**Signature**

```ts
declare const chunk: <A>(chunk: Chunk.Chunk<A>) => Take<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L60)

Since v2.0.0
Take-die.md
Package: `effect`<br />
Module: `Take`<br />

## Take.die

Creates a failing `Take` with the specified defect.

**Signature**

```ts
declare const die: (defect: unknown) => Take<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L68)

Since v2.0.0
Take-dieMessage.md
Package: `effect`<br />
Module: `Take`<br />

## Take.dieMessage

Creates a failing `Take` with the specified error message.

**Signature**

```ts
declare const dieMessage: (message: string) => Take<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L76)

Since v2.0.0
Take-done.md
Package: `effect`<br />
Module: `Take`<br />

## Take.done

Transforms a `Take<A, E>` to an `Effect<A, E>`.

**Signature**

```ts
declare const done: <A, E>(self: Take<A, E>) => Effect.Effect<Chunk.Chunk<A>, Option.Option<E>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L84)

Since v2.0.0
Take-end.md
Package: `effect`<br />
Module: `Take`<br />

## Take.end

Represents the end-of-stream marker.

**Signature**

```ts
declare const end: Take<never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L92)

Since v2.0.0
Take-fail.md
Package: `effect`<br />
Module: `Take`<br />

## Take.fail

Creates a failing `Take` with the specified error.

**Signature**

```ts
declare const fail: <E>(error: E) => Take<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L100)

Since v2.0.0
Take-failCause.md
Package: `effect`<br />
Module: `Take`<br />

## Take.failCause

Creates a failing `Take` with the specified cause.

**Signature**

```ts
declare const failCause: <E>(cause: Cause.Cause<E>) => Take<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L108)

Since v2.0.0
Take-fromEffect.md
Package: `effect`<br />
Module: `Take`<br />

## Take.fromEffect

Creates an effect from `Effect<A, E, R>` that does not fail, but succeeds with
the `Take<A, E>`. Error from stream when pulling is converted to
`Take.failCause`. Creates a single value chunk.

**Signature**

```ts
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Take<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L118)

Since v2.0.0
Take-fromExit.md
Package: `effect`<br />
Module: `Take`<br />

## Take.fromExit

Creates a `Take` from an `Exit`.

**Signature**

```ts
declare const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Take<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L127)

Since v2.0.0
Take-fromPull.md
Package: `effect`<br />
Module: `Take`<br />

## Take.fromPull

Creates effect from `Effect<Chunk<A>, Option<E>, R>` that does not fail, but
succeeds with the `Take<A, E>`. Errors from stream when pulling are converted
to `Take.failCause`, and the end-of-stream is converted to `Take.end`.

**Signature**

```ts
declare const fromPull: <A, E, R>(pull: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Effect.Effect<Take<A, E>, never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L137)

Since v2.0.0
Take-isDone.md
Package: `effect`<br />
Module: `Take`<br />

## Take.isDone

Checks if this `take` is done (`Take.end`).

**Signature**

```ts
declare const isDone: <A, E>(self: Take<A, E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L147)

Since v2.0.0
TArray-collectFirst.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.collectFirst

Finds the result of applying a partial function to the first value in its
domain.

**Signature**

```ts
declare const collectFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TArray<A>) => STM.STM<Option.Option<B>>; <A, B>(self: TArray<A>, pf: (a: A) => Option.Option<B>): STM.STM<Option.Option<B>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L60)

Since v2.0.0
TArray-collectFirstSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.collectFirstSTM

Finds the result of applying an transactional partial function to the first
value in its domain.

**Signature**

```ts
declare const collectFirstSTM: { <A, B, E, R>(pf: (a: A) => Option.Option<STM.STM<B, E, R>>): (self: TArray<A>) => STM.STM<Option.Option<B>, E, R>; <A, B, E, R>(self: TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>): STM.STM<Option.Option<B>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L72)

Since v2.0.0
TArray-contains.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.contains

Determine if the array contains a specified value.

**Signature**

```ts
declare const contains: { <A>(value: A): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, value: A): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L84)

Since v2.0.0
TArray-count.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.count

Count the values in the array matching a predicate.

**Signature**

```ts
declare const count: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<number>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<number>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L96)

Since v2.0.0
TArray-countSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.countSTM

Count the values in the array matching a transactional predicate.

**Signature**

```ts
declare const countSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<number, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<number, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L108)

Since v2.0.0
TArray-empty.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.empty

Makes an empty `TArray`.

**Signature**

```ts
declare const empty: <A>() => STM.STM<TArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L119)

Since v2.0.0
TArray-every.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.every

Atomically evaluate the conjunction of a predicate across the members of
the array.

**Signature**

```ts
declare const every: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L128)

Since v2.0.0
TArray-everySTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.everySTM

Atomically evaluate the conjunction of a transactional predicate across the
members of the array.

**Signature**

```ts
declare const everySTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L140)

Since v2.0.0
TArray-findFirst.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirst

Find the first element in the array matching the specified predicate.

**Signature**

```ts
declare const findFirst: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L151)

Since v2.0.0
TArray-findFirstIndex.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirstIndex

Get the first index of a specific value in the array.

**Signature**

```ts
declare const findFirstIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L162)

Since v2.0.0
TArray-findFirstIndexFrom.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirstIndexFrom

Get the first index of a specific value in the array starting from the
specified index.

**Signature**

```ts
declare const findFirstIndexFrom: { <A>(value: A, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, from: number): STM.STM<Option.Option<number>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L174)

Since v2.0.0
TArray-findFirstIndexWhere.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirstIndexWhere

Get the index of the first entry in the array matching a predicate.

**Signature**

```ts
declare const findFirstIndexWhere: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<number>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L185)

Since v2.0.0
TArray-findFirstIndexWhereFrom.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirstIndexWhereFrom

Get the index of the first entry in the array starting from the specified
index, matching a predicate.

**Signature**

```ts
declare const findFirstIndexWhereFrom: { <A>(predicate: Predicate<A>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>, from: number): STM.STM<Option.Option<number>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L197)

Since v2.0.0
TArray-findFirstIndexWhereFromSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirstIndexWhereFromSTM

Starting at specified index, get the index of the next entry that matches a
transactional predicate.

**Signature**

```ts
declare const findFirstIndexWhereFromSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>, from: number): STM.STM<Option.Option<number>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L220)

Since v2.0.0
TArray-findFirstIndexWhereSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirstIndexWhereSTM

Get the index of the next entry that matches a transactional predicate.

**Signature**

```ts
declare const findFirstIndexWhereSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<number>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L208)

Since v2.0.0
TArray-findFirstSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findFirstSTM

Find the first element in the array matching a transactional predicate.

**Signature**

```ts
declare const findFirstSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L238)

Since v2.0.0
TArray-findLast.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findLast

Find the last element in the array matching a predicate.

**Signature**

```ts
declare const findLast: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L249)

Since v2.0.0
TArray-findLastIndex.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findLastIndex

Get the last index of a specific value in the array bounded above by a
specific index.

**Signature**

```ts
declare const findLastIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L261)

Since v2.0.0
TArray-findLastIndexFrom.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findLastIndexFrom

Get the last index of a specific value in the array bounded above by a
specific index.

**Signature**

```ts
declare const findLastIndexFrom: { <A>(value: A, end: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, end: number): STM.STM<Option.Option<number>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L273)

Since v2.0.0
TArray-findLastSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.findLastSTM

Find the last element in the array matching a transactional predicate.

**Signature**

```ts
declare const findLastSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L284)

Since v2.0.0
TArray-forEach.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.forEach

Atomically performs transactional effect for each item in array.

**Signature**

```ts
declare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L295)

Since v2.0.0
TArray-fromIterable.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.fromIterable

Creates a new `TArray` from an iterable collection of values.

**Signature**

```ts
declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TArray<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L306)

Since v2.0.0
TArray-get.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.get

Extracts value from ref in array.

**Signature**

```ts
declare const get: { (index: number): <A>(self: TArray<A>) => STM.STM<A>; <A>(self: TArray<A>, index: number): STM.STM<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L314)

Since v2.0.0
TArray-headOption.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.headOption

The first entry of the array, if it exists.

**Signature**

```ts
declare const headOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L325)

Since v2.0.0
TArray-lastOption.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.lastOption

The last entry in the array, if it exists.

**Signature**

```ts
declare const lastOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L333)

Since v2.0.0
TArray-make.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.make

Makes a new `TArray` that is initialized with specified values.

**Signature**

```ts
declare const make: <Elements extends [any, ...Array<any>]>(...elements: Elements) => STM.STM<TArray<Elements[number]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L341)

Since v2.0.0
TArray-maxOption.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.maxOption

Atomically compute the greatest element in the array, if it exists.

**Signature**

```ts
declare const maxOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L351)

Since v2.0.0
TArray-minOption.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.minOption

Atomically compute the least element in the array, if it exists.

**Signature**

```ts
declare const minOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L362)

Since v2.0.0
TArray-reduce.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.reduce

Atomically folds using a pure function.

**Signature**

```ts
declare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z): (self: TArray<A>) => STM.STM<Z>; <Z, A>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z): STM.STM<Z>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L373)

Since v2.0.0
TArray-reduceOption.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.reduceOption

Atomically reduce the array, if non-empty, by a binary operator.

**Signature**

```ts
declare const reduceOption: { <A>(f: (x: A, y: A) => A): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, f: (x: A, y: A) => A): STM.STM<Option.Option<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L384)

Since v2.0.0
TArray-reduceOptionSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.reduceOptionSTM

Atomically reduce the non-empty array using a transactional binary
operator.

**Signature**

```ts
declare const reduceOptionSTM: { <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>): STM.STM<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L396)

Since v2.0.0
TArray-reduceSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.reduceSTM

Atomically folds using a transactional function.

**Signature**

```ts
declare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): (self: TArray<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L408)

Since v2.0.0
TArray-size.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.size

Returns the size of the `TArray`.

**Signature**

```ts
declare const size: <A>(self: TArray<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L419)

Since v2.0.0
TArray-some.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.some

Determine if the array contains a value satisfying a predicate.

**Signature**

```ts
declare const some: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L427)

Since v2.0.0
TArray-someSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.someSTM

Determine if the array contains a value satisfying a transactional
predicate.

**Signature**

```ts
declare const someSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L439)

Since v2.0.0
TArray-toArray.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.toArray

Collects all elements into a chunk.

**Signature**

```ts
declare const toArray: <A>(self: TArray<A>) => STM.STM<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L451)

Since v2.0.0, 2.0.0
TArray-transform.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.transform

Atomically updates all elements using a pure function.

**Signature**

```ts
declare const transform: { <A>(f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, f: (value: A) => A): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L459)

Since v2.0.0
TArray-transformSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.transformSTM

Atomically updates all elements using a transactional effect.

**Signature**

```ts
declare const transformSTM: { <A, R, E>(f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L470)

Since v2.0.0
TArray-update.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.update

Updates element in the array with given function.

**Signature**

```ts
declare const update: { <A>(index: number, f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, index: number, f: (value: A) => A): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L481)

Since v2.0.0
TArray-updateSTM.md
Package: `effect`<br />
Module: `TArray`<br />

## TArray.updateSTM

Atomically updates element in the array with given transactional effect.

**Signature**

```ts
declare const updateSTM: { <A, R, E>(index: number, f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, index: number, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L492)

Since v2.0.0
Take-Take.md
Package: `effect`<br />
Module: `Take`<br />

## Take.Take

A `Take<A, E>` represents a single `take` from a queue modeling a stream of
values. A `Take` may be a failure cause `Cause<E>`, a chunk value `Chunk<A>`,
or an end-of-stream marker.

**Signature**

```ts
export interface Take<out A, out E = never> extends Take.Variance<A, E>, Pipeable {
  /** @internal */
  readonly exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L33)

Since v2.0.0
Take-isFailure.md
Package: `effect`<br />
Module: `Take`<br />

## Take.isFailure

Checks if this `take` is a failure.

**Signature**

```ts
declare const isFailure: <A, E>(self: Take<A, E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L155)

Since v2.0.0
Take-isSuccess.md
Package: `effect`<br />
Module: `Take`<br />

## Take.isSuccess

Checks if this `take` is a success.

**Signature**

```ts
declare const isSuccess: <A, E>(self: Take<A, E>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L163)

Since v2.0.0
Take-make.md
Package: `effect`<br />
Module: `Take`<br />

## Take.make

Constructs a `Take`.

**Signature**

```ts
declare const make: <A, E>(exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>) => Take<A, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L171)

Since v2.0.0
Take-map.md
Package: `effect`<br />
Module: `Take`<br />

## Take.map

Transforms `Take<A, E>` to `Take<B, A>` by applying function `f`.

**Signature**

```ts
declare const map: { <A, B>(f: (a: A) => B): <E>(self: Take<A, E>) => Take<B, E>; <A, E, B>(self: Take<A, E>, f: (a: A) => B): Take<B, E>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L179)

Since v2.0.0
Take-match.md
Package: `effect`<br />
Module: `Take`<br />

## Take.match

Folds over the failure cause, success value and end-of-stream marker to
yield a value.

**Signature**

```ts
declare const match: { <Z, E, Z2, A, Z3>(options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): (self: Take<A, E>) => Z | Z2 | Z3; <A, E, Z, Z2, Z3>(self: Take<A, E>, options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): Z | Z2 | Z3; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L191)

Since v2.0.0
Take-matchEffect.md
Package: `effect`<br />
Module: `Take`<br />

## Take.matchEffect

Effectful version of `Take.fold`.

Folds over the failure cause, success value and end-of-stream marker to
yield an effect.

**Signature**

```ts
declare const matchEffect: { <Z, E2, R, E, Z2, R2, A, Z3, E3, R3>(options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): (self: Take<A, E>) => Effect.Effect<Z | Z2 | Z3, E2 | E | E3, R | R2 | R3>; <A, E, Z, E2, R, Z2, R2, Z3, E3, R3>(self: Take<A, E>, options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): Effect.Effect<Z | Z2 | Z3, E | E2 | E3, R | R2 | R3>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L218)

Since v2.0.0
Take-of.md
Package: `effect`<br />
Module: `Take`<br />

## Take.of

Creates a `Take` with a single value chunk.

**Signature**

```ts
declare const of: <A>(value: A) => Take<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L242)

Since v2.0.0
Take-tap.md
Package: `effect`<br />
Module: `Take`<br />

## Take.tap

Returns an effect that effectfully "peeks" at the success of this take.

**Signature**

```ts
declare const tap: { <A, X, E2, R>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): <E>(self: Take<A, E>) => Effect.Effect<void, E2 | E, R>; <A, E, X, E2, R>(self: Take<A, E>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): Effect.Effect<void, E | E2, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L250)

Since v2.0.0
Terminal-QuitException.md
Package: `@effect/platform`<br />
Module: `Terminal`<br />

## Terminal.QuitException

A `QuitException` represents an exception that occurs when a user attempts to
quit out of a `Terminal` prompt for input (usually by entering `ctrl`+`c`).

**Signature**

```ts
declare class QuitException
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Terminal.ts#L82)

Since v1.0.0
Terminal-Terminal.md
Package: `@effect/platform`<br />
Module: `Terminal`<br />

## Terminal.Terminal

A `Terminal` represents a command-line interface which can read input from a
user and display messages to a user.

**Signature**

```ts
export interface Terminal {
  /**
   * The number of columns available on the platform's terminal interface.
   */
  readonly columns: Effect<number>
  /**
   * Reads a single input event from the default standard input.
   */
  readonly readInput: Effect<UserInput, QuitException>
  /**
   * Reads a single line from the default standard input.
   */
  readonly readLine: Effect<string, QuitException>
  /**
   * Displays text to the the default standard output.
   */
  readonly display: (text: string) => Effect<void, PlatformError>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Terminal.ts#L18)

Since v1.0.0
TestAnnotation-ignored.md
Package: `effect`<br />
Module: `TestAnnotation`<br />

## TestAnnotation.ignored

An annotation which counts ignored tests.

**Signature**

```ts
declare const ignored: TestAnnotation<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L121)

Since v2.0.0
TestAnnotation-repeated.md
Package: `effect`<br />
Module: `TestAnnotation`<br />

## TestAnnotation.repeated

An annotation which counts repeated tests.

**Signature**

```ts
declare const repeated: TestAnnotation<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L132)

Since v2.0.0
TestAnnotation-retried.md
Package: `effect`<br />
Module: `TestAnnotation`<br />

## TestAnnotation.retried

An annotation which counts retried tests.

**Signature**

```ts
declare const retried: TestAnnotation<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L143)

Since v2.0.0
TestAnnotation-tagged.md
Package: `effect`<br />
Module: `TestAnnotation`<br />

## TestAnnotation.tagged

An annotation which tags tests with strings.

**Signature**

```ts
declare const tagged: TestAnnotation<HashSet.HashSet<string>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L154)

Since v2.0.0
TestAnnotationMap-TestAnnotationMap.md
Package: `effect`<br />
Module: `TestAnnotationMap`<br />

## TestAnnotationMap.TestAnnotationMap

An annotation map keeps track of annotations of different types.

**Signature**

```ts
export interface TestAnnotationMap {
  readonly [TestAnnotationMapTypeId]: TestAnnotationMapTypeId
  /** @internal */
  readonly map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L24)

Since v2.0.0
TestAnnotationMap-annotate.md
Package: `effect`<br />
Module: `TestAnnotationMap`<br />

## TestAnnotationMap.annotate

Appends the specified annotation to the annotation map.

**Signature**

```ts
declare const annotate: (<A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L97)

Since v2.0.0
TestAnnotationMap-get.md
Package: `effect`<br />
Module: `TestAnnotationMap`<br />

## TestAnnotationMap.get

Retrieves the annotation of the specified type, or its default value if
there is none.

**Signature**

```ts
declare const get: (<A>(key: TestAnnotation.TestAnnotation<A>) => (self: TestAnnotationMap) => A) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => A)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L82)

Since v2.0.0
TestAnnotations-TestAnnotations.md
Package: `effect`<br />
Module: `TestAnnotations`<br />

## TestAnnotations.TestAnnotations

The `Annotations` trait provides access to an annotation map that tests can
add arbitrary annotations to. Each annotation consists of a string
identifier, an initial value, and a function for combining two values.
Annotations form monoids and you can think of `Annotations` as a more
structured logging service or as a super polymorphic version of the writer
monad effect.

**Signature**

```ts
export interface TestAnnotations {
  readonly [TestAnnotationsTypeId]: TestAnnotationsTypeId

  /**
   * A ref containing the bacnking map for all annotations
   */
  readonly ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>

  /**
   * Accesses an `Annotations` instance in the context and retrieves the
   * annotation of the specified type, or its default value if there is none.
   */
  get<A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A>

  /**
   * Accesses an `Annotations` instance in the context and appends the
   * specified annotation to the annotation map.
   */
  annotate<A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void>

  /**
   * Returns the set of all fibers in this test.
   */
  readonly supervisedFibers: Effect.Effect<
    SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>
  >
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotations.ts#L40)

Since v2.0.0
TestClock-Data.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.Data

`Data` represents the state of the `TestClock`, including the clock time.

**Signature**

```ts
export interface Data {
  readonly instant: number
  readonly sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L89)

Since v2.0.1
TestClock-TestClock.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.TestClock

A `TestClock` makes it easy to deterministically and efficiently test effects
involving the passage of time.

Instead of waiting for actual time to pass, `sleep` and methods implemented
in terms of it schedule effects to take place at a given clock time. Users
can adjust the clock time using the `adjust` and `setTime` methods, and all
effects scheduled to take place on or before that time will automatically be
run in order.

For example, here is how we can test `Effect.timeout` using `TestClock`:

```ts
import * as assert from "node:assert"
import { Duration, Effect, Fiber, TestClock, Option, pipe } from "effect"

Effect.gen(function*() {
  const fiber = yield* pipe(
    Effect.sleep(Duration.minutes(5)),
    Effect.timeout(Duration.minutes(1)),
    Effect.fork
  )
  yield* TestClock.adjust(Duration.minutes(1))
  const result = yield* Fiber.join(fiber)
  assert.deepStrictEqual(result, Option.none())
})
```

Note how we forked the fiber that `sleep` was invoked on. Calls to `sleep`
and methods derived from it will semantically block until the time is set to
on or after the time they are scheduled to run. If we didn't fork the fiber
on which we called sleep we would never get to set the time on the line
below. Thus, a useful pattern when using `TestClock` is to fork the effect
being tested, then adjust the clock time, and finally verify that the
expected effects have been performed.

**Signature**

```ts
export interface TestClock extends Clock.Clock {
  adjust(duration: Duration.DurationInput): Effect.Effect<void>
  adjustWith(duration: Duration.DurationInput): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  readonly save: Effect.Effect<Effect.Effect<void>>
  setTime(time: number): Effect.Effect<void>
  readonly sleeps: Effect.Effect<Chunk.Chunk<number>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L76)

Since v2.0.0
TestClock-adjust.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.adjust

Accesses a `TestClock` instance in the context and increments the time
by the specified duration, running any actions scheduled for on or before
the new time in order.

**Signature**

```ts
declare const adjust: (durationInput: Duration.DurationInput) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L470)

Since v2.0.0
TestClock-currentTimeMillis.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.currentTimeMillis

Accesses the current time of a `TestClock` instance in the context in
milliseconds.

**Signature**

```ts
declare const currentTimeMillis: Effect.Effect<number, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L556)

Since v2.0.0
TestClock-save.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.save

Accesses a `TestClock` instance in the context and saves the clock
state in an effect which, when run, will restore the `TestClock` to the
saved state.

**Signature**

```ts
declare const save: () => Effect.Effect<Effect.Effect<void>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L493)

Since v2.0.0
TestClock-setTime.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.setTime

Accesses a `TestClock` instance in the context and sets the clock time
to the specified `Instant` or `Date`, running any actions scheduled for on or before
the new time in order.

**Signature**

```ts
declare const setTime: (input: DateTime.DateTime.Input) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L502)

Since v2.0.0
TestClock-sleep.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.sleep

Semantically blocks the current fiber until the clock time is equal to or
greater than the specified duration. Once the clock time is adjusted to
on or after the duration, the fiber will automatically be resumed.

**Signature**

```ts
declare const sleep: (durationInput: Duration.DurationInput) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L518)

Since v2.0.0
TestClock-sleeps.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.sleeps

Accesses a `TestClock` instance in the context and returns a list of
times that effects are scheduled to run.

**Signature**

```ts
declare const sleeps: () => Effect.Effect<Chunk.Chunk<number>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L529)

Since v2.0.0
TestClock-testClock.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.testClock

Retrieves the `TestClock` service for this test.

**Signature**

```ts
declare const testClock: () => Effect.Effect<TestClock>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L536)

Since v2.0.0
TestClock-testClockWith.md
Package: `effect`<br />
Module: `TestClock`<br />

## TestClock.testClockWith

Retrieves the `TestClock` service for this test and uses it to run the
specified workflow.

**Signature**

```ts
declare const testClockWith: <A, E, R>(f: (testClock: TestClock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L544)

Since v2.0.0
TestConfig-TestConfig.md
Package: `effect`<br />
Module: `TestConfig`<br />

## TestConfig.TestConfig

The `TestConfig` service provides access to default configuration settings
used by tests, including the number of times to repeat tests to ensure
they are stable, the number of times to retry flaky tests, the sufficient
number of samples to check from a random variable, and the maximum number of
shrinkings to minimize large failures.

**Signature**

```ts
export interface TestConfig {
  /**
   * The number of times to repeat tests to ensure they are stable.
   */
  readonly repeats: number
  /**
   * The number of times to retry flaky tests.
   */
  readonly retries: number
  /**
   * The number of sufficient samples to check for a random variable.
   */
  readonly samples: number
  /**
   * The maximum number of shrinkings to minimize large failures
   */
  readonly shrinks: number
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestConfig.ts#L15)

Since v2.0.0
TestLive-TestLive.md
Package: `effect`<br />
Module: `TestLive`<br />

## TestLive.TestLive

The `Live` trait provides access to the "live" default Effect services from
within tests for workflows such as printing test results to the console or
timing out tests where it is necessary to access the real implementations of
these services.

**Signature**

```ts
export interface TestLive {
  readonly [TestLiveTypeId]: TestLiveTypeId
  provide<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestLive.ts#L28)

Since v2.0.0
TestServices-annotate.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.annotate

Accesses an `Annotations` instance in the context and appends the
specified annotation to the annotation map.

**Signature**

```ts
declare const annotate: <A>(key: TestAnnotation.TestAnnotation<A>, value: A) => Effect.Effect<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L133)

Since v2.0.0
TestServices-annotations.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.annotations

Retrieves the `Annotations` service for this test.

**Signature**

```ts
declare const annotations: () => Effect.Effect<Annotations.TestAnnotations>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L58)

Since v2.0.0
TestServices-annotationsLayer.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.annotationsLayer

Constructs a new `Annotations` service wrapped in a layer.

**Signature**

```ts
declare const annotationsLayer: () => Layer.Layer<Annotations.TestAnnotations>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L108)

Since v2.0.0
TestServices-annotationsWith.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.annotationsWith

Retrieves the `Annotations` service for this test and uses it to run the
specified workflow.

**Signature**

```ts
declare const annotationsWith: <A, E, R>(f: (annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L66)

Since v2.0.0
TestServices-get.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.get

Accesses an `Annotations` instance in the context and retrieves the
annotation of the specified type, or its default value if there is none.

**Signature**

```ts
declare const get: <A>(key: TestAnnotation.TestAnnotation<A>) => Effect.Effect<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L124)

Since v2.0.0
TestServices-live.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.live

Retrieves the `Live` service for this test.

**Signature**

```ts
declare const live: Effect.Effect<Live.TestLive, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L159)

Since v2.0.0
TestServices-liveLayer.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.liveLayer

Constructs a new `Live` service wrapped in a layer.

**Signature**

```ts
declare const liveLayer: () => Layer.Layer<Live.TestLive, never, DefaultServices.DefaultServices>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L190)

Since v2.0.0
TestServices-liveServices.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.liveServices

The default Effect test services.

**Signature**

```ts
declare const liveServices: Context.Context<TestServices>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L39)

Since v2.0.0
TestServices-liveWith.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.liveWith

Retrieves the `Live` service for this test and uses it to run the specified
workflow.

**Signature**

```ts
declare const liveWith: <A, E, R>(f: (live: Live.TestLive) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L151)

Since v2.0.0
TestServices-provideLive.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.provideLive

Provides a workflow with the "live" default Effect services.

**Signature**

```ts
declare const provideLive: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L205)

Since v2.0.0
TestServices-provideWithLive.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.provideWithLive

Runs a transformation function with the live default Effect services while
ensuring that the workflow itself is run with the test services.

**Signature**

```ts
declare const provideWithLive: (<A, E, R, A2, E2, R2>(f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>) & (<A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E | E2, R | R2>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L214)

Since v2.0.0
TestServices-repeats.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.repeats

The number of times to repeat tests to ensure they are stable.

**Signature**

```ts
declare const repeats: Effect.Effect<number, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L369)

Since v2.0.0
TestServices-retries.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.retries

The number of times to retry flaky tests.

**Signature**

```ts
declare const retries: Effect.Effect<number, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L376)

Since v2.0.0
TestServices-samples.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.samples

The number of sufficient samples to check for a random variable.

**Signature**

```ts
declare const samples: Effect.Effect<number, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L383)

Since v2.0.0
TestServices-shrinks.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.shrinks

The maximum number of shrinkings to minimize large failures.

**Signature**

```ts
declare const shrinks: Effect.Effect<number, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L390)

Since v2.0.0
TestServices-sized.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.sized

Retrieves the `Sized` service for this test.

**Signature**

```ts
declare const sized: Effect.Effect<Sized.TestSized, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L245)

Since v2.0.0
TestServices-sizedWith.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.sizedWith

Retrieves the `Sized` service for this test and uses it to run the
specified workflow.

**Signature**

```ts
declare const sizedWith: <A, E, R>(f: (sized: Sized.TestSized) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L234)

Since v2.0.0
TestServices-supervisedFibers.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.supervisedFibers

Returns the set of all fibers in this test.

**Signature**

```ts
declare const supervisedFibers: () => Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L141)

Since v2.0.0
TestServices-testConfig.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.testConfig

Retrieves the `TestConfig` service for this test.

**Signature**

```ts
declare const testConfig: Effect.Effect<TestConfig.TestConfig, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L316)

Since v2.0.0
TestServices-testConfigLayer.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.testConfigLayer

Constructs a new `TestConfig` service with the specified settings.

**Signature**

```ts
declare const testConfigLayer: (params: { readonly repeats: number; readonly retries: number; readonly samples: number; readonly shrinks: number; }) => Layer.Layer<TestConfig.TestConfig>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L347)

Since v2.0.0
TestServices-testConfigWith.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.testConfigWith

Retrieves the `TestConfig` service for this test and uses it to run the
specified workflow.

**Signature**

```ts
declare const testConfigWith: <A, E, R>(f: (config: TestConfig.TestConfig) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L303)

Since v2.0.0
TestServices-withAnnotations.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withAnnotations

Executes the specified workflow with the specified implementation of the
annotations service.

**Signature**

```ts
declare const withAnnotations: ((annotations: Annotations.TestAnnotations) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L80)

Since v2.0.0
TestServices-withAnnotationsScoped.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withAnnotationsScoped

Sets the implementation of the annotations service to the specified value
and restores it to its original value when the scope is closed.

**Signature**

```ts
declare const withAnnotationsScoped: (annotations: Annotations.TestAnnotations) => Effect.Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L95)

Since v2.0.0
TestServices-withLive.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withLive

Executes the specified workflow with the specified implementation of the
live service.

**Signature**

```ts
declare const withLive: ((live: Live.TestLive) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, live: Live.TestLive) => Effect.Effect<A, E, R>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L167)

Since v2.0.0
TestServices-withLiveScoped.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withLiveScoped

Sets the implementation of the live service to the specified value and
restores it to its original value when the scope is closed.

**Signature**

```ts
declare const withLiveScoped: (live: Live.TestLive) => Effect.Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L182)

Since v2.0.0
TestServices-withSized.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withSized

Executes the specified workflow with the specified implementation of the
sized service.

**Signature**

```ts
declare const withSized: ((sized: Sized.TestSized) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, sized: Sized.TestSized) => Effect.Effect<A, E, R>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L253)

Since v2.0.0
TestServices-withSizedScoped.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withSizedScoped

Sets the implementation of the sized service to the specified value and
restores it to its original value when the scope is closed.

**Signature**

```ts
declare const withSizedScoped: (sized: Sized.TestSized) => Effect.Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L268)

Since v2.0.0
TestServices-withTestConfig.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withTestConfig

Executes the specified workflow with the specified implementation of the
config service.

**Signature**

```ts
declare const withTestConfig: ((config: TestConfig.TestConfig) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, config: TestConfig.TestConfig) => Effect.Effect<A, E, R>)
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L324)

Since v2.0.0
TestServices-withTestConfigScoped.md
Package: `effect`<br />
Module: `TestServices`<br />

## TestServices.withTestConfigScoped

Sets the implementation of the config service to the specified value and
restores it to its original value when the scope is closed.

**Signature**

```ts
declare const withTestConfigScoped: (config: TestConfig.TestConfig) => Effect.Effect<void, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L339)

Since v2.0.0
TMap-TMap.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.TMap

Transactional map implemented on top of `TRef` and `TArray`. Resolves
conflicts via chaining.

**Signature**

```ts
export interface TMap<in out K, in out V> extends TMap.Variance<K, V> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L33)

Since v2.0.0
TMap-empty.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.empty

Makes an empty `TMap`.

**Signature**

```ts
declare const empty: <K, V>() => STM.STM<TMap<K, V>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L67)

Since v2.0.0
TMap-find.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.find

Finds the key/value pair matching the specified predicate, and uses the
provided function to extract a value out of it.

**Signature**

```ts
declare const find: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Option.Option<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Option.Option<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L76)

Since v2.0.0
TMap-findAll.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.findAll

Finds all the key/value pairs matching the specified predicate, and uses
the provided function to extract values out them.

**Signature**

```ts
declare const findAll: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Array<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L105)

Since v2.0.0
TMap-findAllSTM.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.findAllSTM

Finds all the key/value pairs matching the specified predicate, and uses
the provided effectful function to extract values out of them..

**Signature**

```ts
declare const findAllSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Array<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Array<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L117)

Since v2.0.0
TMap-findSTM.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.findSTM

Finds the key/value pair matching the specified predicate, and uses the
provided effectful function to extract a value out of it.

**Signature**

```ts
declare const findSTM: { <K, V, A, E, R>(f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Option.Option<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Option.Option<A>, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L88)

Since v2.0.0
TMap-forEach.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.forEach

Atomically performs transactional-effect for each binding present in map.

**Signature**

```ts
declare const forEach: { <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, X, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L130)

Since v2.0.0
TMap-fromIterable.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.fromIterable

Creates a new `TMap` from an iterable collection of key/value pairs.

**Signature**

```ts
declare const fromIterable: <K, V>(iterable: Iterable<readonly [K, V]>) => STM.STM<TMap<K, V>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L141)

Since v2.0.0
TMap-get.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.get

Retrieves value associated with given key.

**Signature**

```ts
declare const get: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K): STM.STM<Option.Option<V>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L151)

Since v2.0.0
TMap-getOrElse.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.getOrElse

Retrieves value associated with given key or default value, in case the key
isn't present.

**Signature**

```ts
declare const getOrElse: { <K, V>(key: K, fallback: LazyArg<V>): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, fallback: LazyArg<V>): STM.STM<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L163)

Since v2.0.0
TMap-has.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.has

Tests whether or not map contains a key.

**Signature**

```ts
declare const has: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<boolean>; <K, V>(self: TMap<K, V>, key: K): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L174)

Since v2.0.0
TMap-isEmpty.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.isEmpty

Tests if the map is empty or not.

**Signature**

```ts
declare const isEmpty: <K, V>(self: TMap<K, V>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L185)

Since v2.0.0
TMap-keys.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.keys

Collects all keys stored in map.

**Signature**

```ts
declare const keys: <K, V>(self: TMap<K, V>) => STM.STM<Array<K>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L193)

Since v2.0.0
TMap-make.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.make

Makes a new `TMap` that is initialized with specified values.

**Signature**

```ts
declare const make: <K, V>(...entries: Array<readonly [K, V]>) => STM.STM<TMap<K, V>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L201)

Since v2.0.0
TMap-merge.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.merge

If the key is not already associated with a value, stores the provided value,
otherwise merge the existing value with the new one using function `f` and
store the result.

**Signature**

```ts
declare const merge: { <K, V>(key: K, value: V, f: (x: V, y: V) => V): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V): STM.STM<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L211)

Since v2.0.0
TMap-reduce.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.reduce

Atomically folds using a pure function.

**Signature**

```ts
declare const reduce: { <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z): (self: TMap<K, V>) => STM.STM<Z>; <K, V, Z>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z): STM.STM<Z>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L222)

Since v2.0.0
TMap-reduceSTM.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.reduceSTM

Atomically folds using a transactional function.

**Signature**

```ts
declare const reduceSTM: { <Z, V, K, R, E>(zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): (self: TMap<K, V>) => STM.STM<Z, E, R>; <Z, V, K, R, E>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L233)

Since v2.0.0
TMap-remove.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.remove

Removes binding for given key.

**Signature**

```ts
declare const remove: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L244)

Since v2.0.0
TMap-removeAll.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.removeAll

Deletes all entries associated with the specified keys.

**Signature**

```ts
declare const removeAll: { <K>(keys: Iterable<K>): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, keys: Iterable<K>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L255)

Since v2.0.0
TMap-removeIf.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.removeIf

Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

**Signature**

```ts
declare const removeIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L267)

Since v2.0.0
TMap-retainIf.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.retainIf

Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

**Signature**

```ts
declare const retainIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L303)

Since v2.0.0
TMap-set.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.set

Stores new binding into the map.

**Signature**

```ts
declare const set: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L338)

Since v2.0.0
TMap-setIfAbsent.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.setIfAbsent

Stores new binding in the map if it does not already exist.

**Signature**

```ts
declare const setIfAbsent: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L349)

Since v2.0.0
TMap-size.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.size

Returns the number of bindings.

**Signature**

```ts
declare const size: <K, V>(self: TMap<K, V>) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L360)

Since v2.0.0
TMap-takeFirst.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.takeFirst

Takes the first matching value, or retries until there is one.

**Signature**

```ts
declare const takeFirst: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<A>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L368)

Since v2.0.0
TMap-takeFirstSTM.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.takeFirstSTM

Takes the first matching value, or retries until there is one.

**Signature**

```ts
declare const takeFirstSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<A, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L379)

Since v2.0.0
TMap-takeSome.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.takeSome

Takes all matching values, or retries until there is at least one.

**Signature**

```ts
declare const takeSome: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>]>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<[A, ...Array<A>]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L390)

Since v2.0.0
TMap-takeSomeSTM.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.takeSomeSTM

Takes all matching values, or retries until there is at least one.

**Signature**

```ts
declare const takeSomeSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>], E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<[A, ...Array<A>], E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L401)

Since v2.0.0
TMap-toArray.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.toArray

Collects all bindings into an `Array`.

**Signature**

```ts
declare const toArray: <K, V>(self: TMap<K, V>) => STM.STM<Array<[K, V]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L433)

Since v2.0.0
TMap-toChunk.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.toChunk

Collects all bindings into a `Chunk`.

**Signature**

```ts
declare const toChunk: <K, V>(self: TMap<K, V>) => STM.STM<Chunk.Chunk<[K, V]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L417)

Since v2.0.0
TMap-toHashMap.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.toHashMap

Collects all bindings into a `HashMap`.

**Signature**

```ts
declare const toHashMap: <K, V>(self: TMap<K, V>) => STM.STM<HashMap.HashMap<K, V>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L425)

Since v2.0.0
TMap-toMap.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.toMap

Collects all bindings into a `Map`.

**Signature**

```ts
declare const toMap: <K, V>(self: TMap<K, V>) => STM.STM<ReadonlyMap<K, V>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L441)

Since v2.0.0
TMap-transform.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.transform

Atomically updates all bindings using a pure function.

**Signature**

```ts
declare const transform: { <K, V>(f: (key: K, value: V) => readonly [K, V]): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (key: K, value: V) => readonly [K, V]): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L449)

Since v2.0.0
TMap-transformSTM.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.transformSTM

Atomically updates all bindings using a transactional function.

**Signature**

```ts
declare const transformSTM: { <K, V, R, E>(f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L460)

Since v2.0.0
TMap-transformValues.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.transformValues

Atomically updates all values using a pure function.

**Signature**

```ts
declare const transformValues: { <V>(f: (value: V) => V): <K>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (value: V) => V): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L471)

Since v2.0.0
TMap-transformValuesSTM.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.transformValuesSTM

Atomically updates all values using a transactional function.

**Signature**

```ts
declare const transformValuesSTM: { <V, R, E>(f: (value: V) => STM.STM<V, E, R>): <K>(self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (value: V) => STM.STM<V, E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L482)

Since v2.0.0
TMap-updateWith.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.updateWith

Updates the mapping for the specified key with the specified function,
which takes the current value of the key as an input, if it exists, and
either returns `Some` with a new value to indicate to update the value in
the map or `None` to remove the value from the map. Returns `Some` with the
updated value or `None` if the value was removed from the map.

**Signature**

```ts
declare const updateWith: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): STM.STM<Option.Option<V>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L497)

Since v2.0.0
TMap-values.md
Package: `effect`<br />
Module: `TMap`<br />

## TMap.values

Collects all values stored in map.

**Signature**

```ts
declare const values: <K, V>(self: TMap<K, V>) => STM.STM<Array<V>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L515)

Since v2.0.0
TPriorityQueue-empty.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.empty

Constructs a new empty `TPriorityQueue` with the specified `Order`.

**Signature**

```ts
declare const empty: <A>(order: Order.Order<A>) => STM.STM<TPriorityQueue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L67)

Since v2.0.0
TPriorityQueue-fromIterable.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.fromIterable

Creates a new `TPriorityQueue` from an iterable collection of values.

**Signature**

```ts
declare const fromIterable: <A>(order: Order.Order<A>) => (iterable: Iterable<A>) => STM.STM<TPriorityQueue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L75)

Since v2.0.0
TPriorityQueue-isEmpty.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.isEmpty

Checks whether the queue is empty.

**Signature**

```ts
declare const isEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L85)

Since v2.0.0
TPriorityQueue-isNonEmpty.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.isNonEmpty

Checks whether the queue is not empty.

**Signature**

```ts
declare const isNonEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L93)

Since v2.0.0
TPriorityQueue-make.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.make

Makes a new `TPriorityQueue` that is initialized with specified values.

**Signature**

```ts
declare const make: <A>(order: Order.Order<A>) => (...elements: Array<A>) => STM.STM<TPriorityQueue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L101)

Since v2.0.0
TPriorityQueue-offer.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.offer

Offers the specified value to the queue.

**Signature**

```ts
declare const offer: { <A>(value: A): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, value: A): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L109)

Since v2.0.0
TPriorityQueue-offerAll.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.offerAll

Offers all of the elements in the specified collection to the queue.

**Signature**

```ts
declare const offerAll: { <A>(values: Iterable<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, values: Iterable<A>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L120)

Since v2.0.0
TPriorityQueue-peek.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.peek

Peeks at the first value in the queue without removing it, retrying until a
value is in the queue.

**Signature**

```ts
declare const peek: <A>(self: TPriorityQueue<A>) => STM.STM<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L132)

Since v2.0.0
TPriorityQueue-peekOption.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.peekOption

Peeks at the first value in the queue without removing it, returning `None`
if there is not a value in the queue.

**Signature**

```ts
declare const peekOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L141)

Since v2.0.0
TPriorityQueue-removeIf.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.removeIf

Removes all elements from the queue matching the specified predicate.

**Signature**

```ts
declare const removeIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L149)

Since v2.0.0
TPriorityQueue-retainIf.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.retainIf

Retains only elements from the queue matching the specified predicate.

**Signature**

```ts
declare const retainIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L160)

Since v2.0.0
TPriorityQueue-size.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.size

Returns the size of the queue.

**Signature**

```ts
declare const size: <A>(self: TPriorityQueue<A>) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L171)

Since v2.0.0
TPriorityQueue-TPriorityQueue.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.TPriorityQueue

A `TPriorityQueue` contains values of type `A` that an `Order` is defined
on. Unlike a `TQueue`, `take` returns the highest priority value (the value
that is first in the specified ordering) as opposed to the first value
offered to the queue. The ordering that elements with the same priority will
be taken from the queue is not guaranteed.

**Signature**

```ts
export interface TPriorityQueue<in out A> extends TPriorityQueue.Variance<A> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L36)

Since v2.0.0
TPriorityQueue-take.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.take

Takes a value from the queue, retrying until a value is in the queue.

**Signature**

```ts
declare const take: <A>(self: TPriorityQueue<A>) => STM.STM<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L179)

Since v2.0.0
TPriorityQueue-takeAll.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.takeAll

Takes all values from the queue.

**Signature**

```ts
declare const takeAll: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L187)

Since v2.0.0
TPriorityQueue-takeOption.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.takeOption

Takes a value from the queue, returning `None` if there is not a value in
the queue.

**Signature**

```ts
declare const takeOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L196)

Since v2.0.0
TPriorityQueue-takeUpTo.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.takeUpTo

Takes up to the specified maximum number of elements from the queue.

**Signature**

```ts
declare const takeUpTo: { (n: number): <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>; <A>(self: TPriorityQueue<A>, n: number): STM.STM<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L204)

Since v2.0.0
TPriorityQueue-toArray.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.toArray

Collects all values into an array.

**Signature**

```ts
declare const toArray: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L223)

Since v2.0.0
TPriorityQueue-toChunk.md
Package: `effect`<br />
Module: `TPriorityQueue`<br />

## TPriorityQueue.toChunk

Collects all values into a `Chunk`.

**Signature**

```ts
declare const toChunk: <A>(self: TPriorityQueue<A>) => STM.STM<Chunk.Chunk<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L215)

Since v2.0.0
TPubSub-awaitShutdown.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.awaitShutdown

Waits until the `TPubSub` is shutdown. The `STM` returned by this method will
not resume until the queue has been shutdown. If the `TPubSub` is already
shutdown, the `STM` will resume right away.

**Signature**

```ts
declare const awaitShutdown: <A>(self: TPubSub<A>) => STM.STM<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L64)

Since v2.0.0
TPubSub-bounded.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.bounded

Creates a bounded `TPubSub` with the back pressure strategy. The `TPubSub` will retain
messages until they have been taken by all subscribers, applying back
pressure to publishers if the `TPubSub` is at capacity.

**Signature**

```ts
declare const bounded: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L74)

Since v2.0.0
TPubSub-capacity.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.capacity

Returns the number of elements the `TPubSub` can hold.

**Signature**

```ts
declare const capacity: <A>(self: TPubSub<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L82)

Since v2.0.0
TPubSub-dropping.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.dropping

Creates a bounded `TPubSub` with the dropping strategy. The `TPubSub` will drop new
messages if the `TPubSub` is at capacity.

**Signature**

```ts
declare const dropping: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L91)

Since v2.0.0
TPubSub-isEmpty.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.isEmpty

Returns `true` if the `TPubSub` contains zero elements, `false` otherwise.

**Signature**

```ts
declare const isEmpty: <A>(self: TPubSub<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L99)

Since v2.0.0
TPubSub-isFull.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.isFull

Returns `true` if the `TPubSub` contains at least one element, `false`
otherwise.

**Signature**

```ts
declare const isFull: <A>(self: TPubSub<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L108)

Since v2.0.0
TPubSub-isShutdown.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

**Signature**

```ts
declare const isShutdown: <A>(self: TPubSub<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L125)

Since v2.0.0
TPubSub-publish.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.publish

Publishes a message to the `TPubSub`, returning whether the message was published
to the `TPubSub`.

**Signature**

```ts
declare const publish: { <A>(value: A): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, value: A): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L134)

Since v2.0.0
TPubSub-publishAll.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.publishAll

Publishes all of the specified messages to the `TPubSub`, returning whether they
were published to the `TPubSub`.

**Signature**

```ts
declare const publishAll: { <A>(iterable: Iterable<A>): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, iterable: Iterable<A>): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L146)

Since v2.0.0
TPubSub-shutdown.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

**Signature**

```ts
declare const shutdown: <A>(self: TPubSub<A>) => STM.STM<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L117)

Since v2.0.0
TPubSub-size.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.size

Retrieves the size of the `TPubSub`, which is equal to the number of elements
in the `TPubSub`. This may be negative if fibers are suspended waiting for
elements to be added to the `TPubSub`.

**Signature**

```ts
declare const size: <A>(self: TPubSub<A>) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L159)

Since v2.0.0
TPubSub-sliding.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.sliding

Creates a bounded `TPubSub` with the sliding strategy. The `TPubSub` will add new
messages and drop old messages if the `TPubSub` is at capacity.

For best performance use capacities that are powers of two.

**Signature**

```ts
declare const sliding: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L170)

Since v2.0.0
TPubSub-subscribe.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.subscribe

Subscribes to receive messages from the `TPubSub`. The resulting subscription can
be evaluated multiple times to take a message from the `TPubSub` each time. The
caller is responsible for unsubscribing from the `TPubSub` by shutting down the
queue.

**Signature**

```ts
declare const subscribe: <A>(self: TPubSub<A>) => STM.STM<TQueue.TDequeue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L181)

Since v2.0.0
TPubSub-subscribeScoped.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.subscribeScoped

Subscribes to receive messages from the `TPubSub`. The resulting subscription can
be evaluated multiple times within the scope to take a message from the `TPubSub`
each time.

**Signature**

```ts
declare const subscribeScoped: <A>(self: TPubSub<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L191)

Since v2.0.0
TPubSub-unbounded.md
Package: `effect`<br />
Module: `TPubSub`<br />

## TPubSub.unbounded

Creates an unbounded `TPubSub`.

**Signature**

```ts
declare const unbounded: <A>() => STM.STM<TPubSub<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L200)

Since v2.0.0
TQueue-BaseTQueue.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.BaseTQueue

The base interface that all `TQueue`s must implement.

**Signature**

```ts
export interface BaseTQueue {
  /**
   * Returns the number of elements the queue can hold.
   */
  capacity(): number

  /**
   * Retrieves the size of the queue, which is equal to the number of elements
   * in the queue. This may be negative if fibers are suspended waiting for
   * elements to be added to the queue.
   */
  readonly size: STM.STM<number>

  /**
   * Returns `true` if the `TQueue` contains at least one element, `false`
   * otherwise.
   */
  readonly isFull: STM.STM<boolean>

  /**
   * Returns `true` if the `TQueue` contains zero elements, `false` otherwise.
   */
  readonly isEmpty: STM.STM<boolean>

  /**
   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls
   * to `offer*` and `take*` will be interrupted immediately.
   */
  readonly shutdown: STM.STM<void>

  /**
   * Returns `true` if `shutdown` has been called, otherwise returns `false`.
   */
  readonly isShutdown: STM.STM<boolean>

  /**
   * Waits until the queue is shutdown. The `STM` returned by this method will
   * not resume until the queue has been shutdown. If the queue is already
   * shutdown, the `STM` will resume right away.
   */
  readonly awaitShutdown: STM.STM<void>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L109)

Since v2.0.0
TQueue-awaitShutdown.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.awaitShutdown

Waits until the queue is shutdown. The `STM` returned by this method will
not resume until the queue has been shutdown. If the queue is already
shutdown, the `STM` will resume right away.

**Signature**

```ts
declare const awaitShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L209)

Since v2.0.0
TQueue-bounded.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.bounded

Creates a bounded queue with the back pressure strategy. The queue will
retain values until they have been taken, applying back pressure to
offerors if the queue is at capacity.

For best performance use capacities that are powers of two.

**Signature**

```ts
declare const bounded: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L221)

Since v2.0.0
TQueue-capacity.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.capacity

Returns the number of elements the queue can hold.

**Signature**

```ts
declare const capacity: <A>(self: TDequeue<A> | TEnqueue<A>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L229)

Since v2.0.0
TQueue-dropping.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.dropping

Creates a bounded queue with the dropping strategy. The queue will drop new
values if the queue is at capacity.

For best performance use capacities that are powers of two.

**Signature**

```ts
declare const dropping: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L240)

Since v2.0.0
TQueue-isEmpty.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.isEmpty

Returns `true` if the `TQueue` contains zero elements, `false` otherwise.

**Signature**

```ts
declare const isEmpty: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L248)

Since v2.0.0
TQueue-isFull.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.isFull

Returns `true` if the `TQueue` contains at least one element, `false`
otherwise.

**Signature**

```ts
declare const isFull: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L257)

Since v2.0.0
TQueue-isShutdown.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

**Signature**

```ts
declare const isShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L265)

Since v2.0.0
TQueue-isTDequeue.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.isTDequeue

Returns `true` if the specified value is a `TDequeue`, `false` otherwise.

**Signature**

```ts
declare const isTDequeue: (u: unknown) => u is TDequeue<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L191)

Since v2.0.0
TQueue-isTEnqueue.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.isTEnqueue

Returns `true` if the specified value is a `TEnqueue`, `false` otherwise.

**Signature**

```ts
declare const isTEnqueue: (u: unknown) => u is TEnqueue<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L199)

Since v2.0.0
TQueue-isTQueue.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.isTQueue

Returns `true` if the specified value is a `TQueue`, `false` otherwise.

**Signature**

```ts
declare const isTQueue: (u: unknown) => u is TQueue<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L183)

Since v2.0.0
TQueue-offer.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.offer

Places one value in the queue.

**Signature**

```ts
declare const offer: { <A>(value: A): (self: TEnqueue<A>) => STM.STM<void>; <A>(self: TEnqueue<A>, value: A): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L273)

Since v2.0.0
TQueue-offerAll.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.offerAll

For Bounded TQueue: uses the `BackPressure` Strategy, places the values in
the queue and always returns true. If the queue has reached capacity, then
the fiber performing the `offerAll` will be suspended until there is room
in the queue.

For Unbounded TQueue: Places all values in the queue and returns true.

For Sliding TQueue: uses `Sliding` Strategy If there is room in the queue,
it places the values otherwise it removes the old elements and enqueues the
new ones. Always returns true.

For Dropping TQueue: uses `Dropping` Strategy, It places the values in the
queue but if there is no room it will not enqueue them and return false.

**Signature**

```ts
declare const offerAll: { <A>(iterable: Iterable<A>): (self: TEnqueue<A>) => STM.STM<boolean>; <A>(self: TEnqueue<A>, iterable: Iterable<A>): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L296)

Since v2.0.0
TQueue-peek.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.peek

Views the next element in the queue without removing it, retrying if the
queue is empty.

**Signature**

```ts
declare const peek: <A>(self: TDequeue<A>) => STM.STM<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L308)

Since v2.0.0
TQueue-peekOption.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.peekOption

Views the next element in the queue without removing it, returning `None`
if the queue is empty.

**Signature**

```ts
declare const peekOption: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L317)

Since v2.0.0
TQueue-poll.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.poll

Takes a single element from the queue, returning `None` if the queue is
empty.

**Signature**

```ts
declare const poll: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L326)

Since v2.0.0
TQueue-seek.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.seek

Drops elements from the queue while they do not satisfy the predicate,
taking and returning the first element that does satisfy the predicate.
Retries if no elements satisfy the predicate.

**Signature**

```ts
declare const seek: { <A>(predicate: Predicate<A>): (self: TDequeue<A>) => STM.STM<A>; <A>(self: TDequeue<A>, predicate: Predicate<A>): STM.STM<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L336)

Since v2.0.0
TQueue-shutdown.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

**Signature**

```ts
declare const shutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L348)

Since v2.0.0
TQueue-size.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.size

Retrieves the size of the queue, which is equal to the number of elements
in the queue. This may be negative if fibers are suspended waiting for
elements to be added to the queue.

**Signature**

```ts
declare const size: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L358)

Since v2.0.0
TQueue-sliding.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.sliding

Creates a bounded queue with the sliding strategy. The queue will add new
values and drop old values if the queue is at capacity.

For best performance use capacities that are powers of two.

**Signature**

```ts
declare const sliding: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L369)

Since v2.0.0
TQueue-take.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.take

Takes the oldest value in the queue. If the queue is empty, this will return
a computation that resumes when an item has been added to the queue.

**Signature**

```ts
declare const take: <A>(self: TDequeue<A>) => STM.STM<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L378)

Since v2.0.0
TQueue-takeAll.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.takeAll

Takes all the values in the queue and returns the values. If the queue is
empty returns an empty collection.

**Signature**

```ts
declare const takeAll: <A>(self: TDequeue<A>) => STM.STM<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L387)

Since v2.0.0
TQueue-takeBetween.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.takeBetween

Takes a number of elements from the queue between the specified minimum and
maximum. If there are fewer than the minimum number of elements available,
retries until at least the minimum number of elements have been collected.

**Signature**

```ts
declare const takeBetween: { (min: number, max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, min: number, max: number): STM.STM<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L397)

Since v2.0.0
TQueue-takeN.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.takeN

Takes the specified number of elements from the queue. If there are fewer
than the specified number of elements available, it retries until they
become available.

**Signature**

```ts
declare const takeN: { (n: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, n: number): STM.STM<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L410)

Since v2.0.0
TQueue-takeUpTo.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.takeUpTo

Takes up to max number of values from the queue.

**Signature**

```ts
declare const takeUpTo: { (max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, max: number): STM.STM<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L421)

Since v2.0.0
TQueue-unbounded.md
Package: `effect`<br />
Module: `TQueue`<br />

## TQueue.unbounded

Creates an unbounded queue.

**Signature**

```ts
declare const unbounded: <A>() => STM.STM<TQueue<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L432)

Since v2.0.0
TRandom-live.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.live

The "live" `TRandom` service wrapped into a `Layer`.

**Signature**

```ts
declare const live: Layer.Layer<TRandom, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L79)

Since v2.0.0
Tracer-withSpanContext.md
Package: `@effect/opentelemetry`<br />
Module: `Tracer`<br />

## Tracer.withSpanContext

Set the effect's parent span from the given opentelemetry `SpanContext`.

This is handy when you set up OpenTelemetry outside of Effect and want to
attach to a parent span.

**Signature**

```ts
declare const withSpanContext: { (spanContext: Otel.SpanContext): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>; <A, E, R>(effect: Effect<A, E, R>, spanContext: Otel.SpanContext): Effect<A, E, Exclude<R, ParentSpan>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/opentelemetry/src/Tracer.ts#L133)

Since v1.0.0
TRandom-Tag.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.Tag

The service tag used to access `TRandom` in the environment of an effect.

**Signature**

```ts
declare const Tag: Context.Tag<TRandom, TRandom>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L71)

Since v2.0.0
TRandom-next.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.next

Returns the next number from the pseudo-random number generator.

**Signature**

```ts
declare const next: STM.STM<number, never, TRandom>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L87)

Since v2.0.0
TRandom-nextBoolean.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.nextBoolean

Returns the next boolean value from the pseudo-random number generator.

**Signature**

```ts
declare const nextBoolean: STM.STM<boolean, never, TRandom>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L95)

Since v2.0.0
TRandom-nextInt.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.nextInt

Returns the next integer from the pseudo-random number generator.

**Signature**

```ts
declare const nextInt: STM.STM<number, never, TRandom>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L103)

Since v2.0.0
TRandom-nextIntBetween.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.nextIntBetween

Returns the next integer in the specified range from the pseudo-random number
generator.

**Signature**

```ts
declare const nextIntBetween: (low: number, high: number) => STM.STM<number, never, TRandom>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L112)

Since v2.0.0
TRandom-nextRange.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.nextRange

Returns the next number in the specified range from the pseudo-random number
generator.

**Signature**

```ts
declare const nextRange: (min: number, max: number) => STM.STM<number, never, TRandom>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L121)

Since v2.0.0
TRandom-shuffle.md
Package: `effect`<br />
Module: `TRandom`<br />

## TRandom.shuffle

Uses the pseudo-random number generator to shuffle the specified iterable.

**Signature**

```ts
declare const shuffle: <A>(elements: Iterable<A>) => STM.STM<Array<A>, never, TRandom>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L129)

Since v2.0.0
TReentrantLock-TReentrantLock.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.TReentrantLock

A `TReentrantLock` is a reentrant read/write lock. Multiple readers may all
concurrently acquire read locks. Only one writer is allowed to acquire a
write lock at any given time. Read locks may be upgraded into write locks. A
fiber that has a write lock may acquire other write locks or read locks.

The two primary methods of this structure are `readLock`, which acquires a
read lock in a scoped context, and `writeLock`, which acquires a write lock
in a scoped context.

Although located in the STM package, there is no need for locks within STM
transactions. However, this lock can be quite useful in effectful code, to
provide consistent read/write access to mutable state; and being in STM
allows this structure to be composed into more complicated concurrent
structures that are consumed from effectful code.

**Signature**

```ts
export interface TReentrantLock extends TReentrantLock.Proto {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L41)

Since v2.0.0
TReentrantLock-acquireRead.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.acquireRead

Acquires a read lock. The transaction will suspend until no other fiber is
holding a write lock. Succeeds with the number of read locks held by this
fiber.

**Signature**

```ts
declare const acquireRead: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L72)

Since v2.0.0
TReentrantLock-acquireWrite.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.acquireWrite

Acquires a write lock. The transaction will suspend until no other fibers
are holding read or write locks. Succeeds with the number of write locks
held by this fiber.

**Signature**

```ts
declare const acquireWrite: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L82)

Since v2.0.0
TReentrantLock-fiberReadLocks.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.fiberReadLocks

Retrieves the number of acquired read locks for this fiber.

**Signature**

```ts
declare const fiberReadLocks: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L90)

Since v2.0.0
TReentrantLock-fiberWriteLocks.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.fiberWriteLocks

Retrieves the number of acquired write locks for this fiber.

**Signature**

```ts
declare const fiberWriteLocks: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L98)

Since v2.0.0
TReentrantLock-lock.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.lock

Just a convenience method for applications that only need reentrant locks,
without needing a distinction between readers / writers.

See `TReentrantLock.writeLock`.

**Signature**

```ts
declare const lock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L109)

Since v2.0.0
TReentrantLock-locked.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.locked

Determines if any fiber has a read or write lock.

**Signature**

```ts
declare const locked: (self: TReentrantLock) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L117)

Since v2.0.0
TReentrantLock-make.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.make

Makes a new reentrant read/write lock.

**Signature**

```ts
declare const make: STM.STM<TReentrantLock, never, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L125)

Since v2.0.0
TReentrantLock-readLock.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.readLock

Obtains a read lock in a scoped context.

**Signature**

```ts
declare const readLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L133)

Since v2.0.0
TReentrantLock-readLocked.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.readLocked

Determines if any fiber has a read lock.

**Signature**

```ts
declare const readLocked: (self: TReentrantLock) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L149)

Since v2.0.0
TReentrantLock-readLocks.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.readLocks

Retrieves the total number of acquired read locks.

**Signature**

```ts
declare const readLocks: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L141)

Since v2.0.0
TReentrantLock-releaseRead.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.releaseRead

Releases a read lock held by this fiber. Succeeds with the outstanding
number of read locks held by this fiber.

**Signature**

```ts
declare const releaseRead: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L158)

Since v2.0.0
TReentrantLock-releaseWrite.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.releaseWrite

Releases a write lock held by this fiber. Succeeds with the outstanding
number of write locks held by this fiber.

**Signature**

```ts
declare const releaseWrite: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L167)

Since v2.0.0
TReentrantLock-withLock.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.withLock

Runs the specified workflow with a lock.

**Signature**

```ts
declare const withLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L175)

Since v2.0.0
TReentrantLock-withReadLock.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.withReadLock

Runs the specified workflow with a read lock.

**Signature**

```ts
declare const withReadLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L186)

Since v2.0.0
TReentrantLock-withWriteLock.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.withWriteLock

Runs the specified workflow with a write lock.

**Signature**

```ts
declare const withWriteLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L197)

Since v2.0.0
TReentrantLock-writeLock.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.writeLock

Obtains a write lock in a scoped context.

**Signature**

```ts
declare const writeLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L208)

Since v2.0.0
TReentrantLock-writeLocked.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.writeLocked

Determines if a write lock is held by some fiber.

**Signature**

```ts
declare const writeLocked: (self: TReentrantLock) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L216)

Since v2.0.0
TReentrantLock-writeLocks.md
Package: `effect`<br />
Module: `TReentrantLock`<br />

## TReentrantLock.writeLocks

Computes the number of write locks held by fibers.

**Signature**

```ts
declare const writeLocks: (self: TReentrantLock) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L224)

Since v2.0.0
TRef-TRef.md
Package: `effect`<br />
Module: `TRef`<br />

## TRef.TRef

A `TRef<A>` is a purely functional description of a mutable reference that can
be modified as part of a transactional effect. The fundamental operations of
a `TRef` are `set` and `get`. `set` transactionally sets the reference to a
new value. `get` gets the current value of the reference.

NOTE: While `TRef<A>` provides the transactional equivalent of a mutable
reference, the value inside the `TRef` should be immutable.

**Signature**

```ts
export interface TRef<in out A> extends TRef.Variance<A>, Pipeable {
  /**
   * Note: the method is unbound, exposed only for potential extensions.
   */
  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L38)

Since v2.0.0
Traversable-sequence.md
Package: `@effect/typeclass`<br />
Module: `Traversable`<br />

## Traversable.sequence

Returns a default `sequence` implementation.

**Signature**

```ts
declare const sequence: <T extends TypeLambda>(T: Traversable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, R, O, E, A>(self: Kind<T, TR, TO, TE, Kind<F, R, O, E, A>>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Traversable.ts#L46)

Since v0.24.0
Traversable-traverseComposition.md
Package: `@effect/typeclass`<br />
Module: `Traversable`<br />

## Traversable.traverseComposition

Returns a default binary `traverse` composition.

**Signature**

```ts
declare const traverseComposition: <T extends TypeLambda, G extends TypeLambda>(T: Traversable<T>, G: Traversable<G>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, GR, GO, GE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Kind<F, R, O, E, B>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, B>>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Traversable.ts#L31)

Since v0.24.0
Traversable-traverseTap.md
Package: `@effect/typeclass`<br />
Module: `Traversable`<br />

## Traversable.traverseTap

Given a function which returns a `F` effect, thread this effect
through the running of this function on all the values in `T`,
returning an `T<A>` in a `F` context, ignoring the values
returned by the provided function.

**Signature**

```ts
declare const traverseTap: <T extends TypeLambda>(T: Traversable<T>) => <F extends TypeLambda>(F: Applicative<F>) => { <A, R, O, E, B>(f: (a: A) => Kind<F, R, O, E, B>): <TR, TO, TE>(self: Kind<T, TR, TO, TE, A>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>; <TR, TO, TE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, B>): Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/Traversable.ts#L61)

Since v0.24.0
TraversableFilterable-traverseFilterMap.md
Package: `@effect/typeclass`<br />
Module: `TraversableFilterable`<br />

## TraversableFilterable.traverseFilterMap

Returns a default binary `traverseFilterMap` implementation.

**Signature**

```ts
declare const traverseFilterMap: <T extends TypeLambda>(T: Traversable<T> & Filterable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, Option<B>>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, B>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/TraversableFilterable.ts#L71)

Since v0.24.0
TraversableFilterable-traversePartitionMap.md
Package: `@effect/typeclass`<br />
Module: `TraversableFilterable`<br />

## TraversableFilterable.traversePartitionMap

Returns a default binary `traversePartitionMap` implementation.

**Signature**

```ts
declare const traversePartitionMap: <T extends TypeLambda>(T: Traversable<T> & Covariant<T> & Filterable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, A, R, O, E, B, C>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, Either<C, B>>) => Kind<F, R, O, E, [Kind<T, TR, TO, TE, B>, Kind<T, TR, TO, TE, C>]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/typeclass/src/TraversableFilterable.ts#L55)

Since v0.24.0
Trie-compact.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.compact

Filters out `None` values from a `Trie` of `Options`s.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<Option.Option<number>>().pipe(
  Trie.insert("shells", Option.some(0)),
  Trie.insert("sells", Option.none()),
  Trie.insert("she", Option.some(2))
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("she", 2)
)

assert.equal(Equal.equals(Trie.compact(trie), trieMapV), true)
```

**Signature**

```ts
declare const compact: <A>(self: Trie<Option<A>>) => Trie<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L720)

Since v2.0.0
Trie-empty.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.empty

Creates an empty `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<string>()

assert.equal(Trie.size(trie), 0)
assert.deepStrictEqual(Array.from(trie), [])
```

**Signature**

```ts
declare const empty: <V = never>() => Trie<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L60)

Since v2.0.0
Trie-entries.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.entries

Returns an `IterableIterator` of the entries within the `Trie`.

The entries are returned by keys in alphabetical order, regardless of insertion order.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1)
)

const result = Array.from(Trie.entries(trie))
assert.deepStrictEqual(result, [["call", 0], ["me", 1]])
```

**Signature**

```ts
declare const entries: <V>(self: Trie<V>) => IterableIterator<[string, V]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L205)

Since v2.0.0
Trie-entriesWithPrefix.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.entriesWithPrefix

Returns an `IterableIterator` of the entries within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.entriesWithPrefix(trie, "she"))
assert.deepStrictEqual(result, [["she", 0], ["shells", 1]])
```

**Signature**

```ts
declare const entriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<[string, V]>; <V>(self: Trie<V>, prefix: string): IterableIterator<[string, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L312)

Since v2.0.0
Trie-filter.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.filter

Filters entries out of a `Trie` using the specified predicate.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("she", 2)
)

const trieMapK = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1)
)

assert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)
assert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)
```

**Signature**

```ts
declare const filter: { <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: Trie<A>) => Trie<B>; <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: Trie<A>) => Trie<A>; <A, B extends A>(self: Trie<A>, f: (a: A, k: string) => a is B): Trie<B>; <A>(self: Trie<A>, f: (a: A, k: string) => boolean): Trie<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L649)

Since v2.0.0
Trie-filterMap.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.filterMap

Maps over the entries of the `Trie` using the specified partial function
and filters out `None` values.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("she", 2)
)

const trieMapK = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1)
)

assert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)
assert.equal(
  Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),
  true
)
```

**Signature**

```ts
declare const filterMap: { <A, B>(f: (value: A, key: string) => Option<B>): (self: Trie<A>) => Trie<B>; <A, B>(self: Trie<A>, f: (value: A, key: string) => Option<B>): Trie<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L690)

Since v2.0.0
Trie-forEach.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.forEach

Applies the specified function to the entries of the `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

let value = 0

Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2),
  Trie.forEach((n, key) => {
    value += n + key.length
  })
)

assert.equal(value, 17)
```

**Signature**

```ts
declare const forEach: { <V>(f: (value: V, key: string) => void): (self: Trie<V>) => void; <V>(self: Trie<V>, f: (value: V, key: string) => void): void; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L747)

Since v2.0.0
Trie-fromIterable.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.fromIterable

Creates a new `Trie` from an iterable collection of key/value pairs (e.g. `Array<[string, V]>`).

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const iterable: Array<readonly [string, number]> = [["call", 0], ["me", 1], ["mind", 2], ["mid", 3]]
const trie = Trie.fromIterable(iterable)

// The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order
assert.deepStrictEqual(Array.from(trie), [["call", 0], ["me", 1], ["mid", 3], ["mind", 2]])
assert.equal(Equal.equals(Trie.make(["call", 0], ["me", 1], ["mind", 2], ["mid", 3]), trie), true)
```

**Signature**

```ts
declare const fromIterable: <V>(entries: Iterable<readonly [string, V]>) => Trie<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L81)

Since v2.0.0
Trie-get.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.get

Safely lookup the value for the specified key in the `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

assert.deepStrictEqual(Trie.get(trie, "call"), Option.some(0))
assert.deepStrictEqual(Trie.get(trie, "me"), Option.some(1))
assert.deepStrictEqual(Trie.get(trie, "mind"), Option.some(2))
assert.deepStrictEqual(Trie.get(trie, "mid"), Option.some(3))
assert.deepStrictEqual(Trie.get(trie, "cale"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "ma"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "midn"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "mea"), Option.none())
```

**Signature**

```ts
declare const get: { (key: string): <V>(self: Trie<V>) => Option<V>; <V>(self: Trie<V>, key: string): Option<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L423)

Since v2.0.0
Trie-has.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.has

Check if the given key exists in the `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

assert.equal(Trie.has(trie, "call"), true)
assert.equal(Trie.has(trie, "me"), true)
assert.equal(Trie.has(trie, "mind"), true)
assert.equal(Trie.has(trie, "mid"), true)
assert.equal(Trie.has(trie, "cale"), false)
assert.equal(Trie.has(trie, "ma"), false)
assert.equal(Trie.has(trie, "midn"), false)
assert.equal(Trie.has(trie, "mea"), false)
```

**Signature**

```ts
declare const has: { (key: string): <V>(self: Trie<V>) => boolean; <V>(self: Trie<V>, key: string): boolean; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L456)

Since v2.0.0
Trie-insert.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.insert

Insert a new entry in the `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie1 = Trie.empty<number>().pipe(
  Trie.insert("call", 0)
)
const trie2 = trie1.pipe(Trie.insert("me", 1))
const trie3 = trie2.pipe(Trie.insert("mind", 2))
const trie4 = trie3.pipe(Trie.insert("mid", 3))

assert.deepStrictEqual(Array.from(trie1), [["call", 0]])
assert.deepStrictEqual(Array.from(trie2), [["call", 0], ["me", 1]])
assert.deepStrictEqual(Array.from(trie3), [["call", 0], ["me", 1], ["mind", 2]])
assert.deepStrictEqual(Array.from(trie4), [["call", 0], ["me", 1], ["mid", 3], ["mind", 2]])
```

**Signature**

```ts
declare const insert: { <V1>(key: string, value: V1): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, key: string, value: V1): Trie<V | V1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L128)

Since v2.0.0
Trie-insertMany.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.insertMany

Insert multiple entries in the `Trie` at once.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieInsert = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insertMany(
    [["sells", 1], ["she", 2]]
  )
)

assert.equal(
  Equal.equals(trie, trieInsert),
  true
)
```

**Signature**

```ts
declare const insertMany: { <V1>(iter: Iterable<[string, V1]>): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, iter: Iterable<[string, V1]>): Trie<V | V1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L837)

Since v2.0.0
Trie-isEmpty.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.isEmpty

Checks if the `Trie` contains any entries.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>()
const trie1 = trie.pipe(Trie.insert("ma", 0))

assert.equal(Trie.isEmpty(trie), true)
assert.equal(Trie.isEmpty(trie1), false)
```

**Signature**

```ts
declare const isEmpty: <V>(self: Trie<V>) => boolean
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L479)

Since v2.0.0
Trie-keys.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.keys

Returns an `IterableIterator` of the keys within the `Trie`.

The keys are returned in alphabetical order, regardless of insertion order.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("cab", 0),
  Trie.insert("abc", 1),
  Trie.insert("bca", 2)
)

const result = Array.from(Trie.keys(trie))
assert.deepStrictEqual(result, ["abc", "bca", "cab"])
```

**Signature**

```ts
declare const keys: <V>(self: Trie<V>) => IterableIterator<string>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L156)

Since v2.0.0
Trie-keysWithPrefix.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.keysWithPrefix

Returns an `IterableIterator` of the keys within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.keysWithPrefix(trie, "she"))
assert.deepStrictEqual(result, ["she", "shells"])
```

**Signature**

```ts
declare const keysWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<string>; <V>(self: Trie<V>, prefix: string): IterableIterator<string>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L254)

Since v2.0.0
Trie-longestPrefixOf.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.longestPrefixOf

Returns the longest key/value in the `Trie`
that is a prefix of that `key` if it exists, `None` otherwise.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.deepStrictEqual(Trie.longestPrefixOf(trie, "sell"), Option.none())
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "sells"), Option.some(["sells", 1]))
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "shell"), Option.some(["she", 2]))
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "shellsort"), Option.some(["shells", 0]))
```

**Signature**

```ts
declare const longestPrefixOf: { (key: string): <V>(self: Trie<V>) => Option<[string, V]>; <V>(self: Trie<V>, key: string): Option<[string, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L369)

Since v2.0.0
Trie-make.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.make

Constructs a new `Trie` from the specified entries (`[string, V]`).

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.make(["ca", 0], ["me", 1])

assert.deepStrictEqual(Array.from(trie), [["ca", 0], ["me", 1]])
assert.equal(Equal.equals(Trie.fromIterable([["ca", 0], ["me", 1]]), trie), true)
```

**Signature**

```ts
declare const make: <Entries extends Array<readonly [string, any]>>(...entries: Entries) => Trie<Entries[number] extends readonly [any, infer V] ? V : never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L100)

Since v2.0.0
Trie-map.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.map

Maps over the entries of the `Trie` using the specified function.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("shells", 1),
  Trie.insert("sells", 2),
  Trie.insert("she", 3)
)

const trieMapK = Trie.empty<number>().pipe(
  Trie.insert("shells", 6),
  Trie.insert("sells", 5),
  Trie.insert("she", 3)
)

assert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)
assert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)
```

**Signature**

```ts
declare const map: { <A, V>(f: (value: V, key: string) => A): (self: Trie<V>) => Trie<A>; <V, A>(self: Trie<V>, f: (value: V, key: string) => A): Trie<A>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L614)

Since v2.0.0
TSet-TSet.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.TSet

Transactional set implemented on top of `TMap`.

**Signature**

```ts
export interface TSet<in out A> extends TSet.Variance<A> {}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L31)

Since v2.0.0
TSet-add.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.add

Stores new element in the set.

**Signature**

```ts
declare const add: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L62)

Since v2.0.0
TSet-difference.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.difference

Atomically transforms the set into the difference of itself and the
provided set.

**Signature**

```ts
declare const difference: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L74)

Since v2.0.0
TSet-empty.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.empty

Makes an empty `TSet`.

**Signature**

```ts
declare const empty: <A>() => STM.STM<TSet<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L85)

Since v2.0.0
TSet-forEach.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.forEach

Atomically performs transactional-effect for each element in set.

**Signature**

```ts
declare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L93)

Since v2.0.0
TSet-fromIterable.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.fromIterable

Creates a new `TSet` from an iterable collection of values.

**Signature**

```ts
declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TSet<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L104)

Since v2.0.0
TSet-has.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.has

Tests whether or not set contains an element.

**Signature**

```ts
declare const has: { <A>(value: A): (self: TSet<A>) => STM.STM<boolean>; <A>(self: TSet<A>, value: A): STM.STM<boolean>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L112)

Since v2.0.0
TSet-intersection.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.intersection

Atomically transforms the set into the intersection of itself and the
provided set.

**Signature**

```ts
declare const intersection: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L124)

Since v2.0.0
TSet-isEmpty.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.isEmpty

Tests if the set is empty or not

**Signature**

```ts
declare const isEmpty: <A>(self: TSet<A>) => STM.STM<boolean>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L135)

Since v2.0.0
TSet-make.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.make

Makes a new `TSet` that is initialized with specified values.

**Signature**

```ts
declare const make: <Elements extends Array<any>>(...elements: Elements) => STM.STM<TSet<Elements[number]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L143)

Since v2.0.0
TSet-reduce.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.reduce

Atomically folds using a pure function.

**Signature**

```ts
declare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: TSet<A>) => STM.STM<Z>; <Z, A>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): STM.STM<Z>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L153)

Since v2.0.0
TSet-reduceSTM.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.reduceSTM

Atomically folds using a transactional function.

**Signature**

```ts
declare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): (self: TSet<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L164)

Since v2.0.0
TSet-remove.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.remove

Removes a single element from the set.

**Signature**

```ts
declare const remove: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L175)

Since v2.0.0
TSet-removeAll.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.removeAll

Removes elements from the set.

**Signature**

```ts
declare const removeAll: { <A>(iterable: Iterable<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, iterable: Iterable<A>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L186)

Since v2.0.0
TSet-removeIf.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.removeIf

Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

**Signature**

```ts
declare const removeIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L198)

Since v2.0.0
TSet-retainIf.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.retainIf

Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

**Signature**

```ts
declare const retainIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L227)

Since v2.0.0
TSet-size.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.size

Returns the set's cardinality.

**Signature**

```ts
declare const size: <A>(self: TSet<A>) => STM.STM<number>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L255)

Since v2.0.0
TSet-takeFirst.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.takeFirst

Takes the first matching value, or retries until there is one.

**Signature**

```ts
declare const takeFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<B>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L263)

Since v2.0.0
TSet-takeFirstSTM.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.takeFirstSTM

Takes the first matching value, or retries until there is one.

**Signature**

```ts
declare const takeFirstSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<B, E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<B, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L274)

Since v2.0.0
TSet-takeSome.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.takeSome

Takes all matching values, or retries until there is at least one.

**Signature**

```ts
declare const takeSome: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<[B, ...Array<B>]>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<[B, ...Array<B>]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L285)

Since v2.0.0
TSet-takeSomeSTM.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.takeSomeSTM

Takes all matching values, or retries until there is at least one.

**Signature**

```ts
declare const takeSomeSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<[B, ...Array<B>], E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<[B, ...Array<B>], E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L296)

Since v2.0.0
TSet-toArray.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.toArray

Collects all elements into a `Array`.

**Signature**

```ts
declare const toArray: <A>(self: TSet<A>) => STM.STM<Array<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L323)

Since v2.0.0
TSet-toChunk.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.toChunk

Collects all elements into a `Chunk`.

**Signature**

```ts
declare const toChunk: <A>(self: TSet<A>) => STM.STM<Chunk.Chunk<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L307)

Since v2.0.0
TSet-toHashSet.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.toHashSet

Collects all elements into a `HashSet`.

**Signature**

```ts
declare const toHashSet: <A>(self: TSet<A>) => STM.STM<HashSet.HashSet<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L315)

Since v2.0.0
TSet-toReadonlySet.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.toReadonlySet

Collects all elements into a `ReadonlySet`.

**Signature**

```ts
declare const toReadonlySet: <A>(self: TSet<A>) => STM.STM<ReadonlySet<A>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L331)

Since v2.0.0
TSet-transform.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.transform

Atomically updates all elements using a pure function.

**Signature**

```ts
declare const transform: { <A>(f: (a: A) => A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, f: (a: A) => A): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L339)

Since v2.0.0
TSet-transformSTM.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.transformSTM

Atomically updates all elements using a transactional function.

**Signature**

```ts
declare const transformSTM: { <A, R, E>(f: (a: A) => STM.STM<A, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (a: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L350)

Since v2.0.0
TSet-union.md
Package: `effect`<br />
Module: `TSet`<br />

## TSet.union

Atomically transforms the set into the union of itself and the provided
set.

**Signature**

```ts
declare const union: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L362)

Since v2.0.0
TSubscriptionRef-TSubscriptionRef.md
Package: `effect`<br />
Module: `TSubscriptionRef`<br />

## TSubscriptionRef.TSubscriptionRef

A `TSubscriptionRef<A>` is a `TRef` that can be subscribed to in order to
receive a `TDequeue<A>` of the current value and all committed changes to the value.

**Signature**

```ts
export interface TSubscriptionRef<in out A> extends TSubscriptionRef.Variance<A>, TRef.TRef<A> {
  /** @internal */
  readonly ref: TRef.TRef<A>
  /** @internal */
  readonly pubsub: TPubSub.TPubSub<A>
  /** @internal */
  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>

  /**
   * A TDequeue containing the current value of the `Ref` as well as all changes
   * to that value.
   */
  readonly changes: STM.STM<TQueue.TDequeue<A>>
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L34)

Since v3.10.0
Trie-modify.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.modify

Updates the value of the specified key within the `Trie` if it exists.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.deepStrictEqual(trie.pipe(Trie.modify("she", (v) => v + 10), Trie.get("she")), Option.some(12))

assert.equal(Equal.equals(trie.pipe(Trie.modify("me", (v) => v)), trie), true)
```

**Signature**

```ts
declare const modify: { <V1, V>(key: string, f: (v: V) => V1): (self: Trie<V>) => Trie<V1 | V>; <V1, V>(self: Trie<V>, key: string, f: (v: V) => V1): Trie<V | V1>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L774)

Since v2.0.0
Trie-reduce.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.reduce

Reduce a state over the entries of the `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.equal(
  trie.pipe(
    Trie.reduce(0, (acc, n) => acc + n)
  ),
  3
)
assert.equal(
  trie.pipe(
    Trie.reduce(10, (acc, n) => acc + n)
  ),
  13
)
assert.equal(
  trie.pipe(
    Trie.reduce("", (acc, _, key) => acc + key)
  ),
  "sellssheshells"
)
```

**Signature**

```ts
declare const reduce: { <Z, V>(zero: Z, f: (accumulator: Z, value: V, key: string) => Z): (self: Trie<V>) => Z; <Z, V>(self: Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L576)

Since v2.0.0
Trie-remove.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.remove

Remove the entry for the specified key in the `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

const trie1 = trie.pipe(Trie.remove("call"))
const trie2 = trie1.pipe(Trie.remove("mea"))

assert.deepStrictEqual(Trie.get(trie, "call"), Option.some(0))
assert.deepStrictEqual(Trie.get(trie1, "call"), Option.none())
assert.deepStrictEqual(Trie.get(trie2, "call"), Option.none())
```

**Signature**

```ts
declare const remove: { (key: string): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, key: string): Trie<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L534)

Since v2.0.0
Trie-removeMany.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.removeMany

Removes all entries in the `Trie` which have the specified keys.

**Example**

```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.equal(
  Equal.equals(trie.pipe(Trie.removeMany(["she", "sells"])), Trie.empty<number>().pipe(Trie.insert("shells", 0))),
  true
)
```

**Signature**

```ts
declare const removeMany: { (keys: Iterable<string>): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, keys: Iterable<string>): Trie<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L802)

Since v2.0.0
Trie-size.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.size

Returns the size of the `Trie` (number of entries in the `Trie`).

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("a", 0),
  Trie.insert("b", 1)
)

assert.equal(Trie.size(trie), 2)
```

**Signature**

```ts
declare const size: <V>(self: Trie<V>) => number
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L393)

Since v2.0.0
Trie-toEntries.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.toEntries

Returns an `Array<[K, V]>` of the entries within the `Trie`.

Equivalent to `Array.from(Trie.entries(trie))`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1)
)
const result = Trie.toEntries(trie)

assert.deepStrictEqual(result, [["call", 0], ["me", 1]])
```

**Signature**

```ts
declare const toEntries: <V>(self: Trie<V>) => Array<[string, V]>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L229)

Since v2.0.0
Trie-toEntriesWithPrefix.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.toEntriesWithPrefix

Returns `Array<[K, V]>` of the entries within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("sea", 2),
  Trie.insert("she", 3)
)

const result = Trie.toEntriesWithPrefix(trie, "she")
assert.deepStrictEqual(result, [["she", 3], ["shells", 0]])
```

**Signature**

```ts
declare const toEntriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => Array<[string, V]>; <V>(self: Trie<V>, prefix: string): Array<[string, V]>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L340)

Since v2.0.0
Trie-unsafeGet.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.unsafeGet

Unsafely lookup the value for the specified key in the `Trie`.

`unsafeGet` will throw if the key is not found. Use `get` instead to safely
get a value from the `Trie`.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1)
)

assert.throws(() => Trie.unsafeGet(trie, "mae"))
```

**Signature**

```ts
declare const unsafeGet: { (key: string): <V>(self: Trie<V>) => V; <V>(self: Trie<V>, key: string): V; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L503)

Since v2.0.0
Trie-values.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.values

Returns an `IterableIterator` of the values within the `Trie`.

Values are ordered based on their key in alphabetical order, regardless of insertion order.

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("and", 2)
)

const result = Array.from(Trie.values(trie))
assert.deepStrictEqual(result, [2, 0, 1])
```

**Signature**

```ts
declare const values: <V>(self: Trie<V>) => IterableIterator<V>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L181)

Since v2.0.0
Trie-valuesWithPrefix.md
Package: `effect`<br />
Module: `Trie`<br />

## Trie.valuesWithPrefix

Returns an `IterableIterator` of the values within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

**Example**

```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.valuesWithPrefix(trie, "she"))

// 0: "she", 1: "shells"
assert.deepStrictEqual(result, [0, 1])
```

**Signature**

```ts
declare const valuesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<V>; <V>(self: Trie<V>, prefix: string): IterableIterator<V>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L284)

Since v2.0.0
Tuple-appendElement.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.appendElement

Appends an element to the end of a tuple.

**Signature**

```ts
declare const appendElement: { <B>(that: B): <A extends ReadonlyArray<unknown>>(self: A) => [...A, B]; <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L230)

Since v2.0.0
Tuple-at.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.at

Retrieves the element at a specified index from a tuple.

**Example**

```ts
import * as assert from "node:assert"
import { Tuple } from "effect"

assert.deepStrictEqual(Tuple.at([1, 'hello', true], 1), 'hello')
```

**Signature**

```ts
declare const at: { <N extends number>(index: N): <A extends ReadonlyArray<unknown>>(self: A) => A[N]; <A extends ReadonlyArray<unknown>, N extends number>(self: A, index: N): A[N]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L249)

Since v3.4.0
Tuple-getEquivalence.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.getEquivalence

Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
by applying each `Equivalence` to the corresponding element of the tuple.

**Signature**

```ts
declare const getEquivalence: <T extends ReadonlyArray<Equivalence.Equivalence<any>>>(...isEquivalents: T) => Equivalence.Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L205)

Since v2.0.0
Tuple-getFirst.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.getFirst

Return the first element of a tuple.

**Example**

```ts
import * as assert from "node:assert"
import { getFirst } from "effect/Tuple"

assert.deepStrictEqual(getFirst(["hello", 42]), "hello")
```

**Signature**

```ts
declare const getFirst: <L, R>(self: readonly [L, R]) => L
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L50)

Since v2.0.0
Tuple-getOrder.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.getOrder

This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
of the tuple.

**Signature**

```ts
declare const getOrder: <T extends ReadonlyArray<order.Order<any>>>(...elements: T) => order.Order<{ [I in keyof T]: [T[I]] extends [order.Order<infer A>] ? A : never; }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L220)

Since v2.0.0
Tuple-getSecond.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.getSecond

Return the second element of a tuple.

**Example**

```ts
import * as assert from "node:assert"
import { getSecond } from "effect/Tuple"

assert.deepStrictEqual(getSecond(["hello", 42]), 42)
```

**Signature**

```ts
declare const getSecond: <L, R>(self: readonly [L, R]) => R
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L66)

Since v2.0.0
Tuple-isTupleOf.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.isTupleOf

Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.

An `Array` is considered to be a `TupleOf` if its length is exactly `N`.

**Example**

```ts
import * as assert from "node:assert"
import { isTupleOf } from "effect/Tuple"

assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3];
if (isTupleOf(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number]
}

```

**Signature**

```ts
declare const isTupleOf: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L279)

Since v3.3.0
Tuple-isTupleOfAtLeast.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.isTupleOfAtLeast

Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.

An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.

**Example**

```ts
import * as assert from "node:assert"
import { isTupleOfAtLeast } from "effect/Tuple"

assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3, 4];
if (isTupleOfAtLeast(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number, ...number[]]
}

```

**Signature**

```ts
declare const isTupleOfAtLeast: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L304)

Since v3.3.0
Tuple-make.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.make

Constructs a new tuple from the provided values.

**Example**

```ts
import * as assert from "node:assert"
import { make } from "effect/Tuple"

assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])
```

**Signature**

```ts
declare const make: <A extends ReadonlyArray<any>>(...elements: A) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L34)

Since v2.0.0
Tuple-map.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.map

Transforms each element of tuple using the given function, treating tuple homomorphically

**Example**

```ts
import * as assert from "node:assert"
import { pipe, Tuple } from "effect"

const result = pipe(
  ["a", 1, false] as const,
  Tuple.map((el) => el.toString().toUpperCase())
)
assert.deepStrictEqual(result, ['A', '1', 'FALSE'])
```

**Signature**

```ts
declare const map: { <T extends ReadonlyArray<any> | [], B>(fn: (element: T[number]) => B): (self: T) => TupleOf<T["length"], B>; <B, T extends ReadonlyArray<any> | []>(self: T, fn: (element: T[number]) => B): TupleOf<T["length"], B>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L86)

Since v3.9.0
Tuple-mapBoth.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.mapBoth

Transforms both elements of a tuple using the given functions.

**Example**

```ts
import * as assert from "node:assert"
import { mapBoth } from "effect/Tuple"

assert.deepStrictEqual(
  mapBoth(["hello", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),
  ["HELLO", "42"]
)
```

**Signature**

```ts
declare const mapBoth: { <L1, L2, R1, R2>(options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): (self: readonly [L1, R1]) => [L2, R2]; <L1, R1, L2, R2>(self: readonly [L1, R1], options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): [L2, R2]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L119)

Since v2.0.0
Tuple-mapFirst.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.mapFirst

Transforms the first component of a tuple using a given function.

**Example**

```ts
import * as assert from "node:assert"
import { mapFirst } from "effect/Tuple"

assert.deepStrictEqual(
  mapFirst(["hello", 42], s => s.toUpperCase()),
  ["HELLO", 42]
)
```

**Signature**

```ts
declare const mapFirst: { <L1, L2>(f: (left: L1) => L2): <R>(self: readonly [L1, R]) => [L2, R]; <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L156)

Since v2.0.0
Tuple-mapSecond.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.mapSecond

Transforms the second component of a tuple using a given function.

**Example**

```ts
import * as assert from "node:assert"
import { mapSecond } from "effect/Tuple"

assert.deepStrictEqual(
  mapSecond(["hello", 42], n => n.toString()),
  ["hello", "42"]
)
```

**Signature**

```ts
declare const mapSecond: { <R1, R2>(f: (right: R1) => R2): <L>(self: readonly [L, R1]) => [L, R2]; <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2]; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L178)

Since v2.0.0
Tuple-swap.md
Package: `effect`<br />
Module: `Tuple`<br />

## Tuple.swap

Swaps the two elements of a tuple.

**Example**

```ts
import * as assert from "node:assert"
import { swap } from "effect/Tuple"

assert.deepStrictEqual(swap(["hello", 42]), [42, "hello"])
```

**Signature**

```ts
declare const swap: <L, R>(self: readonly [L, R]) => [R, L]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L196)

Since v2.0.0
Types-Concurrency.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Concurrency

Describes the concurrency to use when executing multiple Effect's.

**Signature**

```ts
type Concurrency = number | "unbounded" | "inherit"
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L218)

Since v2.0.0
Types-Contravariant.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Contravariant

Contravariant helper.

**Signature**

```ts
type Contravariant<A> = (_: A) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L319)

Since v2.0.0
Types-Covariant.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Covariant

Covariant helper.

**Signature**

```ts
type Covariant<A> = (_: never) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L299)

Since v2.0.0
Types-DeepMutable.md
Package: `effect`<br />
Module: `Types`<br />

## Types.DeepMutable

Like `Types.Mutable`, but works recursively.

**Example**

```ts
import type { Types } from "effect"

type DeepMutableStruct = Types.DeepMutable<{
  readonly a: string;
  readonly b: readonly string[]
}>
// { a: string; b: string[] }
```

**Signature**

```ts
type DeepMutable<T> = T extends ReadonlyMap<infer K, infer V> ? Map<DeepMutable<K>, DeepMutable<V>>
  : T extends ReadonlySet<infer V> ? Set<DeepMutable<V>>
  : T extends string | number | boolean | bigint | symbol ? T
  : { -readonly [K in keyof T]: DeepMutable<T[K]> }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L260)

Since v3.1.0
Types-Equals.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Equals

Determines if two types are equal.

**Example**

```ts
import type { Types } from "effect"

type Res1 = Types.Equals<{ a: number }, { a: number }> // true
type Res2 = Types.Equals<{ a: number }, { b: number }> // false
```

**Signature**

```ts
type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <
  T
>() => T extends Y ? 1 : 2 ? true
  : false
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L142)

Since v2.0.0
Types-EqualsWith.md
Package: `effect`<br />
Module: `Types`<br />

## Types.EqualsWith

Determines if two types are equal, allowing to specify the return types.

**Signature**

```ts
type EqualsWith<A, B, Y, N> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? Y : N
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L153)

Since v3.15.0
Types-ExcludeTag.md
Package: `effect`<br />
Module: `Types`<br />

## Types.ExcludeTag

Excludes the tagged object from the type.

**Example**

```ts
import type { Types } from "effect"

type Res = Types.ExcludeTag<string | { _tag: "a" } | { _tag: "b" }, "a"> // string | { _tag: "b" }
```

**Signature**

```ts
type ExcludeTag<E, K> = Exclude<E, { _tag: K }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L85)

Since v2.0.0
Types-ExtractTag.md
Package: `effect`<br />
Module: `Types`<br />

## Types.ExtractTag

Extracts the type of the given tag.

**Example**

```ts
import type { Types } from "effect"

type Res = Types.ExtractTag<{ _tag: "a", a: number } | { _tag: "b", b: number }, "b"> // { _tag: "b", b: number }
```

**Signature**

```ts
type ExtractTag<E, K> = Extract<E, { _tag: K }>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L100)

Since v2.0.0
Types-Has.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Has

Determines if a record contains any of the given keys.

**Example**

```ts
import type { Types } from "effect"

type Res1 = Types.Has<{ a: number }, "a" | "b"> // true
type Res2 = Types.Has<{ c: number }, "a" | "b"> // false
```

**Signature**

```ts
type Has<A, Key> = (Key extends infer K ? K extends keyof A ? true : never : never) extends never
  ? false
  : true
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L169)

Since v2.0.0
Types-Invariant.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Invariant

Invariant helper.

**Signature**

```ts
type Invariant<A> = (_: A) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L279)

Since v2.0.0
Types-MergeLeft.md
Package: `effect`<br />
Module: `Types`<br />

## Types.MergeLeft

Merges two object where the keys of the left object take precedence in the case of a conflict.

**Example**

```ts
import type { Types } from "effect"
type MergeLeft = Types.MergeLeft<{ a: number, b: number; }, { a: string }> // { a: number; b: number; }
```

**Signature**

```ts
type MergeLeft<Source, Target> = MergeRight<Target, Source>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L185)

Since v2.0.0
Types-MergeRight.md
Package: `effect`<br />
Module: `Types`<br />

## Types.MergeRight

Merges two object where the keys of the right object take precedence in the case of a conflict.

**Example**

```ts
import type { Types } from "effect"
type MergeRight = Types.MergeRight<{ a: number, b: number; }, { a: string }> // { a: string; b: number; }
```

**Signature**

```ts
type MergeRight<Target, Source> = Simplify<
  & Source
  & {
    [Key in keyof Target as Key extends keyof Source ? never : Key]: Target[Key]
  }
>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L199)

Since v2.0.0
Types-Mutable.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Mutable

Make all properties in `T` mutable. Supports arrays, tuples, and records as well.

**Example**

```ts
import type { Types } from "effect"

type MutableStruct = Types.Mutable<{ readonly a: string; readonly b: number }> // { a: string; b: number; }

type MutableArray = Types.Mutable<ReadonlyArray<string>> // string[]

type MutableTuple = Types.Mutable<readonly [string, number]> // [string, number]

type MutableRecord = Types.Mutable<{ readonly [_: string]: number }> // { [x: string]: number; }
```

**Signature**

```ts
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L239)

Since v2.0.0
Types-NoInfer.md
Package: `effect`<br />
Module: `Types`<br />

## Types.NoInfer

Avoid inference on a specific parameter

**Signature**

```ts
type NoInfer<A> = [A][A extends any ? 0 : never]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L271)

Since v2.0.0
Types-Simplify.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Simplify

Simplifies the type signature of a type.

**Example**

```ts
import type { Types } from "effect"

type Res = Types.Simplify<{ a: number } & { b: number }> // { a: number; b: number; }
```

**Signature**

```ts
type Simplify<A> = {
  [K in keyof A]: A[K]
} extends infer B ? B : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L124)

Since v2.0.0
Types-Tags.md
Package: `effect`<br />
Module: `Types`<br />

## Types.Tags

Returns the tags in a type.

**Example**

```ts
import type { Types } from "effect"

type Res = Types.Tags<string | { _tag: "a" } | { _tag: "b" } > // "a" | "b"
```

**Signature**

```ts
type Tags<E> = E extends { _tag: string } ? E["_tag"] : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L71)

Since v2.0.0
Types-TupleOf.md
Package: `effect`<br />
Module: `Types`<br />

## Types.TupleOf

Represents a tuple with a fixed number of elements of type `T`.

This type constructs a tuple that has exactly `N` elements of type `T`.

**Example**

```ts
import { TupleOf } from "effect/Types"

// A tuple with exactly 3 numbers
const example1: TupleOf<3, number> = [1, 2, 3]; // valid
// @ts-expect-error
const example2: TupleOf<3, number> = [1, 2]; // invalid
// @ts-expect-error
const example3: TupleOf<3, number> = [1, 2, 3, 4]; // invalid
```

**Signature**

```ts
type TupleOf<N, T> = N extends N ? number extends N ? Array<T> : _TupleOf<T, N, []> : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L32)

Since v3.3.0
Types-TupleOfAtLeast.md
Package: `effect`<br />
Module: `Types`<br />

## Types.TupleOfAtLeast

Represents a tuple with at least `N` elements of type `T`.

This type constructs a tuple that has a fixed number of elements `N` of type `T` at the start,
followed by any number (including zero) of additional elements of the same type `T`.

**Example**

```ts
import { TupleOfAtLeast } from "effect/Types"

// A tuple with at least 3 numbers
const example1: TupleOfAtLeast<3, number> = [1, 2, 3]; // valid
const example2: TupleOfAtLeast<3, number> = [1, 2, 3, 4, 5]; // valid
// @ts-expect-error
const example3: TupleOfAtLeast<3, number> = [1, 2]; // invalid
```

**Signature**

```ts
type [...TupleOf<N, T>, ...T[]] = [...TupleOf<N, T>, ...Array<T>]
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L57)

Since v3.3.0
Types-UnionToIntersection.md
Package: `effect`<br />
Module: `Types`<br />

## Types.UnionToIntersection

A utility type that transforms a union type `T` into an intersection type.

**Signature**

```ts
type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R
  : never
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L108)

Since v2.0.0
UpstreamPullRequest-isNoUpstream.md
Package: `effect`<br />
Module: `UpstreamPullRequest`<br />

## UpstreamPullRequest.isNoUpstream

Returns `true` if the specified `UpstreamPullRequest` is a `NoUpstream`,
`false` otherwise.

**Signature**

```ts
declare const isNoUpstream: <A>(self: UpstreamPullRequest<A>) => self is NoUpstream
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L95)

Since v2.0.0
UpstreamPullRequest-isPulled.md
Package: `effect`<br />
Module: `UpstreamPullRequest`<br />

## UpstreamPullRequest.isPulled

Returns `true` if the specified `UpstreamPullRequest` is a `Pulled`, `false`
otherwise.

**Signature**

```ts
declare const isPulled: <A>(self: UpstreamPullRequest<A>) => self is Pulled<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L86)

Since v2.0.0
UpstreamPullRequest-isUpstreamPullRequest.md
Package: `effect`<br />
Module: `UpstreamPullRequest`<br />

## UpstreamPullRequest.isUpstreamPullRequest

Returns `true` if the specified value is an `UpstreamPullRequest`, `false`
otherwise.

**Signature**

```ts
declare const isUpstreamPullRequest: (u: unknown) => u is UpstreamPullRequest<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L77)

Since v2.0.0
UpstreamPullRequest-match.md
Package: `effect`<br />
Module: `UpstreamPullRequest`<br />

## UpstreamPullRequest.match

Folds an `UpstreamPullRequest<A>` into a value of type `Z`.

**Signature**

```ts
declare const match: { <A, Z>(options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): (self: UpstreamPullRequest<A>) => Z; <A, Z>(self: UpstreamPullRequest<A>, options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L103)

Since v2.0.0
UpstreamPullStrategy-isPullAfterAllEnqueued.md
Package: `effect`<br />
Module: `UpstreamPullStrategy`<br />

## UpstreamPullStrategy.isPullAfterAllEnqueued

Returns `true` if the specified `UpstreamPullStrategy` is a
`PullAfterAllEnqueued`, `false` otherwise.

**Signature**

```ts
declare const isPullAfterAllEnqueued: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterAllEnqueued<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L98)

Since v2.0.0
UpstreamPullStrategy-isPullAfterNext.md
Package: `effect`<br />
Module: `UpstreamPullStrategy`<br />

## UpstreamPullStrategy.isPullAfterNext

Returns `true` if the specified `UpstreamPullStrategy` is a `PullAfterNext`,
`false` otherwise.

**Signature**

```ts
declare const isPullAfterNext: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterNext<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L89)

Since v2.0.0
UpstreamPullStrategy-isUpstreamPullStrategy.md
Package: `effect`<br />
Module: `UpstreamPullStrategy`<br />

## UpstreamPullStrategy.isUpstreamPullStrategy

Returns `true` if the specified value is an `UpstreamPullStrategy`, `false`
otherwise.

**Signature**

```ts
declare const isUpstreamPullStrategy: (u: unknown) => u is UpstreamPullStrategy<unknown>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L79)

Since v2.0.0
UpstreamPullStrategy-match.md
Package: `effect`<br />
Module: `UpstreamPullStrategy`<br />

## UpstreamPullStrategy.match

Folds an `UpstreamPullStrategy<A>` into a value of type `Z`.

**Signature**

```ts
declare const match: { <A, Z>(options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): (self: UpstreamPullStrategy<A>) => Z; <A, Z>(self: UpstreamPullStrategy<A>, options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): Z; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L107)

Since v2.0.0
Url-fromString.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.fromString

Parses a URL string into a `URL` object, returning an `Either` type for safe
error handling.

**Details**

This function converts a string into a `URL` object, enabling safe URL
parsing with built-in error handling. If the string is invalid or fails to
parse, this function does not throw an error; instead, it wraps the error in
a `IllegalArgumentException` and returns it as the `Left` value of an
`Either`. The `Right` value contains the successfully parsed `URL`.

An optional `base` parameter can be provided to resolve relative URLs. If
specified, the function interprets the input `url` as relative to this
`base`. This is especially useful when dealing with URLs that might not be
fully qualified.

**Example**

```ts
import { Url } from "@effect/platform"
import { Either } from "effect"

// Parse an absolute URL
//
//       Either<URL, IllegalArgumentException>
//      
const parsed = Url.fromString("https://example.com/path")

if (Either.isRight(parsed)) {
  console.log("Parsed URL:", parsed.right.toString())
} else {
  console.log("Error:", parsed.left.message)
}
// Output: Parsed URL: https://example.com/path

// Parse a relative URL with a base
const relativeParsed = Url.fromString("/relative-path", "https://example.com")

if (Either.isRight(relativeParsed)) {
  console.log("Parsed relative URL:", relativeParsed.right.toString())
} else {
  console.log("Error:", relativeParsed.left.message)
}
// Output: Parsed relative URL: https://example.com/relative-path
```

**Signature**

```ts
declare const fromString: (url: string, base?: string | URL | undefined) => Either.Either<URL, Cause.IllegalArgumentException>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L60)

Since v1.0.0
Url-modifyUrlParams.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.modifyUrlParams

Reads, modifies, and updates the query parameters of a URL.

**Details**

This function provides a functional way to interact with query parameters by
reading the current parameters, applying a transformation function, and then
writing the updated parameters back to the URL. It returns a new `URL` object
with the modified parameters, ensuring immutability.

**Example**

```ts
import { Url, UrlParams } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

const changedUrl = Url.modifyUrlParams(myUrl, UrlParams.append("key", "value"))

console.log(changedUrl.toString())
// Output: https://example.com/?foo=bar&key=value
```

**Signature**

```ts
declare const modifyUrlParams: { (f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): (url: URL) => URL; (url: URL, f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L317)

Since v1.0.0
Url-mutate.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.mutate

This function clones the original `URL` object and applies a callback to the
clone, allowing multiple updates at once.

**Example**

```ts
import { Url } from "@effect/platform"

const myUrl = new URL("https://example.com")

const mutatedUrl = Url.mutate(myUrl, (url) => {
  url.username = "user"
  url.password = "pass"
})

console.log("Mutated:", mutatedUrl.toString())
// Output: Mutated: https://user:pass@example.com/
```

**Signature**

```ts
declare const mutate: { (f: (url: URL) => void): (self: URL) => URL; (self: URL, f: (url: URL) => void): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L92)

Since v1.0.0
Url-setHash.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setHash

Updates the hash fragment of the URL.

**Signature**

```ts
declare const setHash: { (hash: string): (url: URL) => URL; (url: URL, hash: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L117)

Since v1.0.0
Url-setHost.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setHost

Updates the host (domain and port) of the URL.

**Signature**

```ts
declare const setHost: { (host: string): (url: URL) => URL; (url: URL, host: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L128)

Since v1.0.0
Url-setHostname.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setHostname

Updates the domain of the URL without modifying the port.

**Signature**

```ts
declare const setHostname: { (hostname: string): (url: URL) => URL; (url: URL, hostname: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L139)

Since v1.0.0
Url-setHref.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setHref

Replaces the entire URL string.

**Signature**

```ts
declare const setHref: { (href: string): (url: URL) => URL; (url: URL, href: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L150)

Since v1.0.0
Url-setPassword.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setPassword

Updates the password used for authentication.

**Signature**

```ts
declare const setPassword: { (password: string | Redacted.Redacted): (url: URL) => URL; (url: URL, password: string | Redacted.Redacted): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L161)

Since v1.0.0
Url-setPathname.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setPathname

Updates the path of the URL.

**Signature**

```ts
declare const setPathname: { (pathname: string): (url: URL) => URL; (url: URL, pathname: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L177)

Since v1.0.0
Url-setPort.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setPort

Updates the port of the URL.

**Signature**

```ts
declare const setPort: { (port: string | number): (url: URL) => URL; (url: URL, port: string | number): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L188)

Since v1.0.0
Url-setProtocol.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setProtocol

Updates the protocol (e.g., `http`, `https`).

**Signature**

```ts
declare const setProtocol: { (protocol: string): (url: URL) => URL; (url: URL, protocol: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L199)

Since v1.0.0
Url-setSearch.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setSearch

Updates the query string of the URL.

**Signature**

```ts
declare const setSearch: { (search: string): (url: URL) => URL; (url: URL, search: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L210)

Since v1.0.0
Url-setUrlParams.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setUrlParams

Updates the query parameters of a URL.

**Details**

This function allows you to set or replace the query parameters of a `URL`
object using the provided `UrlParams`. It creates a new `URL` object with the
updated parameters, leaving the original object unchanged.

**Example**

```ts
import { Url, UrlParams } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

// Write parameters
const updatedUrl = Url.setUrlParams(
  myUrl,
  UrlParams.fromInput([["key", "value"]])
)

console.log(updatedUrl.toString())
// Output: https://example.com/?key=value
```

**Signature**

```ts
declare const setUrlParams: { (urlParams: UrlParams.UrlParams): (url: URL) => URL; (url: URL, urlParams: UrlParams.UrlParams): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L255)

Since v1.0.0
Url-setUsername.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.setUsername

Updates the username used for authentication.

**Signature**

```ts
declare const setUsername: { (username: string): (url: URL) => URL; (url: URL, username: string): URL; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L221)

Since v1.0.0
Url-urlParams.md
Package: `@effect/platform`<br />
Module: `Url`<br />

## Url.urlParams

Retrieves the query parameters from a URL.

**Details**

This function extracts the query parameters from a `URL` object and returns
them as `UrlParams`. The resulting structure can be easily manipulated or
inspected.

**Example**

```ts
import { Url } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

// Read parameters
const params = Url.urlParams(myUrl)

console.log(params)
// Output: [ [ 'foo', 'bar' ] ]
```

**Signature**

```ts
declare const urlParams: (url: URL) => UrlParams.UrlParams
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Url.ts#L289)

Since v1.0.0
UrlParams-schemaStruct.md
Package: `@effect/platform`<br />
Module: `UrlParams`<br />

## UrlParams.schemaStruct

Extract schema from all key-value pairs in the given `UrlParams`.

**Example**

```ts
import * as assert from "node:assert"
import { Effect, Schema } from "effect"
import { UrlParams } from "@effect/platform"

Effect.gen(function* () {
  const urlParams = UrlParams.fromInput({ "a": [10, "string"], "b": false })
  const result = yield* UrlParams.schemaStruct(Schema.Struct({
    a: Schema.Tuple(Schema.NumberFromString, Schema.String),
    b: Schema.BooleanFromString
  }))(urlParams)

  assert.deepStrictEqual(result, {
    a: [10, "string"],
    b: false
  })
})
```

**Signature**

```ts
declare const schemaStruct: <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/UrlParams.ts#L325)

Since v1.0.0
UrlParams-toRecord.md
Package: `@effect/platform`<br />
Module: `UrlParams`<br />

## UrlParams.toRecord

Builds a `Record` containing all the key-value pairs in the given `UrlParams`
as `string` (if only one value for a key) or a `NonEmptyArray<string>`
(when more than one value for a key)

**Example**

```ts
import * as assert from "node:assert"
import { UrlParams } from "@effect/platform"

const urlParams = UrlParams.fromInput({ a: 1, b: true, c: "string", e: [1, 2, 3] })
const result = UrlParams.toRecord(urlParams)

assert.deepStrictEqual(
  result,
  { "a": "1", "b": "true", "c": "string", "e": ["1", "2", "3"] }
)
```

**Signature**

```ts
declare const toRecord: (self: UrlParams) => Record<string, string | Arr.NonEmptyArray<string>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/UrlParams.ts#L263)

Since v1.0.0
utils-assertEquals.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertEquals

Asserts that `actual` is equal to `expected` using the `Equal.equals` trait.

**Signature**

```ts
declare const assertEquals: <A>(actual: A, expected: A, message?: string, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L58)

Since v0.21.0
utils-assertFailure.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertFailure

Asserts that `exit` is a failure.

**Signature**

```ts
declare const assertFailure: <A, E>(exit: Exit.Exit<A, E>, expected: Cause.Cause<E>, ..._: Array<never>) => asserts exit is Exit.Failure<never, E>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L243)

Since v0.21.0
Utils-PCGRandom.md
Package: `effect`<br />
Module: `Utils`<br />

## Utils.PCGRandom

PCG is a family of simple fast space-efficient statistically good algorithms
for random number generation. Unlike many general-purpose RNGs, they are also
hard to predict.

**Signature**

```ts
declare class PCGRandom { constructor(
    seedHi?: OptionalNumber,
    seedLo?: OptionalNumber,
    incHi?: OptionalNumber,
    incLo?: OptionalNumber
  ) }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L516)

Since v2.0.0
Utils-structuralRegion.md
Package: `effect`<br />
Module: `Utils`<br />

## Utils.structuralRegion

Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code

**Signature**

```ts
declare const structuralRegion: <A>(body: () => A, tester?: (a: unknown, b: unknown) => boolean) => A
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L762)

Since v3.1.1
Utils-structuralRegionState.md
Package: `effect`<br />
Module: `Utils`<br />

## Utils.structuralRegionState

Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code

**Signature**

```ts
declare const structuralRegionState: { enabled: boolean; tester: ((a: unknown, b: unknown) => boolean) | undefined; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L747)

Since v3.1.1
WorkerRunner-CloseLatch.md
Package: `@effect/platform`<br />
Module: `WorkerRunner`<br />

## WorkerRunner.CloseLatch

The worker close latch is used by platform runners to signal that the worker
has been closed.

**Signature**

```ts
export interface CloseLatch {
  readonly _: unique symbol
}
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/WorkerRunner.ts#L77)

Since v1.0.0
WorkerRunner-launch.md
Package: `@effect/platform`<br />
Module: `WorkerRunner`<br />

## WorkerRunner.launch

Launch the specified layer, interrupting the fiber when the CloseLatch is
triggered.

**Signature**

```ts
declare const launch: <A, E, R>(layer: Layer.Layer<A, E, R>) => Effect.Effect<void, E | WorkerError, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/WorkerRunner.ts#L249)

Since v1.0.0
Workflow-CaptureDefects.md
Package: `@effect/workflow`<br />
Module: `Workflow`<br />

## Workflow.CaptureDefects

If you set this annotation to `true` for a workflow, it will capture defects
and include them in the result of the workflow or it's activities.

By default, this is set to `true`, meaning that defects will be captured.

**Signature**

```ts
declare class CaptureDefects
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Workflow.ts#L557)

Since v1.0.0
Workflow-withCompensation.md
Package: `@effect/workflow`<br />
Module: `Workflow`<br />

## Workflow.withCompensation

Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
called if the entire workflow fails, allowing you to perform cleanup or
other actions based on the success value and the cause of the workflow failure.

NOTE: Compensation will not work for nested activities. Compensation
finalizers are only registered for top-level effects in the workflow.

**Signature**

```ts
declare const withCompensation: { <A, R2>(compensation: (value: A, cause: Cause.Cause<unknown>) => Effect.Effect<void, never, R2>): <E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | R2 | WorkflowInstance | Scope.Scope>; <A, E, R, R2>(effect: Effect.Effect<A, E, R>, compensation: (value: A, cause: Cause.Cause<unknown>) => Effect.Effect<void, never, R2>): Effect.Effect<A, E, R | R2 | WorkflowInstance | Scope.Scope>; }
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/Workflow.ts#L520)

Since v1.0.0
WorkflowProxy-toHttpApiGroup.md
Package: `@effect/workflow`<br />
Module: `WorkflowProxy`<br />

## WorkflowProxy.toHttpApiGroup

Derives an `HttpApiGroup` from a list of workflows.

```ts
import { HttpApi, HttpApiBuilder } from "@effect/platform"
import { Workflow, WorkflowProxy, WorkflowProxyServer } from "@effect/workflow"
import { Layer, Schema } from "effect"

const EmailWorkflow = Workflow.make({
  name: "EmailWorkflow",
  payload: {
    id: Schema.String,
    to: Schema.String
  },
  idempotencyKey: ({ id }) => id
})

const myWorkflows = [EmailWorkflow] as const

// Use WorkflowProxy.toHttpApiGroup to create a `HttpApiGroup` from the
// workflows
class MyApi extends HttpApi.make("api")
  .add(WorkflowProxy.toHttpApiGroup("workflows", myWorkflows))
{}

// Use WorkflowProxyServer.layerHttpApi to create a layer that implements the
// workflows HttpApiGroup
const ApiLayer = HttpApiBuilder.api(MyApi).pipe(
  Layer.provide(WorkflowProxyServer.layerHttpApi(MyApi, "workflows", myWorkflows))
)
```

**Signature**

```ts
declare const toHttpApiGroup: <const Name extends string, const Workflows extends NonEmptyReadonlyArray<Workflow.Any>>(name: Name, workflows: Workflows) => HttpApiGroup.HttpApiGroup<Name, ConvertHttpApi<Workflows[number]>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/WorkflowProxy.ts#L118)

Since v1.0.0
WorkflowProxy-toRpcGroup.md
Package: `@effect/workflow`<br />
Module: `WorkflowProxy`<br />

## WorkflowProxy.toRpcGroup

Derives an `RpcGroup` from a list of workflows.

```ts
import { RpcServer } from "@effect/rpc"
import { Workflow, WorkflowProxy, WorkflowProxyServer } from "@effect/workflow"
import { Layer, Schema } from "effect"

const EmailWorkflow = Workflow.make({
  name: "EmailWorkflow",
  payload: {
    id: Schema.String,
    to: Schema.String
  },
  idempotencyKey: ({ id }) => id
})

const myWorkflows = [EmailWorkflow] as const

// Use WorkflowProxy.toRpcGroup to create a `RpcGroup` from the
// workflows
class MyRpcs extends WorkflowProxy.toRpcGroup(myWorkflows) {}

// Use WorkflowProxyServer.layerRpcHandlers to create a layer that implements
// the rpc handlers
const ApiLayer = RpcServer.layer(MyRpcs).pipe(
  Layer.provide(WorkflowProxyServer.layerRpcHandlers(myWorkflows))
)
```

**Signature**

```ts
declare const toRpcGroup: <const Workflows extends NonEmptyReadonlyArray<Workflow.Any>, const Prefix extends string = "">(workflows: Workflows, options?: { readonly prefix?: Prefix | undefined; }) => RpcGroup.RpcGroup<ConvertRpcs<Workflows[number], Prefix>>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/platform/src/WorkflowProxy.ts#L44)

Since v1.0.0
utils-assertFalse.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertFalse

Asserts that `self` is `false`.

**Signature**

```ts
declare const assertFalse: (self: boolean, message?: string, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L106)

Since v0.21.0
utils-assertInclude.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertInclude

Asserts that `actual` includes `expected`.

**Signature**

```ts
declare const assertInclude: (actual: string | undefined, expected: string, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L115)

Since v0.21.0
utils-assertInstanceOf.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertInstanceOf

Asserts that `value` is an instance of `constructor`.

**Signature**

```ts
declare const assertInstanceOf: <C extends abstract new (...args: any) => any>(value: unknown, constructor: C, message?: string, ..._: Array<never>) => asserts value is InstanceType<C>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L83)

Since v0.21.0
utils-assertLeft.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertLeft

Asserts that `either` is `Left`.

**Signature**

```ts
declare const assertLeft: <R, L>(either: Either.Either<R, L>, expected: L, ..._: Array<never>) => asserts either is Either.Left<L, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L213)

Since v0.21.0
utils-assertMatch.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertMatch

Asserts that `actual` matches `regexp`.

**Signature**

```ts
declare const assertMatch: (actual: string, regexp: RegExp, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L128)

Since v0.21.0
utils-assertNone.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertNone

Asserts that `option` is `None`.

**Signature**

```ts
declare const assertNone: <A>(option: Option.Option<A>, ..._: Array<never>) => asserts option is Option.None<never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L187)

Since v0.21.0
utils-assertRight.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertRight

Asserts that `either` is `Right`.

**Signature**

```ts
declare const assertRight: <R, L>(either: Either.Either<R, L>, expected: R, ..._: Array<never>) => asserts either is Either.Right<never, R>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L226)

Since v0.21.0
utils-assertSome.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertSome

Asserts that `option` is `Some`.

**Signature**

```ts
declare const assertSome: <A>(option: Option.Option<A>, expected: A, ..._: Array<never>) => asserts option is Option.Some<A>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L196)

Since v0.21.0
utils-assertSuccess.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertSuccess

Asserts that `exit` is a success.

**Signature**

```ts
declare const assertSuccess: <A, E>(exit: Exit.Exit<A, E>, expected: A, ..._: Array<never>) => asserts exit is Exit.Success<A, never>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L256)

Since v0.21.0
utils-assertTrue.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.assertTrue

Asserts that `self` is `true`.

**Signature**

```ts
declare const assertTrue: (self: unknown, message?: string, ..._: Array<never>) => asserts self
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L97)

Since v0.21.0
utils-deepStrictEqual.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.deepStrictEqual

Asserts that `actual` is equal to `expected` using the `Equal.equals` trait.

**Signature**

```ts
declare const deepStrictEqual: <A>(actual: A, expected: A, message?: string, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L31)

Since v0.21.0
utils-doesNotThrow.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.doesNotThrow

Asserts that `thunk` does not throw an error.

**Signature**

```ts
declare const doesNotThrow: (thunk: () => void, message?: string, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L70)

Since v0.21.0
utils-fail.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.fail

Throws an `AssertionError` with the provided error message.

**Signature**

```ts
declare const fail: (message: string) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L22)

Since v0.21.0
utils-notDeepStrictEqual.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.notDeepStrictEqual

Asserts that `actual` is not equal to `expected` using the `Equal.equals` trait.

**Signature**

```ts
declare const notDeepStrictEqual: <A>(actual: A, expected: A, message?: string, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L40)

Since v0.21.0
utils-strictEqual.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.strictEqual

Asserts that `actual` is equal to `expected` using the `Equal.equals` trait.

**Signature**

```ts
declare const strictEqual: <A>(actual: A, expected: A, message?: string, ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L49)

Since v0.21.0
utils-throws.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.throws

Asserts that `thunk` throws an error.

**Signature**

```ts
declare const throws: (thunk: () => void, error?: Error | ((u: unknown) => undefined), ..._: Array<never>) => void
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L139)

Since v0.21.0
utils-throwsAsync.md
Package: `@effect/vitest`<br />
Module: `utils`<br />

## utils.throwsAsync

Asserts that `thunk` throws an error.

**Signature**

```ts
declare const throwsAsync: (thunk: () => Promise<void>, error?: Error | ((u: unknown) => undefined), ..._: Array<never>) => Promise<void>
```

[Source](https://github.com/Effect-TS/effect/tree/main/packages/vitest/src/utils.ts#L159)

Since v0.21.0
